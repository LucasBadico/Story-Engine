
- [ ] upload image endpoint
- [ ] revisar tennat id: Atualizar Membership e AuditLog (requer mudança de interface)

# Relacoes no extract (LLM Gateway + Main Service)
- [ ] definir mapa oficial de relation types + mirrors no main-service (baseado no entity_relation.go)
- [ ] expor ou documentar mapa oficial para consumo do gateway
- [ ] adicionar phase4 relation_discovery no llm-gateway-service (prompt + usecase + eventos)
- [ ] adicionar phase5 relation_normalize no llm-gateway-service (normalizacao via mapa + fallback LLM)
- [ ] atualizar payload de retorno da API para incluir relations (entities + relations)
- [ ] ajustar SSE para result_entities/result_relations e confirmar ordem de entrega
- [ ] alinhar persistencia no main-service usando create_mirror quando aplicavel
- [ ] documentar contrato de relations (payload, eventos, relation_type)

# Easy wins
- [ ] LLM Gateway - sanitizar parâmetros sensíveis do entity extract (chunk size, overlap, thresholds) com limites via env
- [ ] LLM Gateway - handle deletes from main-service (remove embeddings/docs on entity delete)
- [ ] LLM Gateway - adicionar testes de integracao para phases 3+ (phase3 match, phase4 entities, phase5 relations, phase6 normalize, phase7 match)
- [ ] LLM Gateway - revisar metadata extra em embedding_documents (quais campos incluir por entidade)
- [ ] LLM Gateway - provider Gemini (embeddings)
  - [ ] definir escopo: embeddings only (sem geração de texto) e modelo alvo
  - [ ] adicionar config/envs (provider, base url, api key, model)
  - [ ] criar adapter `internal/adapters/embeddings/gemini` implementando a porta de embedder
  - [ ] wire-up no factory/config para selecionar o provider Gemini
  - [ ] testes unitários do adapter (mock HTTP) e smoke test no worker
  - [ ] atualizar docs de setup com exemplo de envs do Gemini
- [ ] world entities -  
  - [ ] view
    - [ ] evento- continua errado
    - [ ] character trait association ta com erro
    - [ ] lore esta com view/edit, deixar so com edit
    - [ ] character - associacao a evento nao ta funcionando
    - [ ] character - sem associacao a story/chapter/scene/beat
    - [ ] character - add grahp the relationships
    - [ ] story - falta character list
    
    - [ ] world - faction create relations
      - [ ] missing faction as type of relations.
      - erro na hora de criar relacao 
    - validar 
    - [ ] 
  - md
- [ ] rpg entities -  view e md
- [x] ingestao das novas entidades
- [x] add lore and faction

Economia vale a pena? Sim! É:
Baixo custo (~2-3h de implementação)
Complementa naturalmente o inventário
Essencial para compra/venda/trade
Base para futuras features (shops, quests com rewards)

Próximos passos frontend v2
  Instalar dependências: pnpm install na raiz
  Build dos packages: pnpm build
  Testar Storybook: pnpm --filter ui-package storybook
  Rodar web-app: pnpm --filter web-app dev
  Build do plugin: pnpm --filter obsidian-plugin-v2 build
  A estrutura está pronta para desenvolvimento. Os imports usam os nomes dos pacotes (@story-engine/ui-package, @story-engine/shared-ts, @story-engine/tokens) que funcionarão após a instalação das dependências com pnpm.



- [ ] pattern to import
- story {title}
- world {title}* dont duplicate the word world in the title
- rpg {title}* dont duplicate the word rpg in the title



World documents with lists of entities
 - locations
 - characters
 - artifacts
 - events (character, location, artifact)
 - factions
 - lores
 - traits
 - archetypes


 - Pattern of md files
  - list with entities related to the current entity - editable
  - Description 
  - how to use it - will show up if help is turned on.
  - fields to edit - maybe in a table with editable fields


  - criar um modo de importar historia de um tenant para outro tenant.

- [ ] Criar um flag/revision para quando algo estiver "errado/incongruente".


- corrigir ingestion de scene


- revisar world
 - esta faltando magia/power, tech/veihicle/knowledge


 - criar um lugar centralizado pra buildar as injecoes
