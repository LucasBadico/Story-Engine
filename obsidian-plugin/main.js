/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => StoryEnginePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian9 = require("obsidian");

// src/api/client.ts
var StoryEngineClient = class {
  constructor(apiUrl, apiKey) {
    this.apiUrl = apiUrl;
    this.apiKey = apiKey;
  }
  async request(method, endpoint, body, tenantId) {
    const url = `${this.apiUrl}${endpoint}`;
    const headers = new Headers();
    headers.set("Content-Type", "application/json");
    if (this.apiKey) {
      headers.set("Authorization", `Bearer ${this.apiKey}`);
    }
    if (tenantId) {
      const trimmedTenantId = tenantId.trim();
      if (trimmedTenantId) {
        headers.set("X-Tenant-ID", trimmedTenantId);
      }
    }
    const options = {
      method,
      headers
    };
    if (body) {
      options.body = JSON.stringify(body);
    }
    const response = await fetch(url, options);
    if (!response.ok) {
      let error;
      try {
        error = await response.json();
      } catch (e) {
        error = {
          error: "unknown_error",
          message: `HTTP ${response.status}: ${response.statusText}`,
          code: "HTTP_ERROR"
        };
      }
      const errorMessage = error.message || error.error || `HTTP ${response.status}: ${response.statusText}`;
      throw new Error(errorMessage);
    }
    return response.json();
  }
  async listStories(tenantId) {
    const trimmedTenantId = tenantId.trim();
    if (!trimmedTenantId) {
      throw new Error("Tenant ID is required");
    }
    const response = await this.request(
      "GET",
      "/api/v1/stories",
      void 0,
      trimmedTenantId
    );
    return response.stories || [];
  }
  async getStory(id) {
    const response = await this.request(
      "GET",
      `/api/v1/stories/${id}`
    );
    return response.story;
  }
  async createStory(tenantId, title) {
    const trimmedTenantId = tenantId.trim();
    if (!trimmedTenantId) {
      throw new Error("Tenant ID is required");
    }
    const response = await this.request(
      "POST",
      "/api/v1/stories",
      {
        title: title.trim()
      },
      trimmedTenantId
    );
    return response.story;
  }
  async cloneStory(id, tenantId) {
    const trimmedTenantId = tenantId.trim();
    if (!trimmedTenantId) {
      throw new Error("Tenant ID is required");
    }
    const response = await this.request(
      "POST",
      `/api/v1/stories/${id}/clone`,
      {},
      trimmedTenantId
    );
    return response.story;
  }
  async getTenant(id) {
    const response = await this.request(
      "GET",
      `/api/v1/tenants/${id}`
    );
    return response.tenant;
  }
  async testConnection() {
    try {
      await this.request("GET", "/health");
      return true;
    } catch (e) {
      return false;
    }
  }
  async updateStory(id, title, status) {
    const body = { title: title.trim() };
    if (status) {
      body.status = status;
    }
    const response = await this.request(
      "PUT",
      `/api/v1/stories/${id}`,
      body
    );
    return response.story;
  }
  async getStoryWithHierarchy(id) {
    const story = await this.getStory(id);
    const chapters = await this.getChapters(id);
    const chaptersWithContent = await Promise.all(
      chapters.map(async (chapter) => {
        const scenes = await this.getScenes(chapter.id);
        const scenesWithBeats = await Promise.all(
          scenes.map(async (scene) => {
            const beats = await this.getBeats(scene.id);
            return { scene, beats };
          })
        );
        return { chapter, scenes: scenesWithBeats };
      })
    );
    return {
      story,
      chapters: chaptersWithContent
    };
  }
  async createChapter(storyId, chapter) {
    const response = await this.request(
      "POST",
      "/api/v1/chapters",
      {
        story_id: storyId,
        number: chapter.number,
        title: chapter.title,
        status: chapter.status
      }
    );
    return response.chapter;
  }
  async updateChapter(id, chapter) {
    const response = await this.request(
      "PUT",
      `/api/v1/chapters/${id}`,
      chapter
    );
    return response.chapter;
  }
  async getChapters(storyId) {
    const response = await this.request(
      "GET",
      `/api/v1/stories/${storyId}/chapters`
    );
    return response.chapters || [];
  }
  async getChapter(id) {
    const response = await this.request(
      "GET",
      `/api/v1/chapters/${id}`
    );
    return response.chapter;
  }
  async deleteChapter(id) {
    await this.request("DELETE", `/api/v1/chapters/${id}`);
  }
  async createScene(scene) {
    const response = await this.request(
      "POST",
      "/api/v1/scenes",
      scene
    );
    return response.scene;
  }
  async updateScene(id, scene) {
    const response = await this.request(
      "PUT",
      `/api/v1/scenes/${id}`,
      scene
    );
    return response.scene;
  }
  async getScenes(chapterId) {
    const response = await this.request(
      "GET",
      `/api/v1/chapters/${chapterId}/scenes`
    );
    return response.scenes || [];
  }
  async getScene(id) {
    const response = await this.request(
      "GET",
      `/api/v1/scenes/${id}`
    );
    return response.scene;
  }
  async deleteScene(id) {
    await this.request("DELETE", `/api/v1/scenes/${id}`);
  }
  async createBeat(beat) {
    const response = await this.request(
      "POST",
      "/api/v1/beats",
      beat
    );
    return response.beat;
  }
  async updateBeat(id, beat) {
    const response = await this.request(
      "PUT",
      `/api/v1/beats/${id}`,
      beat
    );
    return response.beat;
  }
  async getBeats(sceneId) {
    const response = await this.request(
      "GET",
      `/api/v1/scenes/${sceneId}/beats`
    );
    return response.beats || [];
  }
  async getBeat(id) {
    const response = await this.request(
      "GET",
      `/api/v1/beats/${id}`
    );
    return response.beat;
  }
  async deleteBeat(id) {
    await this.request("DELETE", `/api/v1/beats/${id}`);
  }
  // Get all versions of a story (for version history)
  async getStoryVersions(rootStoryId) {
    const response = await this.request(
      "GET",
      `/api/v1/stories/${rootStoryId}/versions`
    );
    return response.stories || [];
  }
};

// src/settings.ts
var import_obsidian = require("obsidian");
var StoryEngineSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Story Engine Settings" });
    new import_obsidian.Setting(containerEl).setName("API URL").setDesc("The base URL of the Story Engine API").addText(
      (text) => text.setPlaceholder("http://localhost:8080").setValue(this.plugin.settings.apiUrl).onChange(async (value) => {
        this.plugin.settings.apiUrl = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("API Key").setDesc("API key for authentication (optional for MVP)").addText((text) => {
      text.setPlaceholder("Enter API key").setValue(this.plugin.settings.apiKey).inputEl.type = "password";
      text.onChange(async (value) => {
        this.plugin.settings.apiKey = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Tenant ID").setDesc("Your workspace tenant ID (UUID format)").addText(
      (text) => text.setPlaceholder("00000000-0000-0000-0000-000000000000").setValue(this.plugin.settings.tenantId || "").onChange(async (value) => {
        this.plugin.settings.tenantId = value.trim();
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Sync Folder Path").setDesc("Folder path where synced stories will be stored").addText(
      (text) => text.setPlaceholder("Stories").setValue(this.plugin.settings.syncFolderPath || "Stories").onChange(async (value) => {
        this.plugin.settings.syncFolderPath = value.trim() || "Stories";
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Auto Version Snapshots").setDesc("Automatically create version snapshots when syncing").addToggle(
      (toggle) => {
        var _a;
        return toggle.setValue((_a = this.plugin.settings.autoVersionSnapshots) != null ? _a : true).onChange(async (value) => {
          this.plugin.settings.autoVersionSnapshots = value;
          await this.plugin.saveSettings();
        });
      }
    );
    new import_obsidian.Setting(containerEl).setName("Conflict Resolution").setDesc("How to resolve conflicts when both local and service have changes").addDropdown(
      (dropdown) => dropdown.addOption("service", "Service Wins").addOption("local", "Local Wins").addOption("manual", "Manual (Newer Wins)").setValue(this.plugin.settings.conflictResolution || "service").onChange(async (value) => {
        this.plugin.settings.conflictResolution = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Test Connection").setDesc("Test connection to the Story Engine API").addButton(
      (button) => button.setButtonText("Test").onClick(async () => {
        button.setButtonText("Testing...");
        button.setDisabled(true);
        try {
          const result = await this.plugin.apiClient.testConnection();
          if (result) {
            button.setButtonText("Success!");
            setTimeout(() => {
              button.setButtonText("Test");
              button.setDisabled(false);
            }, 2e3);
          } else {
            button.setButtonText("Failed");
            setTimeout(() => {
              button.setButtonText("Test");
              button.setDisabled(false);
            }, 2e3);
          }
        } catch (err) {
          button.setButtonText("Error");
          setTimeout(() => {
            button.setButtonText("Test");
            button.setDisabled(false);
          }, 2e3);
        }
      })
    );
  }
};

// src/commands.ts
var import_obsidian3 = require("obsidian");

// src/views/StorySyncModal.ts
var import_obsidian2 = require("obsidian");
var StorySyncModal = class extends import_obsidian2.Modal {
  constructor(plugin, mode) {
    super(plugin.app);
    this.stories = [];
    this.loading = true;
    this.error = null;
    this.plugin = plugin;
    this.mode = mode;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    const title = this.mode === "pull" ? "Sync Story from Service" : "Push Story to Service";
    contentEl.createEl("h2", { text: title });
    await this.loadStories();
    if (this.loading) {
      contentEl.createEl("p", { text: "Loading stories..." });
      return;
    }
    if (this.error) {
      contentEl.createEl("p", {
        text: `Error: ${this.error}`,
        cls: "story-engine-error"
      });
      return;
    }
    if (this.stories.length === 0) {
      contentEl.createEl("p", { text: "No stories found." });
      return;
    }
    const storiesList = contentEl.createEl("div", { cls: "story-engine-list" });
    for (const story of this.stories) {
      const storyItem = storiesList.createEl("div", {
        cls: "story-engine-item"
      });
      const title2 = storyItem.createEl("div", {
        cls: "story-engine-title",
        text: story.title
      });
      const meta = storyItem.createEl("div", {
        cls: "story-engine-meta"
      });
      meta.createEl("span", {
        text: `Version ${story.version_number}`
      });
      meta.createEl("span", {
        text: `Status: ${story.status}`
      });
      storyItem.onclick = async () => {
        this.close();
        try {
          if (this.mode === "pull") {
            await this.plugin.syncService.pullStory(story.id);
          } else {
            const folderPath = this.plugin.fileManager.getStoryFolderPath(
              story.title
            );
            await this.plugin.syncService.pushStory(folderPath);
          }
        } catch (err) {
          const errorMessage = err instanceof Error ? err.message : "Failed to sync story";
          new import_obsidian2.Notice(`Error: ${errorMessage}`, 5e3);
        }
      };
    }
  }
  async loadStories() {
    this.loading = true;
    this.error = null;
    try {
      if (!this.plugin.settings.tenantId) {
        this.error = "Tenant ID not configured";
        this.loading = false;
        return;
      }
      this.stories = await this.plugin.apiClient.listStories(
        this.plugin.settings.tenantId
      );
    } catch (err) {
      this.error = err instanceof Error ? err.message : "Unknown error";
    } finally {
      this.loading = false;
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/commands.ts
function registerCommands(plugin) {
  plugin.addCommand({
    id: "list-stories",
    name: "List Stories",
    callback: () => {
      plugin.activateView();
    }
  });
  plugin.addCommand({
    id: "create-story",
    name: "Create Story",
    callback: () => {
      plugin.createStoryCommand();
    }
  });
  plugin.addCommand({
    id: "sync-story-from-service",
    name: "Sync Story from Service",
    callback: () => {
      new StorySyncModal(plugin, "pull").open();
    }
  });
  plugin.addCommand({
    id: "push-story-to-service",
    name: "Push Story to Service",
    callback: () => {
      new StorySyncModal(plugin, "push").open();
    }
  });
  plugin.addCommand({
    id: "sync-all-stories",
    name: "Sync All Stories",
    callback: async () => {
      if (!plugin.settings.tenantId) {
        new import_obsidian3.Notice("Please configure Tenant ID in settings", 5e3);
        return;
      }
      try {
        new import_obsidian3.Notice("Syncing all stories...");
        await plugin.syncService.pullAllStories();
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to sync stories";
        new import_obsidian3.Notice(`Error: ${errorMessage}`, 5e3);
      }
    }
  });
}

// src/views/StoryDetailsModal.ts
var import_obsidian4 = require("obsidian");
var StoryDetailsModal = class _StoryDetailsModal extends import_obsidian4.Modal {
  constructor(plugin, story) {
    super(plugin.app);
    this.plugin = plugin;
    this.story = story;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: this.story.title });
    const details = contentEl.createEl("div", { cls: "story-engine-details" });
    details.createEl("p", {
      text: `Status: ${this.story.status}`
    });
    details.createEl("p", {
      text: `Version: ${this.story.version_number}`
    });
    details.createEl("p", {
      text: `Created: ${new Date(this.story.created_at).toLocaleString()}`
    });
    details.createEl("p", {
      text: `Updated: ${new Date(this.story.updated_at).toLocaleString()}`
    });
    details.createEl("p", {
      text: `ID: ${this.story.id}`,
      cls: "story-engine-id"
    });
    const buttonContainer = contentEl.createEl("div", {
      cls: "story-engine-buttons"
    });
    const cloneButton = buttonContainer.createEl("button", {
      text: "Clone Story",
      cls: "mod-cta"
    });
    cloneButton.onclick = async () => {
      cloneButton.disabled = true;
      cloneButton.setText("Cloning...");
      try {
        if (!this.plugin.settings.tenantId) {
          throw new Error("Tenant ID not configured");
        }
        const clonedStory = await this.plugin.apiClient.cloneStory(
          this.story.id,
          this.plugin.settings.tenantId
        );
        this.close();
        new _StoryDetailsModal(this.plugin, clonedStory).open();
      } catch (err) {
        cloneButton.setText(
          err instanceof Error ? err.message : "Clone failed"
        );
        setTimeout(() => {
          cloneButton.disabled = false;
          cloneButton.setText("Clone Story");
        }, 3e3);
      }
    };
    const copyIdButton = buttonContainer.createEl("button", {
      text: "Copy ID"
    });
    copyIdButton.onclick = () => {
      const textarea = contentEl.createEl("textarea");
      textarea.value = this.story.id;
      textarea.style.position = "fixed";
      textarea.style.opacity = "0";
      textarea.style.left = "-9999px";
      textarea.select();
      try {
        const doc = contentEl.ownerDocument || globalThis.document;
        if (doc && doc.execCommand) {
          doc.execCommand("copy");
          copyIdButton.setText("Copied!");
          setTimeout(() => {
            copyIdButton.setText("Copy ID");
          }, 2e3);
        }
      } catch (err) {
        console.error("Failed to copy ID:", err);
      }
      textarea.remove();
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/CreateStoryModal.ts
var import_obsidian5 = require("obsidian");
var CreateStoryModal = class extends import_obsidian5.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.title = "";
    this.shouldSync = true;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Create New Story" });
    new import_obsidian5.Setting(contentEl).setName("Story Title").setDesc("Enter the title for your new story").addText(
      (text) => text.setPlaceholder("My New Story").setValue(this.title).onChange((value) => {
        this.title = value;
      }).inputEl.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          this.submit();
        }
      })
    );
    new import_obsidian5.Setting(contentEl).setName("Sync to Obsidian").setDesc("Automatically sync the story files to your vault after creation").addToggle(
      (toggle) => toggle.setValue(this.shouldSync).onChange((value) => {
        this.shouldSync = value;
      })
    );
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const createButton = buttonContainer.createEl("button", {
      text: "Create",
      cls: "mod-cta"
    });
    createButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
    const titleInput = contentEl.querySelector("input");
    if (titleInput) {
      titleInput.focus();
    }
  }
  submit() {
    const trimmedTitle = this.title.trim();
    if (!trimmedTitle) {
      new import_obsidian5.Notice("Please enter a story title", 3e3);
      return;
    }
    this.close();
    this.onSubmit(trimmedTitle, this.shouldSync);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/sync/fileManager.ts
var import_obsidian6 = require("obsidian");
var FileManager = class {
  constructor(vault, baseFolder) {
    this.vault = vault;
    this.baseFolder = baseFolder;
  }
  // Get the folder path for a specific story
  getStoryFolderPath(storyTitle) {
    const sanitized = this.sanitizeFolderName(storyTitle);
    return `${this.baseFolder}/${sanitized}`;
  }
  // Sanitize folder/file names
  sanitizeFolderName(name) {
    return name.replace(/[<>:"/\\|?*]/g, "-").replace(/\s+/g, " ").trim();
  }
  // Generate frontmatter with Obsidian tags
  generateFrontmatter(baseFields, extraFields, options) {
    const fields = { ...baseFields };
    if (extraFields) {
      Object.assign(fields, extraFields);
    }
    const tags = [];
    if (options) {
      tags.push(`story-engine/${options.entityType}`);
      if (options.storyName) {
        const sanitizedStoryName = this.sanitizeFolderName(options.storyName).toLowerCase().replace(/\s+/g, "-");
        tags.push(`story/${sanitizedStoryName}`);
      }
      if (options.date) {
        const date = typeof options.date === "string" ? new Date(options.date) : options.date;
        if (!isNaN(date.getTime())) {
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, "0");
          const day = String(date.getDate()).padStart(2, "0");
          tags.push(`date/${year}/${month}/${day}`);
        }
      }
    }
    const lines = ["---"];
    for (const [key, value] of Object.entries(fields)) {
      if (value === null || value === void 0) {
        lines.push(`${key}: null`);
      } else if (typeof value === "string") {
        const escaped = value.replace(/"/g, '\\"');
        if (value.includes(":") || value.includes("\n") || value.includes('"')) {
          lines.push(`${key}: "${escaped}"`);
        } else {
          lines.push(`${key}: ${escaped}`);
        }
      } else {
        lines.push(`${key}: ${value}`);
      }
    }
    if (tags.length > 0) {
      lines.push(`tags:`);
      for (const tag of tags) {
        lines.push(`  - ${tag}`);
      }
    }
    lines.push("---", "");
    return lines.join("\n");
  }
  // Ensure folder exists
  async ensureFolderExists(path) {
    const folder = this.vault.getAbstractFileByPath(path);
    if (!folder) {
      await this.vault.createFolder(path);
    }
  }
  // Write story metadata (story.md)
  async writeStoryMetadata(story, folderPath) {
    await this.ensureFolderExists(folderPath);
    const baseFields = {
      id: story.id,
      title: story.title,
      status: story.status,
      version: story.version_number,
      root_story_id: story.root_story_id,
      previous_version_id: story.previous_story_id,
      created_at: story.created_at,
      updated_at: story.updated_at
    };
    const frontmatter = this.generateFrontmatter(baseFields, void 0, {
      entityType: "story",
      storyName: story.title,
      date: story.created_at
    });
    const content = `${frontmatter}
# ${story.title}

Version: ${story.version_number}
Status: ${story.status}
`;
    const filePath = `${folderPath}/story.md`;
    const file = this.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian6.TFile) {
      await this.vault.modify(file, content);
    } else {
      await this.vault.create(filePath, content);
    }
  }
  // Write chapter file
  async writeChapterFile(chapterWithContent, filePath, storyName) {
    const { chapter, scenes } = chapterWithContent;
    const baseFields = {
      id: chapter.id,
      story_id: chapter.story_id,
      number: chapter.number,
      title: chapter.title,
      status: chapter.status,
      created_at: chapter.created_at,
      updated_at: chapter.updated_at
    };
    const frontmatter = this.generateFrontmatter(baseFields, void 0, {
      entityType: "chapter",
      storyName,
      date: chapter.created_at
    });
    let content = `${frontmatter}
# ${chapter.title}

`;
    if (scenes.length > 0) {
      content += `## Scenes

`;
      for (const { scene, beats } of scenes) {
        content += `- [[Scene-${scene.order_num}]] - ${scene.goal || "No goal"}
`;
        if (beats.length > 0) {
          content += `  - ${beats.length} beat(s)
`;
        }
      }
      content += `
`;
    }
    const file = this.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian6.TFile) {
      await this.vault.modify(file, content);
    } else {
      await this.vault.create(filePath, content);
    }
  }
  // Read story metadata
  async readStoryMetadata(folderPath) {
    const filePath = `${folderPath}/story.md`;
    const file = this.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian6.TFile)) {
      throw new Error(`Story metadata file not found: ${filePath}`);
    }
    const content = await this.vault.read(file);
    const frontmatter = this.parseFrontmatter(content);
    return {
      frontmatter: {
        id: frontmatter.id,
        title: frontmatter.title,
        status: frontmatter.status,
        version: parseInt(frontmatter.version),
        root_story_id: frontmatter.root_story_id,
        previous_version_id: frontmatter.previous_version_id || null,
        created_at: frontmatter.created_at,
        updated_at: frontmatter.updated_at
      },
      content: content.split("---").slice(2).join("---").trim()
    };
  }
  // Parse YAML frontmatter
  parseFrontmatter(content) {
    const match = content.match(/^---\n([\s\S]*?)\n---/);
    if (!match) {
      return {};
    }
    const frontmatterText = match[1];
    const result = {};
    for (const line of frontmatterText.split("\n")) {
      const colonIndex = line.indexOf(":");
      if (colonIndex > 0) {
        const key = line.slice(0, colonIndex).trim();
        const value = line.slice(colonIndex + 1).trim().replace(/^["']|["']$/g, "");
        result[key] = value;
      }
    }
    return result;
  }
  // Copy story folder to versions folder
  async createVersionSnapshot(storyFolderPath, versionNumber) {
    const versionsPath = `${storyFolderPath}/versions`;
    await this.ensureFolderExists(versionsPath);
    const versionFolderPath = `${versionsPath}/v${versionNumber}`;
    const existingVersion = this.vault.getAbstractFileByPath(versionFolderPath);
    if (existingVersion) {
      console.log(`Version v${versionNumber} already exists, skipping snapshot`);
      return;
    }
    await this.ensureFolderExists(versionFolderPath);
    const storyFolder = this.vault.getAbstractFileByPath(storyFolderPath);
    if (!(storyFolder instanceof import_obsidian6.TFolder)) {
      throw new Error(`Story folder not found: ${storyFolderPath}`);
    }
    await this.copyFolderContents(storyFolder, versionFolderPath, "versions");
    console.log(`Created version snapshot: v${versionNumber}`);
  }
  // Recursively copy folder contents
  async copyFolderContents(sourceFolder, destPath, excludeFolderName) {
    for (const child of sourceFolder.children) {
      if (child instanceof import_obsidian6.TFile) {
        const relativePath = child.path.replace(sourceFolder.path + "/", "");
        const destFilePath = `${destPath}/${relativePath}`;
        const content = await this.vault.read(child);
        await this.vault.create(destFilePath, content);
      } else if (child instanceof import_obsidian6.TFolder) {
        if (excludeFolderName && child.name === excludeFolderName) {
          continue;
        }
        const relativePath = child.path.replace(sourceFolder.path + "/", "");
        const destFolderPath = `${destPath}/${relativePath}`;
        await this.ensureFolderExists(destFolderPath);
        await this.copyFolderContents(child, destFolderPath, excludeFolderName);
      }
    }
  }
  // Write scene file
  async writeSceneFile(sceneWithBeats, filePath, storyName) {
    const { scene, beats } = sceneWithBeats;
    const baseFields = {
      id: scene.id,
      story_id: scene.story_id,
      chapter_id: scene.chapter_id,
      order_num: scene.order_num,
      time_ref: scene.time_ref || "",
      goal: scene.goal || "",
      created_at: scene.created_at,
      updated_at: scene.updated_at
    };
    const extraFields = {};
    if (scene.pov_character_id) {
      extraFields.pov_character_id = scene.pov_character_id;
    }
    if (scene.location_id) {
      extraFields.location_id = scene.location_id;
    }
    const frontmatter = this.generateFrontmatter(baseFields, extraFields, {
      entityType: "scene",
      storyName,
      date: scene.created_at
    });
    let content = `${frontmatter}
# Scene ${scene.order_num}

`;
    if (scene.goal) {
      content += `**Goal:** ${scene.goal}

`;
    }
    if (scene.time_ref) {
      content += `**Time:** ${scene.time_ref}

`;
    }
    if (beats.length > 0) {
      content += `## Beats

`;
      for (const beat of beats) {
        content += `### Beat ${beat.order_num} - ${beat.type}

`;
        if (beat.intent) {
          content += `**Intent:** ${beat.intent}

`;
        }
        if (beat.outcome) {
          content += `**Outcome:** ${beat.outcome}

`;
        }
      }
    }
    const file = this.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian6.TFile) {
      await this.vault.modify(file, content);
    } else {
      await this.vault.create(filePath, content);
    }
  }
  // Write beat file
  async writeBeatFile(beat, filePath, storyName) {
    const baseFields = {
      id: beat.id,
      scene_id: beat.scene_id,
      order_num: beat.order_num,
      type: beat.type,
      intent: beat.intent || "",
      outcome: beat.outcome || "",
      created_at: beat.created_at,
      updated_at: beat.updated_at
    };
    const frontmatter = this.generateFrontmatter(baseFields, void 0, {
      entityType: "beat",
      storyName,
      date: beat.created_at
    });
    let content = `${frontmatter}
# Beat ${beat.order_num} - ${beat.type}

`;
    if (beat.intent) {
      content += `**Intent:** ${beat.intent}

`;
    }
    if (beat.outcome) {
      content += `**Outcome:** ${beat.outcome}

`;
    }
    const file = this.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian6.TFile) {
      await this.vault.modify(file, content);
    } else {
      await this.vault.create(filePath, content);
    }
  }
  // List all chapter files in a story folder
  async listChapterFiles(storyFolderPath) {
    const chaptersPath = `${storyFolderPath}/chapters`;
    const folder = this.vault.getAbstractFileByPath(chaptersPath);
    if (!(folder instanceof import_obsidian6.TFolder)) {
      return [];
    }
    const chapterFiles = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian6.TFile && child.extension === "md") {
        chapterFiles.push(child.path);
      }
    }
    return chapterFiles.sort();
  }
  // List all scene files in a chapter folder
  async listSceneFiles(chapterFolderPath) {
    const scenesPath = `${chapterFolderPath}/scenes`;
    const folder = this.vault.getAbstractFileByPath(scenesPath);
    if (!(folder instanceof import_obsidian6.TFolder)) {
      return [];
    }
    const sceneFiles = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian6.TFile && child.extension === "md") {
        sceneFiles.push(child.path);
      }
    }
    return sceneFiles.sort();
  }
  // List all beat files in a scene folder
  async listBeatFiles(sceneFolderPath) {
    const beatsPath = `${sceneFolderPath}/beats`;
    const folder = this.vault.getAbstractFileByPath(beatsPath);
    if (!(folder instanceof import_obsidian6.TFolder)) {
      return [];
    }
    const beatFiles = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian6.TFile && child.extension === "md") {
        beatFiles.push(child.path);
      }
    }
    return beatFiles.sort();
  }
};

// src/sync/syncService.ts
var import_obsidian7 = require("obsidian");
var SyncService = class {
  constructor(apiClient, fileManager, settings) {
    this.apiClient = apiClient;
    this.fileManager = fileManager;
    this.settings = settings;
  }
  // Pull story from service to Obsidian (Service → Obsidian)
  async pullStory(storyId) {
    try {
      const storyData = await this.apiClient.getStoryWithHierarchy(storyId);
      const folderPath = this.fileManager.getStoryFolderPath(
        storyData.story.title
      );
      await this.fileManager.writeStoryMetadata(
        storyData.story,
        folderPath
      );
      const chaptersFolderPath = `${folderPath}/chapters`;
      await this.fileManager.ensureFolderExists(chaptersFolderPath);
      for (const chapterWithContent of storyData.chapters) {
        const chapterFileName = `Chapter-${chapterWithContent.chapter.number}.md`;
        const chapterFilePath = `${chaptersFolderPath}/${chapterFileName}`;
        await this.fileManager.writeChapterFile(
          chapterWithContent,
          chapterFilePath,
          storyData.story.title
        );
      }
      const existingMetadata = await this.fileManager.readStoryMetadata(folderPath).catch(() => null);
      if (existingMetadata && existingMetadata.frontmatter.version !== void 0 && existingMetadata.frontmatter.version !== storyData.story.version_number) {
        await this.fileManager.createVersionSnapshot(
          folderPath,
          existingMetadata.frontmatter.version
        );
      }
      await this.syncVersionHistory(storyData.story.root_story_id, folderPath);
      new import_obsidian7.Notice(`Story "${storyData.story.title}" synced successfully`);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to sync story";
      new import_obsidian7.Notice(`Error syncing story: ${errorMessage}`, 5e3);
      throw err;
    }
  }
  // Sync all previous versions of a story
  async syncVersionHistory(rootStoryId, storyFolderPath) {
    try {
      const allStories = await this.apiClient.listStories(this.settings.tenantId);
      const versions = allStories.filter((s) => s.root_story_id === rootStoryId);
      versions.sort((a, b) => a.version_number - b.version_number);
      const versionsPath = `${storyFolderPath}/versions`;
      await this.fileManager.ensureFolderExists(versionsPath);
      for (const versionStory of versions) {
        const currentVersion = versions[versions.length - 1].version_number;
        if (versionStory.version_number === currentVersion) {
          continue;
        }
        const versionFolderPath = `${versionsPath}/v${versionStory.version_number}`;
        const existingVersionFolder = this.fileManager["vault"].getAbstractFileByPath(
          versionFolderPath
        );
        if (existingVersionFolder) {
          console.log(`Version v${versionStory.version_number} already exists, skipping`);
          continue;
        }
        const versionData = await this.apiClient.getStoryWithHierarchy(
          versionStory.id
        );
        await this.fileManager.ensureFolderExists(versionFolderPath);
        await this.fileManager.writeStoryMetadata(
          versionData.story,
          versionFolderPath
        );
        const versionChaptersPath = `${versionFolderPath}/chapters`;
        await this.fileManager.ensureFolderExists(versionChaptersPath);
        for (const chapterWithContent of versionData.chapters) {
          const chapterFileName = `Chapter-${chapterWithContent.chapter.number}.md`;
          const chapterFilePath = `${versionChaptersPath}/${chapterFileName}`;
          await this.fileManager.writeChapterFile(
            chapterWithContent,
            chapterFilePath,
            versionData.story.title
          );
        }
        console.log(`Synced version v${versionStory.version_number}`);
      }
    } catch (err) {
      console.error("Error syncing version history:", err);
    }
  }
  // Pull all stories
  async pullAllStories() {
    if (!this.settings.tenantId) {
      throw new Error("Tenant ID is required");
    }
    const stories = await this.apiClient.listStories(this.settings.tenantId);
    for (const story of stories) {
      try {
        await this.pullStory(story.id);
      } catch (err) {
        console.error(`Failed to sync story ${story.id}:`, err);
      }
    }
    new import_obsidian7.Notice(`Synced ${stories.length} stories`);
  }
  // Push story from Obsidian to service (Obsidian → Service)
  async pushStory(folderPath) {
    try {
      const { frontmatter: storyFrontmatter } = await this.fileManager.readStoryMetadata(folderPath);
      if (!storyFrontmatter.id) {
        throw new Error("Story metadata missing ID");
      }
      const storyId = storyFrontmatter.id;
      await this.apiClient.updateStory(
        storyId,
        storyFrontmatter.title,
        storyFrontmatter.status
      );
      const chapterFiles = await this.fileManager.listChapterFiles(folderPath);
      for (const chapterFilePath of chapterFiles) {
        console.log(`Would update chapter: ${chapterFilePath}`);
      }
      new import_obsidian7.Notice(`Story "${storyFrontmatter.title}" pushed successfully`);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to push story";
      new import_obsidian7.Notice(`Error pushing story: ${errorMessage}`, 5e3);
      throw err;
    }
  }
};

// src/views/StoryListView.ts
var import_obsidian8 = require("obsidian");
var STORY_LIST_VIEW_TYPE = "story-engine-list-view";
var StoryListView = class extends import_obsidian8.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.stories = [];
    this.loading = true;
    this.error = null;
    this.plugin = plugin;
  }
  getViewType() {
    return STORY_LIST_VIEW_TYPE;
  }
  getDisplayText() {
    return "Stories";
  }
  getIcon() {
    return "book-open";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("story-engine-view-container");
    await this.render(container);
    await this.loadStories();
  }
  async onClose() {
  }
  async render(container) {
    container.empty();
    const header = container.createDiv({ cls: "story-engine-view-header" });
    header.createEl("h2", { text: "Stories" });
    const headerActions = header.createDiv({ cls: "story-engine-header-actions" });
    const refreshButton = headerActions.createEl("button", {
      text: "Refresh",
      cls: "story-engine-refresh-btn"
    });
    refreshButton.onclick = async () => {
      await this.loadStories();
    };
    const syncAllButton = headerActions.createEl("button", {
      text: "Sync All",
      cls: "story-engine-sync-all-btn"
    });
    syncAllButton.onclick = async () => {
      if (!this.plugin.settings.tenantId) {
        new import_obsidian8.Notice("Please configure Tenant ID in settings", 5e3);
        return;
      }
      try {
        new import_obsidian8.Notice("Syncing all stories...");
        await this.plugin.syncService.pullAllStories();
        await this.loadStories();
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to sync stories";
        new import_obsidian8.Notice(`Error: ${errorMessage}`, 5e3);
      }
    };
    const createButton = headerActions.createEl("button", {
      text: "Create Story",
      cls: "mod-cta story-engine-create-btn"
    });
    createButton.onclick = () => {
      this.plugin.createStoryCommand();
    };
    this.contentEl = container.createDiv({ cls: "story-engine-view-content" });
  }
  renderStories() {
    if (!this.contentEl)
      return;
    this.contentEl.empty();
    if (this.loading) {
      this.contentEl.createEl("p", { text: "Loading stories..." });
      return;
    }
    if (this.error) {
      this.contentEl.createEl("p", {
        text: `Error: ${this.error}`,
        cls: "story-engine-error"
      });
      return;
    }
    if (this.stories.length === 0) {
      this.contentEl.createEl("p", { text: "No stories found." });
      return;
    }
    const storiesList = this.contentEl.createDiv({ cls: "story-engine-list" });
    for (const story of this.stories) {
      const storyItem = storiesList.createDiv({
        cls: "story-engine-item"
      });
      const title = storyItem.createDiv({
        cls: "story-engine-title",
        text: story.title
      });
      const meta = storyItem.createDiv({
        cls: "story-engine-meta"
      });
      meta.createEl("span", {
        text: `Version ${story.version_number}`
      });
      meta.createEl("span", {
        text: `Status: ${story.status}`
      });
      storyItem.onclick = () => {
        new StoryDetailsModal(this.plugin, story).open();
      };
    }
  }
  async loadStories() {
    this.loading = true;
    this.error = null;
    this.renderStories();
    try {
      if (!this.plugin.settings.tenantId) {
        this.error = "Tenant ID not configured";
        this.loading = false;
        this.renderStories();
        return;
      }
      this.stories = await this.plugin.apiClient.listStories(
        this.plugin.settings.tenantId
      );
    } catch (err) {
      this.error = err instanceof Error ? err.message : "Unknown error";
    } finally {
      this.loading = false;
      this.renderStories();
    }
  }
  // Method to refresh the view
  async refresh() {
    await this.loadStories();
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  apiUrl: "http://localhost:8080",
  apiKey: "",
  tenantId: "",
  tenantName: "",
  syncFolderPath: "Stories",
  autoVersionSnapshots: true,
  conflictResolution: "service"
};
var StoryEnginePlugin = class extends import_obsidian9.Plugin {
  async onload() {
    await this.loadSettings();
    this.apiClient = new StoryEngineClient(
      this.settings.apiUrl,
      this.settings.apiKey
    );
    this.fileManager = new FileManager(
      this.app.vault,
      this.settings.syncFolderPath || "Stories"
    );
    this.syncService = new SyncService(
      this.apiClient,
      this.fileManager,
      this.settings
    );
    this.addSettingTab(new StoryEngineSettingTab(this.app, this));
    this.registerView(
      STORY_LIST_VIEW_TYPE,
      (leaf) => new StoryListView(leaf, this)
    );
    this.addRibbonIcon("book-open", "Story Engine", () => {
      this.activateView();
    });
    registerCommands(this);
  }
  async onunload() {
    this.app.workspace.detachLeavesOfType(STORY_LIST_VIEW_TYPE);
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.apiClient = new StoryEngineClient(
      this.settings.apiUrl,
      this.settings.apiKey
    );
    this.fileManager = new FileManager(
      this.app.vault,
      this.settings.syncFolderPath || "Stories"
    );
    this.syncService = new SyncService(
      this.apiClient,
      this.fileManager,
      this.settings
    );
  }
  async createStoryCommand() {
    var _a;
    const tenantId = (_a = this.settings.tenantId) == null ? void 0 : _a.trim();
    if (!tenantId) {
      new import_obsidian9.Notice("Please configure Tenant ID in settings", 5e3);
      return;
    }
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    if (!uuidRegex.test(tenantId)) {
      new import_obsidian9.Notice("Invalid Tenant ID format. Please check your settings.", 5e3);
      return;
    }
    new CreateStoryModal(this.app, async (title, shouldSync) => {
      try {
        new import_obsidian9.Notice(`Creating story "${title}"...`);
        const story = await this.apiClient.createStory(tenantId, title);
        new import_obsidian9.Notice(`Story "${title}" created successfully`);
        if (shouldSync) {
          try {
            new import_obsidian9.Notice(`Syncing story to Obsidian...`);
            await this.syncService.pullStory(story.id);
            new import_obsidian9.Notice(`Story synced to your vault!`);
          } catch (syncErr) {
            const syncErrorMessage = syncErr instanceof Error ? syncErr.message : "Failed to sync story";
            new import_obsidian9.Notice(`Story created but sync failed: ${syncErrorMessage}`, 5e3);
          }
        } else {
          new StoryDetailsModal(this, story).open();
        }
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to create story";
        new import_obsidian9.Notice(`Error: ${errorMessage}`, 5e3);
      }
    }).open();
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(STORY_LIST_VIEW_TYPE)[0];
    if (!leaf) {
      const rightLeaf = workspace.getRightLeaf(false);
      if (!rightLeaf) {
        new import_obsidian9.Notice("Could not create view. Please try again.", 3e3);
        return;
      }
      leaf = rightLeaf;
      await leaf.setViewState({
        type: STORY_LIST_VIEW_TYPE,
        active: true
      });
    }
    workspace.revealLeaf(leaf);
  }
};
