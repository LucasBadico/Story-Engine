/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => StoryEnginePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian14 = require("obsidian");

// src/api/client.ts
var StoryEngineClient = class {
  constructor(apiUrl, apiKey, tenantId = "") {
    this.apiUrl = apiUrl;
    this.apiKey = apiKey;
    this.tenantId = tenantId;
    this.mode = "remote";
  }
  setTenantId(tenantId) {
    this.tenantId = tenantId.trim();
  }
  setMode(mode) {
    this.mode = mode;
  }
  async request(method, endpoint, body, tenantIdOverride) {
    const url = `${this.apiUrl}${endpoint}`;
    const headers = new Headers();
    headers.set("Content-Type", "application/json");
    if (this.apiKey) {
      headers.set("Authorization", `Bearer ${this.apiKey}`);
    }
    const effectiveTenantId = tenantIdOverride != null ? tenantIdOverride : this.tenantId;
    if (effectiveTenantId) {
      const trimmedTenantId = effectiveTenantId.trim();
      if (trimmedTenantId) {
        headers.set("X-Tenant-ID", trimmedTenantId);
      }
    }
    const options = {
      method,
      headers
    };
    if (body) {
      options.body = JSON.stringify(body);
    }
    const response = await fetch(url, options);
    if (!response.ok) {
      let error;
      try {
        error = await response.json();
      } catch (e) {
        error = {
          error: "unknown_error",
          message: `HTTP ${response.status}: ${response.statusText}`,
          code: "HTTP_ERROR"
        };
      }
      const errorMessage = error.message || error.error || `HTTP ${response.status}: ${response.statusText}`;
      throw new Error(errorMessage);
    }
    return response.json();
  }
  async listStories() {
    if (this.mode === "remote" && (!this.tenantId || !this.tenantId.trim())) {
      throw new Error("Tenant ID is required");
    }
    const response = await this.request(
      "GET",
      "/api/v1/stories"
    );
    return response.stories || [];
  }
  async getStory(id) {
    const response = await this.request(
      "GET",
      `/api/v1/stories/${id}`
    );
    return response.story;
  }
  async createStory(title, worldId) {
    if (this.mode === "remote" && (!this.tenantId || !this.tenantId.trim())) {
      throw new Error("Tenant ID is required");
    }
    const body = { title: title.trim() };
    if (worldId) {
      body.world_id = worldId;
    }
    const response = await this.request(
      "POST",
      "/api/v1/stories",
      body
    );
    return response.story;
  }
  async cloneStory(id) {
    if (!this.tenantId || !this.tenantId.trim()) {
      throw new Error("Tenant ID is required");
    }
    const response = await this.request(
      "POST",
      `/api/v1/stories/${id}/clone`,
      {}
    );
    return response.story;
  }
  async getTenant(id) {
    const response = await this.request(
      "GET",
      `/api/v1/tenants/${id}`
    );
    return response.tenant;
  }
  async testConnection() {
    try {
      await this.request("GET", "/health");
      return true;
    } catch (e) {
      return false;
    }
  }
  async updateStory(id, title, status) {
    const body = { title: title.trim() };
    if (status) {
      body.status = status;
    }
    const response = await this.request(
      "PUT",
      `/api/v1/stories/${id}`,
      body
    );
    return response.story;
  }
  async getStoryWithHierarchy(id) {
    const story = await this.getStory(id);
    const chapters = await this.getChapters(id);
    const chaptersWithContent = await Promise.all(
      chapters.map(async (chapter) => {
        const scenes = await this.getScenes(chapter.id);
        const scenesWithBeats = await Promise.all(
          scenes.map(async (scene) => {
            const beats = await this.getBeats(scene.id);
            return { scene, beats };
          })
        );
        return { chapter, scenes: scenesWithBeats };
      })
    );
    return {
      story,
      chapters: chaptersWithContent
    };
  }
  async createChapter(storyId, chapter) {
    const response = await this.request(
      "POST",
      "/api/v1/chapters",
      {
        story_id: storyId,
        number: chapter.number,
        title: chapter.title,
        status: chapter.status
      }
    );
    return response.chapter;
  }
  async updateChapter(id, chapter) {
    const response = await this.request(
      "PUT",
      `/api/v1/chapters/${id}`,
      chapter
    );
    return response.chapter;
  }
  async getChapters(storyId) {
    const response = await this.request(
      "GET",
      `/api/v1/stories/${storyId}/chapters`
    );
    return response.chapters || [];
  }
  async getChapter(id) {
    const response = await this.request(
      "GET",
      `/api/v1/chapters/${id}`
    );
    return response.chapter;
  }
  async deleteChapter(id) {
    await this.request("DELETE", `/api/v1/chapters/${id}`);
  }
  async createScene(scene) {
    const response = await this.request(
      "POST",
      "/api/v1/scenes",
      scene
    );
    return response.scene;
  }
  async updateScene(id, scene) {
    const response = await this.request(
      "PUT",
      `/api/v1/scenes/${id}`,
      scene
    );
    return response.scene;
  }
  async getScenes(chapterId) {
    const response = await this.request(
      "GET",
      `/api/v1/chapters/${chapterId}/scenes`
    );
    return response.scenes || [];
  }
  async getScene(id) {
    const response = await this.request(
      "GET",
      `/api/v1/scenes/${id}`
    );
    return response.scene;
  }
  async deleteScene(id) {
    await this.request("DELETE", `/api/v1/scenes/${id}`);
  }
  async createBeat(beat) {
    const response = await this.request(
      "POST",
      "/api/v1/beats",
      beat
    );
    return response.beat;
  }
  async updateBeat(id, beat) {
    const response = await this.request(
      "PUT",
      `/api/v1/beats/${id}`,
      beat
    );
    return response.beat;
  }
  async getBeats(sceneId) {
    const response = await this.request(
      "GET",
      `/api/v1/scenes/${sceneId}/beats`
    );
    return response.beats || [];
  }
  async getBeat(id) {
    const response = await this.request(
      "GET",
      `/api/v1/beats/${id}`
    );
    return response.beat;
  }
  async deleteBeat(id) {
    await this.request("DELETE", `/api/v1/beats/${id}`);
  }
  // Get all versions of a story (for version history)
  async getStoryVersions(rootStoryId) {
    const response = await this.request(
      "GET",
      `/api/v1/stories/${rootStoryId}/versions`
    );
    return response.stories || [];
  }
  async getScenesByStory(storyId) {
    const response = await this.request(
      "GET",
      `/api/v1/stories/${storyId}/scenes`
    );
    return response.scenes || [];
  }
  async moveScene(sceneId, chapterId) {
    const body = {};
    if (chapterId !== null) {
      body.chapter_id = chapterId;
    } else {
      body.chapter_id = null;
    }
    const response = await this.request(
      "PUT",
      `/api/v1/scenes/${sceneId}/move`,
      body
    );
    return response.scene;
  }
  async getBeatsByStory(storyId) {
    const response = await this.request(
      "GET",
      `/api/v1/stories/${storyId}/beats`
    );
    return response.beats || [];
  }
  async moveBeat(beatId, sceneId) {
    const response = await this.request(
      "PUT",
      `/api/v1/beats/${beatId}/move`,
      { scene_id: sceneId }
    );
    return response.beat;
  }
  async getContentBlocks(chapterId) {
    const response = await this.request(
      "GET",
      `/api/v1/chapters/${chapterId}/content-blocks`
    );
    return response.content_blocks || [];
  }
  async getContentBlock(id) {
    const response = await this.request(
      "GET",
      `/api/v1/content-blocks/${id}`
    );
    return response.content_block;
  }
  async createContentBlock(chapterId, contentBlock) {
    const response = await this.request(
      "POST",
      `/api/v1/chapters/${chapterId}/content-blocks`,
      contentBlock
    );
    return response.content_block;
  }
  async updateContentBlock(id, contentBlock) {
    const response = await this.request(
      "PUT",
      `/api/v1/content-blocks/${id}`,
      contentBlock
    );
    return response.content_block;
  }
  async deleteContentBlock(id) {
    await this.request("DELETE", `/api/v1/content-blocks/${id}`);
  }
  async getContentBlockReferences(contentBlockId) {
    const response = await this.request(
      "GET",
      `/api/v1/content-blocks/${contentBlockId}/references`
    );
    return response.references || [];
  }
  async getContentBlocksByScene(sceneId) {
    const response = await this.request(
      "GET",
      `/api/v1/scenes/${sceneId}/content-blocks`
    );
    return response.content_blocks || [];
  }
  async getContentBlocksByBeat(beatId) {
    const response = await this.request(
      "GET",
      `/api/v1/beats/${beatId}/content-blocks`
    );
    return response.content_blocks || [];
  }
  async createContentBlockReference(contentBlockId, entityType, entityId) {
    const response = await this.request(
      "POST",
      `/api/v1/content-blocks/${contentBlockId}/references`,
      {
        entity_type: entityType,
        entity_id: entityId
      }
    );
    return response.reference;
  }
  async deleteContentBlockReference(id) {
    await this.request("DELETE", `/api/v1/content-block-references/${id}`);
  }
  async getWorlds() {
    const response = await this.request(
      "GET",
      "/api/v1/worlds"
    );
    return response.worlds || [];
  }
  async getWorld(id) {
    const response = await this.request(
      "GET",
      `/api/v1/worlds/${id}`
    );
    return response.world;
  }
  async createWorld(name, description, genre) {
    const response = await this.request(
      "POST",
      "/api/v1/worlds",
      {
        name: name.trim(),
        description: description.trim(),
        genre: genre.trim()
      }
    );
    return response.world;
  }
  async updateWorld(id, name, description, genre) {
    const response = await this.request(
      "PUT",
      `/api/v1/worlds/${id}`,
      {
        name: name.trim(),
        description: description.trim(),
        genre: genre.trim()
      }
    );
    return response.world;
  }
  async getRPGSystems() {
    const response = await this.request(
      "GET",
      "/api/v1/rpg-systems"
    );
    return response.rpg_systems || [];
  }
  async getRPGSystem(id) {
    const response = await this.request(
      "GET",
      `/api/v1/rpg-systems/${id}`
    );
    return response.rpg_system;
  }
  // Character methods
  async getCharacters(worldId) {
    const response = await this.request(
      "GET",
      `/api/v1/worlds/${worldId}/characters`
    );
    return response.characters || [];
  }
  async getCharacter(id) {
    const response = await this.request(
      "GET",
      `/api/v1/characters/${id}`
    );
    return response.character;
  }
  async createCharacter(worldId, data) {
    const response = await this.request(
      "POST",
      `/api/v1/worlds/${worldId}/characters`,
      data
    );
    return response.character;
  }
  async updateCharacter(id, data) {
    const response = await this.request(
      "PUT",
      `/api/v1/characters/${id}`,
      data
    );
    return response.character;
  }
  async deleteCharacter(id) {
    await this.request("DELETE", `/api/v1/characters/${id}`);
  }
  // Location methods
  async getLocations(worldId) {
    const response = await this.request(
      "GET",
      `/api/v1/worlds/${worldId}/locations`
    );
    return response.locations || [];
  }
  async getLocation(id) {
    const response = await this.request(
      "GET",
      `/api/v1/locations/${id}`
    );
    return response.location;
  }
  async createLocation(worldId, data) {
    const response = await this.request(
      "POST",
      `/api/v1/worlds/${worldId}/locations`,
      data
    );
    return response.location;
  }
  async updateLocation(id, data) {
    const response = await this.request(
      "PUT",
      `/api/v1/locations/${id}`,
      data
    );
    return response.location;
  }
  async deleteLocation(id) {
    await this.request("DELETE", `/api/v1/locations/${id}`);
  }
  // Artifact methods
  async getArtifacts(worldId) {
    const response = await this.request(
      "GET",
      `/api/v1/worlds/${worldId}/artifacts`
    );
    return response.artifacts || [];
  }
  async getArtifact(id) {
    const response = await this.request(
      "GET",
      `/api/v1/artifacts/${id}`
    );
    return response.artifact;
  }
  async createArtifact(worldId, data) {
    const response = await this.request(
      "POST",
      `/api/v1/worlds/${worldId}/artifacts`,
      data
    );
    return response.artifact;
  }
  async updateArtifact(id, data) {
    const response = await this.request(
      "PUT",
      `/api/v1/artifacts/${id}`,
      data
    );
    return response.artifact;
  }
  async deleteArtifact(id) {
    await this.request("DELETE", `/api/v1/artifacts/${id}`);
  }
  // Event methods
  async getEvents(worldId) {
    const response = await this.request(
      "GET",
      `/api/v1/worlds/${worldId}/events`
    );
    return response.events || [];
  }
  async getEvent(id) {
    const response = await this.request(
      "GET",
      `/api/v1/events/${id}`
    );
    return response.event;
  }
  async createEvent(worldId, data) {
    const response = await this.request(
      "POST",
      `/api/v1/worlds/${worldId}/events`,
      data
    );
    return response.event;
  }
  async updateEvent(id, data) {
    const response = await this.request(
      "PUT",
      `/api/v1/events/${id}`,
      data
    );
    return response.event;
  }
  async deleteEvent(id) {
    await this.request("DELETE", `/api/v1/events/${id}`);
  }
  // Trait methods
  async getTraits() {
    const response = await this.request(
      "GET",
      "/api/v1/traits"
    );
    return response.traits || [];
  }
  async getTrait(id) {
    const response = await this.request(
      "GET",
      `/api/v1/traits/${id}`
    );
    return response.trait;
  }
  async createTrait(data) {
    const response = await this.request(
      "POST",
      "/api/v1/traits",
      data
    );
    return response.trait;
  }
  async updateTrait(id, data) {
    const response = await this.request(
      "PUT",
      `/api/v1/traits/${id}`,
      data
    );
    return response.trait;
  }
  async deleteTrait(id) {
    await this.request("DELETE", `/api/v1/traits/${id}`);
  }
};

// src/settings.ts
var import_obsidian = require("obsidian");
var StoryEngineSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Story Engine Settings" });
    let tenantIdSetting = null;
    let videoLinkSetting = null;
    let conflictResolutionSetting = null;
    const modeSetting = new import_obsidian.Setting(containerEl).setName("Connection Mode").setDesc("Choose between local (offline) or remote (cloud) mode").addDropdown(
      (dropdown) => dropdown.addOption("local", "Local").addOption("remote", "Remote").setValue(this.plugin.settings.mode || "local").onChange(async (value) => {
        this.plugin.settings.mode = value;
        if (value === "local") {
          this.plugin.settings.conflictResolution = "local";
          if (conflictResolutionSetting) {
            conflictResolutionSetting.settingEl.style.display = "none";
          }
        } else {
          if (conflictResolutionSetting) {
            conflictResolutionSetting.settingEl.style.display = "";
          }
        }
        if (tenantIdSetting) {
          tenantIdSetting.settingEl.style.display = value === "remote" ? "" : "none";
        }
        if (videoLinkSetting) {
          videoLinkSetting.settingEl.style.display = value === "local" ? "" : "none";
        }
        if (this.plugin.apiClient) {
          this.plugin.apiClient.setMode(value);
        }
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("API URL").setDesc("The base URL of the Story Engine API").addText(
      (text) => text.setPlaceholder("http://localhost:8080").setValue(this.plugin.settings.apiUrl).onChange(async (value) => {
        this.plugin.settings.apiUrl = value;
        await this.plugin.saveSettings();
      })
    );
    tenantIdSetting = new import_obsidian.Setting(containerEl).setName("Tenant ID").setDesc("Your workspace tenant ID (UUID format) - Required in remote mode").addText(
      (text) => text.setPlaceholder("00000000-0000-0000-0000-000000000000").setValue(this.plugin.settings.tenantId || "").onChange(async (value) => {
        this.plugin.settings.tenantId = value.trim();
        if (this.plugin.apiClient) {
          this.plugin.apiClient.setTenantId(value.trim());
        }
        await this.plugin.saveSettings();
      })
    );
    if (this.plugin.settings.mode === "local") {
      tenantIdSetting.settingEl.style.display = "none";
    }
    const videoUrl = this.plugin.settings.localModeVideoUrl || "https://example.com/setup-video";
    videoLinkSetting = new import_obsidian.Setting(containerEl).setName("Setup Guide").setDesc(`\u{1F4F9} Learn how to setup local mode: ${videoUrl}`).addButton((button) => {
      button.setButtonText("Open Video").onClick(() => {
        window.open(videoUrl, "_blank");
      });
    });
    if (this.plugin.settings.mode === "remote") {
      videoLinkSetting.settingEl.style.display = "none";
    }
    new import_obsidian.Setting(containerEl).setName("API Key").setDesc("API key for authentication (optional for MVP)").addText((text) => {
      text.setPlaceholder("Enter API key").setValue(this.plugin.settings.apiKey).inputEl.type = "password";
      text.onChange(async (value) => {
        this.plugin.settings.apiKey = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Sync Folder Path").setDesc("Folder path where synced stories will be stored").addText(
      (text) => text.setPlaceholder("Stories").setValue(this.plugin.settings.syncFolderPath || "Stories").onChange(async (value) => {
        this.plugin.settings.syncFolderPath = value.trim() || "Stories";
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Auto Version Snapshots").setDesc("Automatically create version snapshots when syncing").addToggle(
      (toggle) => {
        var _a;
        return toggle.setValue((_a = this.plugin.settings.autoVersionSnapshots) != null ? _a : true).onChange(async (value) => {
          this.plugin.settings.autoVersionSnapshots = value;
          await this.plugin.saveSettings();
        });
      }
    );
    conflictResolutionSetting = new import_obsidian.Setting(containerEl).setName("Conflict Resolution").setDesc("How to resolve conflicts when both local and service have changes").addDropdown(
      (dropdown) => dropdown.addOption("service", "Service Wins").addOption("local", "Local Wins").addOption("manual", "Manual (Newer Wins)").setValue(this.plugin.settings.conflictResolution || "service").onChange(async (value) => {
        this.plugin.settings.conflictResolution = value;
        await this.plugin.saveSettings();
      })
    );
    if (this.plugin.settings.mode === "local") {
      conflictResolutionSetting.settingEl.style.display = "none";
    }
    new import_obsidian.Setting(containerEl).setName("Show Help Box in MD Files").setDesc("Enable/disable info/help boxes in markdown files").addToggle(
      (toggle) => {
        var _a;
        return toggle.setValue((_a = this.plugin.settings.showHelpBox) != null ? _a : true).onChange(async (value) => {
          this.plugin.settings.showHelpBox = value;
          await this.plugin.saveSettings();
        });
      }
    );
    new import_obsidian.Setting(containerEl).setName("Unsplash Access Key").setDesc("Application ID / Access Key for Unsplash API (get one at https://unsplash.com/developers)").addText((text) => {
      text.setPlaceholder("Enter Unsplash access key").setValue(this.plugin.settings.unsplashAccessKey || "").inputEl.type = "password";
      text.onChange(async (value) => {
        this.plugin.settings.unsplashAccessKey = value.trim();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Unsplash Secret Key").setDesc("Secret Key for Unsplash API (optional, needed for some operations)").addText((text) => {
      text.setPlaceholder("Enter Unsplash secret key").setValue(this.plugin.settings.unsplashSecretKey || "").inputEl.type = "password";
      text.onChange(async (value) => {
        this.plugin.settings.unsplashSecretKey = value.trim();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Test Connection").setDesc("Test connection to the Story Engine API").addButton(
      (button) => button.setButtonText("Test").onClick(async () => {
        button.setButtonText("Testing...");
        button.setDisabled(true);
        try {
          const result = await this.plugin.apiClient.testConnection();
          if (result) {
            button.setButtonText("Success!");
            setTimeout(() => {
              button.setButtonText("Test");
              button.setDisabled(false);
            }, 2e3);
          } else {
            button.setButtonText("Failed");
            setTimeout(() => {
              button.setButtonText("Test");
              button.setDisabled(false);
            }, 2e3);
          }
        } catch (err) {
          button.setButtonText("Error");
          setTimeout(() => {
            button.setButtonText("Test");
            button.setDisabled(false);
          }, 2e3);
        }
      })
    );
  }
};

// src/commands.ts
var import_obsidian3 = require("obsidian");

// src/views/StorySyncModal.ts
var import_obsidian2 = require("obsidian");
var StorySyncModal = class extends import_obsidian2.Modal {
  constructor(plugin, mode) {
    super(plugin.app);
    this.stories = [];
    this.loading = true;
    this.error = null;
    this.plugin = plugin;
    this.mode = mode;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    const title = this.mode === "pull" ? "Sync Story from Service" : "Push Story to Service";
    contentEl.createEl("h2", { text: title });
    await this.loadStories();
    if (this.loading) {
      contentEl.createEl("p", { text: "Loading stories..." });
      return;
    }
    if (this.error) {
      contentEl.createEl("p", {
        text: `Error: ${this.error}`,
        cls: "story-engine-error"
      });
      return;
    }
    if (this.stories.length === 0) {
      contentEl.createEl("p", { text: "No stories found." });
      return;
    }
    const storiesList = contentEl.createEl("div", { cls: "story-engine-list" });
    for (const story of this.stories) {
      const storyItem = storiesList.createEl("div", {
        cls: "story-engine-item"
      });
      const title2 = storyItem.createEl("div", {
        cls: "story-engine-title",
        text: story.title
      });
      const meta = storyItem.createEl("div", {
        cls: "story-engine-meta"
      });
      meta.createEl("span", {
        text: `Version ${story.version_number}`
      });
      meta.createEl("span", {
        text: `Status: ${story.status}`
      });
      storyItem.onclick = async () => {
        this.close();
        try {
          if (this.mode === "pull") {
            await this.plugin.syncService.pullStory(story.id);
          } else {
            const folderPath = this.plugin.fileManager.getStoryFolderPath(
              story.title
            );
            await this.plugin.syncService.pushStory(folderPath);
          }
        } catch (err) {
          const errorMessage = err instanceof Error ? err.message : "Failed to sync story";
          new import_obsidian2.Notice(`Error: ${errorMessage}`, 5e3);
        }
      };
    }
  }
  async loadStories() {
    this.loading = true;
    this.error = null;
    try {
      if (!this.plugin.settings.tenantId) {
        this.error = "Tenant ID not configured";
        this.loading = false;
        return;
      }
      this.stories = await this.plugin.apiClient.listStories();
    } catch (err) {
      this.error = err instanceof Error ? err.message : "Unknown error";
    } finally {
      this.loading = false;
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/commands.ts
function registerCommands(plugin) {
  plugin.addCommand({
    id: "list-stories",
    name: "List Stories",
    callback: () => {
      plugin.activateView();
    }
  });
  plugin.addCommand({
    id: "create-story",
    name: "Create Story",
    callback: () => {
      plugin.createStoryCommand();
    }
  });
  plugin.addCommand({
    id: "sync-story-from-service",
    name: "Sync Story from Service",
    callback: () => {
      new StorySyncModal(plugin, "pull").open();
    }
  });
  plugin.addCommand({
    id: "push-story-to-service",
    name: "Push Story to Service",
    callback: () => {
      new StorySyncModal(plugin, "push").open();
    }
  });
  plugin.addCommand({
    id: "sync-all-stories",
    name: "Sync All Stories",
    callback: async () => {
      if (plugin.settings.mode === "remote" && !plugin.settings.tenantId) {
        new import_obsidian3.Notice("Please configure Tenant ID in settings", 5e3);
        return;
      }
      try {
        new import_obsidian3.Notice("Syncing all stories...");
        await plugin.syncService.pullAllStories();
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to sync stories";
        new import_obsidian3.Notice(`Error: ${errorMessage}`, 5e3);
      }
    }
  });
}

// src/views/CreateStoryModal.ts
var import_obsidian5 = require("obsidian");

// src/views/CreateWorldModal.ts
var import_obsidian4 = require("obsidian");
var CreateWorldModal = class extends import_obsidian4.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.name = "";
    this.description = "";
    this.genre = "";
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Create New World" });
    new import_obsidian4.Setting(contentEl).setName("World Name").setDesc("Enter the name for your new world").addText(
      (text) => text.setPlaceholder("My New World").setValue(this.name).onChange((value) => {
        this.name = value;
      }).inputEl.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          const descriptionInput = contentEl.querySelector("textarea");
          if (descriptionInput) {
            descriptionInput.focus();
          }
        }
      })
    );
    new import_obsidian4.Setting(contentEl).setName("Description").setDesc("Enter a description for your world").addTextArea(
      (text) => text.setPlaceholder("A brief description of your world...").setValue(this.description).onChange((value) => {
        this.description = value;
      })
    );
    new import_obsidian4.Setting(contentEl).setName("Genre").setDesc("Enter the genre of your world").addText(
      (text) => text.setPlaceholder("Fantasy, Sci-Fi, Contemporary, etc.").setValue(this.genre).onChange((value) => {
        this.genre = value;
      }).inputEl.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          this.submit();
        }
      })
    );
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const createButton = buttonContainer.createEl("button", {
      text: "Create",
      cls: "mod-cta"
    });
    createButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
    const nameInput = contentEl.querySelector("input");
    if (nameInput) {
      nameInput.focus();
    }
  }
  submit() {
    const trimmedName = this.name.trim();
    const trimmedDescription = this.description.trim();
    const trimmedGenre = this.genre.trim();
    if (!trimmedName) {
      new import_obsidian4.Notice("Please enter a world name", 3e3);
      return;
    }
    if (!trimmedGenre) {
      new import_obsidian4.Notice("Please enter a genre", 3e3);
      return;
    }
    this.close();
    this.onSubmit(trimmedName, trimmedDescription, trimmedGenre);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/CreateStoryModal.ts
var CreateStoryModal = class extends import_obsidian5.Modal {
  constructor(app, plugin, onSubmit) {
    super(app);
    this.title = "";
    this.selectedWorldId = "";
    this.shouldSync = true;
    this.worlds = [];
    this.plugin = plugin;
    this.onSubmit = onSubmit;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Create New Story" });
    try {
      this.worlds = await this.plugin.apiClient.getWorlds();
    } catch (err) {
      console.error("Failed to load worlds:", err);
      this.worlds = [];
    }
    new import_obsidian5.Setting(contentEl).setName("Story Title").setDesc("Enter the title for your new story").addText(
      (text) => text.setPlaceholder("My New Story").setValue(this.title).onChange((value) => {
        this.title = value;
      }).inputEl.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          this.submit();
        }
      })
    );
    const worldOptions = {
      "": "No World"
    };
    for (const world of this.worlds) {
      worldOptions[world.id] = world.name;
    }
    worldOptions["__create_new__"] = "Create new world...";
    new import_obsidian5.Setting(contentEl).setName("World").setDesc("Select a world for this story (optional)").addDropdown((dropdown) => {
      for (const [value, label] of Object.entries(worldOptions)) {
        dropdown.addOption(value, label);
      }
      dropdown.setValue(this.selectedWorldId || "");
      dropdown.onChange(async (value) => {
        if (value === "__create_new__") {
          new CreateWorldModal(this.app, async (name, description, genre) => {
            try {
              const newWorld = await this.plugin.apiClient.createWorld(name, description, genre);
              this.worlds.push(newWorld);
              this.onClose();
              this.onOpen();
              this.selectedWorldId = newWorld.id;
            } catch (err) {
              const errorMessage = err instanceof Error ? err.message : "Failed to create world";
              new import_obsidian5.Notice(`Error: ${errorMessage}`, 5e3);
            }
          }).open();
        } else {
          this.selectedWorldId = value;
        }
      });
    });
    new import_obsidian5.Setting(contentEl).setName("Sync to Obsidian").setDesc("Automatically sync the story files to your vault after creation").addToggle(
      (toggle) => toggle.setValue(this.shouldSync).onChange((value) => {
        this.shouldSync = value;
      })
    );
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const createButton = buttonContainer.createEl("button", {
      text: "Create",
      cls: "mod-cta"
    });
    createButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
    const titleInput = contentEl.querySelector("input");
    if (titleInput) {
      titleInput.focus();
    }
  }
  submit() {
    const trimmedTitle = this.title.trim();
    if (!trimmedTitle) {
      new import_obsidian5.Notice("Please enter a story title", 3e3);
      return;
    }
    this.close();
    const worldId = this.selectedWorldId && this.selectedWorldId !== "__create_new__" ? this.selectedWorldId : void 0;
    this.onSubmit(trimmedTitle, worldId, this.shouldSync);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/sync/fileManager.ts
var import_obsidian6 = require("obsidian");
var FileManager = class {
  constructor(vault, baseFolder) {
    this.vault = vault;
    this.baseFolder = baseFolder;
  }
  // Expose vault for sync operations
  getVault() {
    return this.vault;
  }
  // Get the folder path for a specific story
  getStoryFolderPath(storyTitle) {
    const sanitized = this.sanitizeFolderName(storyTitle);
    return `${this.baseFolder}/${sanitized}`;
  }
  // Sanitize folder/file names
  sanitizeFolderName(name) {
    return name.replace(/[<>:"/\\|?*]/g, "-").replace(/\s+/g, " ").trim();
  }
  // Generate frontmatter with Obsidian tags
  generateFrontmatter(baseFields, extraFields, options) {
    const fields = { ...baseFields };
    if (extraFields) {
      Object.assign(fields, extraFields);
    }
    const tags = [];
    if (options) {
      tags.push(`story-engine/${options.entityType}`);
      if (options.storyName) {
        const sanitizedStoryName = this.sanitizeFolderName(options.storyName).toLowerCase().replace(/\s+/g, "-");
        tags.push(`story/${sanitizedStoryName}`);
      }
      if (options.date) {
        const date = typeof options.date === "string" ? new Date(options.date) : options.date;
        if (!isNaN(date.getTime())) {
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, "0");
          const day = String(date.getDate()).padStart(2, "0");
          tags.push(`date/${year}/${month}/${day}`);
        }
      }
    }
    const lines = ["---"];
    for (const [key, value] of Object.entries(fields)) {
      if (value === null || value === void 0) {
        lines.push(`${key}: null`);
      } else if (typeof value === "string") {
        const escaped = value.replace(/"/g, '\\"');
        if (value.includes(":") || value.includes("\n") || value.includes('"')) {
          lines.push(`${key}: "${escaped}"`);
        } else {
          lines.push(`${key}: ${escaped}`);
        }
      } else {
        lines.push(`${key}: ${value}`);
      }
    }
    if (tags.length > 0) {
      lines.push(`tags:`);
      for (const tag of tags) {
        lines.push(`  - ${tag}`);
      }
    }
    lines.push("---", "");
    return lines.join("\n");
  }
  // Ensure folder exists
  async ensureFolderExists(path) {
    const folder = this.vault.getAbstractFileByPath(path);
    if (!folder) {
      await this.vault.createFolder(path);
    }
  }
  // Write story metadata (story.md)
  async writeStoryMetadata(story, folderPath, chapters, orphanScenes, orphanBeats, chapterContentData) {
    var _a, _b;
    await this.ensureFolderExists(folderPath);
    const baseFields = {
      id: story.id,
      title: story.title,
      status: story.status,
      version: story.version_number,
      root_story_id: story.root_story_id,
      previous_version_id: story.previous_story_id,
      created_at: story.created_at,
      updated_at: story.updated_at
    };
    const frontmatter = this.generateFrontmatter(baseFields, void 0, {
      entityType: "story",
      storyName: story.title,
      date: story.created_at
    });
    let content = `${frontmatter}
# ${story.title}

Version: ${story.version_number}
Status: ${story.status}

`;
    const temporaryChapterTitles = ["Story Prose", "Scene-Level Prose", "Beat-Level Prose"];
    const filteredChapters = (chapters == null ? void 0 : chapters.filter(
      (c) => !temporaryChapterTitles.includes(c.chapter.title) && c.chapter.number < 9e3
    )) || [];
    if (filteredChapters.length > 0) {
      content += `## Chapters, Scenes & Beats

`;
      content += `> [!info] How to use this list
`;
      content += `> - **Create new item**: Add a line with \`-\` followed by the text
`;
      content += `>   - **Chapter**: No indentation (level 0)
`;
      content += `>   - **Scene**: Use 1 tab indentation (inside a chapter)
`;
      content += `>   - **Beat**: Use 2 tabs indentation (inside a scene)
`;
      content += `> - **Reorder**: Move items up/down to change order
`;
      content += `> - **Links**: Use \`[[link-name|text]]\` to create links to existing files
`;
      content += `> - **Format**:
`;
      content += `>   - **Chapter**:
`;
      content += `>     - Complete: \`Chapter N: title\`
`;
      content += `>     - Simplified: \`title\`
`;
      content += `>   - **Scene**:
`;
      content += `>     - Complete: \`Scene N: goal - timeRef\`
`;
      content += `>     - Simplified:
`;
      content += `>       - \`goal - timeRef\`
`;
      content += `>       - \`goal\`
`;
      content += `>   - **Beat**:
`;
      content += `>     - Complete: \`Beat N: intent -> outcome\`
`;
      content += `>     - Simplified:
`;
      content += `>       - \`intent -> outcome\`
`;
      content += `>       - \`intent\`
`;
      content += `> - **Markers**: \`-\` indicates no associated prose, \`+\` indicates associated prose

`;
      for (const chapterWithContent of filteredChapters) {
        const chapter = chapterWithContent.chapter;
        const chapterFileName = `Chapter-${chapter.number}.md`;
        const chapterLinkName = chapterFileName.replace(/\.md$/, "");
        content += `- [[${chapterLinkName}|Chapter ${chapter.number}: ${chapter.title}]]
`;
        for (const { scene, beats } of chapterWithContent.scenes) {
          const sceneFileName = this.generateSceneFileName(scene);
          const sceneLinkName = sceneFileName.replace(/\.md$/, "");
          const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
          content += `	- [[${sceneLinkName}|Scene ${scene.order_num}: ${sceneDisplayText}]]
`;
          for (const beat of beats) {
            const beatFileName = this.generateBeatFileName(beat);
            const beatLinkName = beatFileName.replace(/\.md$/, "");
            const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
            content += `		- [[${beatLinkName}|Beat ${beat.order_num}: ${beatDisplayText}]]
`;
          }
        }
      }
      content += `
`;
    }
    if (orphanScenes && orphanScenes.length > 0) {
      content += `## Orphan Scenes

`;
      content += `> [!info] Scenes without a chapter
`;
      content += `> These scenes are not associated with any chapter. You can:
`;
      content += `> - **Reorder**: Move items up/down to change order
`;
      content += `> - **Links**: Use \`[[link-name|text]]\` to create links to existing files
`;
      content += `> - **Format**:
`;
      content += `>   - Complete: \`Scene N: goal - timeRef\`
`;
      content += `>   - Simplified:
`;
      content += `>     - \`goal - timeRef\`
`;
      content += `>     - \`goal\`
`;
      content += `> - **Markers**: \`-\` indicates no associated prose, \`+\` indicates associated prose

`;
      for (const { scene, beats } of orphanScenes) {
        const sceneFileName = this.generateSceneFileName(scene);
        const sceneLinkName = sceneFileName.replace(/\.md$/, "");
        const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
        content += `- [[${sceneLinkName}|Scene ${scene.order_num}: ${sceneDisplayText}]]
`;
        for (const beat of beats) {
          const beatFileName = this.generateBeatFileName(beat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
          content += `	- [[${beatLinkName}|Beat ${beat.order_num}: ${beatDisplayText}]]
`;
        }
      }
      content += `
`;
    }
    if (orphanBeats && orphanBeats.length > 0) {
      content += `## Orphan Beats

`;
      content += `> [!info] Beats without a scene
`;
      content += `> These beats are not associated with any scene. You can:
`;
      content += `> - **Reorder**: Move items up/down to change order
`;
      content += `> - **Links**: Use \`[[link-name|text]]\` to create links to existing files
`;
      content += `> - **Format**:
`;
      content += `>   - Complete: \`Beat N: intent -> outcome\`
`;
      content += `>   - Simplified:
`;
      content += `>     - \`intent -> outcome\`
`;
      content += `>     - \`intent\`
`;
      content += `> - **Markers**: \`-\` indicates no associated prose, \`+\` indicates associated prose

`;
      for (const beat of orphanBeats) {
        const beatFileName = this.generateBeatFileName(beat);
        const beatLinkName = beatFileName.replace(/\.md$/, "");
        const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
        content += `- [[${beatLinkName}|Beat ${beat.order_num}: ${beatDisplayText}]]
`;
      }
      content += `
`;
    }
    content += `# Story: ${story.title}

`;
    if (filteredChapters.length > 0) {
      for (const chapterWithContent of filteredChapters) {
        const chapter = chapterWithContent.chapter;
        const chapterFileName = `Chapter-${chapter.number}.md`;
        const chapterLinkName = chapterFileName.replace(/\.md$/, "");
        content += `## Chapter ${chapter.number}: [[${chapterLinkName}|${chapter.title}]]

`;
        const contentData = chapterContentData == null ? void 0 : chapterContentData.get(chapter.id);
        let organization = null;
        if (contentData) {
          organization = this.organizeContentBlocks(
            contentData.contentBlocks,
            contentData.contentBlockRefs,
            chapterWithContent.scenes
          );
          for (const contentBlock of organization.chapterOnly) {
            const fileName = this.generateContentBlockFileName(contentBlock);
            const linkName = fileName.replace(/\.md$/, "");
            content += `[[${linkName}|${contentBlock.content.substring(0, 50)}...]]

`;
          }
        }
        for (const { scene, beats } of chapterWithContent.scenes) {
          const sceneFileName = this.generateSceneFileName(scene);
          const sceneLinkName = sceneFileName.replace(/\.md$/, "");
          const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
          content += `### Scene: [[${sceneLinkName}|${sceneDisplayText}]]

`;
          if (organization) {
            const sceneContentBlocks = ((_a = organization.byScene.get(scene.id)) == null ? void 0 : _a.contentBlocks) || [];
            for (const contentBlock of sceneContentBlocks) {
              const fileName = this.generateContentBlockFileName(contentBlock);
              const linkName = fileName.replace(/\.md$/, "");
              content += `[[${linkName}|${contentBlock.content.substring(0, 50)}...]]

`;
            }
          }
          for (const beat of beats) {
            const beatFileName = this.generateBeatFileName(beat);
            const beatLinkName = beatFileName.replace(/\.md$/, "");
            const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
            content += `#### Beat: [[${beatLinkName}|${beatDisplayText}]]

`;
            if (organization) {
              const beatContentBlocks = ((_b = organization.byBeat.get(beat.id)) == null ? void 0 : _b.contentBlocks) || [];
              for (const contentBlock of beatContentBlocks) {
                const fileName = this.generateContentBlockFileName(contentBlock);
                const linkName = fileName.replace(/\.md$/, "");
                content += `[[${linkName}|${contentBlock.content.substring(0, 50)}...]]

`;
              }
            }
          }
        }
      }
    }
    if (orphanScenes && orphanScenes.length > 0) {
      for (const { scene, beats } of orphanScenes) {
        const sceneFileName = this.generateSceneFileName(scene);
        const sceneLinkName = sceneFileName.replace(/\.md$/, "");
        const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
        content += `### Scene: [[${sceneLinkName}|${sceneDisplayText}]]

`;
        for (const beat of beats) {
          const beatFileName = this.generateBeatFileName(beat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
          content += `#### Beat: [[${beatLinkName}|${beatDisplayText}]]

`;
        }
      }
    }
    const filePath = `${folderPath}/story.md`;
    const file = this.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian6.TFile) {
      await this.vault.modify(file, content);
    } else {
      await this.vault.create(filePath, content);
    }
  }
  // Write chapter file
  async writeChapterFile(chapterWithContent, filePath, storyName, contentBlocks, contentBlockRefs, orphanScenes) {
    var _a, _b, _c, _d;
    const { chapter, scenes } = chapterWithContent;
    const baseFields = {
      id: chapter.id,
      story_id: chapter.story_id,
      number: chapter.number,
      title: chapter.title,
      status: chapter.status,
      created_at: chapter.created_at,
      updated_at: chapter.updated_at
    };
    const frontmatter = this.generateFrontmatter(baseFields, void 0, {
      entityType: "chapter",
      storyName,
      date: chapter.created_at
    });
    let content = `${frontmatter}
# ${chapter.title}

`;
    const organization = this.organizeContentBlocks(
      contentBlocks || [],
      contentBlockRefs || [],
      scenes
    );
    content += `## Scenes & Beats

`;
    content += `> [!info] How to use this list
`;
    content += `> - **Create new item**: Add a line with \`-\` followed by the text
`;
    content += `>   - **Scene**: No indentation (level 0)
`;
    content += `>   - **Beat**: Use 1 tab indentation (inside a scene)
`;
    content += `> - **Reorder**: Move items up/down to change order
`;
    content += `> - **Links**: Use \`[[link-name|text]]\` to create links to existing files
`;
    content += `> - **Format**:
`;
    content += `>   - **Scene**:
`;
    content += `>     - Complete: \`Scene N: goal - timeRef\`
`;
    content += `>     - Simplified:
`;
    content += `>       - \`goal - timeRef\`
`;
    content += `>       - \`goal\`
`;
    content += `>   - **Beat**:
`;
    content += `>     - Complete: \`Beat N: intent -> outcome\`
`;
    content += `>     - Simplified:
`;
    content += `>       - \`intent -> outcome\`
`;
    content += `>       - \`intent\`
`;
    content += `> - **Markers**: \`-\` indicates no associated prose, \`+\` indicates associated prose
`;
    content += `> - **Orphan scenes** (without chapter) are shown below for easy association

`;
    for (const { scene, beats } of scenes) {
      const sceneFileName = this.generateSceneFileName(scene);
      const sceneLinkName = sceneFileName.replace(/\.md$/, "");
      const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
      const sceneContentBlocks = ((_a = organization.byScene.get(scene.id)) == null ? void 0 : _a.contentBlocks) || [];
      const hasSceneContent = sceneContentBlocks.length > 0;
      const sceneMarker = hasSceneContent ? "+" : "-";
      content += `${sceneMarker} [[${sceneLinkName}|Scene ${scene.order_num}: ${sceneDisplayText}]]
`;
      for (const beat of beats) {
        const beatFileName = this.generateBeatFileName(beat);
        const beatLinkName = beatFileName.replace(/\.md$/, "");
        const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
        const beatContentBlocks = ((_b = organization.byBeat.get(beat.id)) == null ? void 0 : _b.contentBlocks) || [];
        const hasBeatContent = beatContentBlocks.length > 0;
        const beatMarker = hasBeatContent ? "+" : "-";
        content += `	${beatMarker} [[${beatLinkName}|Beat ${beat.order_num}: ${beatDisplayText}]]
`;
      }
    }
    if (orphanScenes && orphanScenes.length > 0) {
      content += `
`;
      content += `> [!info] Orphan Scenes (not yet associated with this chapter)
`;
      content += `> You can associate these scenes with this chapter by moving them here.

`;
      for (const { scene, beats } of orphanScenes) {
        const sceneFileName = this.generateSceneFileName(scene);
        const sceneLinkName = sceneFileName.replace(/\.md$/, "");
        const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
        content += `- [[${sceneLinkName}|Scene ${scene.order_num}: ${sceneDisplayText}]]
`;
        for (const beat of beats) {
          const beatFileName = this.generateBeatFileName(beat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
          content += `	- [[${beatLinkName}|Beat ${beat.order_num}: ${beatDisplayText}]]
`;
        }
      }
    }
    content += `
`;
    content += `## Chapter ${chapter.number}: ${chapter.title}

`;
    for (const contentBlock of organization.chapterOnly) {
      const fileName = this.generateContentBlockFileName(contentBlock);
      const linkName = fileName.replace(/\.md$/, "");
      content += `[[${linkName}|${contentBlock.content.substring(0, 50)}...]]

`;
    }
    for (const { scene, beats } of scenes) {
      const sceneFileName = this.generateSceneFileName(scene);
      const sceneLinkName = sceneFileName.replace(/\.md$/, "");
      const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
      content += `## Scene: [[${sceneLinkName}|${sceneDisplayText}]]

`;
      const sceneContentBlocks = ((_c = organization.byScene.get(scene.id)) == null ? void 0 : _c.contentBlocks) || [];
      for (const contentBlock of sceneContentBlocks) {
        const fileName = this.generateContentBlockFileName(contentBlock);
        const linkName = fileName.replace(/\.md$/, "");
        content += `[[${linkName}|${contentBlock.content.substring(0, 50)}...]]

`;
      }
      for (const beat of beats) {
        const beatFileName = this.generateBeatFileName(beat);
        const beatLinkName = beatFileName.replace(/\.md$/, "");
        const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
        content += `### Beat: [[${beatLinkName}|${beatDisplayText}]]

`;
        const beatContentBlocks = ((_d = organization.byBeat.get(beat.id)) == null ? void 0 : _d.contentBlocks) || [];
        for (const contentBlock of beatContentBlocks) {
          const fileName = this.generateContentBlockFileName(contentBlock);
          const linkName = fileName.replace(/\.md$/, "");
          content += `[[${linkName}|${contentBlock.content.substring(0, 50)}...]]

`;
        }
      }
    }
    const file = this.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian6.TFile) {
      await this.vault.modify(file, content);
    } else {
      await this.vault.create(filePath, content);
    }
  }
  // Read story metadata
  async readStoryMetadata(folderPath) {
    const filePath = `${folderPath}/story.md`;
    const file = this.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian6.TFile)) {
      throw new Error(`Story metadata file not found: ${filePath}`);
    }
    const content = await this.vault.read(file);
    const frontmatter = this.parseFrontmatter(content);
    return {
      frontmatter: {
        id: frontmatter.id,
        title: frontmatter.title,
        status: frontmatter.status,
        version: parseInt(frontmatter.version),
        root_story_id: frontmatter.root_story_id,
        previous_version_id: frontmatter.previous_version_id || null,
        created_at: frontmatter.created_at,
        updated_at: frontmatter.updated_at
      },
      content: content.split("---").slice(2).join("---").trim()
    };
  }
  // Parse YAML frontmatter
  parseFrontmatter(content) {
    const match = content.match(/^---\n([\s\S]*?)\n---/);
    if (!match) {
      return {};
    }
    const frontmatterText = match[1];
    const result = {};
    for (const line of frontmatterText.split("\n")) {
      const colonIndex = line.indexOf(":");
      if (colonIndex > 0) {
        const key = line.slice(0, colonIndex).trim();
        const value = line.slice(colonIndex + 1).trim().replace(/^["']|["']$/g, "");
        result[key] = value;
      }
    }
    return result;
  }
  // Copy story folder to versions folder
  async createVersionSnapshot(storyFolderPath, versionNumber) {
    const versionsPath = `${storyFolderPath}/versions`;
    await this.ensureFolderExists(versionsPath);
    const versionFolderPath = `${versionsPath}/v${versionNumber}`;
    const existingVersion = this.vault.getAbstractFileByPath(versionFolderPath);
    if (existingVersion) {
      console.log(`Version v${versionNumber} already exists, skipping snapshot`);
      return;
    }
    await this.ensureFolderExists(versionFolderPath);
    const storyFolder = this.vault.getAbstractFileByPath(storyFolderPath);
    if (!(storyFolder instanceof import_obsidian6.TFolder)) {
      throw new Error(`Story folder not found: ${storyFolderPath}`);
    }
    await this.copyFolderContents(storyFolder, versionFolderPath, "versions");
    console.log(`Created version snapshot: v${versionNumber}`);
  }
  // Recursively copy folder contents
  async copyFolderContents(sourceFolder, destPath, excludeFolderName) {
    for (const child of sourceFolder.children) {
      if (child instanceof import_obsidian6.TFile) {
        const relativePath = child.path.replace(sourceFolder.path + "/", "");
        const destFilePath = `${destPath}/${relativePath}`;
        const content = await this.vault.read(child);
        await this.vault.create(destFilePath, content);
      } else if (child instanceof import_obsidian6.TFolder) {
        if (excludeFolderName && child.name === excludeFolderName) {
          continue;
        }
        const relativePath = child.path.replace(sourceFolder.path + "/", "");
        const destFolderPath = `${destPath}/${relativePath}`;
        await this.ensureFolderExists(destFolderPath);
        await this.copyFolderContents(child, destFolderPath, excludeFolderName);
      }
    }
  }
  // Write scene file
  async writeSceneFile(sceneWithBeats, filePath, storyName, contentBlocks, orphanBeats) {
    var _a;
    const { scene, beats } = sceneWithBeats;
    const baseFields = {
      id: scene.id,
      story_id: scene.story_id,
      chapter_id: (_a = scene.chapter_id) != null ? _a : null,
      order_num: scene.order_num,
      time_ref: scene.time_ref || "",
      goal: scene.goal || "",
      created_at: scene.created_at,
      updated_at: scene.updated_at
    };
    const extraFields = {};
    if (scene.pov_character_id) {
      extraFields.pov_character_id = scene.pov_character_id;
    }
    if (scene.location_id) {
      extraFields.location_id = scene.location_id;
    }
    const frontmatter = this.generateFrontmatter(baseFields, extraFields, {
      entityType: "scene",
      storyName,
      date: scene.created_at
    });
    let content = `${frontmatter}
# Scene ${scene.order_num}

`;
    if (scene.goal) {
      content += `**Goal:** ${scene.goal}

`;
    }
    if (scene.time_ref) {
      content += `**Time:** ${scene.time_ref}

`;
    }
    if (beats.length > 0) {
      content += `## Beats

`;
      content += `> [!info] How to use this list
`;
      content += `> - **Create new item**: Add a line with \`-\` followed by the text
`;
      content += `>   - **Beat**: No indentation (level 0)
`;
      content += `> - **Reorder**: Move items up/down to change order
`;
      content += `> - **Links**: Use \`[[link-name|text]]\` to create links to existing files
`;
      content += `> - **Format**:
`;
      content += `>   - **Beat**:
`;
      content += `>     - Complete: \`Beat N: intent -> outcome\`
`;
      content += `>     - Simplified:
`;
      content += `>       - \`intent -> outcome\`
`;
      content += `>       - \`intent\`
`;
      content += `> - **Markers**: \`-\` indicates no associated prose, \`+\` indicates associated prose
`;
      content += `> - **Orphan beats** (without scene) are shown below for easy association

`;
      const beatsWithProse = /* @__PURE__ */ new Set();
      if (contentBlocks) {
        for (const contentBlock of contentBlocks) {
        }
      }
      for (const beat of beats.sort((a, b) => a.order_num - b.order_num)) {
        const beatFileName = this.generateBeatFileName(beat);
        const beatLinkName = beatFileName.replace(/\.md$/, "");
        const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
        const hasBeatProse = beatsWithProse.has(beat.id);
        const beatMarker = hasBeatProse ? "+" : "-";
        content += `${beatMarker} [[${beatLinkName}|Beat ${beat.order_num}: ${beatDisplayText}]]
`;
      }
      if (orphanBeats && orphanBeats.length > 0) {
        content += `
`;
        content += `> [!info] Orphan Beats (not yet associated with this scene)
`;
        content += `> You can associate these beats with this scene by moving them here.

`;
        for (const beat of orphanBeats) {
          const beatFileName = this.generateBeatFileName(beat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
          content += `- [[${beatLinkName}|Beat ${beat.order_num}: ${beatDisplayText}]]
`;
        }
      }
      content += `
`;
    }
    const sceneFileName = this.generateSceneFileName(scene);
    const sceneLinkName = sceneFileName.replace(/\.md$/, "");
    const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
    content += `## Scene: [[${sceneLinkName}|${sceneDisplayText}]]

`;
    if (contentBlocks && contentBlocks.length > 0) {
      const sortedContentBlocks = [...contentBlocks].sort((a, b) => (a.order_num || 0) - (b.order_num || 0));
      for (const contentBlock of sortedContentBlocks) {
        const fileName = this.generateContentBlockFileName(contentBlock);
        const linkName = fileName.replace(/\.md$/, "");
        content += `[[${linkName}|${contentBlock.content.substring(0, 50)}...]]

`;
      }
    }
    for (const beat of beats.sort((a, b) => a.order_num - b.order_num)) {
      const beatFileName = this.generateBeatFileName(beat);
      const beatLinkName = beatFileName.replace(/\.md$/, "");
      const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
      content += `### Beat: [[${beatLinkName}|${beatDisplayText}]]

`;
    }
    const file = this.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian6.TFile) {
      await this.vault.modify(file, content);
    } else {
      await this.vault.create(filePath, content);
    }
  }
  // Write beat file
  async writeBeatFile(beat, filePath, storyName, contentBlocks) {
    const baseFields = {
      id: beat.id,
      scene_id: beat.scene_id,
      order_num: beat.order_num,
      type: beat.type,
      intent: beat.intent || "",
      outcome: beat.outcome || "",
      created_at: beat.created_at,
      updated_at: beat.updated_at
    };
    const frontmatter = this.generateFrontmatter(baseFields, void 0, {
      entityType: "beat",
      storyName,
      date: beat.created_at
    });
    let content = `${frontmatter}
# Beat ${beat.order_num} - ${beat.type}

`;
    if (beat.intent) {
      content += `**Intent:** ${beat.intent}

`;
    }
    if (beat.outcome) {
      content += `**Outcome:** ${beat.outcome}

`;
    }
    const beatFileName = this.generateBeatFileName(beat);
    const beatLinkName = beatFileName.replace(/\.md$/, "");
    const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
    content += `## Beat: [[${beatLinkName}|${beatDisplayText}]]

`;
    if (contentBlocks && contentBlocks.length > 0) {
      const sortedContentBlocks = [...contentBlocks].sort((a, b) => (a.order_num || 0) - (b.order_num || 0));
      for (const contentBlock of sortedContentBlocks) {
        const fileName = this.generateContentBlockFileName(contentBlock);
        const linkName = fileName.replace(/\.md$/, "");
        content += `[[${linkName}|${contentBlock.content.substring(0, 50)}...]]

`;
      }
    }
    const file = this.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian6.TFile) {
      await this.vault.modify(file, content);
    } else {
      await this.vault.create(filePath, content);
    }
  }
  // List all chapter files in a story folder
  async listChapterFiles(storyFolderPath) {
    const chaptersPath = `${storyFolderPath}/00-chapters`;
    const folder = this.vault.getAbstractFileByPath(chaptersPath);
    if (!(folder instanceof import_obsidian6.TFolder)) {
      return [];
    }
    const chapterFiles = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian6.TFile && child.extension === "md") {
        chapterFiles.push(child.path);
      }
    }
    return chapterFiles.sort();
  }
  // List all scene files in a chapter folder
  async listSceneFiles(chapterFolderPath) {
    const scenesPath = `${chapterFolderPath}/01-scenes`;
    const folder = this.vault.getAbstractFileByPath(scenesPath);
    if (!(folder instanceof import_obsidian6.TFolder)) {
      return [];
    }
    const sceneFiles = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian6.TFile && child.extension === "md") {
        sceneFiles.push(child.path);
      }
    }
    return sceneFiles.sort();
  }
  // List all scene files in a story folder
  async listStorySceneFiles(storyFolderPath) {
    const scenesPath = `${storyFolderPath}/01-scenes`;
    const folder = this.vault.getAbstractFileByPath(scenesPath);
    if (!(folder instanceof import_obsidian6.TFolder)) {
      return [];
    }
    const sceneFiles = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian6.TFile && child.extension === "md") {
        sceneFiles.push(child.path);
      }
    }
    return sceneFiles.sort();
  }
  // List all beat files in a story folder
  async listStoryBeatFiles(storyFolderPath) {
    const beatsPath = `${storyFolderPath}/02-beats`;
    const folder = this.vault.getAbstractFileByPath(beatsPath);
    if (!(folder instanceof import_obsidian6.TFolder)) {
      return [];
    }
    const beatFiles = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian6.TFile && child.extension === "md") {
        beatFiles.push(child.path);
      }
    }
    return beatFiles.sort();
  }
  // List all beat files in a scene folder
  async listBeatFiles(sceneFolderPath) {
    const beatsPath = `${sceneFolderPath}/02-beats`;
    const folder = this.vault.getAbstractFileByPath(beatsPath);
    if (!(folder instanceof import_obsidian6.TFolder)) {
      return [];
    }
    const beatFiles = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian6.TFile && child.extension === "md") {
        beatFiles.push(child.path);
      }
    }
    return beatFiles.sort();
  }
  // Get the subfolder name for a content block type
  getContentTypeFolder(type) {
    const typeFolders = {
      text: "00-texts",
      image: "01-images",
      video: "02-videos",
      audio: "03-audios",
      embed: "04-embeds",
      link: "05-links"
    };
    return typeFolders[type] || "99-other";
  }
  // Get the full folder path for content blocks of a specific type
  getContentBlockFolderPath(storyFolderPath, type) {
    const typeFolder = this.getContentTypeFolder(type);
    return `${storyFolderPath}/03-contents/${typeFolder}`;
  }
  // Generate filename for content block based on date and content preview
  generateContentBlockFileName(contentBlock) {
    const date = new Date(contentBlock.created_at);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    const hours = String(date.getHours()).padStart(2, "0");
    const minutes = String(date.getMinutes()).padStart(2, "0");
    const dateStr = `${year}-${month}-${day}T${hours}-${minutes}`;
    let textPart;
    const type = contentBlock.type || "text";
    if (type === "text") {
      textPart = contentBlock.content.substring(0, 30).trim().replace(/[<>:"/\\|?*\n\r\t]/g, "-").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "").toLowerCase() || "content";
    } else if (type === "image" || type === "video" || type === "audio") {
      const meta = contentBlock.metadata || {};
      textPart = (meta.alt_text || meta.caption || meta.title || type).substring(0, 30).trim().replace(/[<>:"/\\|?*\n\r\t]/g, "-").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "").toLowerCase();
    } else if (type === "embed") {
      const meta = contentBlock.metadata || {};
      textPart = (meta.provider || meta.title || "embed").substring(0, 30).trim().replace(/[<>:"/\\|?*\n\r\t]/g, "-").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "").toLowerCase();
    } else if (type === "link") {
      const meta = contentBlock.metadata || {};
      textPart = (meta.title || meta.site_name || "link").substring(0, 30).trim().replace(/[<>:"/\\|?*\n\r\t]/g, "-").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "").toLowerCase();
    } else {
      textPart = "content";
    }
    return `${dateStr}_${textPart}.md`;
  }
  // Organize content blocks by their associations (chapter, scene, beat)
  organizeContentBlocks(contentBlocks, contentBlockRefs, scenes) {
    const organization = {
      chapterOnly: [],
      byScene: /* @__PURE__ */ new Map(),
      byBeat: /* @__PURE__ */ new Map()
    };
    const contentBlockRefsByContentBlock = /* @__PURE__ */ new Map();
    for (const ref of contentBlockRefs) {
      if (!contentBlockRefsByContentBlock.has(ref.content_block_id)) {
        contentBlockRefsByContentBlock.set(ref.content_block_id, []);
      }
      contentBlockRefsByContentBlock.get(ref.content_block_id).push(ref);
    }
    const sceneMap = /* @__PURE__ */ new Map();
    const beatMap = /* @__PURE__ */ new Map();
    for (const { scene, beats } of scenes) {
      sceneMap.set(scene.id, scene);
      for (const beat of beats) {
        beatMap.set(beat.id, beat);
      }
    }
    const sortedContentBlocks = [...contentBlocks].sort((a, b) => (a.order_num || 0) - (b.order_num || 0));
    for (const contentBlock of sortedContentBlocks) {
      const refs = contentBlockRefsByContentBlock.get(contentBlock.id) || [];
      const sceneRef = refs.find((r) => r.entity_type === "scene");
      const beatRef = refs.find((r) => r.entity_type === "beat");
      if (beatRef && beatMap.has(beatRef.entity_id)) {
        const beat = beatMap.get(beatRef.entity_id);
        if (!organization.byBeat.has(beat.id)) {
          organization.byBeat.set(beat.id, { beat, contentBlocks: [] });
        }
        organization.byBeat.get(beat.id).contentBlocks.push(contentBlock);
      } else if (sceneRef && sceneMap.has(sceneRef.entity_id)) {
        const scene = sceneMap.get(sceneRef.entity_id);
        if (!organization.byScene.has(scene.id)) {
          organization.byScene.set(scene.id, { scene, contentBlocks: [] });
        }
        organization.byScene.get(scene.id).contentBlocks.push(contentBlock);
      } else {
        organization.chapterOnly.push(contentBlock);
      }
    }
    return organization;
  }
  // Generate filename for scene based on date and goal
  generateSceneFileName(scene) {
    const date = new Date(scene.created_at);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    const hours = String(date.getHours()).padStart(2, "0");
    const minutes = String(date.getMinutes()).padStart(2, "0");
    const dateStr = `${year}-${month}-${day}T${hours}-${minutes}`;
    const goalSanitized = (scene.goal || "scene").trim().replace(/[<>:"/\\|?*\n\r\t]/g, "-").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "").toLowerCase();
    return `${dateStr}_${goalSanitized}.md`;
  }
  // Generate filename for beat based on date and intent
  generateBeatFileName(beat) {
    const date = new Date(beat.created_at);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    const hours = String(date.getHours()).padStart(2, "0");
    const minutes = String(date.getMinutes()).padStart(2, "0");
    const dateStr = `${year}-${month}-${day}T${hours}-${minutes}`;
    const intentSanitized = (beat.intent || "beat").trim().replace(/[<>:"/\\|?*\n\r\t]/g, "-").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "").toLowerCase();
    return `${dateStr}_${intentSanitized}.md`;
  }
  // Write content block file
  async writeContentBlockFile(contentBlock, filePath, storyName) {
    const type = contentBlock.type || "text";
    const baseFields = {
      id: contentBlock.id,
      chapter_id: contentBlock.chapter_id || null,
      order_num: contentBlock.order_num || 0,
      type,
      kind: contentBlock.kind,
      created_at: contentBlock.created_at,
      updated_at: contentBlock.updated_at
    };
    const meta = contentBlock.metadata || {};
    if (type === "text" && meta.word_count) {
      baseFields.word_count = meta.word_count;
    } else if (type === "image") {
      if (contentBlock.content && contentBlock.content.startsWith("http")) {
        baseFields.original_url = contentBlock.content;
      }
      if (meta.alt_text)
        baseFields.alt_text = meta.alt_text;
      if (meta.caption)
        baseFields.caption = meta.caption;
      if (meta.width)
        baseFields.width = meta.width;
      if (meta.height)
        baseFields.height = meta.height;
      if (meta.mime_type)
        baseFields.mime_type = meta.mime_type;
      if (meta.source)
        baseFields.source = meta.source;
      if (meta.author_name)
        baseFields.author_name = meta.author_name;
      if (meta.attribution)
        baseFields.attribution = meta.attribution;
      if (meta.attribution_url)
        baseFields.attribution_url = meta.attribution_url;
    } else if (type === "video" || type === "audio") {
      if (meta.provider)
        baseFields.provider = meta.provider;
      if (meta.video_id)
        baseFields.video_id = meta.video_id;
      if (meta.duration)
        baseFields.duration = meta.duration;
      if (meta.thumbnail_url)
        baseFields.thumbnail_url = meta.thumbnail_url;
    } else if (type === "embed") {
      if (meta.provider)
        baseFields.provider = meta.provider;
      if (meta.html)
        baseFields.embed_html = meta.html;
    } else if (type === "link") {
      if (meta.title)
        baseFields.link_title = meta.title;
      if (meta.description)
        baseFields.link_description = meta.description;
      if (meta.image_url)
        baseFields.link_image = meta.image_url;
      if (meta.site_name)
        baseFields.site_name = meta.site_name;
    }
    const frontmatter = this.generateFrontmatter(baseFields, void 0, {
      entityType: "content-block",
      storyName,
      date: contentBlock.created_at
    });
    let fileContent;
    if (type === "text") {
      fileContent = `${frontmatter}${contentBlock.content}`;
    } else if (type === "image") {
      let localImagePath = contentBlock.content || "";
      if (contentBlock.content && !contentBlock.content.startsWith("http")) {
        localImagePath = contentBlock.content;
      } else if (contentBlock.content) {
        try {
          localImagePath = await this.downloadImage(contentBlock.content, filePath, contentBlock.id);
        } catch (err) {
          console.error("Failed to download image:", err);
          localImagePath = contentBlock.content;
        }
      }
      const altText = meta.alt_text || "";
      fileContent = `${frontmatter}![${altText}](${localImagePath})`;
      if (meta.caption) {
        fileContent += `

*${meta.caption}*`;
      }
    } else if (type === "video") {
      fileContent = `${frontmatter}[Video](${contentBlock.content})`;
      if (meta.thumbnail_url) {
        fileContent += `

![Thumbnail](${meta.thumbnail_url})`;
      }
    } else if (type === "audio") {
      fileContent = `${frontmatter}[Audio](${contentBlock.content})`;
    } else if (type === "embed") {
      fileContent = `${frontmatter}${meta.html || contentBlock.content}`;
    } else if (type === "link") {
      const title = meta.title || contentBlock.content;
      fileContent = `${frontmatter}[${title}](${contentBlock.content})`;
      if (meta.description) {
        fileContent += `

${meta.description}`;
      }
    } else {
      fileContent = `${frontmatter}${contentBlock.content}`;
    }
    const file = this.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian6.TFile) {
      await this.vault.modify(file, fileContent);
    } else {
      await this.vault.create(filePath, fileContent);
    }
  }
  // Download image from URL and save locally (same folder as content block .md)
  async downloadImage(imageUrl, contentBlockFilePath, contentBlockId) {
    try {
      const response = await fetch(imageUrl);
      if (!response.ok) {
        throw new Error(`Failed to fetch image: ${response.statusText}`);
      }
      const blob = await response.blob();
      const arrayBuffer = await blob.arrayBuffer();
      let extension = "jpg";
      const contentType = response.headers.get("content-type");
      if (contentType) {
        if (contentType.includes("png"))
          extension = "png";
        else if (contentType.includes("gif"))
          extension = "gif";
        else if (contentType.includes("webp"))
          extension = "webp";
        else if (contentType.includes("svg"))
          extension = "svg";
      } else {
        const urlMatch = imageUrl.match(/\.(jpg|jpeg|png|gif|webp|svg)(\?|$)/i);
        if (urlMatch) {
          extension = urlMatch[1].toLowerCase();
        }
      }
      const contentBlockDir = contentBlockFilePath.substring(0, contentBlockFilePath.lastIndexOf("/"));
      const imageFileName = `${contentBlockId}.${extension}`;
      const imagePath = `${contentBlockDir}/${imageFileName}`;
      const existingFile = this.vault.getAbstractFileByPath(imagePath);
      if (existingFile instanceof import_obsidian6.TFile) {
        await this.vault.modifyBinary(existingFile, arrayBuffer);
      } else {
        await this.vault.createBinary(imagePath, arrayBuffer);
      }
      return imageFileName;
    } catch (err) {
      console.error("Error downloading image:", err);
      throw err;
    }
  }
  // Read content block from file
  async readContentBlockFromFile(filePath) {
    const file = this.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian6.TFile)) {
      return null;
    }
    try {
      const fileContent = await this.vault.read(file);
      const frontmatter = this.parseFrontmatter(fileContent);
      const contentMatch = fileContent.match(/^---\n[\s\S]*?\n---\n([\s\S]*)$/);
      let blockContent = contentMatch ? contentMatch[1].trim() : "";
      if (!frontmatter.id) {
        return null;
      }
      const type = frontmatter.type || "text";
      const metadata = {};
      if (type === "image") {
        const imgMatch = blockContent.match(/!\[[^\]]*\]\(([^)]+)\)/);
        if (imgMatch) {
          blockContent = imgMatch[1];
          if (!blockContent.startsWith("http") && frontmatter.original_url) {
            blockContent = frontmatter.original_url;
          }
        }
      } else if (type === "video" || type === "audio" || type === "link") {
        const linkMatch = blockContent.match(/\[[^\]]*\]\(([^)]+)\)/);
        if (linkMatch) {
          blockContent = linkMatch[1];
        }
      }
      if (frontmatter.word_count)
        metadata.word_count = parseInt(frontmatter.word_count, 10);
      if (frontmatter.alt_text)
        metadata.alt_text = frontmatter.alt_text;
      if (frontmatter.caption)
        metadata.caption = frontmatter.caption;
      if (frontmatter.width)
        metadata.width = parseInt(frontmatter.width, 10);
      if (frontmatter.height)
        metadata.height = parseInt(frontmatter.height, 10);
      if (frontmatter.mime_type)
        metadata.mime_type = frontmatter.mime_type;
      if (frontmatter.source)
        metadata.source = frontmatter.source;
      if (frontmatter.author_name)
        metadata.author_name = frontmatter.author_name;
      if (frontmatter.attribution)
        metadata.attribution = frontmatter.attribution;
      if (frontmatter.attribution_url)
        metadata.attribution_url = frontmatter.attribution_url;
      if (frontmatter.provider)
        metadata.provider = frontmatter.provider;
      if (frontmatter.video_id)
        metadata.video_id = frontmatter.video_id;
      if (frontmatter.duration)
        metadata.duration = parseInt(frontmatter.duration, 10);
      if (frontmatter.thumbnail_url)
        metadata.thumbnail_url = frontmatter.thumbnail_url;
      if (frontmatter.embed_html)
        metadata.html = frontmatter.embed_html;
      if (frontmatter.link_title)
        metadata.title = frontmatter.link_title;
      if (frontmatter.link_description)
        metadata.description = frontmatter.link_description;
      if (frontmatter.link_image)
        metadata.image_url = frontmatter.link_image;
      if (frontmatter.site_name)
        metadata.site_name = frontmatter.site_name;
      return {
        id: frontmatter.id,
        chapter_id: frontmatter.chapter_id || null,
        order_num: parseInt(frontmatter.order_num || "0", 10),
        type,
        kind: frontmatter.kind || "final",
        content: blockContent,
        metadata,
        created_at: frontmatter.created_at || "",
        updated_at: frontmatter.updated_at || ""
      };
    } catch (err) {
      console.error(`Failed to read content block from ${filePath}:`, err);
      return null;
    }
  }
  // List all content block files in a story folder (across all type subfolders)
  async listContentBlockFiles(storyFolderPath) {
    const contentsPath = `${storyFolderPath}/03-contents`;
    const folder = this.vault.getAbstractFileByPath(contentsPath);
    if (!(folder instanceof import_obsidian6.TFolder)) {
      return [];
    }
    const contentFiles = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian6.TFolder) {
        for (const file of child.children) {
          if (file instanceof import_obsidian6.TFile && file.extension === "md") {
            contentFiles.push(file.path);
          }
        }
      }
    }
    return contentFiles.sort();
  }
};

// src/sync/syncService.ts
var import_obsidian8 = require("obsidian");

// src/sync/contentBlockParser.ts
function parseHierarchicalProse(chapterContent) {
  const sections = [];
  const frontmatterMatch = chapterContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = chapterContent.substring(contentStart).trim();
  const chapterSectionMatch = bodyContent.match(/##\s+Chapter\s+\d+:\s+[^\n]+\s*\n+([\s\S]*?)(?=\n##\s+Chapter\s+\d+:|$)/);
  if (!chapterSectionMatch) {
    const chapterSectionMatchSameLine = bodyContent.match(/##\s+Chapter\s+\d+:\s+[^\n]+\s+([^\n]+)/);
    if (chapterSectionMatchSameLine) {
      const proseContent2 = chapterSectionMatchSameLine[1].trim();
      if (proseContent2.length > 0 && !proseContent2.startsWith("#")) {
        const paragraph = {
          content: proseContent2,
          linkName: null,
          originalOrder: 0
        };
        sections.push({
          type: "prose",
          prose: paragraph,
          originalOrder: 0
        });
      }
      return { sections };
    }
    return { sections: [] };
  }
  const proseContent = chapterSectionMatch[1].trim();
  const lines = proseContent.split(/\n/);
  let currentScene = null;
  let currentBeat = null;
  let order = 0;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line) {
      continue;
    }
    const sceneMatch = line.match(/^##\s+Scene:\s*(.+)$/);
    if (sceneMatch) {
      const sceneText = sceneMatch[1].trim();
      const parsedScene = parseSceneHeader(sceneText);
      parsedScene.originalOrder = order++;
      currentScene = parsedScene;
      currentBeat = null;
      sections.push({
        type: "scene",
        scene: parsedScene,
        originalOrder: parsedScene.originalOrder
      });
      continue;
    }
    const beatMatch = line.match(/^###\s+Beat:\s*(.+)$/);
    if (beatMatch) {
      const beatText = beatMatch[1].trim();
      const parsedBeat = parseBeatHeader(beatText);
      parsedBeat.originalOrder = order++;
      currentBeat = parsedBeat;
      sections.push({
        type: "beat",
        beat: parsedBeat,
        originalOrder: parsedBeat.originalOrder
      });
      continue;
    }
    if (line.startsWith("#") && !line.match(/^##\s+Scene:/) && !line.match(/^###\s+Beat:/)) {
      continue;
    }
    const proseMatch = line.match(/^\s*\[\[([^\|]+)\|([^\]]+)\]\]\s*$/);
    if (proseMatch) {
      const linkName = proseMatch[1].trim();
      const content = proseMatch[2].trim();
      const paragraph = {
        content,
        linkName,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
      continue;
    }
    if (line.length > 0 && !line.startsWith("#")) {
      const paragraph = {
        content: line,
        linkName: null,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
    }
  }
  return { sections };
}
function parseSceneHeader(text) {
  const linkMatch = text.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
  if (linkMatch) {
    const linkName = linkMatch[1].trim();
    const displayText = linkMatch[2].trim();
    const { goal: goal2, timeRef: timeRef2 } = parseSceneText(displayText);
    return {
      linkName,
      goal: goal2,
      timeRef: timeRef2,
      originalOrder: 0
      // Will be set by caller
    };
  }
  const simpleLinkMatch = text.match(/^\[\[([^\]]+)\]\]$/);
  if (simpleLinkMatch) {
    return {
      linkName: simpleLinkMatch[1].trim(),
      goal: "",
      timeRef: "",
      originalOrder: 0
    };
  }
  const { goal, timeRef } = parseSceneText(text);
  return {
    linkName: null,
    goal,
    timeRef,
    originalOrder: 0
  };
}
function parseSceneText(text) {
  const parts = text.split(/\s*-\s*/);
  if (parts.length >= 2) {
    return {
      goal: parts[0].trim(),
      timeRef: parts.slice(1).join(" - ").trim()
      // Join in case there are multiple "-"
    };
  }
  return {
    goal: text.trim(),
    timeRef: ""
  };
}
function parseBeatHeader(text) {
  const linkMatch = text.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
  if (linkMatch) {
    const linkName = linkMatch[1].trim();
    const displayText = linkMatch[2].trim();
    const { intent: intent2, outcome: outcome2 } = parseBeatText(displayText);
    return {
      linkName,
      intent: intent2,
      outcome: outcome2,
      originalOrder: 0
      // Will be set by caller
    };
  }
  const simpleLinkMatch = text.match(/^\[\[([^\]]+)\]\]$/);
  if (simpleLinkMatch) {
    return {
      linkName: simpleLinkMatch[1].trim(),
      intent: "",
      outcome: "",
      originalOrder: 0
    };
  }
  const { intent, outcome } = parseBeatText(text);
  return {
    linkName: null,
    intent,
    outcome,
    originalOrder: 0
  };
}
function parseBeatText(text) {
  const parts = text.split(/\s*->\s*/);
  if (parts.length >= 2) {
    return {
      intent: parts[0].trim(),
      outcome: parts.slice(1).join(" -> ").trim()
      // Join in case there are multiple "->"
    };
  }
  return {
    intent: text.trim(),
    outcome: ""
  };
}
function compareContentBlocks(paragraph, localContentBlock, remoteContentBlock) {
  const paragraphContent = paragraph.content.trim();
  if (!paragraph.linkName) {
    if (remoteContentBlock && remoteContentBlock.content.trim() === paragraphContent) {
      if (localContentBlock && localContentBlock.id === remoteContentBlock.id) {
        return "unchanged";
      }
      return "unchanged";
    }
    return "new";
  }
  if (!localContentBlock) {
    if (remoteContentBlock && remoteContentBlock.content.trim() === paragraphContent) {
      return "remote_modified";
    }
    return "new";
  }
  if (!remoteContentBlock) {
    return "local_modified";
  }
  const localContent = localContentBlock.content.trim();
  const remoteContent = remoteContentBlock.content.trim();
  if (localContent === paragraphContent && remoteContent === paragraphContent) {
    return "unchanged";
  }
  if (paragraphContent !== localContent && paragraphContent !== remoteContent && localContent === remoteContent) {
    return "local_modified";
  }
  if (localContent === paragraphContent && remoteContent !== paragraphContent) {
    return "remote_modified";
  }
  if (paragraphContent !== localContent && paragraphContent !== remoteContent && localContent !== remoteContent) {
    return "conflict";
  }
  if (paragraphContent === remoteContent && localContent !== remoteContent) {
    return "remote_modified";
  }
  return "conflict";
}
function parseSceneBeatList(chapterContent) {
  const items = [];
  const frontmatterMatch = chapterContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = chapterContent.substring(contentStart).trim();
  const listSectionMatch = bodyContent.match(/##\s+Scenes\s+&\s+Beats\s*\n+([\s\S]*?)(?=\n##|$)/);
  if (!listSectionMatch) {
    return { items: [] };
  }
  const listContent = listSectionMatch[1].trim();
  const lines = listContent.split(/\n/);
  let order = 0;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    const itemMatch = trimmedLine.match(/^([+-])\s+(.+)$/);
    if (!itemMatch) {
      continue;
    }
    const hasProse = itemMatch[1] === "+";
    const itemText = itemMatch[2].trim();
    const tabMatch = line.match(/^(\t*)/);
    const indentLevel = tabMatch ? tabMatch[1].length : 0;
    const isBeat = indentLevel > 0;
    const linkMatch = itemText.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
    let linkName = null;
    let displayText;
    if (linkMatch) {
      linkName = linkMatch[1].trim();
      displayText = linkMatch[2].trim();
    } else {
      displayText = itemText;
    }
    items.push({
      type: isBeat ? "beat" : "scene",
      linkName,
      displayText,
      hasProse,
      indentLevel: isBeat ? 1 : 0,
      originalOrder: order++
    });
  }
  return { items };
}
function parseChapterList(storyContent) {
  const items = [];
  const frontmatterMatch = storyContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = storyContent.substring(contentStart).trim();
  const listSectionMatch = bodyContent.match(/##\s+Chapters(?:,\s*Scenes\s*&\s*Beats)?\s*\n+([\s\S]*?)(?=\n##|$)/);
  if (!listSectionMatch) {
    return { items: [] };
  }
  const listContent = listSectionMatch[1].trim();
  const lines = listContent.split(/\n/);
  let order = 0;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    const itemMatch = trimmedLine.match(/^([+-])\s+(.+)$/);
    if (!itemMatch) {
      continue;
    }
    const hasProse = itemMatch[1] === "+";
    const itemText = itemMatch[2].trim();
    const tabMatch = line.match(/^(\t*)/);
    const indentLevel = tabMatch ? tabMatch[1].length : 0;
    let type;
    if (indentLevel === 0) {
      type = "chapter";
    } else if (indentLevel === 1) {
      type = "scene";
    } else if (indentLevel === 2) {
      type = "beat";
    } else {
      continue;
    }
    const linkMatch = itemText.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
    let linkName = null;
    let displayText;
    if (linkMatch) {
      linkName = linkMatch[1].trim();
      displayText = linkMatch[2].trim();
    } else {
      displayText = itemText;
    }
    items.push({
      type,
      linkName,
      displayText,
      hasProse,
      indentLevel: indentLevel / 2,
      // Normalize to 0, 1, 2
      originalOrder: order++
    });
  }
  return { items };
}
function parseBeatList(sceneContent) {
  const items = [];
  const frontmatterMatch = sceneContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = sceneContent.substring(contentStart).trim();
  const listSectionMatch = bodyContent.match(/##\s+Beats\s*\n+([\s\S]*?)(?=\n##|$)/);
  if (!listSectionMatch) {
    return { items: [] };
  }
  const listContent = listSectionMatch[1].trim();
  const lines = listContent.split(/\n/);
  let order = 0;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    if (trimmedLine.startsWith(">")) {
      continue;
    }
    const itemMatch = trimmedLine.match(/^([+-])\s+(.+)$/);
    if (!itemMatch) {
      continue;
    }
    const hasProse = itemMatch[1] === "+";
    const itemText = itemMatch[2].trim();
    const linkMatch = itemText.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
    let linkName = null;
    let displayText;
    if (linkMatch) {
      linkName = linkMatch[1].trim();
      displayText = linkMatch[2].trim();
    } else {
      displayText = itemText;
    }
    items.push({
      linkName,
      displayText,
      hasProse,
      originalOrder: order++
    });
  }
  return { items };
}
function parseOrphanScenesList(storyContent) {
  const items = [];
  const frontmatterMatch = storyContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = storyContent.substring(contentStart).trim();
  const listSectionMatch = bodyContent.match(/##\s+Orphan\s+Scenes\s*\n+([\s\S]*?)(?=\n##|$)/);
  if (!listSectionMatch) {
    return { items: [] };
  }
  const listContent = listSectionMatch[1].trim();
  const lines = listContent.split(/\n/);
  let order = 0;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    if (trimmedLine.startsWith(">")) {
      continue;
    }
    const itemMatch = trimmedLine.match(/^([+-])\s+(.+)$/);
    if (!itemMatch) {
      continue;
    }
    const hasProse = itemMatch[1] === "+";
    const itemText = itemMatch[2].trim();
    const tabMatch = line.match(/^(\t*)/);
    const indentLevel = tabMatch ? tabMatch[1].length : 0;
    const isBeat = indentLevel > 0;
    const linkMatch = itemText.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
    let linkName = null;
    let displayText;
    if (linkMatch) {
      linkName = linkMatch[1].trim();
      displayText = linkMatch[2].trim();
    } else {
      displayText = itemText;
    }
    items.push({
      type: isBeat ? "beat" : "scene",
      linkName,
      displayText,
      hasProse,
      indentLevel: isBeat ? 1 : 0,
      originalOrder: order++
    });
  }
  return { items };
}
function parseOrphanBeatsList(storyContent) {
  const items = [];
  const frontmatterMatch = storyContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = storyContent.substring(contentStart).trim();
  const listSectionMatch = bodyContent.match(/##\s+Orphan\s+Beats\s*\n+([\s\S]*?)(?=\n##|$)/);
  if (!listSectionMatch) {
    return { items: [] };
  }
  const listContent = listSectionMatch[1].trim();
  const lines = listContent.split(/\n/);
  let order = 0;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    if (trimmedLine.startsWith(">")) {
      continue;
    }
    const itemMatch = trimmedLine.match(/^([+-])\s+(.+)$/);
    if (!itemMatch) {
      continue;
    }
    const hasProse = itemMatch[1] === "+";
    const itemText = itemMatch[2].trim();
    const linkMatch = itemText.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
    let linkName = null;
    let displayText;
    if (linkMatch) {
      linkName = linkMatch[1].trim();
      displayText = linkMatch[2].trim();
    } else {
      displayText = itemText;
    }
    items.push({
      linkName,
      displayText,
      hasProse,
      originalOrder: order++
    });
  }
  return { items };
}
function parseStoryProse(storyContent) {
  const sections = [];
  const frontmatterMatch = storyContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = storyContent.substring(contentStart).trim();
  const storyHeaderMatch = bodyContent.match(/^(#\s+Story:\s*.+)$/m);
  const chapterHeaderMatch = bodyContent.match(/^(##\s+Chapter\s*\d*:\s*.+)$/m);
  let proseStartIndex = -1;
  if (storyHeaderMatch) {
    proseStartIndex = bodyContent.indexOf(storyHeaderMatch[0]);
  } else if (chapterHeaderMatch) {
    proseStartIndex = bodyContent.indexOf(chapterHeaderMatch[0]);
  }
  if (proseStartIndex === -1) {
    return { sections: [] };
  }
  const proseContent = bodyContent.substring(proseStartIndex);
  const lines = proseContent.split(/\n/);
  let order = 0;
  let currentChapter = null;
  let currentScene = null;
  let currentBeat = null;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    if (trimmedLine.startsWith(">")) {
      continue;
    }
    const storyMatch = trimmedLine.match(/^#\s+Story:\s*(.+)$/i);
    if (storyMatch) {
      continue;
    }
    const chapterMatch = trimmedLine.match(/^##\s+Chapter\s*\d*:\s*(.+)$/i);
    if (chapterMatch) {
      const chapterText = chapterMatch[1].trim();
      const linkMatch = chapterText.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
      if (linkMatch) {
        currentChapter = {
          linkName: linkMatch[1].trim(),
          title: linkMatch[2].trim()
        };
      } else {
        currentChapter = {
          linkName: null,
          title: chapterText
        };
      }
      currentScene = null;
      currentBeat = null;
      continue;
    }
    const sceneMatch = trimmedLine.match(/^###\s+Scene:\s*(.+)$/i);
    if (sceneMatch) {
      const sceneText = sceneMatch[1].trim();
      currentScene = parseSceneHeaderText(sceneText);
      currentScene.originalOrder = order++;
      sections.push({
        type: "scene",
        scene: currentScene,
        originalOrder: currentScene.originalOrder
      });
      currentBeat = null;
      continue;
    }
    const beatMatch = trimmedLine.match(/^####\s+Beat:\s*(.+)$/i);
    if (beatMatch) {
      const beatText = beatMatch[1].trim();
      currentBeat = parseBeatHeaderText(beatText);
      currentBeat.originalOrder = order++;
      sections.push({
        type: "beat",
        beat: currentBeat,
        originalOrder: currentBeat.originalOrder
      });
      continue;
    }
    if (trimmedLine.startsWith("#")) {
      continue;
    }
    if (trimmedLine.match(/^[+-]\s+/)) {
      continue;
    }
    const proseMatch = trimmedLine.match(/^\s*\[\[([^\|]+)\|([^\]]+)\]\]\s*$/);
    if (proseMatch) {
      const linkName = proseMatch[1].trim();
      const content = proseMatch[2].trim();
      const paragraph = {
        content,
        linkName,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
      continue;
    }
    if (trimmedLine.length > 0) {
      const paragraph = {
        content: trimmedLine,
        linkName: null,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
    }
  }
  return { sections };
}
function parseSceneHeaderText(text) {
  const linkMatch = text.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
  if (linkMatch) {
    const linkName = linkMatch[1].trim();
    const displayText = linkMatch[2].trim();
    const parts2 = displayText.split(/\s*-\s*/);
    return {
      linkName,
      goal: parts2[0].trim(),
      timeRef: parts2.length > 1 ? parts2.slice(1).join(" - ").trim() : "",
      originalOrder: 0
    };
  }
  const simpleLinkMatch = text.match(/^\[\[([^\]]+)\]\]$/);
  if (simpleLinkMatch) {
    return {
      linkName: simpleLinkMatch[1].trim(),
      goal: "",
      timeRef: "",
      originalOrder: 0
    };
  }
  const parts = text.split(/\s*-\s*/);
  return {
    linkName: null,
    goal: parts[0].trim(),
    timeRef: parts.length > 1 ? parts.slice(1).join(" - ").trim() : "",
    originalOrder: 0
  };
}
function parseBeatHeaderText(text) {
  const linkMatch = text.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
  if (linkMatch) {
    const linkName = linkMatch[1].trim();
    const displayText = linkMatch[2].trim();
    const parts2 = displayText.split(/\s*->\s*/);
    return {
      linkName,
      intent: parts2[0].trim(),
      outcome: parts2.length > 1 ? parts2.slice(1).join(" -> ").trim() : "",
      originalOrder: 0
    };
  }
  const simpleLinkMatch = text.match(/^\[\[([^\]]+)\]\]$/);
  if (simpleLinkMatch) {
    return {
      linkName: simpleLinkMatch[1].trim(),
      intent: "",
      outcome: "",
      originalOrder: 0
    };
  }
  const parts = text.split(/\s*->\s*/);
  return {
    linkName: null,
    intent: parts[0].trim(),
    outcome: parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "",
    originalOrder: 0
  };
}
function parseSceneProse(sceneContent) {
  const sections = [];
  const frontmatterMatch = sceneContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = sceneContent.substring(contentStart).trim();
  const sceneHeaderMatch = bodyContent.match(/^(###\s+Scene:\s*.+)$/m);
  const beatHeaderMatch = bodyContent.match(/^(#{3,4}\s+Beat:\s*.+)$/m);
  let proseStartIndex = -1;
  if (sceneHeaderMatch) {
    proseStartIndex = bodyContent.indexOf(sceneHeaderMatch[0]);
  } else if (beatHeaderMatch) {
    proseStartIndex = bodyContent.indexOf(beatHeaderMatch[0]);
  } else {
    const beatsListEnd = bodyContent.match(/##\s+Beats\s*\n+[\s\S]*?(?=\n###|\n####|\n[^#\-\+>\s]|$)/);
    if (beatsListEnd) {
      proseStartIndex = bodyContent.indexOf(beatsListEnd[0]) + beatsListEnd[0].length;
    } else {
      const firstNonListContent = bodyContent.match(/(?:^|\n)([^#\-\+>\s\n].+)/);
      if (firstNonListContent) {
        proseStartIndex = bodyContent.indexOf(firstNonListContent[1]);
      }
    }
  }
  if (proseStartIndex === -1) {
    return { sections: [] };
  }
  const proseContent = bodyContent.substring(proseStartIndex);
  const lines = proseContent.split(/\n/);
  let order = 0;
  let currentBeat = null;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    if (trimmedLine.startsWith(">")) {
      continue;
    }
    const sceneMatch = trimmedLine.match(/^###\s+Scene:\s*(.+)$/i);
    if (sceneMatch) {
      const sceneText = sceneMatch[1].trim();
      const parsedScene = parseSceneHeaderText(sceneText);
      parsedScene.originalOrder = order++;
      sections.push({
        type: "scene",
        scene: parsedScene,
        originalOrder: parsedScene.originalOrder
      });
      currentBeat = null;
      continue;
    }
    const beatMatch = trimmedLine.match(/^#{3,4}\s+Beat:\s*(.+)$/i);
    if (beatMatch) {
      const beatText = beatMatch[1].trim();
      currentBeat = parseBeatHeaderText(beatText);
      currentBeat.originalOrder = order++;
      sections.push({
        type: "beat",
        beat: currentBeat,
        originalOrder: currentBeat.originalOrder
      });
      continue;
    }
    if (trimmedLine.startsWith("#")) {
      continue;
    }
    if (trimmedLine.match(/^[+-]\s+/)) {
      continue;
    }
    const proseMatch = trimmedLine.match(/^\s*\[\[([^\|]+)\|([^\]]+)\]\]\s*$/);
    if (proseMatch) {
      const linkName = proseMatch[1].trim();
      const content = proseMatch[2].trim();
      const paragraph = {
        content,
        linkName,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
      continue;
    }
    if (trimmedLine.length > 0) {
      const paragraph = {
        content: trimmedLine,
        linkName: null,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
    }
  }
  return { sections };
}
function parseBeatProse(beatContent) {
  const sections = [];
  const frontmatterMatch = beatContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = beatContent.substring(contentStart).trim();
  const beatHeaderMatch = bodyContent.match(/^(##\s+Beat:\s*.+)$/m);
  let proseStartIndex = -1;
  if (beatHeaderMatch) {
    proseStartIndex = bodyContent.indexOf(beatHeaderMatch[0]);
  }
  if (proseStartIndex === -1) {
    return { sections: [] };
  }
  const proseContent = bodyContent.substring(proseStartIndex);
  const lines = proseContent.split(/\n/);
  let order = 0;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    if (trimmedLine.startsWith(">")) {
      continue;
    }
    const beatMatch = trimmedLine.match(/^##\s+Beat:\s*(.+)$/i);
    if (beatMatch) {
      continue;
    }
    if (trimmedLine.startsWith("#")) {
      continue;
    }
    if (trimmedLine.match(/^[+-]\s+/)) {
      continue;
    }
    const proseMatch = trimmedLine.match(/^\s*\[\[([^\|]+)\|([^\]]+)\]\]\s*$/);
    if (proseMatch) {
      const linkName = proseMatch[1].trim();
      const content = proseMatch[2].trim();
      const paragraph = {
        content,
        linkName,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
      continue;
    }
    if (trimmedLine.length > 0) {
      const paragraph = {
        content: trimmedLine,
        linkName: null,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
    }
  }
  return { sections };
}

// src/views/modals/ConflictModal.ts
var import_obsidian7 = require("obsidian");
var ConflictModal = class extends import_obsidian7.Modal {
  constructor(app, localContentBlock, remoteContentBlock, onResolve) {
    super(app);
    this.resolution = null;
    this.localContentBlock = localContentBlock;
    this.remoteContentBlock = remoteContentBlock;
    this.onResolve = onResolve;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", {
      text: "Content Block Conflict"
    });
    contentEl.createEl("p", {
      text: "This content block has been modified both locally and remotely. Choose how to resolve the conflict:"
    });
    const diffContainer = contentEl.createDiv("conflict-diff-container");
    const localDiv = diffContainer.createDiv("conflict-local");
    localDiv.createEl("h3", { text: "Local Version" });
    const localContent = localDiv.createEl("pre", {
      text: this.localContentBlock.content,
      cls: "conflict-content"
    });
    localContent.style.whiteSpace = "pre-wrap";
    localContent.style.maxHeight = "200px";
    localContent.style.overflow = "auto";
    localContent.style.border = "1px solid var(--background-modifier-border)";
    localContent.style.padding = "10px";
    localContent.style.borderRadius = "4px";
    const remoteDiv = diffContainer.createDiv("conflict-remote");
    remoteDiv.createEl("h3", { text: "Remote Version" });
    const remoteContent = remoteDiv.createEl("pre", {
      text: this.remoteContentBlock.content,
      cls: "conflict-content"
    });
    remoteContent.style.whiteSpace = "pre-wrap";
    remoteContent.style.maxHeight = "200px";
    remoteContent.style.overflow = "auto";
    remoteContent.style.border = "1px solid var(--background-modifier-border)";
    remoteContent.style.padding = "10px";
    remoteContent.style.borderRadius = "4px";
    const manualDiv = contentEl.createDiv("conflict-manual");
    manualDiv.createEl("h3", { text: "Manual Merge (Optional)" });
    const manualTextarea = manualDiv.createEl("textarea", {
      text: this.localContentBlock.content,
      cls: "conflict-manual-input"
    });
    manualTextarea.style.width = "100%";
    manualTextarea.style.minHeight = "150px";
    manualTextarea.style.padding = "10px";
    manualTextarea.style.border = "1px solid var(--background-modifier-border)";
    manualTextarea.style.borderRadius = "4px";
    manualTextarea.style.fontFamily = "var(--font-monospace)";
    const buttonContainer = contentEl.createDiv("conflict-buttons");
    buttonContainer.style.marginTop = "20px";
    buttonContainer.style.display = "flex";
    buttonContainer.style.gap = "10px";
    const useLocalBtn = buttonContainer.createEl("button", {
      text: "Use Local",
      cls: "mod-cta"
    });
    useLocalBtn.onclick = async () => {
      this.resolution = { resolution: "local" };
      await this.onResolve(this.resolution);
      this.close();
    };
    const useRemoteBtn = buttonContainer.createEl("button", {
      text: "Use Remote"
    });
    useRemoteBtn.onclick = async () => {
      this.resolution = { resolution: "remote" };
      await this.onResolve(this.resolution);
      this.close();
    };
    const useManualBtn = buttonContainer.createEl("button", {
      text: "Use Manual Merge",
      cls: "mod-primary"
    });
    useManualBtn.onclick = async () => {
      this.resolution = {
        resolution: "manual",
        mergedContent: manualTextarea.value
      };
      await this.onResolve(this.resolution);
      this.close();
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/sync/syncService.ts
var SyncService = class {
  constructor(apiClient, fileManager, settings, app) {
    this.apiClient = apiClient;
    this.fileManager = fileManager;
    this.settings = settings;
    this.app = app;
  }
  // Pull story from service to Obsidian (Service  Obsidian)
  async pullStory(storyId) {
    try {
      const storyData = await this.apiClient.getStoryWithHierarchy(storyId);
      const folderPath = this.fileManager.getStoryFolderPath(
        storyData.story.title
      );
      const allScenes = await this.apiClient.getScenesByStory(storyId);
      const orphanScenes = [];
      for (const scene of allScenes) {
        if (!scene.chapter_id) {
          const beats = await this.apiClient.getBeats(scene.id);
          orphanScenes.push({ scene, beats });
        }
      }
      orphanScenes.sort((a, b) => a.scene.order_num - b.scene.order_num);
      const allBeats = await this.apiClient.getBeatsByStory(storyId);
      const orphanBeats = [];
      const sceneIdSet = new Set(allScenes.map((s) => s.id));
      for (const beat of allBeats) {
        if (!beat.scene_id || !sceneIdSet.has(beat.scene_id)) {
          orphanBeats.push(beat);
        }
      }
      orphanBeats.sort((a, b) => a.order_num - b.order_num);
      const chapterContentData = /* @__PURE__ */ new Map();
      for (const chapterWithContent of storyData.chapters) {
        const contentBlocks = await this.apiClient.getContentBlocks(chapterWithContent.chapter.id);
        const contentBlockRefs = [];
        for (const contentBlock of contentBlocks) {
          const refs = await this.apiClient.getContentBlockReferences(contentBlock.id);
          contentBlockRefs.push(...refs);
        }
        chapterContentData.set(chapterWithContent.chapter.id, { contentBlocks, contentBlockRefs });
      }
      await this.fileManager.writeStoryMetadata(
        storyData.story,
        folderPath,
        storyData.chapters,
        orphanScenes,
        orphanBeats,
        chapterContentData
      );
      const contentsFolderPath = `${folderPath}/03-contents`;
      await this.fileManager.ensureFolderExists(contentsFolderPath);
      for (const typeFolder of ["00-texts", "01-images", "02-videos", "03-audios", "04-embeds", "05-links"]) {
        await this.fileManager.ensureFolderExists(`${contentsFolderPath}/${typeFolder}`);
      }
      const chaptersFolderPath = `${folderPath}/00-chapters`;
      await this.fileManager.ensureFolderExists(chaptersFolderPath);
      for (const chapterWithContent of storyData.chapters) {
        const contentData = chapterContentData.get(chapterWithContent.chapter.id);
        const contentBlocks = (contentData == null ? void 0 : contentData.contentBlocks) || [];
        const contentBlockRefs = (contentData == null ? void 0 : contentData.contentBlockRefs) || [];
        for (const contentBlock of contentBlocks) {
          const contentBlockFileName = this.fileManager.generateContentBlockFileName(contentBlock);
          const typeFolderPath = this.fileManager.getContentBlockFolderPath(folderPath, contentBlock.type || "text");
          await this.fileManager.ensureFolderExists(typeFolderPath);
          const contentBlockFilePath = `${typeFolderPath}/${contentBlockFileName}`;
          await this.fileManager.writeContentBlockFile(
            contentBlock,
            contentBlockFilePath,
            storyData.story.title
          );
        }
        const chapterFileName = `Chapter-${chapterWithContent.chapter.number}.md`;
        const chapterFilePath = `${chaptersFolderPath}/${chapterFileName}`;
        await this.fileManager.writeChapterFile(
          chapterWithContent,
          chapterFilePath,
          storyData.story.title,
          contentBlocks,
          contentBlockRefs,
          orphanScenes
          // Include orphan scenes for easy association
        );
        const scenesFolderPath2 = `${folderPath}/01-scenes`;
        await this.fileManager.ensureFolderExists(scenesFolderPath2);
        for (const { scene, beats } of chapterWithContent.scenes) {
          const sceneContentBlocks = await this.apiClient.getContentBlocksByScene(scene.id);
          const sceneFileName = this.fileManager.generateSceneFileName(scene);
          const sceneFilePath = `${scenesFolderPath2}/${sceneFileName}`;
          await this.fileManager.writeSceneFile(
            { scene, beats },
            sceneFilePath,
            storyData.story.title,
            sceneContentBlocks,
            orphanBeats
            // Include orphan beats for easy association
          );
          const beatsFolderPath2 = `${folderPath}/02-beats`;
          await this.fileManager.ensureFolderExists(beatsFolderPath2);
          for (const beat of beats) {
            const beatContentBlocks = await this.apiClient.getContentBlocksByBeat(beat.id);
            const beatFileName = this.fileManager.generateBeatFileName(beat);
            const beatFilePath = `${beatsFolderPath2}/${beatFileName}`;
            await this.fileManager.writeBeatFile(beat, beatFilePath, storyData.story.title, beatContentBlocks);
          }
        }
      }
      const scenesFolderPath = `${folderPath}/01-scenes`;
      await this.fileManager.ensureFolderExists(scenesFolderPath);
      for (const { scene, beats } of orphanScenes) {
        const sceneContentBlocks = await this.apiClient.getContentBlocksByScene(scene.id);
        const sceneFileName = this.fileManager.generateSceneFileName(scene);
        const sceneFilePath = `${scenesFolderPath}/${sceneFileName}`;
        await this.fileManager.writeSceneFile(
          { scene, beats },
          sceneFilePath,
          storyData.story.title,
          sceneContentBlocks,
          orphanBeats
          // Include orphan beats for easy association
        );
        const beatsFolderPath2 = `${folderPath}/02-beats`;
        await this.fileManager.ensureFolderExists(beatsFolderPath2);
        for (const beat of beats) {
          const beatContentBlocks = await this.apiClient.getContentBlocksByBeat(beat.id);
          const beatFileName = this.fileManager.generateBeatFileName(beat);
          const beatFilePath = `${beatsFolderPath2}/${beatFileName}`;
          await this.fileManager.writeBeatFile(beat, beatFilePath, storyData.story.title, beatContentBlocks);
        }
      }
      const beatsFolderPath = `${folderPath}/02-beats`;
      await this.fileManager.ensureFolderExists(beatsFolderPath);
      for (const beat of orphanBeats) {
        const beatContentBlocks = await this.apiClient.getContentBlocksByBeat(beat.id);
        const beatFileName = this.fileManager.generateBeatFileName(beat);
        const beatFilePath = `${beatsFolderPath}/${beatFileName}`;
        await this.fileManager.writeBeatFile(beat, beatFilePath, storyData.story.title, beatContentBlocks);
      }
      const existingMetadata = await this.fileManager.readStoryMetadata(folderPath).catch(() => null);
      if (existingMetadata && existingMetadata.frontmatter.version !== void 0 && existingMetadata.frontmatter.version !== storyData.story.version_number) {
        await this.fileManager.createVersionSnapshot(
          folderPath,
          existingMetadata.frontmatter.version
        );
      }
      await this.syncVersionHistory(storyData.story.root_story_id, folderPath);
      new import_obsidian8.Notice(`Story "${storyData.story.title}" synced successfully`);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to sync story";
      new import_obsidian8.Notice(`Error syncing story: ${errorMessage}`, 5e3);
      throw err;
    }
  }
  // Sync all previous versions of a story
  async syncVersionHistory(rootStoryId, storyFolderPath) {
    try {
      const allStories = await this.apiClient.listStories();
      const versions = allStories.filter((s) => s.root_story_id === rootStoryId);
      versions.sort((a, b) => a.version_number - b.version_number);
      const versionsPath = `${storyFolderPath}/versions`;
      await this.fileManager.ensureFolderExists(versionsPath);
      for (const versionStory of versions) {
        const currentVersion = versions[versions.length - 1].version_number;
        if (versionStory.version_number === currentVersion) {
          continue;
        }
        const versionFolderPath = `${versionsPath}/v${versionStory.version_number}`;
        const existingVersionFolder = this.fileManager.getVault().getAbstractFileByPath(
          versionFolderPath
        );
        if (existingVersionFolder) {
          console.log(`Version v${versionStory.version_number} already exists, skipping`);
          continue;
        }
        const versionData = await this.apiClient.getStoryWithHierarchy(
          versionStory.id
        );
        await this.fileManager.ensureFolderExists(versionFolderPath);
        await this.fileManager.writeStoryMetadata(
          versionData.story,
          versionFolderPath
        );
        const versionContentsFolderPath = `${versionFolderPath}/03-contents`;
        await this.fileManager.ensureFolderExists(versionContentsFolderPath);
        for (const typeFolder of ["00-texts", "01-images", "02-videos", "03-audios", "04-embeds", "05-links"]) {
          await this.fileManager.ensureFolderExists(`${versionContentsFolderPath}/${typeFolder}`);
        }
        const versionChaptersPath = `${versionFolderPath}/00-chapters`;
        await this.fileManager.ensureFolderExists(versionChaptersPath);
        for (const chapterWithContent of versionData.chapters) {
          const contentBlocks = await this.apiClient.getContentBlocks(chapterWithContent.chapter.id);
          const contentBlockRefs = [];
          for (const contentBlock of contentBlocks) {
            const refs = await this.apiClient.getContentBlockReferences(contentBlock.id);
            contentBlockRefs.push(...refs);
          }
          for (const contentBlock of contentBlocks) {
            const contentBlockFileName = this.fileManager.generateContentBlockFileName(contentBlock);
            const typeFolderPath = this.fileManager.getContentBlockFolderPath(versionFolderPath, contentBlock.type || "text");
            await this.fileManager.ensureFolderExists(typeFolderPath);
            const contentBlockFilePath = `${typeFolderPath}/${contentBlockFileName}`;
            await this.fileManager.writeContentBlockFile(
              contentBlock,
              contentBlockFilePath,
              versionData.story.title
            );
          }
          const chapterFileName = `Chapter-${chapterWithContent.chapter.number}.md`;
          const chapterFilePath = `${versionChaptersPath}/${chapterFileName}`;
          await this.fileManager.writeChapterFile(
            chapterWithContent,
            chapterFilePath,
            versionData.story.title,
            contentBlocks,
            contentBlockRefs
          );
          const versionScenesPath = `${versionFolderPath}/01-scenes`;
          await this.fileManager.ensureFolderExists(versionScenesPath);
          for (const { scene, beats } of chapterWithContent.scenes) {
            const sceneContentBlocks = await this.apiClient.getContentBlocksByScene(scene.id);
            const sceneFileName = this.fileManager.generateSceneFileName(scene);
            const sceneFilePath = `${versionScenesPath}/${sceneFileName}`;
            await this.fileManager.writeSceneFile(
              { scene, beats },
              sceneFilePath,
              versionData.story.title,
              sceneContentBlocks
            );
            const versionBeatsPath = `${versionFolderPath}/02-beats`;
            await this.fileManager.ensureFolderExists(versionBeatsPath);
            for (const beat of beats) {
              const beatContentBlocks = await this.apiClient.getContentBlocksByBeat(beat.id);
              const beatFileName = this.fileManager.generateBeatFileName(beat);
              const beatFilePath = `${versionBeatsPath}/${beatFileName}`;
              await this.fileManager.writeBeatFile(beat, beatFilePath, versionData.story.title, beatContentBlocks);
            }
          }
        }
        console.log(`Synced version v${versionStory.version_number}`);
      }
    } catch (err) {
      console.error("Error syncing version history:", err);
    }
  }
  // Pull all stories
  async pullAllStories() {
    if (this.settings.mode === "remote" && !this.settings.tenantId) {
      throw new Error("Tenant ID is required");
    }
    try {
      await this.apiClient.getWorlds();
    } catch (err) {
      console.error("Failed to load worlds:", err);
    }
    const stories = await this.apiClient.listStories();
    for (const story of stories) {
      try {
        await this.pullStory(story.id);
      } catch (err) {
        console.error(`Failed to sync story ${story.id}:`, err);
      }
    }
    new import_obsidian8.Notice(`Synced ${stories.length} stories`);
  }
  // Push story from Obsidian to service (Obsidian  Service)
  async pushStory(folderPath) {
    try {
      const { frontmatter: storyFrontmatter } = await this.fileManager.readStoryMetadata(folderPath);
      if (!storyFrontmatter.id) {
        throw new Error("Story metadata missing ID");
      }
      const storyId = storyFrontmatter.id;
      const storyFilePath = `${folderPath}/story.md`;
      const storyFile = this.fileManager.getVault().getAbstractFileByPath(storyFilePath);
      if (storyFile instanceof import_obsidian8.TFile) {
        const storyContent = await this.fileManager.getVault().read(storyFile);
        const chapterList = parseChapterList(storyContent);
        if (chapterList.items.length > 0) {
          await this.processChapterList(chapterList, storyId);
        }
        const orphanScenesList = parseOrphanScenesList(storyContent);
        if (orphanScenesList.items.length > 0) {
          await this.processOrphanScenesList(orphanScenesList, storyId);
        }
        const orphanBeatsList = parseOrphanBeatsList(storyContent);
        if (orphanBeatsList.items.length > 0) {
          await this.processOrphanBeatsList(orphanBeatsList, storyId);
        }
        const storyProse = parseStoryProse(storyContent);
        if (storyProse.sections.length > 0) {
          await this.pushStoryContentBlocks(storyFilePath, folderPath, storyId);
        }
      }
      await this.apiClient.updateStory(
        storyId,
        storyFrontmatter.title,
        storyFrontmatter.status
      );
      const chapterFiles = await this.fileManager.listChapterFiles(folderPath);
      for (const chapterFilePath of chapterFiles) {
        console.log(`Would update chapter: ${chapterFilePath}`);
      }
      for (const chapterFilePath of chapterFiles) {
        await this.pushChapterContentBlocks(chapterFilePath, folderPath);
      }
      const sceneFiles = await this.fileManager.listStorySceneFiles(folderPath);
      for (const sceneFilePath of sceneFiles) {
        await this.pushSceneBeats(sceneFilePath, storyId);
        await this.pushSceneContentBlocks(sceneFilePath, folderPath);
      }
      const beatFiles = await this.fileManager.listStoryBeatFiles(folderPath);
      for (const beatFilePath of beatFiles) {
        await this.pushBeatContentBlocks(beatFilePath, folderPath);
      }
      new import_obsidian8.Notice(`Story "${storyFrontmatter.title}" pushed successfully`);
      try {
        new import_obsidian8.Notice(`Syncing story "${storyFrontmatter.title}" from service...`);
        await this.pullStory(storyId);
        new import_obsidian8.Notice(`Story "${storyFrontmatter.title}" synced successfully`);
      } catch (pullErr) {
        const pullErrorMessage = pullErr instanceof Error ? pullErr.message : "Failed to sync story after push";
        new import_obsidian8.Notice(`Warning: ${pullErrorMessage}`, 5e3);
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to push story";
      new import_obsidian8.Notice(`Error pushing story: ${errorMessage}`, 5e3);
      throw err;
    }
  }
  // Push prose blocks from a chapter file (hierarchical structure)
  async pushChapterContentBlocks(chapterFilePath, storyFolderPath) {
    const file = this.fileManager.getVault().getAbstractFileByPath(chapterFilePath);
    if (!(file instanceof import_obsidian8.TFile)) {
      throw new Error(`Chapter file not found: ${chapterFilePath}`);
    }
    const chapterContent = await this.fileManager.getVault().read(file);
    const frontmatter = this.fileManager.parseFrontmatter(chapterContent);
    if (!frontmatter.id || !frontmatter.story_id) {
      throw new Error("Chapter metadata missing ID or story_id");
    }
    const chapterId = frontmatter.id;
    const storyId = frontmatter.story_id;
    const contentsFolderPath = `${storyFolderPath}/03-contents`;
    const sceneBeatList = parseSceneBeatList(chapterContent);
    await this.processSceneBeatList(sceneBeatList, chapterId, storyId);
    const remoteContentBlocks = await this.apiClient.getContentBlocks(chapterId);
    const remoteContentBlocksMap = /* @__PURE__ */ new Map();
    for (const pb of remoteContentBlocks) {
      remoteContentBlocksMap.set(pb.id, pb);
    }
    const existingScenes = await this.apiClient.getScenes(chapterId);
    const sceneMap = /* @__PURE__ */ new Map();
    const sceneIdMap = /* @__PURE__ */ new Map();
    for (const scene of existingScenes) {
      const fileName = this.fileManager.generateSceneFileName(scene);
      const linkName = fileName.replace(/\.md$/, "");
      sceneMap.set(linkName, scene);
      sceneIdMap.set(scene.id, scene);
    }
    const beatMap = /* @__PURE__ */ new Map();
    const beatIdMap = /* @__PURE__ */ new Map();
    for (const scene of existingScenes) {
      const beats = await this.apiClient.getBeats(scene.id);
      for (const beat of beats) {
        const fileName = this.fileManager.generateBeatFileName(beat);
        const linkName = fileName.replace(/\.md$/, "");
        beatMap.set(linkName, beat);
        beatIdMap.set(beat.id, beat);
      }
    }
    const hierarchical = parseHierarchicalProse(chapterContent);
    const updatedSections = [];
    let currentScene = null;
    let currentBeat = null;
    let proseOrderNum = 1;
    let sceneOrderNum = existingScenes.length > 0 ? Math.max(...existingScenes.map((s) => s.order_num)) + 1 : 1;
    for (const section of hierarchical.sections) {
      if (section.type === "scene" && section.scene) {
        const { scene: parsedScene } = section;
        if (parsedScene.linkName) {
          currentScene = sceneMap.get(parsedScene.linkName) || null;
          if (!currentScene) {
            currentScene = sceneIdMap.get(parsedScene.linkName) || null;
          }
          if (currentScene) {
            if (parsedScene.goal !== currentScene.goal || parsedScene.timeRef !== currentScene.time_ref) {
              currentScene = await this.apiClient.updateScene(currentScene.id, {
                goal: parsedScene.goal,
                time_ref: parsedScene.timeRef
              });
            }
          }
        } else {
          currentScene = await this.apiClient.createScene({
            story_id: storyId,
            chapter_id: chapterId,
            order_num: sceneOrderNum++,
            goal: parsedScene.goal,
            time_ref: parsedScene.timeRef
          });
          const sceneFileName = this.fileManager.generateSceneFileName(currentScene);
          const sceneLinkName = sceneFileName.replace(/\.md$/, "");
          sceneMap.set(sceneLinkName, currentScene);
          sceneIdMap.set(currentScene.id, currentScene);
        }
        if (currentScene) {
          const sceneFileName = this.fileManager.generateSceneFileName(currentScene);
          const sceneLinkName = sceneFileName.replace(/\.md$/, "");
          const sceneDisplayText = currentScene.time_ref ? `${currentScene.goal} - ${currentScene.time_ref}` : currentScene.goal;
          updatedSections.push(`## Scene: [[${sceneLinkName}|${sceneDisplayText}]]`);
        }
        currentBeat = null;
      } else if (section.type === "beat" && section.beat) {
        const { beat: parsedBeat } = section;
        if (!currentScene) {
          throw new Error("Beat found without a parent scene");
        }
        if (parsedBeat.linkName) {
          currentBeat = beatMap.get(parsedBeat.linkName) || null;
          if (!currentBeat) {
            currentBeat = beatIdMap.get(parsedBeat.linkName) || null;
          }
          if (currentBeat) {
            if (parsedBeat.intent !== currentBeat.intent || parsedBeat.outcome !== currentBeat.outcome) {
              currentBeat = await this.apiClient.updateBeat(currentBeat.id, {
                intent: parsedBeat.intent,
                outcome: parsedBeat.outcome
              });
            }
          }
        } else {
          const existingBeats = await this.apiClient.getBeats(currentScene.id);
          const beatOrderNum = existingBeats.length > 0 ? Math.max(...existingBeats.map((b) => b.order_num)) + 1 : 1;
          currentBeat = await this.apiClient.createBeat({
            scene_id: currentScene.id,
            order_num: beatOrderNum,
            type: "setup",
            // Default type
            intent: parsedBeat.intent,
            outcome: parsedBeat.outcome
          });
          const beatFileName = this.fileManager.generateBeatFileName(currentBeat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          beatMap.set(beatLinkName, currentBeat);
          beatIdMap.set(currentBeat.id, currentBeat);
        }
        if (currentBeat) {
          const beatFileName = this.fileManager.generateBeatFileName(currentBeat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          const beatDisplayText = currentBeat.outcome ? `${currentBeat.intent} -> ${currentBeat.outcome}` : currentBeat.intent;
          updatedSections.push(`### Beat: [[${beatLinkName}|${beatDisplayText}]]`);
        }
      } else if (section.type === "prose" && section.prose) {
        const { prose: paragraph } = section;
        let localContentBlock = null;
        let remoteContentBlock = null;
        if (paragraph.linkName) {
          const contentBlockFilePath = `${contentsFolderPath}/${paragraph.linkName}.md`;
          localContentBlock = await this.fileManager.readContentBlockFromFile(contentBlockFilePath);
          if (!localContentBlock) {
            localContentBlock = await this.findContentBlockByContent(contentsFolderPath, paragraph.content);
          }
          if (localContentBlock) {
            remoteContentBlock = remoteContentBlocksMap.get(localContentBlock.id) || null;
          } else {
            const normalizedContent = paragraph.content.trim();
            for (const [id, remotePB] of remoteContentBlocksMap.entries()) {
              if (remotePB.content.trim() === normalizedContent) {
                remoteContentBlock = remotePB;
                break;
              }
            }
          }
        } else {
          localContentBlock = await this.findContentBlockByContent(contentsFolderPath, paragraph.content);
          const normalizedContent = paragraph.content.trim();
          for (const [id, remotePB] of remoteContentBlocksMap.entries()) {
            if (remotePB.content.trim() === normalizedContent) {
              remoteContentBlock = remotePB;
              if (!localContentBlock) {
                localContentBlock = await this.findContentBlockById(contentsFolderPath, remotePB.id);
              }
              break;
            }
          }
        }
        const status = compareContentBlocks(paragraph, localContentBlock, remoteContentBlock);
        let finalContentBlock;
        switch (status) {
          case "new": {
            finalContentBlock = await this.apiClient.createContentBlock(chapterId, {
              order_num: proseOrderNum++,
              kind: "final",
              content: paragraph.content
            });
            const fileName = this.fileManager.generateContentBlockFileName(finalContentBlock);
            const filePath = `${contentsFolderPath}/${fileName}`;
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            if (currentScene) {
              await this.apiClient.createContentBlockReference(finalContentBlock.id, "scene", currentScene.id);
            }
            if (currentBeat) {
              await this.apiClient.createContentBlockReference(finalContentBlock.id, "beat", currentBeat.id);
            }
            const linkName = fileName.replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
            break;
          }
          case "unchanged": {
            if (!localContentBlock && remoteContentBlock) {
              finalContentBlock = remoteContentBlock;
              const fileName = this.fileManager.generateContentBlockFileName(finalContentBlock);
              const filePath = `${contentsFolderPath}/${fileName}`;
              await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            } else if (localContentBlock) {
              if (localContentBlock.order_num !== proseOrderNum) {
                finalContentBlock = await this.apiClient.updateContentBlock(localContentBlock.id, {
                  order_num: proseOrderNum++
                });
                const fileName = this.fileManager.generateContentBlockFileName(finalContentBlock);
                const filePath = `${contentsFolderPath}/${fileName}`;
                await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
              } else {
                finalContentBlock = localContentBlock;
                proseOrderNum++;
              }
            } else {
              finalContentBlock = remoteContentBlock;
              proseOrderNum++;
            }
            if (finalContentBlock) {
              const existingRefs = await this.apiClient.getContentBlockReferences(finalContentBlock.id);
              const hasSceneRef = existingRefs.some((r) => r.entity_type === "scene" && r.entity_id === (currentScene == null ? void 0 : currentScene.id));
              const hasBeatRef = existingRefs.some((r) => r.entity_type === "beat" && r.entity_id === (currentBeat == null ? void 0 : currentBeat.id));
              if (currentScene && !hasSceneRef) {
                await this.apiClient.createContentBlockReference(finalContentBlock.id, "scene", currentScene.id);
              }
              if (currentBeat && !hasBeatRef) {
                await this.apiClient.createContentBlockReference(finalContentBlock.id, "beat", currentBeat.id);
              }
            }
            if (paragraph.linkName) {
              updatedSections.push(`[[${paragraph.linkName}|${paragraph.content}]]`);
            } else {
              const fileName = this.fileManager.generateContentBlockFileName(finalContentBlock);
              const linkName = fileName.replace(/\.md$/, "");
              updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
            }
            break;
          }
          case "local_modified": {
            finalContentBlock = await this.apiClient.updateContentBlock(localContentBlock.id, {
              content: paragraph.content,
              order_num: proseOrderNum++
            });
            const fileName = this.fileManager.generateContentBlockFileName(finalContentBlock);
            const filePath = `${contentsFolderPath}/${fileName}`;
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            if (finalContentBlock) {
              const existingRefs = await this.apiClient.getContentBlockReferences(finalContentBlock.id);
              const hasSceneRef = existingRefs.some((r) => r.entity_type === "scene" && r.entity_id === (currentScene == null ? void 0 : currentScene.id));
              const hasBeatRef = existingRefs.some((r) => r.entity_type === "beat" && r.entity_id === (currentBeat == null ? void 0 : currentBeat.id));
              if (currentScene && !hasSceneRef) {
                await this.apiClient.createContentBlockReference(finalContentBlock.id, "scene", currentScene.id);
              }
              if (currentBeat && !hasBeatRef) {
                await this.apiClient.createContentBlockReference(finalContentBlock.id, "beat", currentBeat.id);
              }
            }
            const linkName = fileName.replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
            break;
          }
          case "remote_modified": {
            finalContentBlock = remoteContentBlock;
            const fileName = this.fileManager.generateContentBlockFileName(finalContentBlock);
            const filePath = `${contentsFolderPath}/${fileName}`;
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            if (finalContentBlock) {
              const existingRefs = await this.apiClient.getContentBlockReferences(finalContentBlock.id);
              const hasSceneRef = existingRefs.some((r) => r.entity_type === "scene" && r.entity_id === (currentScene == null ? void 0 : currentScene.id));
              const hasBeatRef = existingRefs.some((r) => r.entity_type === "beat" && r.entity_id === (currentBeat == null ? void 0 : currentBeat.id));
              if (currentScene && !hasSceneRef) {
                await this.apiClient.createContentBlockReference(finalContentBlock.id, "scene", currentScene.id);
              }
              if (currentBeat && !hasBeatRef) {
                await this.apiClient.createContentBlockReference(finalContentBlock.id, "beat", currentBeat.id);
              }
            }
            const linkName = fileName.replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${finalContentBlock.content}]]`);
            new import_obsidian8.Notice(`Prose block updated from remote: ${linkName}`, 3e3);
            proseOrderNum++;
            break;
          }
          case "conflict": {
            const resolution = await this.resolveConflict(localContentBlock, remoteContentBlock);
            let resolvedContent;
            if (resolution.resolution === "local") {
              resolvedContent = paragraph.content;
            } else if (resolution.resolution === "remote") {
              resolvedContent = remoteContentBlock.content;
            } else {
              resolvedContent = resolution.mergedContent || paragraph.content;
            }
            finalContentBlock = await this.apiClient.updateContentBlock(localContentBlock.id, {
              content: resolvedContent,
              order_num: proseOrderNum++
            });
            const fileName = this.fileManager.generateContentBlockFileName(finalContentBlock);
            const filePath = `${contentsFolderPath}/${fileName}`;
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            if (finalContentBlock) {
              const existingRefs = await this.apiClient.getContentBlockReferences(finalContentBlock.id);
              const hasSceneRef = existingRefs.some((r) => r.entity_type === "scene" && r.entity_id === (currentScene == null ? void 0 : currentScene.id));
              const hasBeatRef = existingRefs.some((r) => r.entity_type === "beat" && r.entity_id === (currentBeat == null ? void 0 : currentBeat.id));
              if (currentScene && !hasSceneRef) {
                await this.apiClient.createContentBlockReference(finalContentBlock.id, "scene", currentScene.id);
              }
              if (currentBeat && !hasBeatRef) {
                await this.apiClient.createContentBlockReference(finalContentBlock.id, "beat", currentBeat.id);
              }
            }
            const linkName = fileName.replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${resolvedContent}]]`);
            break;
          }
        }
      }
    }
    await this.updateChapterFile(chapterContent, updatedSections, file, frontmatter, existingScenes, beatMap, remoteContentBlocks, chapterId);
  }
  // Update chapter file with both scene/beat list and chapter content
  async updateChapterFile(originalContent, updatedSections, file, frontmatter, scenes, beatMap, contentBlocks, chapterId) {
    const allContentBlockRefs = [];
    for (const contentBlock of contentBlocks) {
      const refs = await this.apiClient.getContentBlockReferences(contentBlock.id);
      allContentBlockRefs.push(...refs);
    }
    const proseRefsByScene = /* @__PURE__ */ new Map();
    const proseRefsByBeat = /* @__PURE__ */ new Map();
    for (const ref of allContentBlockRefs) {
      if (ref.entity_type === "scene") {
        if (!proseRefsByScene.has(ref.entity_id)) {
          proseRefsByScene.set(ref.entity_id, []);
        }
        proseRefsByScene.get(ref.entity_id).push(ref);
      } else if (ref.entity_type === "beat") {
        if (!proseRefsByBeat.has(ref.entity_id)) {
          proseRefsByBeat.set(ref.entity_id, []);
        }
        proseRefsByBeat.get(ref.entity_id).push(ref);
      }
    }
    const sceneBeatListItems = [];
    for (const scene of scenes.sort((a, b) => a.order_num - b.order_num)) {
      const sceneFileName = this.fileManager.generateSceneFileName(scene);
      const sceneLinkName = sceneFileName.replace(/\.md$/, "");
      const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
      const sceneProseRefs = proseRefsByScene.get(scene.id) || [];
      const sceneContentBlockIds = new Set(sceneProseRefs.map((r) => r.content_block_id));
      const hasSceneProse = Array.from(sceneContentBlockIds).some((contentBlockId) => {
        const blockRefs = allContentBlockRefs.filter((r) => r.content_block_id === contentBlockId);
        return !blockRefs.some((r) => r.entity_type === "beat");
      });
      const sceneMarker = hasSceneProse ? "+" : "-";
      sceneBeatListItems.push(`${sceneMarker} [[${sceneLinkName}|Scene ${scene.order_num}: ${sceneDisplayText}]]`);
      const sceneBeats = [];
      for (const [linkName, beat] of beatMap.entries()) {
        if (beat.scene_id === scene.id) {
          sceneBeats.push(beat);
        }
      }
      for (const beat of sceneBeats.sort((a, b) => a.order_num - b.order_num)) {
        const beatFileName = this.fileManager.generateBeatFileName(beat);
        const beatLinkName = beatFileName.replace(/\.md$/, "");
        const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
        const beatProseRefs = proseRefsByBeat.get(beat.id) || [];
        const hasBeatProse = beatProseRefs.length > 0;
        const beatMarker = hasBeatProse ? "+" : "-";
        sceneBeatListItems.push(`	${beatMarker} [[${beatLinkName}|Beat ${beat.order_num}: ${beatDisplayText}]]`);
      }
    }
    const frontmatterMatch = originalContent.match(/^---\n([\s\S]*?)\n---/);
    const frontmatterText = frontmatterMatch ? frontmatterMatch[0] : "";
    const bodyStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
    const bodyContent = originalContent.substring(bodyStart).trim();
    const chapterNumber = frontmatter.number || "1";
    const chapterTitle = frontmatter.title || "Untitled";
    const listSectionMatch = bodyContent.match(/([\s\S]*?##\s+Scenes\s+&\s+Beats\s*\n+)([\s\S]*?)(?=\n##|$)/);
    const updatedListSection = `## Scenes & Beats

${sceneBeatListItems.join("\n")}

`;
    let updatedBody;
    if (listSectionMatch) {
      const beforeList = listSectionMatch[1];
      const afterList = bodyContent.substring(listSectionMatch.index + listSectionMatch[0].length);
      updatedBody = `${beforeList}${updatedListSection}${afterList}`;
    } else {
      const titleMatch = bodyContent.match(/(#\s+[^\n]+\n+)([\s\S]*)/);
      if (titleMatch) {
        updatedBody = `${titleMatch[1]}${updatedListSection}${titleMatch[2]}`;
      } else {
        updatedBody = `${updatedListSection}${bodyContent}`;
      }
    }
    const chapterHeaderPattern = `##\\s+Chapter\\s+${chapterNumber}:\\s+[^\\n]+`;
    const chapterSectionMatch = updatedBody.match(new RegExp(`([\\s\\S]*?${chapterHeaderPattern}\\s*\\n+)([\\s\\S]*?)(?=\\n##\\s+Chapter\\s+\\d+:|$)`, "i"));
    if (!chapterSectionMatch) {
      const newChapterSection = `

## Chapter ${chapterNumber}: ${chapterTitle}

${updatedSections.join("\n\n")}

`;
      updatedBody = `${updatedBody}${newChapterSection}`;
    } else {
      const beforeChapter = chapterSectionMatch[1];
      const afterChapter = updatedBody.substring(chapterSectionMatch.index + chapterSectionMatch[0].length);
      const newChapterContent = updatedSections.join("\n\n");
      updatedBody = `${beforeChapter}${newChapterContent}

${afterChapter}`;
    }
    const updatedContent = `${frontmatterText}
${updatedBody}`;
    await this.fileManager.getVault().modify(file, updatedContent);
  }
  // Process the "## Chapters, Scenes & Beats" list and update order
  async processChapterList(list, storyId) {
    const existingChapters = await this.apiClient.getChapters(storyId);
    const chapterMap = /* @__PURE__ */ new Map();
    const chapterIdMap = /* @__PURE__ */ new Map();
    for (const chapter of existingChapters) {
      const fileName = `Chapter-${chapter.number}.md`;
      const linkName = fileName.replace(/\.md$/, "");
      chapterMap.set(linkName, chapter);
      chapterIdMap.set(chapter.id, chapter);
    }
    let currentChapter = null;
    let currentScene = null;
    let chapterOrderNum = 1;
    const sceneOrderNums = /* @__PURE__ */ new Map();
    const beatOrderNums = /* @__PURE__ */ new Map();
    for (const item of list.items) {
      if (item.type === "chapter") {
        let title;
        let chapterNumber = null;
        const chapterMatch = item.displayText.match(/Chapter\s+(\d+):\s*(.+)/);
        if (chapterMatch) {
          chapterNumber = parseInt(chapterMatch[1], 10);
          title = chapterMatch[2].trim();
        } else {
          title = item.displayText.trim();
        }
        currentScene = null;
        sceneOrderNums.set("current", 1);
        if (item.linkName) {
          currentChapter = chapterMap.get(item.linkName) || null;
          if (!currentChapter) {
            currentChapter = chapterIdMap.get(item.linkName) || null;
          }
          if (currentChapter) {
            const needsOrderUpdate = currentChapter.number !== chapterOrderNum;
            const needsTitleUpdate = title !== currentChapter.title;
            if (needsOrderUpdate || needsTitleUpdate) {
              currentChapter = await this.apiClient.updateChapter(currentChapter.id, {
                number: chapterOrderNum,
                title: needsTitleUpdate ? title : void 0
              });
              const fileName = `Chapter-${currentChapter.number}.md`;
              const linkName = fileName.replace(/\.md$/, "");
              chapterMap.set(linkName, currentChapter);
              chapterIdMap.set(currentChapter.id, currentChapter);
            }
          }
        } else {
          if (title) {
            currentChapter = await this.apiClient.createChapter(storyId, {
              number: chapterOrderNum,
              title,
              status: "draft"
            });
            const fileName = `Chapter-${currentChapter.number}.md`;
            const linkName = fileName.replace(/\.md$/, "");
            chapterMap.set(linkName, currentChapter);
            chapterIdMap.set(currentChapter.id, currentChapter);
          }
        }
        if (currentChapter) {
          sceneOrderNums.set(currentChapter.id, 1);
        }
        chapterOrderNum++;
      } else if (item.type === "scene" && currentChapter) {
        let goal;
        let timeRef = "";
        const sceneMatch = item.displayText.match(/Scene\s+\d+:\s*(.+)/);
        if (sceneMatch) {
          const sceneText = sceneMatch[1].trim();
          const parts = sceneText.split(/\s*-\s*/);
          goal = parts[0].trim();
          timeRef = parts.length > 1 ? parts.slice(1).join(" - ").trim() : "";
        } else {
          const parts = item.displayText.split(/\s*-\s*/);
          goal = parts[0].trim();
          timeRef = parts.length > 1 ? parts.slice(1).join(" - ").trim() : "";
        }
        const currentSceneOrderNum = sceneOrderNums.get(currentChapter.id) || 1;
        currentScene = null;
        if (item.linkName) {
          const existingScenes = await this.apiClient.getScenes(currentChapter.id);
          const sceneMap = /* @__PURE__ */ new Map();
          const sceneIdMap = /* @__PURE__ */ new Map();
          for (const scene of existingScenes) {
            const fileName = this.fileManager.generateSceneFileName(scene);
            const linkName = fileName.replace(/\.md$/, "");
            sceneMap.set(linkName, scene);
            sceneIdMap.set(scene.id, scene);
          }
          currentScene = sceneMap.get(item.linkName) || null;
          if (!currentScene) {
            currentScene = sceneIdMap.get(item.linkName) || null;
          }
          if (currentScene) {
            const needsOrderUpdate = currentScene.order_num !== currentSceneOrderNum;
            const needsContentUpdate = goal !== currentScene.goal || timeRef !== currentScene.time_ref;
            const needsChapterUpdate = currentScene.chapter_id !== currentChapter.id;
            if (needsOrderUpdate || needsContentUpdate || needsChapterUpdate) {
              currentScene = await this.apiClient.updateScene(currentScene.id, {
                goal,
                time_ref: timeRef,
                order_num: currentSceneOrderNum,
                chapter_id: currentChapter.id
              });
            }
            const existingBeats = await this.apiClient.getBeats(currentScene.id);
            if (existingBeats.length === 0) {
              beatOrderNums.set(currentScene.id, 1);
            } else {
              const maxOrderNum = Math.max(...existingBeats.map((b) => b.order_num));
              beatOrderNums.set(currentScene.id, maxOrderNum + 1);
            }
          }
        } else {
          currentScene = await this.apiClient.createScene({
            story_id: storyId,
            chapter_id: currentChapter.id,
            order_num: currentSceneOrderNum,
            goal,
            time_ref: timeRef
          });
          beatOrderNums.set(currentScene.id, 1);
        }
        sceneOrderNums.set(currentChapter.id, currentSceneOrderNum + 1);
      } else if (item.type === "beat" && currentScene) {
        let intent;
        let outcome = "";
        const beatMatch = item.displayText.match(/Beat\s+\d+:\s*(.+)/);
        if (beatMatch) {
          const beatText = beatMatch[1].trim();
          const parts = beatText.split(/\s*->\s*/);
          intent = parts[0].trim();
          outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
        } else {
          const parts = item.displayText.split(/\s*->\s*/);
          intent = parts[0].trim();
          outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
        }
        const currentBeatOrderNum = beatOrderNums.get(currentScene.id) || 1;
        if (item.linkName) {
          const existingBeats = await this.apiClient.getBeats(currentScene.id);
          const beatMap = /* @__PURE__ */ new Map();
          const beatIdMap = /* @__PURE__ */ new Map();
          for (const beat of existingBeats) {
            const fileName = this.fileManager.generateBeatFileName(beat);
            const linkName = fileName.replace(/\.md$/, "");
            beatMap.set(linkName, beat);
            beatIdMap.set(beat.id, beat);
          }
          let currentBeat = beatMap.get(item.linkName) || null;
          if (!currentBeat) {
            currentBeat = beatIdMap.get(item.linkName) || null;
          }
          if (currentBeat) {
            const needsOrderUpdate = currentBeat.order_num !== currentBeatOrderNum;
            const needsContentUpdate = intent !== currentBeat.intent || outcome !== currentBeat.outcome;
            const needsSceneUpdate = currentBeat.scene_id !== currentScene.id;
            if (needsOrderUpdate || needsContentUpdate || needsSceneUpdate) {
              currentBeat = await this.apiClient.updateBeat(currentBeat.id, {
                intent,
                outcome,
                order_num: currentBeatOrderNum,
                scene_id: currentScene.id
              });
            }
          }
        } else {
          await this.apiClient.createBeat({
            scene_id: currentScene.id,
            order_num: currentBeatOrderNum,
            type: "setup",
            // Default type
            intent,
            outcome
          });
        }
        beatOrderNums.set(currentScene.id, currentBeatOrderNum + 1);
      }
    }
  }
  // Process the "## Beats" list from a scene file and update beat order
  async pushSceneBeats(sceneFilePath, storyId) {
    const file = this.fileManager.getVault().getAbstractFileByPath(sceneFilePath);
    if (!(file instanceof import_obsidian8.TFile)) {
      return;
    }
    const sceneContent = await this.fileManager.getVault().read(file);
    const frontmatter = this.fileManager.parseFrontmatter(sceneContent);
    if (!frontmatter.id) {
      return;
    }
    const sceneId = frontmatter.id;
    const beatList = parseBeatList(sceneContent);
    if (beatList.items.length === 0) {
      return;
    }
    const existingBeats = await this.apiClient.getBeats(sceneId);
    const beatMap = /* @__PURE__ */ new Map();
    const beatIdMap = /* @__PURE__ */ new Map();
    for (const beat of existingBeats) {
      const fileName = this.fileManager.generateBeatFileName(beat);
      const linkName = fileName.replace(/\.md$/, "");
      beatMap.set(linkName, beat);
      beatIdMap.set(beat.id, beat);
    }
    let beatOrderNum = 1;
    for (const item of beatList.items) {
      let intent;
      let outcome = "";
      const beatMatch = item.displayText.match(/Beat\s+\d+:\s*(.+)/);
      if (beatMatch) {
        const beatText = beatMatch[1].trim();
        const parts = beatText.split(/\s*->\s*/);
        intent = parts[0].trim();
        outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
      } else {
        const parts = item.displayText.split(/\s*->\s*/);
        intent = parts[0].trim();
        outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
      }
      if (item.linkName) {
        let currentBeat = beatMap.get(item.linkName) || null;
        if (!currentBeat) {
          currentBeat = beatIdMap.get(item.linkName) || null;
        }
        if (currentBeat) {
          const needsOrderUpdate = currentBeat.order_num !== beatOrderNum;
          const needsContentUpdate = intent !== currentBeat.intent || outcome !== currentBeat.outcome;
          if (needsOrderUpdate || needsContentUpdate) {
            currentBeat = await this.apiClient.updateBeat(currentBeat.id, {
              intent,
              outcome,
              order_num: beatOrderNum
            });
          }
        }
      } else {
        await this.apiClient.createBeat({
          scene_id: sceneId,
          order_num: beatOrderNum,
          type: "setup",
          // Default type
          intent,
          outcome
        });
      }
      beatOrderNum++;
    }
  }
  // Push prose blocks from a story file with hierarchical structure
  // Format: # Story: title, ## Chapter: title, ### Scene: title, #### Beat: title
  async pushStoryContentBlocks(storyFilePath, storyFolderPath, storyId) {
    const file = this.fileManager.getVault().getAbstractFileByPath(storyFilePath);
    if (!(file instanceof import_obsidian8.TFile)) {
      throw new Error(`Story file not found: ${storyFilePath}`);
    }
    const storyContent = await this.fileManager.getVault().read(file);
    const contentsFolderPath = `${storyFolderPath}/03-contents`;
    const storyProse = parseStoryProse(storyContent);
    if (storyProse.sections.length === 0) {
      return;
    }
    const existingChapters = await this.apiClient.getChapters(storyId);
    const chapterByTitle = /* @__PURE__ */ new Map();
    for (const ch of existingChapters) {
      chapterByTitle.set(ch.title.toLowerCase(), ch);
    }
    let currentChapter = null;
    let currentScene = null;
    let currentBeat = null;
    let proseOrderNum = 1;
    const sceneMap = /* @__PURE__ */ new Map();
    const beatMap = /* @__PURE__ */ new Map();
    for (const section of storyProse.sections) {
      if (section.type === "scene" && section.scene) {
        const { scene: parsedScene } = section;
        if (!currentChapter) {
          currentChapter = chapterByTitle.get("story prose") || null;
          if (!currentChapter) {
            currentChapter = await this.apiClient.createChapter(storyId, {
              number: 9999,
              title: "Story Prose",
              status: "draft"
            });
            chapterByTitle.set("story prose", currentChapter);
          }
        }
        if (parsedScene.linkName) {
          currentScene = sceneMap.get(parsedScene.linkName) || null;
        }
        if (!currentScene && parsedScene.goal) {
          const allScenes = await this.apiClient.getScenes(currentChapter.id);
          currentScene = allScenes.find((s) => s.goal === parsedScene.goal) || null;
        }
        if (!currentScene) {
          const existingScenes = await this.apiClient.getScenes(currentChapter.id);
          const sceneOrderNum = existingScenes.length > 0 ? Math.max(...existingScenes.map((s) => s.order_num)) + 1 : 1;
          currentScene = await this.apiClient.createScene({
            story_id: storyId,
            chapter_id: currentChapter.id,
            order_num: sceneOrderNum,
            goal: parsedScene.goal,
            time_ref: parsedScene.timeRef
          });
        }
        if (currentScene) {
          const sceneFileName = this.fileManager.generateSceneFileName(currentScene);
          const sceneLinkName = sceneFileName.replace(/\.md$/, "");
          sceneMap.set(sceneLinkName, currentScene);
        }
        currentBeat = null;
        proseOrderNum = 1;
      } else if (section.type === "beat" && section.beat) {
        const { beat: parsedBeat } = section;
        if (!currentScene) {
          continue;
        }
        if (parsedBeat.linkName) {
          currentBeat = beatMap.get(parsedBeat.linkName) || null;
        }
        if (!currentBeat && parsedBeat.intent) {
          const allBeats = await this.apiClient.getBeats(currentScene.id);
          currentBeat = allBeats.find((b) => b.intent === parsedBeat.intent) || null;
        }
        if (!currentBeat) {
          const existingBeats = await this.apiClient.getBeats(currentScene.id);
          const beatOrderNum = existingBeats.length > 0 ? Math.max(...existingBeats.map((b) => b.order_num)) + 1 : 1;
          currentBeat = await this.apiClient.createBeat({
            scene_id: currentScene.id,
            order_num: beatOrderNum,
            type: "setup",
            intent: parsedBeat.intent,
            outcome: parsedBeat.outcome
          });
        }
        if (currentBeat) {
          const beatFileName = this.fileManager.generateBeatFileName(currentBeat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          beatMap.set(beatLinkName, currentBeat);
        }
      } else if (section.type === "prose" && section.prose) {
        const { prose: paragraph } = section;
        if (!currentChapter) {
          currentChapter = chapterByTitle.get("story prose") || null;
          if (!currentChapter) {
            currentChapter = await this.apiClient.createChapter(storyId, {
              number: 9999,
              title: "Story Prose",
              status: "draft"
            });
            chapterByTitle.set("story prose", currentChapter);
          }
        }
        const remoteContentBlocks = await this.apiClient.getContentBlocks(currentChapter.id);
        const remoteContentBlocksMap = /* @__PURE__ */ new Map();
        for (const pb of remoteContentBlocks) {
          remoteContentBlocksMap.set(pb.id, pb);
        }
        let localContentBlock = null;
        let remoteContentBlock = null;
        if (paragraph.linkName) {
          const contentBlockFilePath = `${contentsFolderPath}/${paragraph.linkName}.md`;
          localContentBlock = await this.fileManager.readContentBlockFromFile(contentBlockFilePath);
          if (!localContentBlock) {
            localContentBlock = await this.findContentBlockByContent(contentsFolderPath, paragraph.content);
          }
          if (localContentBlock) {
            remoteContentBlock = remoteContentBlocksMap.get(localContentBlock.id) || null;
          } else {
            const normalizedContent = paragraph.content.trim();
            for (const [, remotePB] of remoteContentBlocksMap.entries()) {
              if (remotePB.content.trim() === normalizedContent) {
                remoteContentBlock = remotePB;
                break;
              }
            }
          }
        } else {
          localContentBlock = await this.findContentBlockByContent(contentsFolderPath, paragraph.content);
          const normalizedContent = paragraph.content.trim();
          for (const [, remotePB] of remoteContentBlocksMap.entries()) {
            if (remotePB.content.trim() === normalizedContent) {
              remoteContentBlock = remotePB;
              if (!localContentBlock) {
                localContentBlock = await this.findContentBlockById(contentsFolderPath, remotePB.id);
              }
              break;
            }
          }
        }
        const status = compareContentBlocks(paragraph, localContentBlock, remoteContentBlock);
        let finalContentBlock;
        switch (status) {
          case "new": {
            finalContentBlock = await this.apiClient.createContentBlock(currentChapter.id, {
              order_num: proseOrderNum++,
              kind: "final",
              content: paragraph.content
            });
            const fileName = this.fileManager.generateContentBlockFileName(finalContentBlock);
            const filePath = `${contentsFolderPath}/${fileName}`;
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            if (currentScene) {
              await this.apiClient.createContentBlockReference(finalContentBlock.id, "scene", currentScene.id);
            }
            if (currentBeat) {
              await this.apiClient.createContentBlockReference(finalContentBlock.id, "beat", currentBeat.id);
            }
            break;
          }
          case "unchanged": {
            if (!localContentBlock && remoteContentBlock) {
              finalContentBlock = remoteContentBlock;
              const fileName = this.fileManager.generateContentBlockFileName(finalContentBlock);
              const filePath = `${contentsFolderPath}/${fileName}`;
              await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            } else if (localContentBlock) {
              finalContentBlock = localContentBlock;
              proseOrderNum++;
            } else {
              finalContentBlock = remoteContentBlock;
              proseOrderNum++;
            }
            break;
          }
          case "local_modified": {
            finalContentBlock = await this.apiClient.updateContentBlock(localContentBlock.id, {
              content: paragraph.content,
              order_num: proseOrderNum++
            });
            const fileName = this.fileManager.generateContentBlockFileName(finalContentBlock);
            const filePath = `${contentsFolderPath}/${fileName}`;
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            break;
          }
          case "remote_modified": {
            finalContentBlock = remoteContentBlock;
            const fileName = this.fileManager.generateContentBlockFileName(finalContentBlock);
            const filePath = `${contentsFolderPath}/${fileName}`;
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            proseOrderNum++;
            break;
          }
          case "conflict": {
            const resolution = await this.resolveConflict(localContentBlock, remoteContentBlock);
            let resolvedContent = resolution.resolution === "local" ? paragraph.content : resolution.resolution === "remote" ? remoteContentBlock.content : resolution.mergedContent || paragraph.content;
            finalContentBlock = await this.apiClient.updateContentBlock(localContentBlock.id, {
              content: resolvedContent,
              order_num: proseOrderNum++
            });
            const fileName = this.fileManager.generateContentBlockFileName(finalContentBlock);
            const filePath = `${contentsFolderPath}/${fileName}`;
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            break;
          }
        }
      }
    }
  }
  // Push prose blocks from a scene file (scene-level prose, not inside chapters)
  async pushSceneContentBlocks(sceneFilePath, storyFolderPath) {
    const file = this.fileManager.getVault().getAbstractFileByPath(sceneFilePath);
    if (!(file instanceof import_obsidian8.TFile)) {
      return;
    }
    const sceneContent = await this.fileManager.getVault().read(file);
    const frontmatter = this.fileManager.parseFrontmatter(sceneContent);
    if (!frontmatter.id || !frontmatter.story_id) {
      return;
    }
    const sceneId = frontmatter.id;
    const storyId = frontmatter.story_id;
    const contentsFolderPath = `${storyFolderPath}/03-contents`;
    const sceneProse = parseSceneProse(sceneContent);
    if (sceneProse.sections.length === 0) {
      return;
    }
    const chapters = await this.apiClient.getChapters(storyId);
    let tempChapter = chapters.find((c) => c.title === "Scene-Level Prose");
    if (!tempChapter) {
      tempChapter = await this.apiClient.createChapter(storyId, {
        number: 9998,
        // High number to keep it at the end
        title: "Scene-Level Prose",
        status: "draft"
      });
    }
    const remoteContentBlocks = await this.apiClient.getContentBlocks(tempChapter.id);
    const remoteContentBlocksMap = /* @__PURE__ */ new Map();
    for (const pb of remoteContentBlocks) {
      remoteContentBlocksMap.set(pb.id, pb);
    }
    const existingBeats = await this.apiClient.getBeats(sceneId);
    const beatMap = /* @__PURE__ */ new Map();
    const beatIdMap = /* @__PURE__ */ new Map();
    for (const beat of existingBeats) {
      const fileName = this.fileManager.generateBeatFileName(beat);
      const linkName = fileName.replace(/\.md$/, "");
      beatMap.set(linkName, beat);
      beatIdMap.set(beat.id, beat);
    }
    let proseOrderNum = 1;
    let currentBeat = null;
    const updatedSections = [];
    for (const section of sceneProse.sections) {
      if (section.type === "beat" && section.beat) {
        const { beat: parsedBeat } = section;
        if (parsedBeat.linkName) {
          currentBeat = beatMap.get(parsedBeat.linkName) || null;
          if (!currentBeat) {
            currentBeat = beatIdMap.get(parsedBeat.linkName) || null;
          }
        }
        if (currentBeat) {
          const beatFileName = this.fileManager.generateBeatFileName(currentBeat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          const beatDisplayText = currentBeat.outcome ? `${currentBeat.intent} -> ${currentBeat.outcome}` : currentBeat.intent;
          updatedSections.push(`### Beat: [[${beatLinkName}|${beatDisplayText}]]`);
        }
      } else if (section.type === "prose" && section.prose) {
        const { prose: paragraph } = section;
        let localContentBlock = null;
        let remoteContentBlock = null;
        if (paragraph.linkName) {
          const contentBlockFilePath = `${contentsFolderPath}/${paragraph.linkName}.md`;
          localContentBlock = await this.fileManager.readContentBlockFromFile(contentBlockFilePath);
          if (!localContentBlock) {
            localContentBlock = await this.findContentBlockByContent(contentsFolderPath, paragraph.content);
          }
          if (localContentBlock) {
            remoteContentBlock = remoteContentBlocksMap.get(localContentBlock.id) || null;
          } else {
            const normalizedContent = paragraph.content.trim();
            for (const [id, remotePB] of remoteContentBlocksMap.entries()) {
              if (remotePB.content.trim() === normalizedContent) {
                remoteContentBlock = remotePB;
                break;
              }
            }
          }
        } else {
          localContentBlock = await this.findContentBlockByContent(contentsFolderPath, paragraph.content);
          const normalizedContent = paragraph.content.trim();
          for (const [id, remotePB] of remoteContentBlocksMap.entries()) {
            if (remotePB.content.trim() === normalizedContent) {
              remoteContentBlock = remotePB;
              if (!localContentBlock) {
                localContentBlock = await this.findContentBlockById(contentsFolderPath, remotePB.id);
              }
              break;
            }
          }
        }
        const status = compareContentBlocks(paragraph, localContentBlock, remoteContentBlock);
        let finalContentBlock;
        switch (status) {
          case "new": {
            finalContentBlock = await this.apiClient.createContentBlock(tempChapter.id, {
              order_num: proseOrderNum++,
              kind: "final",
              content: paragraph.content
            });
            const fileName = this.fileManager.generateContentBlockFileName(finalContentBlock);
            const filePath = `${contentsFolderPath}/${fileName}`;
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            await this.apiClient.createContentBlockReference(finalContentBlock.id, "scene", sceneId);
            if (currentBeat) {
              await this.apiClient.createContentBlockReference(finalContentBlock.id, "beat", currentBeat.id);
            }
            const linkName = fileName.replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
            break;
          }
          case "unchanged": {
            if (!localContentBlock && remoteContentBlock) {
              finalContentBlock = remoteContentBlock;
              const fileName = this.fileManager.generateContentBlockFileName(finalContentBlock);
              const filePath = `${contentsFolderPath}/${fileName}`;
              await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            } else if (localContentBlock) {
              if (localContentBlock.order_num !== proseOrderNum) {
                finalContentBlock = await this.apiClient.updateContentBlock(localContentBlock.id, {
                  order_num: proseOrderNum++
                });
                const fileName = this.fileManager.generateContentBlockFileName(finalContentBlock);
                const filePath = `${contentsFolderPath}/${fileName}`;
                await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
              } else {
                finalContentBlock = localContentBlock;
                proseOrderNum++;
              }
            } else {
              finalContentBlock = remoteContentBlock;
              proseOrderNum++;
            }
            if (paragraph.linkName) {
              updatedSections.push(`[[${paragraph.linkName}|${paragraph.content}]]`);
            } else {
              const fileName = this.fileManager.generateContentBlockFileName(finalContentBlock);
              const linkName = fileName.replace(/\.md$/, "");
              updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
            }
            break;
          }
          case "local_modified": {
            finalContentBlock = await this.apiClient.updateContentBlock(localContentBlock.id, {
              content: paragraph.content,
              order_num: proseOrderNum++
            });
            const fileName = this.fileManager.generateContentBlockFileName(finalContentBlock);
            const filePath = `${contentsFolderPath}/${fileName}`;
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            const linkName = fileName.replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
            break;
          }
          case "remote_modified": {
            finalContentBlock = remoteContentBlock;
            const fileName = this.fileManager.generateContentBlockFileName(finalContentBlock);
            const filePath = `${contentsFolderPath}/${fileName}`;
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            const linkName = fileName.replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${finalContentBlock.content}]]`);
            new import_obsidian8.Notice(`Scene prose block updated from remote: ${linkName}`, 3e3);
            proseOrderNum++;
            break;
          }
          case "conflict": {
            const resolution = await this.resolveConflict(localContentBlock, remoteContentBlock);
            let resolvedContent;
            if (resolution.resolution === "local") {
              resolvedContent = paragraph.content;
            } else if (resolution.resolution === "remote") {
              resolvedContent = remoteContentBlock.content;
            } else {
              resolvedContent = resolution.mergedContent || paragraph.content;
            }
            finalContentBlock = await this.apiClient.updateContentBlock(localContentBlock.id, {
              content: resolvedContent,
              order_num: proseOrderNum++
            });
            const fileName = this.fileManager.generateContentBlockFileName(finalContentBlock);
            const filePath = `${contentsFolderPath}/${fileName}`;
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            const linkName = fileName.replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${resolvedContent}]]`);
            break;
          }
        }
      }
    }
    if (updatedSections.length > 0) {
      const frontmatterMatch = sceneContent.match(/^---\n([\s\S]*?)\n---/);
      const frontmatterEnd = frontmatterMatch ? frontmatterMatch[0].length : 0;
      const afterFrontmatter = sceneContent.substring(frontmatterEnd).trim();
      const beatsSectionMatch = afterFrontmatter.match(/\n##\s+Beats\s*\n/);
      const insertionPoint = beatsSectionMatch ? frontmatterEnd + afterFrontmatter.indexOf(beatsSectionMatch[0]) : sceneContent.length;
      const beforeProse = sceneContent.substring(0, insertionPoint).trimEnd();
      const afterProse = sceneContent.substring(insertionPoint);
      const updatedContent = `${beforeProse}

${updatedSections.join("\n\n")}
${afterProse}`;
      await this.fileManager.getVault().modify(file, updatedContent);
    }
  }
  // Push prose blocks from a beat file
  async pushBeatContentBlocks(beatFilePath, storyFolderPath) {
    const file = this.fileManager.getVault().getAbstractFileByPath(beatFilePath);
    if (!(file instanceof import_obsidian8.TFile)) {
      return;
    }
    const beatContent = await this.fileManager.getVault().read(file);
    const frontmatter = this.fileManager.parseFrontmatter(beatContent);
    if (!frontmatter.id || !frontmatter.scene_id) {
      return;
    }
    const beatId = frontmatter.id;
    const sceneId = frontmatter.scene_id;
    const contentsFolderPath = `${storyFolderPath}/03-contents`;
    const beatProse = parseBeatProse(beatContent);
    if (beatProse.sections.length === 0) {
      return;
    }
    const scene = await this.apiClient.getScene(sceneId);
    if (!scene) {
      return;
    }
    const storyId = scene.story_id;
    const chapters = await this.apiClient.getChapters(storyId);
    let tempChapter = chapters.find((c) => c.title === "Beat-Level Prose");
    if (!tempChapter) {
      tempChapter = await this.apiClient.createChapter(storyId, {
        number: 9997,
        // High number to keep it at the end
        title: "Beat-Level Prose",
        status: "draft"
      });
    }
    const remoteContentBlocks = await this.apiClient.getContentBlocks(tempChapter.id);
    const remoteContentBlocksMap = /* @__PURE__ */ new Map();
    for (const pb of remoteContentBlocks) {
      remoteContentBlocksMap.set(pb.id, pb);
    }
    let proseOrderNum = 1;
    const updatedSections = [];
    const beat = await this.apiClient.getBeat(beatId);
    if (beat) {
      const beatFileName = this.fileManager.generateBeatFileName(beat);
      const beatLinkName = beatFileName.replace(/\.md$/, "");
      const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
      updatedSections.push(`## Beat: [[${beatLinkName}|${beatDisplayText}]]`);
    }
    for (const section of beatProse.sections) {
      if (section.type === "prose" && section.prose) {
        const { prose: paragraph } = section;
        let localContentBlock = null;
        let remoteContentBlock = null;
        if (paragraph.linkName) {
          const contentBlockFilePath = `${contentsFolderPath}/${paragraph.linkName}.md`;
          localContentBlock = await this.fileManager.readContentBlockFromFile(contentBlockFilePath);
          if (!localContentBlock) {
            localContentBlock = await this.findContentBlockByContent(contentsFolderPath, paragraph.content);
          }
          if (localContentBlock) {
            remoteContentBlock = remoteContentBlocksMap.get(localContentBlock.id) || null;
          } else {
            const normalizedContent = paragraph.content.trim();
            for (const [, remotePB] of remoteContentBlocksMap.entries()) {
              if (remotePB.content.trim() === normalizedContent) {
                remoteContentBlock = remotePB;
                break;
              }
            }
          }
        } else {
          localContentBlock = await this.findContentBlockByContent(contentsFolderPath, paragraph.content);
          const normalizedContent = paragraph.content.trim();
          for (const [, remotePB] of remoteContentBlocksMap.entries()) {
            if (remotePB.content.trim() === normalizedContent) {
              remoteContentBlock = remotePB;
              if (!localContentBlock) {
                localContentBlock = await this.findContentBlockById(contentsFolderPath, remotePB.id);
              }
              break;
            }
          }
        }
        const status = compareContentBlocks(paragraph, localContentBlock, remoteContentBlock);
        let finalContentBlock;
        switch (status) {
          case "new": {
            finalContentBlock = await this.apiClient.createContentBlock(tempChapter.id, {
              order_num: proseOrderNum++,
              kind: "final",
              content: paragraph.content
            });
            const fileName = this.fileManager.generateContentBlockFileName(finalContentBlock);
            const filePath = `${contentsFolderPath}/${fileName}`;
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            await this.apiClient.createContentBlockReference(finalContentBlock.id, "scene", sceneId);
            await this.apiClient.createContentBlockReference(finalContentBlock.id, "beat", beatId);
            const linkName = fileName.replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
            break;
          }
          case "unchanged": {
            if (!localContentBlock && remoteContentBlock) {
              finalContentBlock = remoteContentBlock;
              const fileName = this.fileManager.generateContentBlockFileName(finalContentBlock);
              const filePath = `${contentsFolderPath}/${fileName}`;
              await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
              const linkName = fileName.replace(/\.md$/, "");
              updatedSections.push(`[[${linkName}|${remoteContentBlock.content}]]`);
            } else if (localContentBlock) {
              finalContentBlock = localContentBlock;
              const fileName = this.fileManager.generateContentBlockFileName(finalContentBlock);
              const linkName = fileName.replace(/\.md$/, "");
              updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
              proseOrderNum++;
            } else {
              proseOrderNum++;
              continue;
            }
            break;
          }
          case "local_modified": {
            finalContentBlock = await this.apiClient.updateContentBlock(localContentBlock.id, {
              content: paragraph.content,
              order_num: proseOrderNum++
            });
            const fileName = this.fileManager.generateContentBlockFileName(finalContentBlock);
            const filePath = `${contentsFolderPath}/${fileName}`;
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            const linkName = fileName.replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
            break;
          }
          case "remote_modified": {
            finalContentBlock = remoteContentBlock;
            const fileName = this.fileManager.generateContentBlockFileName(finalContentBlock);
            const filePath = `${contentsFolderPath}/${fileName}`;
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            proseOrderNum++;
            const linkName = fileName.replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${remoteContentBlock.content}]]`);
            break;
          }
          case "conflict": {
            const resolution = await this.resolveConflict(localContentBlock, remoteContentBlock);
            let resolvedContent;
            if (resolution.resolution === "local") {
              resolvedContent = paragraph.content;
            } else if (resolution.resolution === "remote") {
              resolvedContent = remoteContentBlock.content;
            } else {
              resolvedContent = resolution.mergedContent || paragraph.content;
            }
            finalContentBlock = await this.apiClient.updateContentBlock(localContentBlock.id, {
              content: resolvedContent,
              order_num: proseOrderNum++
            });
            const fileName = this.fileManager.generateContentBlockFileName(finalContentBlock);
            const filePath = `${contentsFolderPath}/${fileName}`;
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            const linkName = fileName.replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${resolvedContent}]]`);
            break;
          }
        }
      }
    }
    if (updatedSections.length > 1) {
      const frontmatterMatch = beatContent.match(/^---\n([\s\S]*?)\n---/);
      const frontmatterEnd = frontmatterMatch ? frontmatterMatch[0].length : 0;
      const afterFrontmatter = beatContent.substring(frontmatterEnd).trim();
      const beatSectionMatch = afterFrontmatter.match(/##\s+Beat:\s*.+[\s\S]*/);
      if (beatSectionMatch) {
        const beforeBeatSection = beatContent.substring(0, frontmatterEnd + afterFrontmatter.indexOf(beatSectionMatch[0]));
        const updatedContent = `${beforeBeatSection.trimEnd()}

${updatedSections.join("\n\n")}
`;
        await this.fileManager.getVault().modify(file, updatedContent);
      } else {
        const updatedContent = `${beatContent.trimEnd()}

${updatedSections.join("\n\n")}
`;
        await this.fileManager.getVault().modify(file, updatedContent);
      }
    }
  }
  // Process the "## Orphan Scenes" list and update orphan scenes order
  async processOrphanScenesList(list, storyId) {
    const allScenes = await this.apiClient.getScenesByStory(storyId);
    const sceneMap = /* @__PURE__ */ new Map();
    const sceneIdMap = /* @__PURE__ */ new Map();
    const orphanScenes = allScenes.filter((s) => !s.chapter_id);
    for (const scene of orphanScenes) {
      const fileName = this.fileManager.generateSceneFileName(scene);
      const linkName = fileName.replace(/\.md$/, "");
      sceneMap.set(linkName, scene);
      sceneIdMap.set(scene.id, scene);
    }
    const beatMap = /* @__PURE__ */ new Map();
    const beatIdMap = /* @__PURE__ */ new Map();
    for (const scene of orphanScenes) {
      const beats = await this.apiClient.getBeats(scene.id);
      for (const beat of beats) {
        const fileName = this.fileManager.generateBeatFileName(beat);
        const linkName = fileName.replace(/\.md$/, "");
        beatMap.set(linkName, beat);
        beatIdMap.set(beat.id, beat);
      }
    }
    let currentScene = null;
    let sceneOrderNum = 1;
    const beatOrderNums = /* @__PURE__ */ new Map();
    for (const item of list.items) {
      if (item.type === "scene") {
        let goal;
        let timeRef = "";
        const sceneMatch = item.displayText.match(/Scene\s+\d+:\s*(.+)/);
        if (sceneMatch) {
          const sceneText = sceneMatch[1].trim();
          const parts = sceneText.split(/\s*-\s*/);
          goal = parts[0].trim();
          timeRef = parts.length > 1 ? parts.slice(1).join(" - ").trim() : "";
        } else {
          const parts = item.displayText.split(/\s*-\s*/);
          goal = parts[0].trim();
          timeRef = parts.length > 1 ? parts.slice(1).join(" - ").trim() : "";
        }
        if (item.linkName) {
          currentScene = sceneMap.get(item.linkName) || null;
          if (!currentScene) {
            currentScene = sceneIdMap.get(item.linkName) || null;
          }
          if (currentScene) {
            const needsOrderUpdate = currentScene.order_num !== sceneOrderNum;
            const needsContentUpdate = goal !== currentScene.goal || timeRef !== currentScene.time_ref;
            if (needsOrderUpdate || needsContentUpdate) {
              currentScene = await this.apiClient.updateScene(currentScene.id, {
                goal,
                time_ref: timeRef,
                order_num: sceneOrderNum
              });
            }
            const existingBeats = await this.apiClient.getBeats(currentScene.id);
            if (existingBeats.length === 0) {
              beatOrderNums.set(currentScene.id, 1);
            } else {
              const maxOrderNum = Math.max(...existingBeats.map((b) => b.order_num));
              beatOrderNums.set(currentScene.id, maxOrderNum + 1);
            }
          }
        } else {
          currentScene = await this.apiClient.createScene({
            story_id: storyId,
            chapter_id: null,
            // Orphan scene
            order_num: sceneOrderNum,
            goal,
            time_ref: timeRef
          });
          const sceneFileName = this.fileManager.generateSceneFileName(currentScene);
          const sceneLinkName = sceneFileName.replace(/\.md$/, "");
          sceneMap.set(sceneLinkName, currentScene);
          sceneIdMap.set(currentScene.id, currentScene);
          beatOrderNums.set(currentScene.id, 1);
        }
        sceneOrderNum++;
      } else if (item.type === "beat" && currentScene) {
        let intent;
        let outcome = "";
        const beatMatch = item.displayText.match(/Beat\s+\d+:\s*(.+)/);
        if (beatMatch) {
          const beatText = beatMatch[1].trim();
          const parts = beatText.split(/\s*->\s*/);
          intent = parts[0].trim();
          outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
        } else {
          const parts = item.displayText.split(/\s*->\s*/);
          intent = parts[0].trim();
          outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
        }
        const currentBeatOrderNum = beatOrderNums.get(currentScene.id) || 1;
        if (item.linkName) {
          let currentBeat = beatMap.get(item.linkName) || null;
          if (!currentBeat) {
            currentBeat = beatIdMap.get(item.linkName) || null;
          }
          if (currentBeat) {
            const needsOrderUpdate = currentBeat.order_num !== currentBeatOrderNum;
            const needsContentUpdate = intent !== currentBeat.intent || outcome !== currentBeat.outcome;
            const needsSceneUpdate = currentBeat.scene_id !== currentScene.id;
            if (needsOrderUpdate || needsContentUpdate || needsSceneUpdate) {
              currentBeat = await this.apiClient.updateBeat(currentBeat.id, {
                intent,
                outcome,
                order_num: currentBeatOrderNum,
                scene_id: currentScene.id
              });
            }
          }
        } else {
          await this.apiClient.createBeat({
            scene_id: currentScene.id,
            order_num: currentBeatOrderNum,
            type: "setup",
            // Default type
            intent,
            outcome
          });
        }
        beatOrderNums.set(currentScene.id, currentBeatOrderNum + 1);
      }
    }
  }
  // Process the "## Orphan Beats" list and update orphan beats order
  async processOrphanBeatsList(list, storyId) {
    const allBeats = await this.apiClient.getBeatsByStory(storyId);
    const allScenes = await this.apiClient.getScenesByStory(storyId);
    const sceneIdSet = new Set(allScenes.map((s) => s.id));
    const orphanBeats = allBeats.filter((b) => !b.scene_id || !sceneIdSet.has(b.scene_id));
    const beatMap = /* @__PURE__ */ new Map();
    const beatIdMap = /* @__PURE__ */ new Map();
    for (const beat of orphanBeats) {
      const fileName = this.fileManager.generateBeatFileName(beat);
      const linkName = fileName.replace(/\.md$/, "");
      beatMap.set(linkName, beat);
      beatIdMap.set(beat.id, beat);
    }
    let beatOrderNum = 1;
    for (const item of list.items) {
      let intent;
      let outcome = "";
      const beatMatch = item.displayText.match(/Beat\s+\d+:\s*(.+)/);
      if (beatMatch) {
        const beatText = beatMatch[1].trim();
        const parts = beatText.split(/\s*->\s*/);
        intent = parts[0].trim();
        outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
      } else {
        const parts = item.displayText.split(/\s*->\s*/);
        intent = parts[0].trim();
        outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
      }
      if (item.linkName) {
        let currentBeat = beatMap.get(item.linkName) || null;
        if (!currentBeat) {
          currentBeat = beatIdMap.get(item.linkName) || null;
        }
        if (currentBeat) {
          const needsOrderUpdate = currentBeat.order_num !== beatOrderNum;
          const needsContentUpdate = intent !== currentBeat.intent || outcome !== currentBeat.outcome;
          if (needsOrderUpdate || needsContentUpdate) {
            currentBeat = await this.apiClient.updateBeat(currentBeat.id, {
              intent,
              outcome,
              order_num: beatOrderNum
              // Keep scene_id as null or invalid (orphan) - don't update it
            });
          }
        }
      } else {
        const allScenes2 = await this.apiClient.getScenesByStory(storyId);
        let orphanBeatScene = allScenes2.find((s) => !s.chapter_id && s.goal.startsWith("Orphan Beats Container"));
        if (!orphanBeatScene) {
          orphanBeatScene = await this.apiClient.createScene({
            story_id: storyId,
            chapter_id: null,
            order_num: 9999,
            // High number to keep it at the end
            goal: "Orphan Beats Container",
            time_ref: ""
          });
        }
        await this.apiClient.createBeat({
          scene_id: orphanBeatScene.id,
          order_num: beatOrderNum,
          type: "setup",
          // Default type
          intent,
          outcome
        });
      }
      beatOrderNum++;
    }
  }
  // Process the "## Scenes & Beats" list and create/update/delete scenes and beats
  async processSceneBeatList(list, chapterId, storyId) {
    const existingScenes = await this.apiClient.getScenes(chapterId);
    const sceneMap = /* @__PURE__ */ new Map();
    const sceneIdMap = /* @__PURE__ */ new Map();
    for (const scene of existingScenes) {
      const fileName = this.fileManager.generateSceneFileName(scene);
      const linkName = fileName.replace(/\.md$/, "");
      sceneMap.set(linkName, scene);
      sceneIdMap.set(scene.id, scene);
    }
    const beatMap = /* @__PURE__ */ new Map();
    const beatIdMap = /* @__PURE__ */ new Map();
    for (const scene of existingScenes) {
      const beats = await this.apiClient.getBeats(scene.id);
      for (const beat of beats) {
        const fileName = this.fileManager.generateBeatFileName(beat);
        const linkName = fileName.replace(/\.md$/, "");
        beatMap.set(linkName, beat);
        beatIdMap.set(beat.id, beat);
      }
    }
    let currentScene = null;
    let sceneOrderNum = 1;
    const beatOrderNums = /* @__PURE__ */ new Map();
    for (const item of list.items) {
      if (item.type === "scene") {
        currentScene = null;
        let goal;
        let timeRef = "";
        const sceneMatch = item.displayText.match(/Scene\s+\d+:\s*(.+)/);
        if (sceneMatch) {
          const sceneText = sceneMatch[1].trim();
          const parts = sceneText.split(/\s*-\s*/);
          goal = parts[0].trim();
          timeRef = parts.length > 1 ? parts.slice(1).join(" - ").trim() : "";
        } else {
          const parts = item.displayText.split(/\s*-\s*/);
          goal = parts[0].trim();
          timeRef = parts.length > 1 ? parts.slice(1).join(" - ").trim() : "";
        }
        currentScene = null;
        if (item.linkName) {
          currentScene = sceneMap.get(item.linkName) || null;
          if (!currentScene) {
            currentScene = sceneIdMap.get(item.linkName) || null;
          }
          if (currentScene) {
            const needsOrderUpdate = currentScene.order_num !== sceneOrderNum;
            const needsContentUpdate = goal !== currentScene.goal || timeRef !== currentScene.time_ref;
            if (needsOrderUpdate || needsContentUpdate) {
              currentScene = await this.apiClient.updateScene(currentScene.id, {
                goal,
                time_ref: timeRef,
                order_num: sceneOrderNum
              });
            }
            const existingBeats = await this.apiClient.getBeats(currentScene.id);
            if (existingBeats.length === 0) {
              beatOrderNums.set(currentScene.id, 1);
            } else {
              const maxOrderNum = Math.max(...existingBeats.map((b) => b.order_num));
              beatOrderNums.set(currentScene.id, maxOrderNum + 1);
            }
          }
        } else {
          currentScene = await this.apiClient.createScene({
            story_id: storyId,
            chapter_id: chapterId,
            order_num: sceneOrderNum,
            goal,
            time_ref: timeRef
          });
          const sceneFileName = this.fileManager.generateSceneFileName(currentScene);
          const sceneLinkName = sceneFileName.replace(/\.md$/, "");
          sceneMap.set(sceneLinkName, currentScene);
          sceneIdMap.set(currentScene.id, currentScene);
          beatOrderNums.set(currentScene.id, 1);
        }
        sceneOrderNum++;
      } else if (item.type === "beat" && currentScene) {
        let intent;
        let outcome = "";
        const beatMatch = item.displayText.match(/Beat\s+\d+:\s*(.+)/);
        if (beatMatch) {
          const beatText = beatMatch[1].trim();
          const parts = beatText.split(/\s*->\s*/);
          intent = parts[0].trim();
          outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
        } else {
          const parts = item.displayText.split(/\s*->\s*/);
          intent = parts[0].trim();
          outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
        }
        const currentBeatOrderNum = beatOrderNums.get(currentScene.id) || 1;
        if (item.linkName) {
          let currentBeat = beatMap.get(item.linkName) || null;
          if (!currentBeat) {
            currentBeat = beatIdMap.get(item.linkName) || null;
          }
          if (currentBeat) {
            const needsOrderUpdate = currentBeat.order_num !== currentBeatOrderNum;
            const needsContentUpdate = intent !== currentBeat.intent || outcome !== currentBeat.outcome;
            const needsSceneUpdate = currentBeat.scene_id !== currentScene.id;
            if (needsOrderUpdate || needsContentUpdate || needsSceneUpdate) {
              currentBeat = await this.apiClient.updateBeat(currentBeat.id, {
                intent,
                outcome,
                order_num: currentBeatOrderNum,
                scene_id: currentScene.id
              });
              if (needsSceneUpdate) {
                const beatFileName = this.fileManager.generateBeatFileName(currentBeat);
                const beatLinkName = beatFileName.replace(/\.md$/, "");
                beatMap.set(beatLinkName, currentBeat);
                beatIdMap.set(currentBeat.id, currentBeat);
              }
            }
          }
        } else {
          const newBeat = await this.apiClient.createBeat({
            scene_id: currentScene.id,
            order_num: currentBeatOrderNum,
            type: "setup",
            // Default type
            intent,
            outcome
          });
          const beatFileName = this.fileManager.generateBeatFileName(newBeat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          beatMap.set(beatLinkName, newBeat);
          beatIdMap.set(newBeat.id, newBeat);
        }
        beatOrderNums.set(currentScene.id, currentBeatOrderNum + 1);
      }
    }
  }
  // Find prose block by content when file name doesn't match
  async findContentBlockByContent(contentsFolderPath, content) {
    try {
      const folder = this.fileManager.getVault().getAbstractFileByPath(contentsFolderPath);
      if (!(folder instanceof import_obsidian8.TFolder)) {
        return null;
      }
      const normalizedContent = content.trim();
      for (const child of folder.children) {
        if (child instanceof import_obsidian8.TFile && child.extension === "md") {
          const contentBlock = await this.fileManager.readContentBlockFromFile(child.path);
          if (contentBlock && contentBlock.content.trim() === normalizedContent) {
            return contentBlock;
          }
        }
      }
    } catch (err) {
      console.error("Error searching for prose block by content:", err);
    }
    return null;
  }
  // Find prose block by ID when we have remote ID but need local file
  async findContentBlockById(contentsFolderPath, id) {
    try {
      const folder = this.fileManager.getVault().getAbstractFileByPath(contentsFolderPath);
      if (!(folder instanceof import_obsidian8.TFolder)) {
        return null;
      }
      for (const child of folder.children) {
        if (child instanceof import_obsidian8.TFile && child.extension === "md") {
          const contentBlock = await this.fileManager.readContentBlockFromFile(child.path);
          if (contentBlock && contentBlock.id === id) {
            return contentBlock;
          }
        }
      }
    } catch (err) {
      console.error("Error searching for prose block by ID:", err);
    }
    return null;
  }
  // Resolve conflict using modal or auto-resolve based on mode
  async resolveConflict(localContentBlock, remoteContentBlock) {
    if (this.settings.mode === "local") {
      return { resolution: "local" };
    }
    return new Promise((resolve) => {
      const modal = new ConflictModal(
        this.app,
        localContentBlock,
        remoteContentBlock,
        async (result) => {
          resolve(result);
        }
      );
      modal.open();
    });
  }
  // Update the Chapter section in chapter file (hierarchical structure)
  async updateChapterProseSectionHierarchical(originalContent, updatedSections, file, frontmatter) {
    const frontmatterMatch = originalContent.match(/^---\n([\s\S]*?)\n---/);
    const frontmatterText = frontmatterMatch ? frontmatterMatch[0] : "";
    const bodyStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
    const bodyContent = originalContent.substring(bodyStart).trim();
    const chapterNumber = frontmatter.number || "1";
    const chapterTitle = frontmatter.title || "Untitled";
    const chapterHeaderPattern = `##\\s+Chapter\\s+${chapterNumber}:\\s+[^\\n]+`;
    const chapterSectionMatch = bodyContent.match(new RegExp(`([\\s\\S]*?${chapterHeaderPattern}\\s*\\n+)([\\s\\S]*?)(?=\\n##\\s+Chapter\\s+\\d+:|$)`, "i"));
    if (!chapterSectionMatch) {
      const newChapterSection = `

## Chapter ${chapterNumber}: ${chapterTitle}

${updatedSections.join("\n\n")}

`;
      const updatedContent2 = `${frontmatterText}
${bodyContent}${newChapterSection}`;
      await this.fileManager.getVault().modify(file, updatedContent2);
      return;
    }
    const beforeChapter = chapterSectionMatch[1];
    const afterChapter = bodyContent.substring(chapterSectionMatch.index + chapterSectionMatch[0].length);
    const newChapterContent = updatedSections.join("\n\n");
    const updatedBody = `${beforeChapter}${newChapterContent}

${afterChapter}`;
    const updatedContent = `${frontmatterText}
${updatedBody}`;
    await this.fileManager.getVault().modify(file, updatedContent);
  }
  // Update the Prose section in chapter file
  async updateChapterProseSection(originalContent, updatedParagraphs, file) {
    const frontmatterMatch = originalContent.match(/^---\n([\s\S]*?)\n---/);
    const frontmatter = frontmatterMatch ? frontmatterMatch[0] : "";
    const bodyStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
    const bodyContent = originalContent.substring(bodyStart).trim();
    const proseSectionMatch = bodyContent.match(/([\s\S]*?##\s+Prose\s*\n\n)([\s\S]*?)(?=\n##|\n*$)/);
    if (!proseSectionMatch) {
      const newProseSection = `

## Prose

${updatedParagraphs.join("\n\n")}

`;
      const updatedContent2 = `${frontmatter}
${bodyContent}${newProseSection}`;
      await this.fileManager.getVault().modify(file, updatedContent2);
      return;
    }
    const beforeProse = proseSectionMatch[1];
    const newProseContent = updatedParagraphs.join("\n\n");
    const afterProse = bodyContent.substring(proseSectionMatch.index + proseSectionMatch[0].length);
    const updatedBody = `${beforeProse}${newProseContent}

${afterProse}`;
    const updatedContent = `${frontmatter}
${updatedBody}`;
    await this.fileManager.getVault().modify(file, updatedContent);
  }
};

// src/views/StoryListView.ts
var import_obsidian13 = require("obsidian");

// src/views/modals/ChapterModal.ts
var import_obsidian9 = require("obsidian");
var ChapterModal = class extends import_obsidian9.Modal {
  constructor(app, onSubmit, existingChapters = [], chapter) {
    super(app);
    this.chapter = {
      title: "",
      status: "draft"
    };
    this.isEdit = false;
    this.existingChapters = [];
    this.onSubmit = onSubmit;
    this.existingChapters = existingChapters;
    if (chapter) {
      this.isEdit = true;
      this.chapter = {
        number: chapter.number,
        title: chapter.title,
        status: chapter.status
      };
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", {
      text: this.isEdit ? "Edit Chapter" : "Create Chapter"
    });
    if (this.isEdit) {
      new import_obsidian9.Setting(contentEl).setName("Chapter Number").setDesc("The chapter number").addText(
        (text) => {
          var _a;
          return text.setPlaceholder("1").setValue(((_a = this.chapter.number) == null ? void 0 : _a.toString()) || "1").onChange((value) => {
            const num = parseInt(value);
            if (!isNaN(num) && num > 0) {
              this.chapter.number = num;
            }
          });
        }
      );
    }
    new import_obsidian9.Setting(contentEl).setName("Title").setDesc("Chapter title").addText(
      (text) => text.setPlaceholder("Chapter Title").setValue(this.chapter.title || "").onChange((value) => {
        this.chapter.title = value;
      }).inputEl.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          this.submit();
        }
      })
    );
    new import_obsidian9.Setting(contentEl).setName("Status").setDesc("Chapter status").addDropdown(
      (dropdown) => dropdown.addOption("draft", "Draft").addOption("in_progress", "In Progress").addOption("completed", "Completed").setValue(this.chapter.status || "draft").onChange((value) => {
        this.chapter.status = value;
      })
    );
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const submitButton = buttonContainer.createEl("button", {
      text: this.isEdit ? "Update" : "Create",
      cls: "mod-cta"
    });
    submitButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
    const titleInput = contentEl.querySelector("input[placeholder='Chapter Title']");
    if (titleInput) {
      titleInput.focus();
    }
  }
  async submit() {
    var _a;
    if (!((_a = this.chapter.title) == null ? void 0 : _a.trim())) {
      new import_obsidian9.Notice("Please enter a chapter title", 3e3);
      return;
    }
    if (!this.isEdit) {
      const maxNumber = this.existingChapters.length > 0 ? Math.max(...this.existingChapters.map((c) => c.number)) : 0;
      this.chapter.number = maxNumber + 1;
    } else {
      if (!this.chapter.number || this.chapter.number < 1) {
        new import_obsidian9.Notice("Chapter number must be greater than 0", 3e3);
        return;
      }
    }
    try {
      await this.onSubmit(this.chapter);
      this.close();
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to save chapter";
      new import_obsidian9.Notice(`Error: ${errorMessage}`, 5e3);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/modals/SceneModal.ts
var import_obsidian10 = require("obsidian");
var SceneModal = class extends import_obsidian10.Modal {
  constructor(app, storyId, chapters, onSubmit, existingScenes = [], scene, defaultChapterId) {
    super(app);
    this.scene = {
      time_ref: "",
      goal: ""
    };
    this.isEdit = false;
    this.chapters = [];
    this.existingScenes = [];
    this.storyId = storyId;
    this.chapters = chapters;
    this.existingScenes = existingScenes;
    this.defaultChapterId = defaultChapterId;
    this.onSubmit = onSubmit;
    if (scene) {
      this.isEdit = true;
      this.scene = {
        story_id: scene.story_id,
        chapter_id: scene.chapter_id || null,
        order_num: scene.order_num,
        time_ref: scene.time_ref,
        goal: scene.goal,
        pov_character_id: scene.pov_character_id,
        location_id: scene.location_id
      };
    } else {
      this.scene.story_id = storyId;
      if (defaultChapterId !== void 0) {
        this.scene.chapter_id = defaultChapterId;
      }
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", {
      text: this.isEdit ? "Edit Scene" : "Create Scene"
    });
    new import_obsidian10.Setting(contentEl).setName("Chapter").setDesc("Select the chapter for this scene (optional)").addDropdown((dropdown) => {
      dropdown.addOption("", "No Chapter");
      for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
        dropdown.addOption(
          chapter.id,
          `Chapter ${chapter.number}: ${chapter.title}`
        );
      }
      dropdown.setValue(this.scene.chapter_id || "");
      dropdown.onChange((value) => {
        this.scene.chapter_id = value || null;
      });
    });
    if (this.isEdit) {
      new import_obsidian10.Setting(contentEl).setName("Order Number").setDesc("Scene order within chapter").addText(
        (text) => {
          var _a;
          return text.setPlaceholder("1").setValue(((_a = this.scene.order_num) == null ? void 0 : _a.toString()) || "1").onChange((value) => {
            const num = parseInt(value);
            if (!isNaN(num) && num > 0) {
              this.scene.order_num = num;
            }
          });
        }
      );
    }
    new import_obsidian10.Setting(contentEl).setName("Goal").setDesc("Scene goal or description").addTextArea(
      (text) => text.setPlaceholder("What happens in this scene?").setValue(this.scene.goal || "").onChange((value) => {
        this.scene.goal = value;
      })
    );
    new import_obsidian10.Setting(contentEl).setName("Time Reference").setDesc("When does this scene take place?").addText(
      (text) => text.setPlaceholder("Morning, Evening, etc.").setValue(this.scene.time_ref || "").onChange((value) => {
        this.scene.time_ref = value;
      })
    );
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const submitButton = buttonContainer.createEl("button", {
      text: this.isEdit ? "Update" : "Create",
      cls: "mod-cta"
    });
    submitButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
    const goalInput = contentEl.querySelector("textarea");
    if (goalInput) {
      goalInput.focus();
    }
  }
  async submit() {
    if (!this.isEdit) {
      const chapterId = this.scene.chapter_id || null;
      const scenesInChapter = this.existingScenes.filter(
        (s) => (s.chapter_id || null) === chapterId
      );
      const maxOrderNum = scenesInChapter.length > 0 ? Math.max(...scenesInChapter.map((s) => s.order_num)) : 0;
      this.scene.order_num = maxOrderNum + 1;
    } else {
      if (!this.scene.order_num || this.scene.order_num < 1) {
        new import_obsidian10.Notice("Order number must be greater than 0", 3e3);
        return;
      }
    }
    try {
      await this.onSubmit(this.scene);
      this.close();
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to save scene";
      new import_obsidian10.Notice(`Error: ${errorMessage}`, 5e3);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/modals/BeatModal.ts
var import_obsidian11 = require("obsidian");
var BeatModal = class extends import_obsidian11.Modal {
  constructor(app, storyId, scenes, onSubmit, existingBeats = [], beat, chapters = [], defaultSceneId) {
    super(app);
    this.beat = {
      type: "setup",
      intent: "",
      outcome: ""
    };
    this.isEdit = false;
    this.scenes = [];
    this.chapters = [];
    this.existingBeats = [];
    this.storyId = storyId;
    this.scenes = scenes;
    this.chapters = chapters;
    this.existingBeats = existingBeats;
    this.defaultSceneId = defaultSceneId;
    this.onSubmit = onSubmit;
    if (beat) {
      this.isEdit = true;
      this.beat = {
        scene_id: beat.scene_id,
        order_num: beat.order_num,
        type: beat.type,
        intent: beat.intent,
        outcome: beat.outcome
      };
    } else if (defaultSceneId) {
      this.beat.scene_id = defaultSceneId;
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", {
      text: this.isEdit ? "Edit Beat" : "Create Beat"
    });
    new import_obsidian11.Setting(contentEl).setName("Scene").setDesc("Select the scene for this beat").addDropdown((dropdown) => {
      const scenesByChapter = /* @__PURE__ */ new Map();
      for (const scene of this.scenes) {
        const chapterId = scene.chapter_id || null;
        if (!scenesByChapter.has(chapterId)) {
          scenesByChapter.set(chapterId, []);
        }
        scenesByChapter.get(chapterId).push(scene);
      }
      const getChapterLabel = (chapterId) => {
        if (!chapterId)
          return "No Chapter";
        const chapter = this.chapters.find((c) => c.id === chapterId);
        return chapter ? `Chapter ${chapter.number}: ${chapter.title}` : "No Chapter";
      };
      for (const [chapterId, chapterScenes] of scenesByChapter.entries()) {
        const label = getChapterLabel(chapterId);
        for (const scene of chapterScenes.sort((a, b) => a.order_num - b.order_num)) {
          dropdown.addOption(
            scene.id,
            `${label} > Scene ${scene.order_num}: ${scene.goal || "Untitled"}`
          );
        }
      }
      dropdown.setValue(this.beat.scene_id || "");
      dropdown.onChange((value) => {
        this.beat.scene_id = value;
      });
    });
    if (this.isEdit) {
      new import_obsidian11.Setting(contentEl).setName("Order Number").setDesc("Beat order within scene").addText(
        (text) => {
          var _a;
          return text.setPlaceholder("1").setValue(((_a = this.beat.order_num) == null ? void 0 : _a.toString()) || "1").onChange((value) => {
            const num = parseInt(value);
            if (!isNaN(num) && num > 0) {
              this.beat.order_num = num;
            }
          });
        }
      );
    }
    new import_obsidian11.Setting(contentEl).setName("Type").setDesc("Beat type").addDropdown(
      (dropdown) => dropdown.addOption("setup", "Setup").addOption("turn", "Turn").addOption("reveal", "Reveal").addOption("conflict", "Conflict").addOption("climax", "Climax").addOption("resolution", "Resolution").addOption("hook", "Hook").addOption("transition", "Transition").setValue(this.beat.type || "setup").onChange((value) => {
        this.beat.type = value;
      })
    );
    new import_obsidian11.Setting(contentEl).setName("Intent").setDesc("What is the intent of this beat?").addTextArea(
      (text) => text.setPlaceholder("What does the character want?").setValue(this.beat.intent || "").onChange((value) => {
        this.beat.intent = value;
      })
    );
    new import_obsidian11.Setting(contentEl).setName("Outcome").setDesc("What is the outcome of this beat?").addTextArea(
      (text) => text.setPlaceholder("What happens as a result?").setValue(this.beat.outcome || "").onChange((value) => {
        this.beat.outcome = value;
      })
    );
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const submitButton = buttonContainer.createEl("button", {
      text: this.isEdit ? "Update" : "Create",
      cls: "mod-cta"
    });
    submitButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
    const intentInput = contentEl.querySelector("textarea");
    if (intentInput) {
      intentInput.focus();
    }
  }
  async submit() {
    if (!this.beat.scene_id) {
      new import_obsidian11.Notice("Please select a scene", 3e3);
      return;
    }
    if (!this.beat.type) {
      new import_obsidian11.Notice("Please select a beat type", 3e3);
      return;
    }
    if (!this.isEdit) {
      const beatsInScene = this.existingBeats.filter((b) => b.scene_id === this.beat.scene_id);
      const maxOrderNum = beatsInScene.length > 0 ? Math.max(...beatsInScene.map((b) => b.order_num)) : 0;
      this.beat.order_num = maxOrderNum + 1;
    } else {
      if (!this.beat.order_num || this.beat.order_num < 1) {
        new import_obsidian11.Notice("Order number must be greater than 0", 3e3);
        return;
      }
    }
    try {
      await this.onSubmit(this.beat);
      this.close();
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to save beat";
      new import_obsidian11.Notice(`Error: ${errorMessage}`, 5e3);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/modals/ContentBlockModal.ts
var import_obsidian12 = require("obsidian");

// src/api/unsplash.ts
var UnsplashClient = class {
  constructor(accessKey, secretKey) {
    this.apiUrl = "https://api.unsplash.com";
    this.accessKey = accessKey || "YOUR_UNSPLASH_ACCESS_KEY";
    this.secretKey = secretKey || "";
  }
  async searchImages(query, page = 1, perPage = 20) {
    const url = `${this.apiUrl}/search/photos?query=${encodeURIComponent(query)}&page=${page}&per_page=${perPage}`;
    const headers = {
      "Accept-Version": "v1"
    };
    if (!this.accessKey || this.accessKey === "YOUR_UNSPLASH_ACCESS_KEY") {
      throw new Error("Unsplash access key is required. Please configure it in plugin settings.");
    }
    headers["Authorization"] = `Client-ID ${this.accessKey}`;
    const response = await fetch(url, { headers });
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Unsplash API error: ${response.status} ${response.statusText}. ${errorText}`);
    }
    return response.json();
  }
  getImageUrl(photo, size = "regular") {
    return photo.urls[size];
  }
  getAttributionUrl(photo) {
    return photo.links.html;
  }
  getAttributionText(photo) {
    return `Photo by ${photo.user.name} on Unsplash`;
  }
};

// src/views/modals/ContentBlockModal.ts
var ContentBlockModal = class extends import_obsidian12.Modal {
  constructor(app, onSubmit, contentBlock, plugin) {
    var _a, _b, _c, _d;
    super(app);
    this.contentBlock = {
      type: "text",
      kind: "final",
      content: "",
      metadata: {}
    };
    this.isEdit = false;
    this.unsplashResults = [];
    this.unsplashSearchQuery = "";
    this.unsplashSearching = false;
    this.selectedImageUrl = "";
    this.currentImageSourceTab = "internet link";
    this.onSubmit = onSubmit;
    this.plugin = plugin;
    const unsplashAccessKey = ((_b = (_a = this.plugin) == null ? void 0 : _a.settings) == null ? void 0 : _b.unsplashAccessKey) || "";
    const unsplashSecretKey = ((_d = (_c = this.plugin) == null ? void 0 : _c.settings) == null ? void 0 : _d.unsplashSecretKey) || "";
    this.unsplashClient = new UnsplashClient(unsplashAccessKey, unsplashSecretKey);
    if (contentBlock) {
      this.isEdit = true;
      this.contentBlock = {
        type: contentBlock.type,
        kind: contentBlock.kind || "final",
        content: contentBlock.content,
        metadata: contentBlock.metadata || {}
      };
      if (contentBlock.type === "image" && contentBlock.content) {
        this.selectedImageUrl = contentBlock.content;
      }
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", {
      text: this.isEdit ? "Edit Content Block" : "Create Content Block"
    });
    if (this.isEdit && !this.contentBlock.type) {
      new import_obsidian12.Setting(contentEl).setName("Type").setDesc("Select the content type").addDropdown(
        (dropdown) => dropdown.addOption("text", "Text").addOption("image", "Image").setValue(this.contentBlock.type || "text").onChange((value) => {
          this.contentBlock.type = value;
          this.renderContentFields();
        })
      );
    }
    this.renderContentFields();
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const submitButton = buttonContainer.createEl("button", {
      text: this.isEdit ? "Update" : "Create",
      cls: "mod-cta"
    });
    submitButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
  }
  renderContentFields() {
    var _a, _b, _c, _d, _e, _f, _g;
    const { contentEl } = this;
    const existingFields = contentEl.querySelectorAll(".content-block-field");
    existingFields.forEach((el) => el.remove());
    if (this.contentBlock.type === "text") {
      const textField = contentEl.createDiv({ cls: "content-block-field" });
      new import_obsidian12.Setting(textField).setName("Content").setDesc("Enter the text content").addTextArea(
        (text) => text.setPlaceholder("Enter text...").setValue(this.contentBlock.content || "").onChange((value) => {
          this.contentBlock.content = value;
          if (!this.contentBlock.metadata) {
            this.contentBlock.metadata = {};
          }
          this.contentBlock.metadata.word_count = value.trim().split(/\s+/).filter((w) => w.length > 0).length;
        })
      );
    } else if (this.contentBlock.type === "image") {
      const imageField = contentEl.createDiv({ cls: "content-block-field" });
      const sourceValue = ((_a = this.contentBlock.metadata) == null ? void 0 : _a.source) || "internet link";
      this.currentImageSourceTab = sourceValue;
      const tabsContainer = imageField.createDiv({ cls: "content-block-source-tabs" });
      const unsplashTab = tabsContainer.createEl("button", {
        text: "Unsplash",
        cls: `content-block-source-tab ${this.currentImageSourceTab === "unsplash" ? "is-active" : ""}`
      });
      const internetTab = tabsContainer.createEl("button", {
        text: "Internet Link",
        cls: `content-block-source-tab ${this.currentImageSourceTab === "internet link" ? "is-active" : ""}`
      });
      const localTab = tabsContainer.createEl("button", {
        text: "Local Upload",
        cls: `content-block-source-tab ${this.currentImageSourceTab === "local" ? "is-active" : ""}`
      });
      const tabContent = imageField.createDiv({ cls: "content-block-source-tab-content" });
      unsplashTab.onclick = () => {
        this.currentImageSourceTab = "unsplash";
        if (!this.contentBlock.metadata) {
          this.contentBlock.metadata = {};
        }
        this.contentBlock.metadata.source = "unsplash";
        this.renderContentFields();
      };
      internetTab.onclick = () => {
        this.currentImageSourceTab = "internet link";
        if (!this.contentBlock.metadata) {
          this.contentBlock.metadata = {};
        }
        this.contentBlock.metadata.source = "internet link";
        this.renderContentFields();
      };
      localTab.onclick = () => {
        this.currentImageSourceTab = "local";
        if (!this.contentBlock.metadata) {
          this.contentBlock.metadata = {};
        }
        this.contentBlock.metadata.source = "local";
        this.renderContentFields();
      };
      if (this.currentImageSourceTab === "unsplash") {
        const unsplashAccessKey = ((_c = (_b = this.plugin) == null ? void 0 : _b.settings) == null ? void 0 : _c.unsplashAccessKey) || "";
        if (unsplashAccessKey && unsplashAccessKey !== "YOUR_UNSPLASH_ACCESS_KEY") {
          const unsplashSetting = new import_obsidian12.Setting(tabContent);
          unsplashSetting.setName("Search Unsplash");
          unsplashSetting.setDesc("Search for free images");
          unsplashSetting.addButton((button) => {
            button.setButtonText("Search");
            button.onClick(() => {
              this.showUnsplashSearch();
            });
          });
        } else {
          const unsplashSetting = new import_obsidian12.Setting(tabContent);
          unsplashSetting.setName("Search Unsplash");
          unsplashSetting.setDesc("Configure Unsplash Access Key and Secret Key in plugin settings to enable image search");
          unsplashSetting.addButton((button) => {
            button.setButtonText("Search");
            button.setDisabled(true);
          });
        }
        if (this.selectedImageUrl) {
          new import_obsidian12.Setting(tabContent).setName("Selected Image URL").setDesc("Image URL from Unsplash").addText(
            (text) => text.setValue(this.selectedImageUrl).setDisabled(true)
          );
        }
      } else if (this.currentImageSourceTab === "internet link") {
        new import_obsidian12.Setting(tabContent).setName("Image URL").setDesc("Enter image URL").addText(
          (text) => text.setPlaceholder("https://example.com/image.jpg").setValue(this.selectedImageUrl).onChange((value) => {
            this.selectedImageUrl = value;
            this.contentBlock.content = value;
            if (!this.contentBlock.metadata) {
              this.contentBlock.metadata = {};
            }
            this.contentBlock.metadata.source = "internet link";
          })
        );
      } else if (this.currentImageSourceTab === "local") {
        new import_obsidian12.Setting(tabContent).setName("Upload from Computer").setDesc("Upload image from your computer (coming soon)").addButton((button) => {
          button.setButtonText("Choose File");
          button.setDisabled(true);
        });
      }
      const altTextValue = ((_d = this.contentBlock.metadata) == null ? void 0 : _d.alt_text) || "";
      const altTextSetting = new import_obsidian12.Setting(imageField);
      altTextSetting.setName("Alt Text");
      altTextSetting.setDesc("Alt text for accessibility");
      altTextSetting.addText(
        (text) => text.setPlaceholder("Describe the image for accessibility").setValue(altTextValue).onChange((value) => {
          if (!this.contentBlock.metadata) {
            this.contentBlock.metadata = {};
          }
          this.contentBlock.metadata.alt_text = value || void 0;
        })
      );
      const authorNameValue = ((_e = this.contentBlock.metadata) == null ? void 0 : _e.author_name) || "";
      new import_obsidian12.Setting(imageField).setName("Author Name").setDesc("Name of the image author/photographer").addText(
        (text) => text.setPlaceholder("Author name").setValue(authorNameValue).onChange((value) => {
          if (!this.contentBlock.metadata) {
            this.contentBlock.metadata = {};
          }
          this.contentBlock.metadata.author_name = value || void 0;
        })
      );
      const attributionValue = ((_f = this.contentBlock.metadata) == null ? void 0 : _f.attribution) || "";
      new import_obsidian12.Setting(imageField).setName("Attribution").setDesc("Attribution text (e.g., 'Photo by John Doe on Unsplash')").addText(
        (text) => text.setPlaceholder("Photo by Author Name on Source").setValue(attributionValue).onChange((value) => {
          if (!this.contentBlock.metadata) {
            this.contentBlock.metadata = {};
          }
          this.contentBlock.metadata.attribution = value || void 0;
        })
      );
      const attributionUrlValue = ((_g = this.contentBlock.metadata) == null ? void 0 : _g.attribution_url) || "";
      new import_obsidian12.Setting(imageField).setName("Attribution URL").setDesc("Link to the original image or author page").addText(
        (text) => text.setPlaceholder("https://example.com/photo").setValue(attributionUrlValue).onChange((value) => {
          if (!this.contentBlock.metadata) {
            this.contentBlock.metadata = {};
          }
          this.contentBlock.metadata.attribution_url = value || void 0;
        })
      );
    }
  }
  showUnsplashSearch() {
    const { contentEl } = this;
    const searchModal = new import_obsidian12.Modal(this.app);
    searchModal.titleEl.setText("Search Unsplash");
    const searchContent = searchModal.contentEl;
    const searchInput = searchContent.createEl("input", {
      type: "text",
      placeholder: "Search for images...",
      cls: "unsplash-search-input"
    });
    searchInput.value = this.unsplashSearchQuery;
    searchInput.style.width = "100%";
    searchInput.style.padding = "0.5rem";
    searchInput.style.marginBottom = "1rem";
    const searchButton = searchContent.createEl("button", {
      text: "Search",
      cls: "mod-cta"
    });
    searchButton.style.marginBottom = "1rem";
    const resultsContainer = searchContent.createDiv({ cls: "unsplash-results-grid" });
    const performSearch = async () => {
      const query = searchInput.value.trim();
      if (!query) {
        new import_obsidian12.Notice("Please enter a search query", 3e3);
        return;
      }
      this.unsplashSearching = true;
      searchButton.disabled = true;
      searchButton.setText("Searching...");
      resultsContainer.empty();
      resultsContainer.createEl("p", { text: "Searching..." });
      try {
        const response = await this.unsplashClient.searchImages(query, 1, 20);
        this.unsplashResults = response.results;
        resultsContainer.empty();
        if (this.unsplashResults.length === 0) {
          resultsContainer.createEl("p", { text: "No results found." });
        } else {
          for (const photo of this.unsplashResults) {
            const photoItem = resultsContainer.createDiv({ cls: "unsplash-photo-item" });
            const img = photoItem.createEl("img", {
              attr: {
                src: this.unsplashClient.getImageUrl(photo, "thumb"),
                alt: photo.alt_description || photo.description || "Unsplash photo"
              }
            });
            img.style.width = "100%";
            img.style.height = "150px";
            img.style.objectFit = "cover";
            img.style.borderRadius = "4px";
            img.style.cursor = "pointer";
            const photoInfo = photoItem.createDiv({ cls: "unsplash-photo-info" });
            photoInfo.createEl("p", {
              text: photo.alt_description || photo.description || "Untitled",
              cls: "unsplash-photo-title"
            });
            photoInfo.createEl("p", {
              text: this.unsplashClient.getAttributionText(photo),
              cls: "unsplash-photo-attribution"
            });
            photoItem.onclick = () => {
              const imageUrl = this.unsplashClient.getImageUrl(photo, "regular");
              this.selectedImageUrl = imageUrl;
              this.contentBlock.content = imageUrl;
              if (!this.contentBlock.metadata) {
                this.contentBlock.metadata = {};
              }
              const altText = photo.alt_description || photo.description || "";
              this.contentBlock.metadata.alt_text = altText;
              this.contentBlock.metadata.attribution = this.unsplashClient.getAttributionText(photo);
              this.contentBlock.metadata.attribution_url = this.unsplashClient.getAttributionUrl(photo);
              this.contentBlock.metadata.author_name = photo.user.name;
              this.contentBlock.metadata.source = "unsplash";
              searchModal.close();
              this.renderContentFields();
              new import_obsidian12.Notice("Image selected");
            };
          }
        }
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to search Unsplash";
        new import_obsidian12.Notice(`Error: ${errorMessage}`, 5e3);
        resultsContainer.empty();
        resultsContainer.createEl("p", {
          text: `Error: ${errorMessage}`,
          cls: "story-engine-error"
        });
      } finally {
        this.unsplashSearching = false;
        searchButton.disabled = false;
        searchButton.setText("Search");
      }
    };
    searchButton.onclick = performSearch;
    searchInput.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        performSearch();
      }
    });
    if (this.unsplashSearchQuery) {
      performSearch();
    }
    searchModal.open();
  }
  async submit() {
    var _a, _b;
    if (!this.contentBlock.type) {
      this.contentBlock.type = "text";
    }
    if (this.contentBlock.type === "text" && !((_a = this.contentBlock.content) == null ? void 0 : _a.trim())) {
      new import_obsidian12.Notice("Please enter text content", 3e3);
      return;
    }
    if (this.contentBlock.type === "image" && !((_b = this.contentBlock.content) == null ? void 0 : _b.trim())) {
      new import_obsidian12.Notice("Please enter an image URL or select an image", 3e3);
      return;
    }
    try {
      await this.onSubmit(this.contentBlock);
      this.close();
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to save content block";
      new import_obsidian12.Notice(`Error: ${errorMessage}`, 5e3);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/StoryListView.ts
var STORY_LIST_VIEW_TYPE = "story-engine-list-view";
var StoryListView = class extends import_obsidian13.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.stories = [];
    this.worlds = [];
    this.rpgSystems = [];
    this.loading = true;
    this.error = null;
    this.currentStory = null;
    this.currentWorld = null;
    this.viewMode = "list";
    this.currentTab = "chapters";
    this.worldTab = "characters";
    this.listTab = "stories";
    this.expandedWorldId = null;
    this.chapters = [];
    this.scenes = [];
    this.beats = [];
    this.contentBlocks = [];
    this.contentBlockRefs = [];
    this.loadingHierarchy = false;
    // World entities
    this.characters = [];
    this.locations = [];
    this.artifacts = [];
    this.events = [];
    this.traits = [];
    this.loadingWorldData = false;
    this.plugin = plugin;
  }
  getViewType() {
    return STORY_LIST_VIEW_TYPE;
  }
  getDisplayText() {
    if (this.viewMode === "details" && this.currentStory) {
      return this.currentStory.title;
    }
    if (this.viewMode === "world-details" && this.currentWorld) {
      return this.currentWorld.name;
    }
    return "Stories";
  }
  getIcon() {
    return "book-open";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("story-engine-view-container");
    await this.render(container);
    await this.loadStories();
  }
  async onClose() {
  }
  async render(container) {
    container.empty();
    this.headerEl = container.createDiv({ cls: "story-engine-view-header" });
    this.contentEl = container.createDiv({ cls: "story-engine-view-content" });
    if (this.viewMode === "details" && this.currentStory) {
      this.renderDetails();
    } else if (this.viewMode === "world-details" && this.currentWorld) {
      this.renderWorldDetails();
    } else {
      this.renderListHeader();
      this.renderListContent();
    }
  }
  renderListHeader() {
    if (!this.headerEl)
      return;
    this.headerEl.empty();
    this.headerEl.createEl("h2", { text: "Stories" });
    const tabsContainer = this.headerEl.createDiv({ cls: "story-engine-tabs" });
    const storiesTab = tabsContainer.createEl("button", {
      text: "Stories",
      cls: `story-engine-tab ${this.listTab === "stories" ? "is-active" : ""}`
    });
    storiesTab.onclick = () => {
      this.listTab = "stories";
      this.renderListHeader();
      this.renderListContent();
    };
    const worldsTab = tabsContainer.createEl("button", {
      text: "Worlds",
      cls: `story-engine-tab ${this.listTab === "worlds" ? "is-active" : ""}`
    });
    worldsTab.onclick = () => {
      this.listTab = "worlds";
      this.renderListHeader();
      this.renderListContent();
    };
    const rpgSystemsTab = tabsContainer.createEl("button", {
      text: "RPG Systems",
      cls: `story-engine-tab ${this.listTab === "rpg-systems" ? "is-active" : ""}`
    });
    rpgSystemsTab.onclick = () => {
      this.listTab = "rpg-systems";
      this.renderListHeader();
      this.renderListContent();
    };
    const settingsButton = tabsContainer.createEl("button", {
      cls: "story-engine-settings-btn story-engine-tab",
      attr: { "aria-label": "Open Settings" }
    });
    (0, import_obsidian13.setIcon)(settingsButton, "gear");
    settingsButton.onclick = () => {
      this.plugin.openSettings();
    };
  }
  renderListContent() {
    if (!this.contentEl)
      return;
    this.contentEl.empty();
    if (this.loading) {
      this.contentEl.createEl("p", { text: "Loading..." });
      return;
    }
    if (this.error) {
      this.contentEl.createEl("p", {
        text: `Error: ${this.error}`,
        cls: "story-engine-error"
      });
      this.renderActionsBar();
      return;
    }
    switch (this.listTab) {
      case "stories":
        this.renderStoriesTab();
        break;
      case "worlds":
        this.renderWorldsTab();
        break;
      case "rpg-systems":
        this.renderRPGSystemsTab();
        break;
    }
    this.renderActionsBar();
  }
  renderActionsBar() {
    if (!this.contentEl)
      return;
    const actionsBar = this.contentEl.createDiv({ cls: "story-engine-actions-bar" });
    const refreshButton = actionsBar.createEl("button", {
      text: "Refresh",
      cls: "story-engine-refresh-btn"
    });
    refreshButton.onclick = async () => {
      await this.loadStories();
    };
    const syncAllButton = actionsBar.createEl("button", {
      text: "Sync All",
      cls: "story-engine-sync-all-btn"
    });
    syncAllButton.onclick = async () => {
      if (!this.plugin.settings.tenantId) {
        new import_obsidian13.Notice("Please configure Tenant ID in settings", 5e3);
        return;
      }
      try {
        new import_obsidian13.Notice("Syncing all stories...");
        await this.plugin.syncService.pullAllStories();
        await this.loadStories();
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to sync stories";
        new import_obsidian13.Notice(`Error: ${errorMessage}`, 5e3);
      }
    };
    let createButtonText = "Create Story";
    let createButtonAction = () => {
      this.plugin.createStoryCommand();
    };
    if (this.listTab === "worlds") {
      createButtonText = "Create World";
      createButtonAction = async () => {
        new CreateWorldModal(this.app, async (name, description, genre) => {
          try {
            new import_obsidian13.Notice(`Creating world "${name}"...`);
            const newWorld = await this.plugin.apiClient.createWorld(name, description, genre);
            new import_obsidian13.Notice(`World "${name}" created successfully`);
            await this.loadStories();
          } catch (err) {
            const errorMessage = err instanceof Error ? err.message : "Failed to create world";
            new import_obsidian13.Notice(`Error: ${errorMessage}`, 5e3);
          }
        }).open();
      };
    } else if (this.listTab === "rpg-systems") {
      createButtonText = "Create RPG System";
      createButtonAction = () => {
        new import_obsidian13.Notice("Create RPG System - Coming soon", 3e3);
      };
    }
    const createButton = actionsBar.createEl("button", {
      text: createButtonText,
      cls: "mod-cta story-engine-create-btn"
    });
    createButton.onclick = createButtonAction;
  }
  renderDetailsHeader() {
    if (!this.headerEl || !this.currentStory)
      return;
    this.headerEl.empty();
    const headerLeft = this.headerEl.createDiv({ cls: "story-engine-header-left" });
    const backButton = headerLeft.createEl("button", {
      text: "\u2190 Back",
      cls: "story-engine-back-btn"
    });
    backButton.onclick = () => {
      this.showList();
    };
    const titleContainer = headerLeft.createDiv({ cls: "story-engine-title-container" });
    const titleRow = titleContainer.createDiv({ cls: "story-engine-title-row" });
    const titleH2 = titleRow.createEl("h2", {
      text: this.currentStory.title,
      cls: "story-engine-title-header"
    });
    const statusPill = titleRow.createSpan({
      cls: `story-engine-status-pill story-engine-status-${this.currentStory.status.toLowerCase().replace(/\s+/g, "-")}`
    });
    statusPill.textContent = this.currentStory.status;
    const versionSpan = titleRow.createSpan({ cls: "story-engine-version" });
    versionSpan.textContent = `v.${this.currentStory.version_number}`;
    const uuidRow = titleContainer.createDiv({ cls: "story-engine-uuid-row" });
    const uuidSpan = uuidRow.createSpan({ cls: "story-engine-uuid" });
    uuidSpan.textContent = this.currentStory.id;
    const copyUuidButton = uuidRow.createEl("button", {
      cls: "story-engine-copy-uuid-btn",
      attr: { "aria-label": "Copy UUID" }
    });
    (0, import_obsidian13.setIcon)(copyUuidButton, "copy");
    copyUuidButton.onclick = () => {
      this.copyStoryId();
    };
    const headerActions = this.headerEl.createDiv({ cls: "story-engine-header-actions" });
    const contextButton = headerActions.createEl("button", {
      cls: "story-engine-context-btn",
      attr: { "aria-label": "Story Actions" }
    });
    (0, import_obsidian13.setIcon)(contextButton, "more-vertical");
    const dropdownMenu = headerActions.createDiv({ cls: "story-engine-dropdown-menu" });
    dropdownMenu.style.display = "none";
    const editOption = dropdownMenu.createEl("button", {
      cls: "story-engine-dropdown-item"
    });
    (0, import_obsidian13.setIcon)(editOption, "pencil");
    editOption.createSpan({ text: "Edit Story Name" });
    editOption.onclick = () => {
      dropdownMenu.style.display = "none";
      this.showEditStoryNameModal();
    };
    const cloneOption = dropdownMenu.createEl("button", {
      cls: "story-engine-dropdown-item"
    });
    (0, import_obsidian13.setIcon)(cloneOption, "copy");
    cloneOption.createSpan({ text: "Clone Story" });
    cloneOption.onclick = async () => {
      dropdownMenu.style.display = "none";
      await this.cloneStory();
    };
    const pullOption = dropdownMenu.createEl("button", {
      cls: "story-engine-dropdown-item"
    });
    (0, import_obsidian13.setIcon)(pullOption, "download");
    pullOption.createSpan({ text: "Pull from Service" });
    pullOption.onclick = async () => {
      dropdownMenu.style.display = "none";
      if (!this.currentStory)
        return;
      try {
        new import_obsidian13.Notice(`Pulling story "${this.currentStory.title}"...`);
        await this.plugin.syncService.pullStory(this.currentStory.id);
        await this.loadHierarchy();
        this.renderTabContent();
        new import_obsidian13.Notice(`Story pulled successfully!`);
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to pull story";
        new import_obsidian13.Notice(`Error: ${errorMessage}`, 5e3);
      }
    };
    const pushOption = dropdownMenu.createEl("button", {
      cls: "story-engine-dropdown-item"
    });
    (0, import_obsidian13.setIcon)(pushOption, "upload");
    pushOption.createSpan({ text: "Push to Service" });
    pushOption.onclick = async () => {
      dropdownMenu.style.display = "none";
      if (!this.currentStory)
        return;
      try {
        const folderPath = this.plugin.fileManager.getStoryFolderPath(this.currentStory.title);
        new import_obsidian13.Notice(`Pushing story "${this.currentStory.title}"...`);
        await this.plugin.syncService.pushStory(folderPath);
        new import_obsidian13.Notice(`Story pushed successfully!`);
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to push story";
        new import_obsidian13.Notice(`Error: ${errorMessage}`, 5e3);
      }
    };
    contextButton.onclick = (e) => {
      e.stopPropagation();
      const isVisible = dropdownMenu.style.display !== "none";
      dropdownMenu.style.display = isVisible ? "none" : "block";
    };
    document.addEventListener("click", () => {
      dropdownMenu.style.display = "none";
    }, { once: true });
  }
  renderStoriesTab() {
    if (this.stories.length === 0) {
      this.contentEl.createEl("p", { text: "No stories found." });
      return;
    }
    const storiesList = this.contentEl.createDiv({ cls: "story-engine-list" });
    for (const story of this.stories) {
      this.renderStoryItem(storiesList, story);
    }
  }
  renderWorldsTab() {
    if (this.worlds.length === 0) {
      this.contentEl.createEl("p", { text: "No worlds found." });
      return;
    }
    const storiesByWorld = /* @__PURE__ */ new Map();
    for (const story of this.stories) {
      const worldId = story.world_id || null;
      if (!storiesByWorld.has(worldId)) {
        storiesByWorld.set(worldId, []);
      }
      storiesByWorld.get(worldId).push(story);
    }
    const worldsList = this.contentEl.createDiv({ cls: "story-engine-list" });
    for (const world of this.worlds) {
      const worldStories = storiesByWorld.get(world.id) || [];
      const worldItem = worldsList.createDiv({ cls: "story-engine-world-item" });
      const worldHeader = worldItem.createDiv({ cls: "story-engine-world-item-header" });
      const worldTitle = worldHeader.createDiv({ cls: "story-engine-world-title" });
      worldTitle.createEl("h3", { text: world.name });
      if (world.description) {
        worldTitle.createEl("p", {
          text: world.description,
          cls: "story-engine-world-description"
        });
      }
      worldTitle.style.cursor = "pointer";
      worldTitle.onclick = () => {
        this.showWorldDetails(world);
      };
      const accordionButton = worldHeader.createEl("button", {
        text: worldStories.length > 0 ? `${worldStories.length} story${worldStories.length !== 1 ? "s" : ""}` : "No stories",
        cls: `story-engine-accordion-btn ${this.expandedWorldId === world.id ? "is-expanded" : ""}`
      });
      accordionButton.onclick = (e) => {
        e.stopPropagation();
        if (this.expandedWorldId === world.id) {
          this.expandedWorldId = null;
        } else {
          this.expandedWorldId = world.id;
        }
        this.renderListContent();
      };
      if (this.expandedWorldId === world.id && worldStories.length > 0) {
        const storiesContent = worldItem.createDiv({ cls: "story-engine-world-stories-content" });
        for (const story of worldStories) {
          this.renderStoryItem(storiesContent, story);
        }
      }
    }
    const storiesWithoutWorld = storiesByWorld.get(null) || [];
    if (storiesWithoutWorld.length > 0) {
      const noWorldItem = worldsList.createDiv({ cls: "story-engine-world-item" });
      const noWorldHeader = noWorldItem.createDiv({ cls: "story-engine-world-item-header" });
      noWorldHeader.createEl("h3", { text: "No World" });
      const accordionButton = noWorldHeader.createEl("button", {
        text: `${storiesWithoutWorld.length} story${storiesWithoutWorld.length !== 1 ? "s" : ""}`,
        cls: `story-engine-accordion-btn ${this.expandedWorldId === "no-world" ? "is-expanded" : ""}`
      });
      accordionButton.onclick = () => {
        if (this.expandedWorldId === "no-world") {
          this.expandedWorldId = null;
        } else {
          this.expandedWorldId = "no-world";
        }
        this.renderListContent();
      };
      if (this.expandedWorldId === "no-world") {
        const storiesContent = noWorldItem.createDiv({ cls: "story-engine-world-stories-content" });
        for (const story of storiesWithoutWorld) {
          this.renderStoryItem(storiesContent, story);
        }
      }
    }
  }
  renderRPGSystemsTab() {
    if (this.rpgSystems.length === 0) {
      if (this.plugin.settings.mode === "local") {
        this.contentEl.createEl("p", { text: "RPG systems are not available in local mode." });
      } else {
        this.contentEl.createEl("p", { text: "No RPG systems found." });
      }
      return;
    }
    const rpgSystemsList = this.contentEl.createDiv({ cls: "story-engine-list" });
    for (const rpgSystem of this.rpgSystems) {
      const rpgSystemItem = rpgSystemsList.createDiv({
        cls: "story-engine-item"
      });
      const title = rpgSystemItem.createDiv({
        cls: "story-engine-title",
        text: rpgSystem.name
      });
      const meta = rpgSystemItem.createDiv({
        cls: "story-engine-meta"
      });
      if (rpgSystem.description) {
        meta.createEl("span", {
          text: rpgSystem.description
        });
      }
      if (rpgSystem.is_builtin) {
        meta.createEl("span", {
          text: "Built-in",
          cls: "story-engine-badge"
        });
      }
    }
  }
  renderStoryItem(container, story) {
    const storyItem = container.createDiv({
      cls: "story-engine-item"
    });
    const title = storyItem.createDiv({
      cls: "story-engine-title",
      text: story.title
    });
    const meta = storyItem.createDiv({
      cls: "story-engine-meta"
    });
    meta.createEl("span", {
      text: `Version ${story.version_number}`
    });
    meta.createEl("span", {
      text: `Status: ${story.status}`
    });
    if (story.world_id) {
      const world = this.worlds.find((w) => w.id === story.world_id);
      if (world) {
        meta.createEl("span", {
          text: `World: ${world.name}`
        });
      }
    }
    storyItem.onclick = async () => {
      await this.showStoryDetails(story);
    };
  }
  async loadStories() {
    this.loading = true;
    this.error = null;
    try {
      if (this.plugin.settings.mode === "remote" && !this.plugin.settings.tenantId) {
        this.error = "Tenant ID not configured";
        this.loading = false;
        this.renderListContent();
        return;
      }
      this.worlds = await this.plugin.apiClient.getWorlds();
      this.stories = await this.plugin.apiClient.listStories();
      try {
        this.rpgSystems = await this.plugin.apiClient.getRPGSystems();
      } catch (rpgErr) {
        console.warn("RPG systems not available:", rpgErr);
        this.rpgSystems = [];
      }
    } catch (err) {
      this.error = err instanceof Error ? err.message : "Failed to load stories";
      console.error("Error loading stories:", err);
    } finally {
      this.loading = false;
      this.renderListContent();
    }
  }
  // Method to refresh the view
  async refresh() {
    await this.loadStories();
  }
  async showStoryDetails(story) {
    this.currentStory = story;
    this.viewMode = "details";
    this.currentTab = "chapters";
    await this.loadHierarchy();
    this.renderDetails();
  }
  async loadHierarchy() {
    if (!this.currentStory)
      return;
    this.loadingHierarchy = true;
    try {
      this.chapters = await this.plugin.apiClient.getChapters(this.currentStory.id);
      this.scenes = await this.plugin.apiClient.getScenesByStory(this.currentStory.id);
      this.beats = await this.plugin.apiClient.getBeatsByStory(this.currentStory.id);
      const contentBlocksMap = /* @__PURE__ */ new Map();
      this.contentBlockRefs = [];
      for (const chapter of this.chapters) {
        const chapterBlocks = await this.plugin.apiClient.getContentBlocks(chapter.id);
        for (const block of chapterBlocks) {
          contentBlocksMap.set(block.id, block);
        }
      }
      for (const scene of this.scenes) {
        const sceneBlocks = await this.plugin.apiClient.getContentBlocksByScene(scene.id);
        for (const block of sceneBlocks) {
          contentBlocksMap.set(block.id, block);
        }
      }
      for (const beat of this.beats) {
        const beatBlocks = await this.plugin.apiClient.getContentBlocksByBeat(beat.id);
        for (const block of beatBlocks) {
          contentBlocksMap.set(block.id, block);
        }
      }
      this.contentBlocks = Array.from(contentBlocksMap.values());
      for (const block of this.contentBlocks) {
        const refs = await this.plugin.apiClient.getContentBlockReferences(block.id);
        this.contentBlockRefs.push(...refs);
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to load hierarchy";
      new import_obsidian13.Notice(`Error: ${errorMessage}`, 5e3);
    } finally {
      this.loadingHierarchy = false;
    }
  }
  showList() {
    this.currentStory = null;
    this.viewMode = "list";
    this.renderListHeader();
    this.renderListContent();
  }
  renderDetails() {
    if (!this.contentEl || !this.currentStory)
      return;
    this.renderDetailsHeader();
    this.contentEl.empty();
    this.renderTabs();
    this.renderTabContent();
  }
  renderTabs() {
    if (!this.contentEl)
      return;
    const existingTabs = this.contentEl.querySelector(".story-engine-tabs");
    if (existingTabs) {
      existingTabs.remove();
    }
    const tabsContainer = this.contentEl.createDiv({ cls: "story-engine-tabs" });
    const chaptersTab = tabsContainer.createEl("button", {
      text: "Chapters",
      cls: `story-engine-tab ${this.currentTab === "chapters" ? "is-active" : ""}`
    });
    chaptersTab.onclick = () => {
      this.currentTab = "chapters";
      this.renderTabs();
      this.renderTabContent();
    };
    const scenesTab = tabsContainer.createEl("button", {
      text: "Scenes",
      cls: `story-engine-tab ${this.currentTab === "scenes" ? "is-active" : ""}`
    });
    scenesTab.onclick = () => {
      this.currentTab = "scenes";
      this.renderTabs();
      this.renderTabContent();
    };
    const beatsTab = tabsContainer.createEl("button", {
      text: "Beats",
      cls: `story-engine-tab ${this.currentTab === "beats" ? "is-active" : ""}`
    });
    beatsTab.onclick = () => {
      this.currentTab = "beats";
      this.renderTabs();
      this.renderTabContent();
    };
    const contentsTab = tabsContainer.createEl("button", {
      text: "Contents",
      cls: `story-engine-tab ${this.currentTab === "contents" ? "is-active" : ""}`
    });
    contentsTab.onclick = () => {
      this.currentTab = "contents";
      this.renderTabs();
      this.renderTabContent();
    };
  }
  renderTabContent() {
    if (!this.contentEl)
      return;
    const existingContent = this.contentEl.querySelector(".story-engine-tab-content");
    if (existingContent) {
      existingContent.remove();
    }
    const tabContent = this.contentEl.createDiv({ cls: "story-engine-tab-content" });
    if (this.loadingHierarchy) {
      tabContent.createEl("p", { text: "Loading..." });
      return;
    }
    switch (this.currentTab) {
      case "chapters":
        this.renderChaptersTab(tabContent);
        break;
      case "scenes":
        this.renderScenesTab(tabContent);
        break;
      case "beats":
        this.renderBeatsTab(tabContent);
        break;
      case "contents":
        this.renderContentsTab(tabContent);
        break;
    }
  }
  renderChaptersTab(container) {
    container.empty();
    const list = container.createDiv({ cls: "story-engine-list" });
    if (this.chapters.length === 0) {
      list.createEl("p", { text: "No chapters found." });
    } else {
      for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
        const item = list.createDiv({ cls: "story-engine-item" });
        item.createDiv({
          cls: "story-engine-title",
          text: `Chapter ${chapter.number}: ${chapter.title}`
        });
        const meta = item.createDiv({ cls: "story-engine-meta" });
        meta.createEl("span", { text: `Status: ${chapter.status}` });
        const actions = item.createDiv({ cls: "story-engine-item-actions" });
        actions.createEl("button", { text: "Edit" }).onclick = () => {
          new ChapterModal(this.app, async (updatedChapter) => {
            try {
              await this.plugin.apiClient.updateChapter(chapter.id, updatedChapter);
              await this.loadHierarchy();
              this.renderTabContent();
              new import_obsidian13.Notice("Chapter updated successfully");
            } catch (err) {
              throw err;
            }
          }, this.chapters, chapter).open();
        };
        if (chapter.number > 1) {
          actions.createEl("button", { text: "Up" }).onclick = () => {
            this.moveChapterUp(chapter);
          };
        }
        if (chapter.number < this.chapters.length) {
          actions.createEl("button", { text: "Down" }).onclick = () => {
            this.moveChapterDown(chapter);
          };
        }
        if (this.currentTab === "contents") {
          actions.createEl("button", { text: "+ Content" }).onclick = () => {
            this.createContentForEntity("chapter", chapter.id, chapter.id);
          };
        }
        actions.createEl("button", { text: "Delete" }).onclick = async () => {
          if (confirm("Delete this chapter?")) {
            try {
              await this.plugin.apiClient.deleteChapter(chapter.id);
              await this.loadHierarchy();
              this.renderTabContent();
              new import_obsidian13.Notice("Chapter deleted");
            } catch (err) {
              new import_obsidian13.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
            }
          }
        };
      }
    }
    const footer = container.createDiv({ cls: "story-engine-list-footer" });
    const createButton = footer.createEl("button", {
      text: "Create Chapter",
      cls: "mod-cta"
    });
    createButton.onclick = () => {
      if (!this.currentStory)
        return;
      new ChapterModal(this.app, async (chapter) => {
        try {
          await this.plugin.apiClient.createChapter(this.currentStory.id, chapter);
          await this.loadHierarchy();
          this.renderTabContent();
          new import_obsidian13.Notice("Chapter created successfully");
        } catch (err) {
          throw err;
        }
      }, this.chapters).open();
    };
  }
  renderScenesTab(container) {
    container.empty();
    const scenesByChapter = /* @__PURE__ */ new Map();
    for (const scene of this.scenes) {
      const chapterId = scene.chapter_id || null;
      if (!scenesByChapter.has(chapterId)) {
        scenesByChapter.set(chapterId, []);
      }
      scenesByChapter.get(chapterId).push(scene);
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
      const chapterScenes = scenesByChapter.get(chapter.id) || [];
      const group = list.createDiv({ cls: "story-engine-group" });
      const groupHeader = group.createDiv({ cls: "story-engine-group-header" });
      groupHeader.createEl("h3", { text: `Chapter ${chapter.number}: ${chapter.title}` });
      const groupItems = group.createDiv({ cls: "story-engine-group-items" });
      if (chapterScenes.length === 0) {
        groupItems.createEl("p", { text: "No scenes in this chapter." });
      } else {
        for (const scene of chapterScenes.sort((a, b) => a.order_num - b.order_num)) {
          this.renderSceneItem(groupItems, scene);
        }
      }
      const groupFooter = group.createDiv({ cls: "story-engine-group-footer" });
      const addButton = groupFooter.createEl("button", {
        text: "+ Add Scene",
        cls: "story-engine-add-btn"
      });
      addButton.onclick = () => {
        if (!this.currentStory)
          return;
        new SceneModal(this.app, this.currentStory.id, this.chapters, async (scene) => {
          try {
            scene.chapter_id = chapter.id;
            await this.plugin.apiClient.createScene(scene);
            await this.loadHierarchy();
            this.renderTabContent();
            new import_obsidian13.Notice("Scene created successfully");
          } catch (err) {
            throw err;
          }
        }, this.scenes, void 0, chapter.id).open();
      };
    }
    const orphanScenes = scenesByChapter.get(null) || [];
    if (orphanScenes.length > 0 || scenesByChapter.size === 0) {
      const group = list.createDiv({ cls: "story-engine-group" });
      const groupHeader = group.createDiv({ cls: "story-engine-group-header" });
      groupHeader.createEl("h3", { text: "Sem Chapter" });
      const groupItems = group.createDiv({ cls: "story-engine-group-items" });
      for (const scene of orphanScenes.sort((a, b) => a.order_num - b.order_num)) {
        this.renderSceneItem(groupItems, scene);
      }
      const groupFooter = group.createDiv({ cls: "story-engine-group-footer" });
      const addButton = groupFooter.createEl("button", {
        text: "+ Add Scene",
        cls: "story-engine-add-btn"
      });
      addButton.onclick = () => {
        if (!this.currentStory)
          return;
        new SceneModal(this.app, this.currentStory.id, this.chapters, async (scene) => {
          try {
            scene.chapter_id = null;
            await this.plugin.apiClient.createScene(scene);
            await this.loadHierarchy();
            this.renderTabContent();
            new import_obsidian13.Notice("Scene created successfully");
          } catch (err) {
            throw err;
          }
        }, this.scenes, void 0, null).open();
      };
    }
  }
  renderSceneItem(container, scene) {
    const item = container.createDiv({ cls: "story-engine-item" });
    item.createDiv({
      cls: "story-engine-title",
      text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`
    });
    const meta = item.createDiv({ cls: "story-engine-meta" });
    if (scene.time_ref) {
      meta.createEl("span", { text: `Time: ${scene.time_ref}` });
    }
    const actions = item.createDiv({ cls: "story-engine-item-actions" });
    actions.createEl("button", { text: "Edit" }).onclick = () => {
      if (!this.currentStory)
        return;
      new SceneModal(this.app, this.currentStory.id, this.chapters, async (updatedScene) => {
        try {
          await this.plugin.apiClient.updateScene(scene.id, updatedScene);
          await this.loadHierarchy();
          this.renderTabContent();
          new import_obsidian13.Notice("Scene updated successfully");
        } catch (err) {
          throw err;
        }
      }, this.scenes, scene).open();
    };
    const siblingScenes = this.scenes.filter((s) => s.chapter_id === scene.chapter_id).sort((a, b) => a.order_num - b.order_num);
    const minOrderNum = siblingScenes.length > 0 ? Math.min(...siblingScenes.map((s) => s.order_num)) : scene.order_num;
    const maxOrderNum = siblingScenes.length > 0 ? Math.max(...siblingScenes.map((s) => s.order_num)) : scene.order_num;
    if (scene.order_num > minOrderNum) {
      actions.createEl("button", { text: "Up" }).onclick = () => {
        this.moveSceneUp(scene);
      };
    }
    if (scene.order_num < maxOrderNum) {
      actions.createEl("button", { text: "Down" }).onclick = () => {
        this.moveSceneDown(scene);
      };
    }
    actions.createEl("button", { text: "Relinkar" }).onclick = async () => {
      await this.showMoveSceneModal(scene);
    };
    if (this.currentTab === "contents") {
      const chapterId = scene.chapter_id || (this.chapters.length > 0 ? this.chapters[0].id : "");
      if (chapterId) {
        actions.createEl("button", { text: "+ Content" }).onclick = () => {
          this.createContentForEntity("scene", scene.id, chapterId);
        };
      }
    }
    actions.createEl("button", { text: "Delete" }).onclick = async () => {
      if (confirm("Delete this scene?")) {
        try {
          await this.plugin.apiClient.deleteScene(scene.id);
          await this.loadHierarchy();
          this.renderTabContent();
          new import_obsidian13.Notice("Scene deleted");
        } catch (err) {
          new import_obsidian13.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
        }
      }
    };
  }
  renderBeatsTab(container) {
    container.empty();
    const beatsByScene = /* @__PURE__ */ new Map();
    for (const beat of this.beats) {
      if (!beatsByScene.has(beat.scene_id)) {
        beatsByScene.set(beat.scene_id, []);
      }
      beatsByScene.get(beat.scene_id).push(beat);
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
      const chapterScenes = this.scenes.filter((s) => s.chapter_id === chapter.id).sort((a, b) => a.order_num - b.order_num);
      if (chapterScenes.length > 0) {
        const chapterGroup = list.createDiv({ cls: "story-engine-chapter-group" });
        const chapterHeader = chapterGroup.createDiv({ cls: "story-engine-chapter-group-header" });
        chapterHeader.createEl("h2", {
          text: `Chapter ${chapter.number}: ${chapter.title}`
        });
        const chapterContent = chapterGroup.createDiv({ cls: "story-engine-chapter-group-content" });
        for (const scene of chapterScenes) {
          const sceneBeats = beatsByScene.get(scene.id) || [];
          const sceneGroup = chapterContent.createDiv({ cls: "story-engine-group" });
          const sceneHeader = sceneGroup.createDiv({ cls: "story-engine-group-header" });
          sceneHeader.createEl("h3", {
            text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`
          });
          const sceneItems = sceneGroup.createDiv({ cls: "story-engine-group-items" });
          if (sceneBeats.length === 0) {
            sceneItems.createEl("p", { text: "No beats in this scene." });
          } else {
            for (const beat of sceneBeats.sort((a, b) => a.order_num - b.order_num)) {
              this.renderBeatItem(sceneItems, beat);
            }
          }
          const sceneFooter = sceneGroup.createDiv({ cls: "story-engine-group-footer" });
          const addButton = sceneFooter.createEl("button", {
            text: "+ Add Beat",
            cls: "story-engine-add-btn"
          });
          addButton.onclick = () => {
            if (!this.currentStory)
              return;
            new BeatModal(this.app, this.currentStory.id, this.scenes, async (beat) => {
              try {
                beat.scene_id = scene.id;
                await this.plugin.apiClient.createBeat(beat);
                await this.loadHierarchy();
                this.renderTabContent();
                new import_obsidian13.Notice("Beat created successfully");
              } catch (err) {
                throw err;
              }
            }, this.beats, void 0, this.chapters, scene.id).open();
          };
        }
      }
    }
    const orphanBeats = this.beats.filter((b) => {
      const scene = this.scenes.find((s) => s.id === b.scene_id);
      return !scene || !scene.chapter_id;
    });
    if (orphanBeats.length > 0 || this.scenes.some((s) => !s.chapter_id)) {
      const orphanGroup = list.createDiv({ cls: "story-engine-chapter-group" });
      const orphanHeader = orphanGroup.createDiv({ cls: "story-engine-chapter-group-header" });
      orphanHeader.createEl("h2", { text: "Sem Chapter" });
      const orphanContent = orphanGroup.createDiv({ cls: "story-engine-chapter-group-content" });
      const orphanScenes = this.scenes.filter((s) => !s.chapter_id).sort((a, b) => a.order_num - b.order_num);
      for (const scene of orphanScenes) {
        const sceneBeats = beatsByScene.get(scene.id) || [];
        const sceneGroup = orphanContent.createDiv({ cls: "story-engine-group" });
        const sceneHeader = sceneGroup.createDiv({ cls: "story-engine-group-header" });
        sceneHeader.createEl("h3", {
          text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`
        });
        const sceneItems = sceneGroup.createDiv({ cls: "story-engine-group-items" });
        if (sceneBeats.length === 0) {
          sceneItems.createEl("p", { text: "No beats in this scene." });
        } else {
          for (const beat of sceneBeats.sort((a, b) => a.order_num - b.order_num)) {
            this.renderBeatItem(sceneItems, beat);
          }
        }
        const sceneFooter = sceneGroup.createDiv({ cls: "story-engine-group-footer" });
        const addButton = sceneFooter.createEl("button", {
          text: "+ Add Beat",
          cls: "story-engine-add-btn"
        });
        addButton.onclick = () => {
          if (!this.currentStory)
            return;
          new BeatModal(this.app, this.currentStory.id, this.scenes, async (beat) => {
            try {
              beat.scene_id = scene.id;
              await this.plugin.apiClient.createBeat(beat);
              await this.loadHierarchy();
              this.renderTabContent();
              new import_obsidian13.Notice("Beat created successfully");
            } catch (err) {
              throw err;
            }
          }, this.beats, void 0, this.chapters, scene.id).open();
        };
      }
      const beatsWithoutScene = orphanBeats.filter((b) => {
        const scene = this.scenes.find((s) => s.id === b.scene_id);
        return !scene;
      });
      if (beatsWithoutScene.length > 0) {
        const sceneGroup = orphanContent.createDiv({ cls: "story-engine-group" });
        const sceneHeader = sceneGroup.createDiv({ cls: "story-engine-group-header" });
        sceneHeader.createEl("h3", { text: "Sem Scene" });
        const sceneItems = sceneGroup.createDiv({ cls: "story-engine-group-items" });
        for (const beat of beatsWithoutScene.sort((a, b) => a.order_num - b.order_num)) {
          this.renderBeatItem(sceneItems, beat);
        }
      }
    }
  }
  renderBeatItem(container, beat) {
    const item = container.createDiv({ cls: "story-engine-item" });
    item.createDiv({
      cls: "story-engine-title",
      text: `Beat ${beat.order_num}: ${beat.type}`
    });
    const meta = item.createDiv({ cls: "story-engine-meta" });
    if (beat.intent) {
      meta.createEl("span", { text: `Intent: ${beat.intent}` });
    }
    if (beat.outcome) {
      meta.createEl("span", { text: `Outcome: ${beat.outcome}` });
    }
    const actions = item.createDiv({ cls: "story-engine-item-actions" });
    actions.createEl("button", { text: "Edit" }).onclick = () => {
      if (!this.currentStory)
        return;
      new BeatModal(this.app, this.currentStory.id, this.scenes, async (updatedBeat) => {
        try {
          await this.plugin.apiClient.updateBeat(beat.id, updatedBeat);
          await this.loadHierarchy();
          this.renderTabContent();
          new import_obsidian13.Notice("Beat updated successfully");
        } catch (err) {
          throw err;
        }
      }, this.beats, beat, this.chapters).open();
    };
    const siblingBeats = this.beats.filter((b) => b.scene_id === beat.scene_id).sort((a, b) => a.order_num - b.order_num);
    const minOrderNum = siblingBeats.length > 0 ? Math.min(...siblingBeats.map((b) => b.order_num)) : beat.order_num;
    const maxOrderNum = siblingBeats.length > 0 ? Math.max(...siblingBeats.map((b) => b.order_num)) : beat.order_num;
    if (beat.order_num > minOrderNum) {
      actions.createEl("button", { text: "Up" }).onclick = () => {
        this.moveBeatUp(beat);
      };
    }
    if (beat.order_num < maxOrderNum) {
      actions.createEl("button", { text: "Down" }).onclick = () => {
        this.moveBeatDown(beat);
      };
    }
    actions.createEl("button", { text: "Relinkar" }).onclick = async () => {
      await this.showMoveBeatModal(beat);
    };
    if (this.currentTab === "contents") {
      const scene = this.scenes.find((s) => s.id === beat.scene_id);
      const chapterId = (scene == null ? void 0 : scene.chapter_id) || (this.chapters.length > 0 ? this.chapters[0].id : "");
      if (chapterId) {
        actions.createEl("button", { text: "+ Content" }).onclick = () => {
          this.createContentForEntity("beat", beat.id, chapterId);
        };
      }
    }
    actions.createEl("button", { text: "Delete" }).onclick = async () => {
      if (confirm("Delete this beat?")) {
        try {
          await this.plugin.apiClient.deleteBeat(beat.id);
          await this.loadHierarchy();
          this.renderTabContent();
          new import_obsidian13.Notice("Beat deleted");
        } catch (err) {
          new import_obsidian13.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
        }
      }
    };
  }
  showEditStoryNameModal() {
    if (!this.currentStory)
      return;
    const modal = new import_obsidian13.Modal(this.app);
    modal.titleEl.setText("Edit Story Name");
    const content = modal.contentEl;
    let title = this.currentStory.title;
    content.createEl("label", { text: "Story Name *" });
    const titleInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: title });
    titleInput.oninput = () => {
      title = titleInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      if (!title.trim()) {
        new import_obsidian13.Notice("Story name is required", 3e3);
        return;
      }
      try {
        const updatedStory = await this.plugin.apiClient.updateStory(this.currentStory.id, title.trim());
        this.currentStory = updatedStory;
        await this.loadStories();
        this.renderDetailsHeader();
        modal.close();
        new import_obsidian13.Notice("Story name updated");
      } catch (err) {
        new import_obsidian13.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
    titleInput.focus();
    titleInput.select();
  }
  async cloneStory() {
    var _a;
    if (!this.currentStory)
      return;
    const cloneButton = (_a = this.headerEl) == null ? void 0 : _a.querySelector(".story-engine-clone-btn");
    if (cloneButton) {
      cloneButton.disabled = true;
      cloneButton.setText("Cloning...");
    }
    try {
      if (!this.plugin.settings.tenantId) {
        throw new Error("Tenant ID not configured");
      }
      const clonedStory = await this.plugin.apiClient.cloneStory(
        this.currentStory.id
      );
      new import_obsidian13.Notice(`Story "${clonedStory.title}" cloned successfully!`);
      await this.loadStories();
      await this.showStoryDetails(clonedStory);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Clone failed";
      new import_obsidian13.Notice(`Error: ${errorMessage}`, 5e3);
      if (cloneButton) {
        cloneButton.setText("Clone Story");
        cloneButton.disabled = false;
      }
    }
  }
  showEditWorldModal() {
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian13.Modal(this.app);
    modal.titleEl.setText("Edit World");
    const content = modal.contentEl;
    let name = this.currentWorld.name;
    let description = this.currentWorld.description;
    let genre = this.currentWorld.genre;
    content.createEl("label", { text: "World Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: name });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Genre *" });
    const genreInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: genre });
    genreInput.oninput = () => {
      genre = genreInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.value = description;
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian13.Notice("World name is required", 3e3);
        return;
      }
      if (!genre.trim()) {
        new import_obsidian13.Notice("Genre is required", 3e3);
        return;
      }
      try {
        const updatedWorld = await this.plugin.apiClient.updateWorld(
          this.currentWorld.id,
          name.trim(),
          description.trim(),
          genre.trim()
        );
        this.currentWorld = updatedWorld;
        await this.loadStories();
        this.renderWorldDetails();
        modal.close();
        new import_obsidian13.Notice("World updated");
      } catch (err) {
        new import_obsidian13.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
    nameInput.focus();
    nameInput.select();
  }
  copyStoryId() {
    if (!this.currentStory)
      return;
    navigator.clipboard.writeText(this.currentStory.id).then(() => {
      new import_obsidian13.Notice("UUID copied to clipboard");
    }).catch(() => {
      const textarea = document.createElement("textarea");
      textarea.value = this.currentStory.id;
      textarea.style.position = "fixed";
      textarea.style.opacity = "0";
      textarea.style.left = "-9999px";
      document.body.appendChild(textarea);
      textarea.select();
      try {
        document.execCommand("copy");
        new import_obsidian13.Notice("UUID copied to clipboard");
      } catch (err) {
        new import_obsidian13.Notice("Failed to copy UUID", 3e3);
      }
      document.body.removeChild(textarea);
    });
  }
  async moveChapterUp(chapter) {
    const sortedChapters = [...this.chapters].sort((a, b) => a.number - b.number);
    const currentIndex = sortedChapters.findIndex((c) => c.id === chapter.id);
    if (currentIndex <= 0)
      return;
    const previousChapter = sortedChapters[currentIndex - 1];
    const tempNumber = chapter.number;
    try {
      await this.plugin.apiClient.updateChapter(chapter.id, { number: previousChapter.number });
      await this.plugin.apiClient.updateChapter(previousChapter.id, { number: tempNumber });
      await this.loadHierarchy();
      this.renderTabContent();
      new import_obsidian13.Notice("Chapter moved up");
    } catch (err) {
      new import_obsidian13.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
    }
  }
  async moveChapterDown(chapter) {
    const sortedChapters = [...this.chapters].sort((a, b) => a.number - b.number);
    const currentIndex = sortedChapters.findIndex((c) => c.id === chapter.id);
    if (currentIndex < 0 || currentIndex >= sortedChapters.length - 1)
      return;
    const nextChapter = sortedChapters[currentIndex + 1];
    const tempNumber = chapter.number;
    try {
      await this.plugin.apiClient.updateChapter(chapter.id, { number: nextChapter.number });
      await this.plugin.apiClient.updateChapter(nextChapter.id, { number: tempNumber });
      await this.loadHierarchy();
      this.renderTabContent();
      new import_obsidian13.Notice("Chapter moved down");
    } catch (err) {
      new import_obsidian13.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
    }
  }
  async moveSceneUp(scene) {
    const siblingScenes = this.scenes.filter((s) => s.chapter_id === scene.chapter_id).sort((a, b) => a.order_num - b.order_num);
    const currentIndex = siblingScenes.findIndex((s) => s.id === scene.id);
    if (currentIndex <= 0)
      return;
    const previousScene = siblingScenes[currentIndex - 1];
    const tempOrderNum = scene.order_num;
    try {
      await this.plugin.apiClient.updateScene(scene.id, { order_num: previousScene.order_num });
      await this.plugin.apiClient.updateScene(previousScene.id, { order_num: tempOrderNum });
      await this.loadHierarchy();
      this.renderTabContent();
      new import_obsidian13.Notice("Scene moved up");
    } catch (err) {
      new import_obsidian13.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
    }
  }
  async moveSceneDown(scene) {
    const siblingScenes = this.scenes.filter((s) => s.chapter_id === scene.chapter_id).sort((a, b) => a.order_num - b.order_num);
    const currentIndex = siblingScenes.findIndex((s) => s.id === scene.id);
    if (currentIndex < 0 || currentIndex >= siblingScenes.length - 1)
      return;
    const nextScene = siblingScenes[currentIndex + 1];
    const tempOrderNum = scene.order_num;
    try {
      await this.plugin.apiClient.updateScene(scene.id, { order_num: nextScene.order_num });
      await this.plugin.apiClient.updateScene(nextScene.id, { order_num: tempOrderNum });
      await this.loadHierarchy();
      this.renderTabContent();
      new import_obsidian13.Notice("Scene moved down");
    } catch (err) {
      new import_obsidian13.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
    }
  }
  async moveBeatUp(beat) {
    const siblingBeats = this.beats.filter((b) => b.scene_id === beat.scene_id).sort((a, b) => a.order_num - b.order_num);
    const currentIndex = siblingBeats.findIndex((b) => b.id === beat.id);
    if (currentIndex <= 0)
      return;
    const previousBeat = siblingBeats[currentIndex - 1];
    const tempOrderNum = beat.order_num;
    try {
      await this.plugin.apiClient.updateBeat(beat.id, { order_num: previousBeat.order_num });
      await this.plugin.apiClient.updateBeat(previousBeat.id, { order_num: tempOrderNum });
      await this.loadHierarchy();
      this.renderTabContent();
      new import_obsidian13.Notice("Beat moved up");
    } catch (err) {
      new import_obsidian13.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
    }
  }
  async moveBeatDown(beat) {
    const siblingBeats = this.beats.filter((b) => b.scene_id === beat.scene_id).sort((a, b) => a.order_num - b.order_num);
    const currentIndex = siblingBeats.findIndex((b) => b.id === beat.id);
    if (currentIndex < 0 || currentIndex >= siblingBeats.length - 1)
      return;
    const nextBeat = siblingBeats[currentIndex + 1];
    const tempOrderNum = beat.order_num;
    try {
      await this.plugin.apiClient.updateBeat(beat.id, { order_num: nextBeat.order_num });
      await this.plugin.apiClient.updateBeat(nextBeat.id, { order_num: tempOrderNum });
      await this.loadHierarchy();
      this.renderTabContent();
      new import_obsidian13.Notice("Beat moved down");
    } catch (err) {
      new import_obsidian13.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
    }
  }
  async showMoveSceneModal(scene) {
    if (!this.currentStory)
      return;
    const modal = new import_obsidian13.Modal(this.app);
    modal.titleEl.setText("Move Scene");
    const content = modal.contentEl;
    content.createEl("p", { text: `Move scene "${scene.goal || `Scene ${scene.order_num}`}" to:` });
    const select = content.createEl("select", { cls: "story-engine-move-select" });
    const noChapterOption = select.createEl("option", { text: "No Chapter", value: "" });
    for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
      const option = select.createEl("option", {
        text: `Chapter ${chapter.number}: ${chapter.title}`,
        value: chapter.id
      });
      if (scene.chapter_id === chapter.id) {
        option.selected = true;
      }
    }
    if (!scene.chapter_id) {
      noChapterOption.selected = true;
    }
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const moveButton = buttonContainer.createEl("button", {
      text: "Move",
      cls: "mod-cta"
    });
    moveButton.onclick = async () => {
      const selectedChapterId = select.value || null;
      try {
        await this.plugin.apiClient.moveScene(scene.id, selectedChapterId);
        await this.loadHierarchy();
        this.renderTabContent();
        modal.close();
        new import_obsidian13.Notice("Scene moved successfully");
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to move scene";
        new import_obsidian13.Notice(`Error: ${errorMessage}`, 5e3);
      }
    };
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.onclick = () => modal.close();
    modal.open();
  }
  async showMoveBeatModal(beat) {
    if (!this.currentStory)
      return;
    const modal = new import_obsidian13.Modal(this.app);
    modal.titleEl.setText("Move Beat");
    const content = modal.contentEl;
    content.createEl("p", { text: `Move beat "${beat.type}" to:` });
    const select = content.createEl("select", { cls: "story-engine-move-select" });
    for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
      const chapterScenes = this.scenes.filter((s) => s.chapter_id === chapter.id).sort((a, b) => a.order_num - b.order_num);
      if (chapterScenes.length > 0) {
        const optgroup = select.createEl("optgroup");
        optgroup.label = `Chapter ${chapter.number}: ${chapter.title}`;
        for (const scene of chapterScenes) {
          const option = optgroup.createEl("option", {
            text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`,
            value: scene.id
          });
          if (beat.scene_id === scene.id) {
            option.selected = true;
          }
        }
      }
    }
    const orphanScenes = this.scenes.filter((s) => !s.chapter_id);
    if (orphanScenes.length > 0) {
      const optgroup = select.createEl("optgroup");
      optgroup.label = "No Chapter";
      for (const scene of orphanScenes.sort((a, b) => a.order_num - b.order_num)) {
        const option = optgroup.createEl("option", {
          text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`,
          value: scene.id
        });
        if (beat.scene_id === scene.id) {
          option.selected = true;
        }
      }
    }
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const moveButton = buttonContainer.createEl("button", {
      text: "Move",
      cls: "mod-cta"
    });
    moveButton.onclick = async () => {
      const selectedSceneId = select.value;
      if (!selectedSceneId) {
        new import_obsidian13.Notice("Please select a scene", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.moveBeat(beat.id, selectedSceneId);
        await this.loadHierarchy();
        this.renderTabContent();
        modal.close();
        new import_obsidian13.Notice("Beat moved successfully");
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to move beat";
        new import_obsidian13.Notice(`Error: ${errorMessage}`, 5e3);
      }
    };
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.onclick = () => modal.close();
    modal.open();
  }
  renderContentsTab(container) {
    container.empty();
    const contentsByChapter = /* @__PURE__ */ new Map();
    const contentsByScene = /* @__PURE__ */ new Map();
    const contentsByBeat = /* @__PURE__ */ new Map();
    const orphanContents = [];
    for (const block of this.contentBlocks) {
      const refs = this.contentBlockRefs.filter((r) => r.content_block_id === block.id);
      if (refs.length === 0) {
        orphanContents.push(block);
        continue;
      }
      for (const ref of refs) {
        if (ref.entity_type === "chapter") {
          if (!contentsByChapter.has(ref.entity_id)) {
            contentsByChapter.set(ref.entity_id, []);
          }
          contentsByChapter.get(ref.entity_id).push(block);
        } else if (ref.entity_type === "scene") {
          if (!contentsByScene.has(ref.entity_id)) {
            contentsByScene.set(ref.entity_id, []);
          }
          contentsByScene.get(ref.entity_id).push(block);
        } else if (ref.entity_type === "beat") {
          if (!contentsByBeat.has(ref.entity_id)) {
            contentsByBeat.set(ref.entity_id, []);
          }
          contentsByBeat.get(ref.entity_id).push(block);
        }
      }
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
      const chapterContents = contentsByChapter.get(chapter.id) || [];
      const chapterScenes = this.scenes.filter((s) => s.chapter_id === chapter.id).sort((a, b) => a.order_num - b.order_num);
      if (chapterContents.length > 0 || chapterScenes.length > 0 || chapterScenes.some((s) => {
        const sceneContents = contentsByScene.get(s.id) || [];
        const sceneBeats = this.beats.filter((b) => b.scene_id === s.id);
        const beatContents = sceneBeats.flatMap((b) => contentsByBeat.get(b.id) || []);
        return sceneContents.length > 0 || beatContents.length > 0;
      })) {
        const chapterGroup = list.createDiv({ cls: "story-engine-chapter-group" });
        const chapterHeader = chapterGroup.createDiv({ cls: "story-engine-chapter-group-header story-engine-hoverable-header" });
        chapterHeader.createEl("h2", {
          text: `Chapter ${chapter.number}: ${chapter.title}`
        });
        const chapterHeaderActions = chapterHeader.createDiv({ cls: "story-engine-hover-header-actions" });
        const textBtn = chapterHeaderActions.createEl("button", {
          cls: "story-engine-add-content-btn story-engine-add-text-btn",
          attr: { "aria-label": "Add text content" }
        });
        textBtn.innerHTML = '<span class="story-engine-icon">\u{1F4DD}</span>';
        textBtn.onclick = () => {
          this.createContentForEntity("chapter", chapter.id, chapter.id, "text");
        };
        const imageBtn = chapterHeaderActions.createEl("button", {
          cls: "story-engine-add-content-btn story-engine-add-image-btn",
          attr: { "aria-label": "Add image content" }
        });
        imageBtn.innerHTML = '<span class="story-engine-icon">\u{1F5BC}\uFE0F</span>';
        imageBtn.onclick = () => {
          this.createContentForEntity("chapter", chapter.id, chapter.id, "image");
        };
        const chapterContent = chapterGroup.createDiv({ cls: "story-engine-chapter-group-content" });
        const chapterContentsGroup = chapterContent.createDiv({ cls: "story-engine-group" });
        const chapterContentsHeader = chapterContentsGroup.createDiv({ cls: "story-engine-group-header" });
        chapterContentsHeader.createEl("h3", { text: "Chapter Contents" });
        const chapterContentsItems = chapterContentsGroup.createDiv({ cls: "story-engine-group-items" });
        if (chapterContents.length > 0) {
          for (const block of chapterContents) {
            this.renderContentItem(chapterContentsItems, block, "chapter", chapter.id);
          }
        } else {
          chapterContentsItems.createEl("p", { text: "No content in this chapter.", cls: "story-engine-empty-content" });
        }
        for (const scene of chapterScenes) {
          const sceneContents = contentsByScene.get(scene.id) || [];
          const sceneBeats = this.beats.filter((b) => b.scene_id === scene.id).sort((a, b) => a.order_num - b.order_num);
          const beatContents = sceneBeats.flatMap((b) => contentsByBeat.get(b.id) || []);
          const sceneGroup = chapterContent.createDiv({ cls: "story-engine-group" });
          const sceneHeader = sceneGroup.createDiv({ cls: "story-engine-group-header story-engine-hoverable-header" });
          sceneHeader.createEl("h3", {
            text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`
          });
          const sceneHeaderActions = sceneHeader.createDiv({ cls: "story-engine-hover-header-actions" });
          const chapterId = scene.chapter_id || (this.chapters.length > 0 ? this.chapters[0].id : "");
          if (chapterId) {
            const textBtn2 = sceneHeaderActions.createEl("button", {
              cls: "story-engine-add-content-btn story-engine-add-text-btn",
              attr: { "aria-label": "Add text content" }
            });
            textBtn2.innerHTML = '<span class="story-engine-icon">\u{1F4DD}</span>';
            textBtn2.onclick = () => {
              this.createContentForEntity("scene", scene.id, chapterId, "text");
            };
            const imageBtn2 = sceneHeaderActions.createEl("button", {
              cls: "story-engine-add-content-btn story-engine-add-image-btn",
              attr: { "aria-label": "Add image content" }
            });
            imageBtn2.innerHTML = '<span class="story-engine-icon">\u{1F5BC}\uFE0F</span>';
            imageBtn2.onclick = () => {
              this.createContentForEntity("scene", scene.id, chapterId, "image");
            };
          }
          const sceneItems = sceneGroup.createDiv({ cls: "story-engine-group-items" });
          if (sceneContents.length > 0) {
            for (const block of sceneContents) {
              this.renderContentItem(sceneItems, block, "scene", scene.id);
            }
          } else {
            sceneItems.createEl("p", { text: "No content in this scene.", cls: "story-engine-empty-content" });
          }
          for (const beat of sceneBeats) {
            const beatContents2 = contentsByBeat.get(beat.id) || [];
            const beatSubGroup = sceneItems.createDiv({ cls: "story-engine-beat-subgroup" });
            const beatSubGroupTitle = beatSubGroup.createDiv({ cls: "story-engine-beat-subgroup-title-container story-engine-hoverable-header" });
            beatSubGroupTitle.createEl("h4", {
              text: `Beat ${beat.order_num}: ${beat.type}`,
              cls: "story-engine-beat-subgroup-title"
            });
            const beatHeaderActions = beatSubGroupTitle.createDiv({ cls: "story-engine-hover-header-actions" });
            const beatChapterId = scene.chapter_id || (this.chapters.length > 0 ? this.chapters[0].id : "");
            if (beatChapterId) {
              const textBtn2 = beatHeaderActions.createEl("button", {
                cls: "story-engine-add-content-btn story-engine-add-text-btn",
                attr: { "aria-label": "Add text content" }
              });
              textBtn2.innerHTML = '<span class="story-engine-icon">\u{1F4DD}</span>';
              textBtn2.onclick = () => {
                this.createContentForEntity("beat", beat.id, beatChapterId, "text");
              };
              const imageBtn2 = beatHeaderActions.createEl("button", {
                cls: "story-engine-add-content-btn story-engine-add-image-btn",
                attr: { "aria-label": "Add image content" }
              });
              imageBtn2.innerHTML = '<span class="story-engine-icon">\u{1F5BC}\uFE0F</span>';
              imageBtn2.onclick = () => {
                this.createContentForEntity("beat", beat.id, beatChapterId, "image");
              };
            }
            if (beatContents2.length > 0) {
              for (const block of beatContents2) {
                this.renderContentItem(beatSubGroup, block, "beat", beat.id);
              }
            } else {
              beatSubGroup.createEl("p", { text: "No content in this beat.", cls: "story-engine-empty-beat-content" });
            }
          }
        }
      }
    }
    if (orphanContents.length > 0 || this.scenes.some((s) => !s.chapter_id)) {
      const orphanGroup = list.createDiv({ cls: "story-engine-chapter-group" });
      const orphanHeader = orphanGroup.createDiv({ cls: "story-engine-chapter-group-header" });
      orphanHeader.createEl("h2", { text: "Sem Chapter" });
      const orphanContent = orphanGroup.createDiv({ cls: "story-engine-chapter-group-content" });
      const orphanScenes = this.scenes.filter((s) => !s.chapter_id).sort((a, b) => a.order_num - b.order_num);
      for (const scene of orphanScenes) {
        const sceneContents = contentsByScene.get(scene.id) || [];
        const sceneBeats = this.beats.filter((b) => b.scene_id === scene.id).sort((a, b) => a.order_num - b.order_num);
        const beatContents = sceneBeats.flatMap((b) => contentsByBeat.get(b.id) || []);
        const sceneGroup = orphanContent.createDiv({ cls: "story-engine-group" });
        const sceneHeader = sceneGroup.createDiv({ cls: "story-engine-group-header story-engine-hoverable-header" });
        sceneHeader.createEl("h3", {
          text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`
        });
        const sceneHeaderActions = sceneHeader.createDiv({ cls: "story-engine-header-actions" });
        const chapterId = this.chapters.length > 0 ? this.chapters[0].id : "";
        if (chapterId) {
          sceneHeaderActions.createEl("button", {
            text: "+ Content",
            cls: "story-engine-add-content-btn"
          }).onclick = () => {
            this.createContentForEntity("scene", scene.id, chapterId);
          };
        }
        const sceneItems = sceneGroup.createDiv({ cls: "story-engine-group-items" });
        if (sceneContents.length > 0) {
          for (const block of sceneContents) {
            this.renderContentItem(sceneItems, block, "scene", scene.id);
          }
        } else {
          sceneItems.createEl("p", { text: "No content in this scene." });
        }
        for (const beat of sceneBeats) {
          const beatContents2 = contentsByBeat.get(beat.id) || [];
          const beatSubGroup = sceneItems.createDiv({ cls: "story-engine-beat-subgroup" });
          const beatSubGroupTitle = beatSubGroup.createDiv({ cls: "story-engine-beat-subgroup-title-container story-engine-hoverable-header" });
          beatSubGroupTitle.createEl("h4", {
            text: `Beat ${beat.order_num}: ${beat.type}`,
            cls: "story-engine-beat-subgroup-title"
          });
          const beatHeaderActions = beatSubGroupTitle.createDiv({ cls: "story-engine-hover-header-actions" });
          const beatChapterId = this.chapters.length > 0 ? this.chapters[0].id : "";
          if (beatChapterId) {
            beatHeaderActions.createEl("button", {
              text: "+ Content",
              cls: "story-engine-add-content-btn"
            }).onclick = () => {
              this.createContentForEntity("beat", beat.id, beatChapterId);
            };
          }
          if (beatContents2.length > 0) {
            for (const block of beatContents2) {
              this.renderContentItem(beatSubGroup, block, "beat", beat.id);
            }
          } else {
            beatSubGroup.createEl("p", { text: "No content in this beat.", cls: "story-engine-empty-beat-content" });
          }
        }
      }
      if (orphanContents.length > 0) {
        const orphanContentsGroup = orphanContent.createDiv({ cls: "story-engine-group" });
        const orphanContentsHeader = orphanContentsGroup.createDiv({ cls: "story-engine-group-header" });
        orphanContentsHeader.createEl("h3", { text: "Sem Refer\xEAncia" });
        const orphanContentsItems = orphanContentsGroup.createDiv({ cls: "story-engine-group-items" });
        for (const block of orphanContents) {
          this.renderContentItem(orphanContentsItems, block, null, null);
        }
      }
    }
  }
  renderContentItem(container, contentBlock, entityType, entityId) {
    var _a, _b;
    const item = container.createDiv({ cls: "story-engine-item story-engine-content-item" });
    const itemContent = item.createDiv({ cls: "story-engine-content-item-content" });
    const iconContainer = itemContent.createDiv({ cls: "story-engine-content-icon" });
    const iconMap = {
      text: "file-text",
      image: "image",
      video: "video",
      audio: "music",
      embed: "code",
      link: "external-link"
    };
    const iconName = iconMap[contentBlock.type] || "file";
    (0, import_obsidian13.setIcon)(iconContainer, iconName);
    const preview = itemContent.createDiv({ cls: "story-engine-content-preview" });
    if (contentBlock.type === "text") {
      const textPreview = contentBlock.content || "";
      const truncated = textPreview.length > 100 ? textPreview.substring(0, 100) + "..." : textPreview;
      preview.createEl("span", { text: truncated });
    } else if (contentBlock.type === "image") {
      const imgContainer = preview.createDiv({ cls: "story-engine-image-container" });
      const img = imgContainer.createEl("img", {
        attr: { src: contentBlock.content || "", alt: ((_a = contentBlock.metadata) == null ? void 0 : _a.alt_text) || "" },
        cls: "story-engine-content-thumbnail"
      });
      img.style.maxWidth = "100px";
      img.style.maxHeight = "60px";
      img.style.objectFit = "cover";
      img.style.borderRadius = "4px";
      if ((_b = contentBlock.metadata) == null ? void 0 : _b.attribution) {
        const attribution = imgContainer.createDiv({ cls: "story-engine-unsplash-attribution" });
        attribution.createEl("span", {
          text: contentBlock.metadata.attribution,
          cls: "story-engine-attribution-text"
        });
      }
    } else {
      preview.createEl("span", { text: contentBlock.content || "" });
    }
    const actions = item.createDiv({ cls: "story-engine-item-actions" });
    actions.createEl("button", { text: "Edit" }).onclick = () => {
      new ContentBlockModal(this.app, async (updatedContentBlock) => {
        try {
          await this.plugin.apiClient.updateContentBlock(contentBlock.id, updatedContentBlock);
          await this.loadHierarchy();
          this.renderTabContent();
          new import_obsidian13.Notice("Content block updated successfully");
        } catch (err) {
          throw err;
        }
      }, contentBlock, this.plugin).open();
    };
    actions.createEl("button", { text: "Move" }).onclick = async () => {
      await this.showMoveContentModal(contentBlock, entityType, entityId, "move");
    };
    actions.createEl("button", { text: "Link" }).onclick = async () => {
      await this.showMoveContentModal(contentBlock, entityType, entityId, "link");
    };
    actions.createEl("button", { text: "Delete" }).onclick = async () => {
      if (confirm("Delete this content block?")) {
        try {
          await this.plugin.apiClient.deleteContentBlock(contentBlock.id);
          await this.loadHierarchy();
          this.renderTabContent();
          new import_obsidian13.Notice("Content block deleted");
        } catch (err) {
          new import_obsidian13.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
        }
      }
    };
  }
  async showMoveContentModal(contentBlock, currentEntityType, currentEntityId, mode) {
    if (!this.currentStory)
      return;
    const modal = new import_obsidian13.Modal(this.app);
    modal.titleEl.setText(mode === "move" ? "Move Content Block" : "Link Content Block");
    const content = modal.contentEl;
    content.createEl("p", {
      text: mode === "move" ? `Move content block to:` : `Link content block to (will appear in both places):`
    });
    const select = content.createEl("select", { cls: "story-engine-move-select" });
    const noRefOption = select.createEl("option", { text: "No Reference", value: "" });
    for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
      const option = select.createEl("option", {
        text: `Chapter ${chapter.number}: ${chapter.title}`,
        value: `chapter:${chapter.id}`
      });
      if (currentEntityType === "chapter" && currentEntityId === chapter.id) {
        option.selected = true;
      }
    }
    for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
      const chapterScenes = this.scenes.filter((s) => s.chapter_id === chapter.id).sort((a, b) => a.order_num - b.order_num);
      if (chapterScenes.length > 0) {
        const optgroup = select.createEl("optgroup");
        optgroup.label = `Chapter ${chapter.number}: ${chapter.title} - Scenes`;
        for (const scene of chapterScenes) {
          const option = optgroup.createEl("option", {
            text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`,
            value: `scene:${scene.id}`
          });
          if (currentEntityType === "scene" && currentEntityId === scene.id) {
            option.selected = true;
          }
        }
      }
    }
    const orphanScenes = this.scenes.filter((s) => !s.chapter_id);
    if (orphanScenes.length > 0) {
      const optgroup = select.createEl("optgroup");
      optgroup.label = "No Chapter - Scenes";
      for (const scene of orphanScenes.sort((a, b) => a.order_num - b.order_num)) {
        const option = optgroup.createEl("option", {
          text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`,
          value: `scene:${scene.id}`
        });
        if (currentEntityType === "scene" && currentEntityId === scene.id) {
          option.selected = true;
        }
      }
    }
    for (const scene of this.scenes.sort((a, b) => a.order_num - b.order_num)) {
      const sceneBeats = this.beats.filter((b) => b.scene_id === scene.id).sort((a, b) => a.order_num - b.order_num);
      if (sceneBeats.length > 0) {
        const chapter = this.chapters.find((c) => c.id === scene.chapter_id);
        const chapterLabel = chapter ? `Chapter ${chapter.number}` : "No Chapter";
        const optgroup = select.createEl("optgroup");
        optgroup.label = `${chapterLabel} > Scene ${scene.order_num} - Beats`;
        for (const beat of sceneBeats) {
          const option = optgroup.createEl("option", {
            text: `Beat ${beat.order_num}: ${beat.type}`,
            value: `beat:${beat.id}`
          });
          if (currentEntityType === "beat" && currentEntityId === beat.id) {
            option.selected = true;
          }
        }
      }
    }
    if (!currentEntityType) {
      noRefOption.selected = true;
    }
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const actionButton = buttonContainer.createEl("button", {
      text: mode === "move" ? "Move" : "Link",
      cls: "mod-cta"
    });
    actionButton.onclick = async () => {
      const selectedValue = select.value;
      try {
        if (mode === "move" && currentEntityType && currentEntityId) {
          const currentRef = this.contentBlockRefs.find(
            (r) => r.content_block_id === contentBlock.id && r.entity_type === currentEntityType && r.entity_id === currentEntityId
          );
          if (currentRef) {
            await this.plugin.apiClient.deleteContentBlockReference(currentRef.id);
          }
        }
        if (selectedValue) {
          const [entityType, entityId] = selectedValue.split(":");
          await this.plugin.apiClient.createContentBlockReference(contentBlock.id, entityType, entityId);
        }
        await this.loadHierarchy();
        this.renderTabContent();
        modal.close();
        new import_obsidian13.Notice(mode === "move" ? "Content block moved successfully" : "Content block linked successfully");
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : `Failed to ${mode} content block`;
        new import_obsidian13.Notice(`Error: ${errorMessage}`, 5e3);
      }
    };
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.onclick = () => modal.close();
    modal.open();
  }
  async createContentForEntity(entityType, entityId, chapterId, contentType = "text") {
    if (!this.currentStory)
      return;
    if (!chapterId) {
      if (this.chapters.length === 0) {
        new import_obsidian13.Notice("No chapter available. Please create a chapter first.", 5e3);
        return;
      }
      chapterId = this.chapters[0].id;
    }
    const chapterBlocks = this.contentBlocks.filter((cb) => {
      const refs = this.contentBlockRefs.filter((r) => r.content_block_id === cb.id && r.entity_type === "chapter" && r.entity_id === chapterId);
      return refs.length > 0 || cb.chapter_id === chapterId;
    });
    const maxOrderNum = chapterBlocks.length > 0 ? Math.max(...chapterBlocks.map((cb) => cb.order_num || 0)) : 0;
    const nextOrderNum = maxOrderNum + 1;
    const initialContentBlock = {
      type: contentType,
      kind: "final",
      content: "",
      metadata: {}
    };
    new ContentBlockModal(this.app, async (contentBlock) => {
      try {
        contentBlock.order_num = nextOrderNum;
        const created = await this.plugin.apiClient.createContentBlock(chapterId, contentBlock);
        await this.plugin.apiClient.createContentBlockReference(created.id, entityType, entityId);
        await this.loadHierarchy();
        this.renderTabContent();
        new import_obsidian13.Notice("Content block created successfully");
      } catch (err) {
        throw err;
      }
    }, initialContentBlock, this.plugin).open();
  }
  // ==================== World View Methods ====================
  async showWorldDetails(world) {
    this.currentWorld = world;
    this.viewMode = "world-details";
    this.worldTab = "characters";
    await this.loadWorldData();
    this.renderWorldDetails();
  }
  async loadWorldData() {
    if (!this.currentWorld)
      return;
    this.loadingWorldData = true;
    try {
      this.characters = await this.plugin.apiClient.getCharacters(this.currentWorld.id);
      this.locations = await this.plugin.apiClient.getLocations(this.currentWorld.id);
      this.artifacts = await this.plugin.apiClient.getArtifacts(this.currentWorld.id);
      this.events = await this.plugin.apiClient.getEvents(this.currentWorld.id);
      try {
        this.traits = await this.plugin.apiClient.getTraits();
      } catch (err) {
        console.warn("Traits not available:", err);
        this.traits = [];
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to load world data";
      new import_obsidian13.Notice(`Error: ${errorMessage}`, 5e3);
    } finally {
      this.loadingWorldData = false;
    }
  }
  renderWorldDetails() {
    if (!this.contentEl || !this.currentWorld)
      return;
    this.renderWorldDetailsHeader();
    this.contentEl.empty();
    this.renderWorldTabs();
    this.renderWorldTabContent();
  }
  renderWorldDetailsHeader() {
    if (!this.headerEl || !this.currentWorld)
      return;
    this.headerEl.empty();
    const headerLeft = this.headerEl.createDiv({ cls: "story-engine-header-left" });
    const backButton = headerLeft.createEl("button", {
      text: "\u2190 Back",
      cls: "story-engine-back-btn"
    });
    backButton.onclick = () => {
      this.currentWorld = null;
      this.viewMode = "list";
      this.listTab = "worlds";
      this.renderListHeader();
      this.renderListContent();
    };
    const titleContainer = headerLeft.createDiv({ cls: "story-engine-title-container" });
    const titleRow = titleContainer.createDiv({ cls: "story-engine-title-row" });
    titleRow.createEl("h2", {
      text: this.currentWorld.name,
      cls: "story-engine-title-header"
    });
    if (this.currentWorld.genre) {
      const genrePill = titleRow.createSpan({
        cls: "story-engine-status-pill story-engine-status-draft"
      });
      genrePill.textContent = this.currentWorld.genre;
    }
    const uuidRow = titleContainer.createDiv({ cls: "story-engine-uuid-row" });
    const uuidSpan = uuidRow.createSpan({ cls: "story-engine-uuid" });
    uuidSpan.textContent = this.currentWorld.id;
    const copyUuidButton = uuidRow.createEl("button", {
      cls: "story-engine-copy-uuid-btn",
      attr: { "aria-label": "Copy UUID" }
    });
    (0, import_obsidian13.setIcon)(copyUuidButton, "copy");
    copyUuidButton.onclick = () => {
      if (!this.currentWorld)
        return;
      navigator.clipboard.writeText(this.currentWorld.id).then(() => {
        new import_obsidian13.Notice("UUID copied to clipboard");
      }).catch(() => {
        new import_obsidian13.Notice("Failed to copy UUID", 3e3);
      });
    };
    if (this.currentWorld.description) {
      const descRow = titleContainer.createDiv({ cls: "story-engine-world-desc" });
      descRow.textContent = this.currentWorld.description;
    }
    const headerActions = this.headerEl.createDiv({ cls: "story-engine-header-actions" });
    const contextButton = headerActions.createEl("button", {
      cls: "story-engine-context-btn",
      attr: { "aria-label": "World Actions" }
    });
    (0, import_obsidian13.setIcon)(contextButton, "more-vertical");
    const dropdownMenu = headerActions.createDiv({ cls: "story-engine-dropdown-menu" });
    dropdownMenu.style.display = "none";
    const editOption = dropdownMenu.createEl("button", {
      cls: "story-engine-dropdown-item"
    });
    (0, import_obsidian13.setIcon)(editOption, "pencil");
    editOption.createSpan({ text: "Edit World" });
    editOption.onclick = () => {
      dropdownMenu.style.display = "none";
      this.showEditWorldModal();
    };
    contextButton.onclick = (e) => {
      e.stopPropagation();
      const isVisible = dropdownMenu.style.display !== "none";
      dropdownMenu.style.display = isVisible ? "none" : "block";
    };
    document.addEventListener("click", () => {
      dropdownMenu.style.display = "none";
    }, { once: true });
  }
  renderWorldTabs() {
    if (!this.contentEl)
      return;
    const existingTabs = this.contentEl.querySelector(".story-engine-tabs");
    if (existingTabs) {
      existingTabs.remove();
    }
    const tabsContainer = this.contentEl.createDiv({ cls: "story-engine-tabs" });
    const tabs = [
      { key: "characters", label: "Characters" },
      { key: "locations", label: "Locations" },
      { key: "artifacts", label: "Artifacts" },
      { key: "events", label: "Events" },
      { key: "traits", label: "Traits" }
    ];
    for (const tab of tabs) {
      const tabButton = tabsContainer.createEl("button", {
        text: tab.label,
        cls: `story-engine-tab ${this.worldTab === tab.key ? "is-active" : ""}`
      });
      tabButton.onclick = () => {
        this.worldTab = tab.key;
        this.renderWorldTabs();
        this.renderWorldTabContent();
      };
    }
  }
  renderWorldTabContent() {
    if (!this.contentEl)
      return;
    const existingContent = this.contentEl.querySelector(".story-engine-tab-content");
    if (existingContent) {
      existingContent.remove();
    }
    const contentContainer = this.contentEl.createDiv({ cls: "story-engine-tab-content" });
    if (this.loadingWorldData) {
      contentContainer.createEl("p", { text: "Loading..." });
      return;
    }
    switch (this.worldTab) {
      case "characters":
        this.renderCharactersTab(contentContainer);
        break;
      case "locations":
        this.renderLocationsTab(contentContainer);
        break;
      case "artifacts":
        this.renderArtifactsTab(contentContainer);
        break;
      case "events":
        this.renderEventsTab(contentContainer);
        break;
      case "traits":
        this.renderTraitsTab(contentContainer);
        break;
    }
    this.renderWorldActionsBar(contentContainer);
  }
  renderWorldActionsBar(container) {
    const actionsBar = container.createDiv({ cls: "story-engine-actions-bar" });
    let createButtonText = "Create Character";
    let createButtonAction = () => {
      this.showCreateCharacterModal();
    };
    switch (this.worldTab) {
      case "locations":
        createButtonText = "Create Location";
        createButtonAction = () => this.showCreateLocationModal();
        break;
      case "artifacts":
        createButtonText = "Create Artifact";
        createButtonAction = () => this.showCreateArtifactModal();
        break;
      case "events":
        createButtonText = "Create Event";
        createButtonAction = () => this.showCreateEventModal();
        break;
      case "traits":
        createButtonText = "Create Trait";
        createButtonAction = () => this.showCreateTraitModal();
        break;
    }
    const createButton = actionsBar.createEl("button", {
      text: createButtonText,
      cls: "mod-cta story-engine-create-btn"
    });
    createButton.onclick = createButtonAction;
  }
  renderCharactersTab(container) {
    if (this.characters.length === 0) {
      container.createEl("p", { text: "No characters found. Create your first character!" });
      return;
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const character of this.characters) {
      const item = list.createDiv({ cls: "story-engine-item" });
      item.createDiv({ cls: "story-engine-title", text: character.name });
      const meta = item.createDiv({ cls: "story-engine-meta" });
      if (character.description) {
        meta.createEl("span", { text: character.description.substring(0, 50) + (character.description.length > 50 ? "..." : "") });
      }
      const actions = item.createDiv({ cls: "story-engine-item-actions" });
      actions.createEl("button", { text: "Edit" }).onclick = () => {
        this.showEditCharacterModal(character);
      };
      actions.createEl("button", { text: "Delete" }).onclick = async () => {
        if (confirm(`Delete character "${character.name}"?`)) {
          try {
            await this.plugin.apiClient.deleteCharacter(character.id);
            await this.loadWorldData();
            this.renderWorldTabContent();
            new import_obsidian13.Notice("Character deleted");
          } catch (err) {
            new import_obsidian13.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
          }
        }
      };
    }
  }
  renderLocationsTab(container) {
    if (this.locations.length === 0) {
      container.createEl("p", { text: "No locations found. Create your first location!" });
      return;
    }
    const rootLocations = this.locations.filter((l) => !l.parent_id);
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const location of rootLocations.sort((a, b) => a.name.localeCompare(b.name))) {
      this.renderLocationItem(list, location, 0);
    }
  }
  renderLocationItem(container, location, level) {
    const item = container.createDiv({ cls: "story-engine-item" });
    item.style.marginLeft = `${level * 1}rem`;
    const titleRow = item.createDiv({ cls: "story-engine-title" });
    titleRow.textContent = location.name;
    if (location.type) {
      const typeBadge = titleRow.createSpan({ cls: "story-engine-badge" });
      typeBadge.textContent = location.type;
    }
    const meta = item.createDiv({ cls: "story-engine-meta" });
    if (location.description) {
      meta.createEl("span", { text: location.description.substring(0, 50) + (location.description.length > 50 ? "..." : "") });
    }
    const actions = item.createDiv({ cls: "story-engine-item-actions" });
    actions.createEl("button", { text: "Edit" }).onclick = () => {
      this.showEditLocationModal(location);
    };
    actions.createEl("button", { text: "Delete" }).onclick = async () => {
      if (confirm(`Delete location "${location.name}"?`)) {
        try {
          await this.plugin.apiClient.deleteLocation(location.id);
          await this.loadWorldData();
          this.renderWorldTabContent();
          new import_obsidian13.Notice("Location deleted");
        } catch (err) {
          new import_obsidian13.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
        }
      }
    };
    const children = this.locations.filter((l) => l.parent_id === location.id);
    for (const child of children.sort((a, b) => a.name.localeCompare(b.name))) {
      this.renderLocationItem(container, child, level + 1);
    }
  }
  renderArtifactsTab(container) {
    if (this.artifacts.length === 0) {
      container.createEl("p", { text: "No artifacts found. Create your first artifact!" });
      return;
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const artifact of this.artifacts) {
      const item = list.createDiv({ cls: "story-engine-item" });
      const titleRow = item.createDiv({ cls: "story-engine-title" });
      titleRow.textContent = artifact.name;
      if (artifact.rarity) {
        const rarityBadge = titleRow.createSpan({ cls: `story-engine-badge story-engine-rarity-${artifact.rarity.toLowerCase()}` });
        rarityBadge.textContent = artifact.rarity;
      }
      const meta = item.createDiv({ cls: "story-engine-meta" });
      if (artifact.description) {
        meta.createEl("span", { text: artifact.description.substring(0, 50) + (artifact.description.length > 50 ? "..." : "") });
      }
      const actions = item.createDiv({ cls: "story-engine-item-actions" });
      actions.createEl("button", { text: "Edit" }).onclick = () => {
        this.showEditArtifactModal(artifact);
      };
      actions.createEl("button", { text: "Delete" }).onclick = async () => {
        if (confirm(`Delete artifact "${artifact.name}"?`)) {
          try {
            await this.plugin.apiClient.deleteArtifact(artifact.id);
            await this.loadWorldData();
            this.renderWorldTabContent();
            new import_obsidian13.Notice("Artifact deleted");
          } catch (err) {
            new import_obsidian13.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
          }
        }
      };
    }
  }
  renderEventsTab(container) {
    if (this.events.length === 0) {
      container.createEl("p", { text: "No events found. Create your first event!" });
      return;
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const event of this.events.sort((a, b) => b.importance - a.importance)) {
      const item = list.createDiv({ cls: "story-engine-item" });
      const titleRow = item.createDiv({ cls: "story-engine-title" });
      titleRow.textContent = event.name;
      const importanceBadge = titleRow.createSpan({ cls: "story-engine-badge" });
      importanceBadge.textContent = `\u2605${event.importance}`;
      if (event.type) {
        const typeBadge = titleRow.createSpan({ cls: "story-engine-badge" });
        typeBadge.textContent = event.type;
      }
      const meta = item.createDiv({ cls: "story-engine-meta" });
      if (event.timeline) {
        meta.createEl("span", { text: `Timeline: ${event.timeline}` });
      }
      if (event.description) {
        meta.createEl("span", { text: event.description.substring(0, 50) + (event.description.length > 50 ? "..." : "") });
      }
      const actions = item.createDiv({ cls: "story-engine-item-actions" });
      actions.createEl("button", { text: "Edit" }).onclick = () => {
        this.showEditEventModal(event);
      };
      actions.createEl("button", { text: "Delete" }).onclick = async () => {
        if (confirm(`Delete event "${event.name}"?`)) {
          try {
            await this.plugin.apiClient.deleteEvent(event.id);
            await this.loadWorldData();
            this.renderWorldTabContent();
            new import_obsidian13.Notice("Event deleted");
          } catch (err) {
            new import_obsidian13.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
          }
        }
      };
    }
  }
  renderTraitsTab(container) {
    if (this.traits.length === 0) {
      container.createEl("p", { text: "No traits found. Create your first trait!" });
      return;
    }
    const traitsByCategory = /* @__PURE__ */ new Map();
    for (const trait of this.traits) {
      const category = trait.category || "Uncategorized";
      if (!traitsByCategory.has(category)) {
        traitsByCategory.set(category, []);
      }
      traitsByCategory.get(category).push(trait);
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const [category, categoryTraits] of traitsByCategory.entries()) {
      const group = list.createDiv({ cls: "story-engine-group" });
      const groupHeader = group.createDiv({ cls: "story-engine-group-header" });
      groupHeader.createEl("h3", { text: category });
      const groupItems = group.createDiv({ cls: "story-engine-group-items" });
      for (const trait of categoryTraits.sort((a, b) => a.name.localeCompare(b.name))) {
        const item = groupItems.createDiv({ cls: "story-engine-item" });
        item.createDiv({ cls: "story-engine-title", text: trait.name });
        const meta = item.createDiv({ cls: "story-engine-meta" });
        if (trait.description) {
          meta.createEl("span", { text: trait.description.substring(0, 50) + (trait.description.length > 50 ? "..." : "") });
        }
        const actions = item.createDiv({ cls: "story-engine-item-actions" });
        actions.createEl("button", { text: "Edit" }).onclick = () => {
          this.showEditTraitModal(trait);
        };
        actions.createEl("button", { text: "Delete" }).onclick = async () => {
          if (confirm(`Delete trait "${trait.name}"?`)) {
            try {
              await this.plugin.apiClient.deleteTrait(trait.id);
              await this.loadWorldData();
              this.renderWorldTabContent();
              new import_obsidian13.Notice("Trait deleted");
            } catch (err) {
              new import_obsidian13.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
            }
          }
        };
      }
    }
  }
  // Modal methods for World entities
  showCreateCharacterModal() {
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian13.Modal(this.app);
    modal.titleEl.setText("Create Character");
    const content = modal.contentEl;
    let name = "";
    let description = "";
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input" });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Create", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian13.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.createCharacter(this.currentWorld.id, { name: name.trim(), description: description.trim() });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian13.Notice("Character created");
      } catch (err) {
        new import_obsidian13.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
    nameInput.focus();
  }
  showEditCharacterModal(character) {
    const modal = new import_obsidian13.Modal(this.app);
    modal.titleEl.setText("Edit Character");
    const content = modal.contentEl;
    let name = character.name;
    let description = character.description;
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: name });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.value = description;
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian13.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.updateCharacter(character.id, { name: name.trim(), description: description.trim() });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian13.Notice("Character updated");
      } catch (err) {
        new import_obsidian13.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  showCreateLocationModal() {
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian13.Modal(this.app);
    modal.titleEl.setText("Create Location");
    const content = modal.contentEl;
    let name = "";
    let type = "";
    let description = "";
    let parentId = null;
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input" });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Type" });
    const typeInput = content.createEl("input", { type: "text", cls: "story-engine-input", placeholder: "e.g., City, Forest, Building" });
    typeInput.oninput = () => {
      type = typeInput.value;
    };
    content.createEl("label", { text: "Parent Location" });
    const parentSelect = content.createEl("select", { cls: "story-engine-select" });
    parentSelect.createEl("option", { value: "", text: "None (Root Location)" });
    for (const loc of this.locations.sort((a, b) => a.name.localeCompare(b.name))) {
      parentSelect.createEl("option", { value: loc.id, text: loc.name });
    }
    parentSelect.onchange = () => {
      parentId = parentSelect.value || null;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Create", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian13.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.createLocation(this.currentWorld.id, {
          name: name.trim(),
          type: type.trim(),
          description: description.trim(),
          parent_id: parentId
        });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian13.Notice("Location created");
      } catch (err) {
        new import_obsidian13.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
    nameInput.focus();
  }
  showEditLocationModal(location) {
    const modal = new import_obsidian13.Modal(this.app);
    modal.titleEl.setText("Edit Location");
    const content = modal.contentEl;
    let name = location.name;
    let type = location.type;
    let description = location.description;
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: name });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Type" });
    const typeInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: type });
    typeInput.oninput = () => {
      type = typeInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.value = description;
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian13.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.updateLocation(location.id, { name: name.trim(), type: type.trim(), description: description.trim() });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian13.Notice("Location updated");
      } catch (err) {
        new import_obsidian13.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  showCreateArtifactModal() {
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian13.Modal(this.app);
    modal.titleEl.setText("Create Artifact");
    const content = modal.contentEl;
    let name = "";
    let description = "";
    let rarity = "";
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input" });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Rarity" });
    const raritySelect = content.createEl("select", { cls: "story-engine-select" });
    raritySelect.createEl("option", { value: "", text: "Select Rarity" });
    ["Common", "Uncommon", "Rare", "Epic", "Legendary", "Unique"].forEach((r) => {
      raritySelect.createEl("option", { value: r.toLowerCase(), text: r });
    });
    raritySelect.onchange = () => {
      rarity = raritySelect.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Create", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian13.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.createArtifact(this.currentWorld.id, {
          name: name.trim(),
          description: description.trim(),
          rarity
        });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian13.Notice("Artifact created");
      } catch (err) {
        new import_obsidian13.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
    nameInput.focus();
  }
  showEditArtifactModal(artifact) {
    const modal = new import_obsidian13.Modal(this.app);
    modal.titleEl.setText("Edit Artifact");
    const content = modal.contentEl;
    let name = artifact.name;
    let description = artifact.description;
    let rarity = artifact.rarity;
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: name });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Rarity" });
    const raritySelect = content.createEl("select", { cls: "story-engine-select" });
    raritySelect.createEl("option", { value: "", text: "Select Rarity" });
    ["Common", "Uncommon", "Rare", "Epic", "Legendary", "Unique"].forEach((r) => {
      const opt = raritySelect.createEl("option", { value: r.toLowerCase(), text: r });
      if (rarity.toLowerCase() === r.toLowerCase())
        opt.selected = true;
    });
    raritySelect.onchange = () => {
      rarity = raritySelect.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.value = description;
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian13.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.updateArtifact(artifact.id, { name: name.trim(), description: description.trim(), rarity });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian13.Notice("Artifact updated");
      } catch (err) {
        new import_obsidian13.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  showCreateEventModal() {
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian13.Modal(this.app);
    modal.titleEl.setText("Create Event");
    const content = modal.contentEl;
    let name = "";
    let type = "";
    let description = "";
    let timeline = "";
    let importance = 5;
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input" });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Type" });
    const typeInput = content.createEl("input", { type: "text", cls: "story-engine-input", placeholder: "e.g., Battle, Discovery, Treaty" });
    typeInput.oninput = () => {
      type = typeInput.value;
    };
    content.createEl("label", { text: "Timeline" });
    const timelineInput = content.createEl("input", { type: "text", cls: "story-engine-input", placeholder: "e.g., Year 100, Before the War" });
    timelineInput.oninput = () => {
      timeline = timelineInput.value;
    };
    content.createEl("label", { text: "Importance (1-10)" });
    const importanceInput = content.createEl("input", { type: "number", cls: "story-engine-input", value: "5", attr: { min: "1", max: "10" } });
    importanceInput.oninput = () => {
      importance = parseInt(importanceInput.value) || 5;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Create", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian13.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.createEvent(this.currentWorld.id, {
          name: name.trim(),
          type: type.trim() || void 0,
          description: description.trim() || void 0,
          timeline: timeline.trim() || void 0,
          importance: Math.max(1, Math.min(10, importance))
        });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian13.Notice("Event created");
      } catch (err) {
        new import_obsidian13.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
    nameInput.focus();
  }
  showEditEventModal(event) {
    const modal = new import_obsidian13.Modal(this.app);
    modal.titleEl.setText("Edit Event");
    const content = modal.contentEl;
    let name = event.name;
    let type = event.type || "";
    let description = event.description || "";
    let timeline = event.timeline || "";
    let importance = event.importance;
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: name });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Type" });
    const typeInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: type });
    typeInput.oninput = () => {
      type = typeInput.value;
    };
    content.createEl("label", { text: "Timeline" });
    const timelineInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: timeline });
    timelineInput.oninput = () => {
      timeline = timelineInput.value;
    };
    content.createEl("label", { text: "Importance (1-10)" });
    const importanceInput = content.createEl("input", { type: "number", cls: "story-engine-input", value: importance.toString(), attr: { min: "1", max: "10" } });
    importanceInput.oninput = () => {
      importance = parseInt(importanceInput.value) || 5;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.value = description;
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian13.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.updateEvent(event.id, {
          name: name.trim(),
          type: type.trim() || void 0,
          description: description.trim() || void 0,
          timeline: timeline.trim() || void 0,
          importance: Math.max(1, Math.min(10, importance))
        });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian13.Notice("Event updated");
      } catch (err) {
        new import_obsidian13.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  showCreateTraitModal() {
    const modal = new import_obsidian13.Modal(this.app);
    modal.titleEl.setText("Create Trait");
    const content = modal.contentEl;
    let name = "";
    let category = "";
    let description = "";
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input" });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Category" });
    const categoryInput = content.createEl("input", { type: "text", cls: "story-engine-input", placeholder: "e.g., Personality, Physical, Background" });
    categoryInput.oninput = () => {
      category = categoryInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Create", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian13.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.createTrait({
          name: name.trim(),
          category: category.trim(),
          description: description.trim()
        });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian13.Notice("Trait created");
      } catch (err) {
        new import_obsidian13.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
    nameInput.focus();
  }
  showEditTraitModal(trait) {
    const modal = new import_obsidian13.Modal(this.app);
    modal.titleEl.setText("Edit Trait");
    const content = modal.contentEl;
    let name = trait.name;
    let category = trait.category;
    let description = trait.description;
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: name });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Category" });
    const categoryInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: category });
    categoryInput.oninput = () => {
      category = categoryInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.value = description;
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian13.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.updateTrait(trait.id, { name: name.trim(), category: category.trim(), description: description.trim() });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian13.Notice("Trait updated");
      } catch (err) {
        new import_obsidian13.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  apiUrl: "http://localhost:8080",
  apiKey: "",
  tenantId: "",
  tenantName: "",
  syncFolderPath: "Stories",
  autoVersionSnapshots: true,
  conflictResolution: "service",
  mode: "local",
  showHelpBox: true,
  localModeVideoUrl: "https://example.com/setup-video"
};
var StoryEnginePlugin = class extends import_obsidian14.Plugin {
  async onload() {
    await this.loadSettings();
    this.apiClient = new StoryEngineClient(
      this.settings.apiUrl,
      this.settings.apiKey,
      this.settings.tenantId || ""
    );
    this.apiClient.setMode(this.settings.mode || "local");
    this.fileManager = new FileManager(
      this.app.vault,
      this.settings.syncFolderPath || "Stories"
    );
    this.syncService = new SyncService(
      this.apiClient,
      this.fileManager,
      this.settings,
      this.app
    );
    this.addSettingTab(new StoryEngineSettingTab(this.app, this));
    this.registerView(
      STORY_LIST_VIEW_TYPE,
      (leaf) => new StoryListView(leaf, this)
    );
    this.addRibbonIcon("book-open", "Story Engine", () => {
      this.activateView();
    });
    registerCommands(this);
  }
  async onunload() {
    this.app.workspace.detachLeavesOfType(STORY_LIST_VIEW_TYPE);
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.apiClient) {
      this.apiClient.setTenantId(this.settings.tenantId || "");
      this.apiClient.setMode(this.settings.mode || "local");
    } else {
      this.apiClient = new StoryEngineClient(
        this.settings.apiUrl,
        this.settings.apiKey,
        this.settings.tenantId || ""
      );
      this.apiClient.setMode(this.settings.mode || "local");
    }
    this.fileManager = new FileManager(
      this.app.vault,
      this.settings.syncFolderPath || "Stories"
    );
    this.syncService = new SyncService(
      this.apiClient,
      this.fileManager,
      this.settings,
      this.app
    );
  }
  async createStoryCommand() {
    var _a;
    if (this.settings.mode === "remote") {
      const tenantId = (_a = this.settings.tenantId) == null ? void 0 : _a.trim();
      if (!tenantId) {
        new import_obsidian14.Notice("Please configure Tenant ID in settings", 5e3);
        return;
      }
      const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
      if (!uuidRegex.test(tenantId)) {
        new import_obsidian14.Notice("Invalid Tenant ID format. Please check your settings.", 5e3);
        return;
      }
    }
    new CreateStoryModal(this.app, this, async (title, worldId, shouldSync) => {
      try {
        new import_obsidian14.Notice(`Creating story "${title}"...`);
        const story = await this.apiClient.createStory(title, worldId);
        new import_obsidian14.Notice(`Story "${title}" created successfully`);
        if (shouldSync) {
          try {
            new import_obsidian14.Notice(`Syncing story to Obsidian...`);
            await this.syncService.pullStory(story.id);
            new import_obsidian14.Notice(`Story synced to your vault!`);
          } catch (syncErr) {
            const syncErrorMessage = syncErr instanceof Error ? syncErr.message : "Failed to sync story";
            new import_obsidian14.Notice(`Story created but sync failed: ${syncErrorMessage}`, 5e3);
          }
        }
        const openView = this.app.workspace.getLeavesOfType(STORY_LIST_VIEW_TYPE)[0];
        if (openView) {
          const view = openView.view;
          await view.refresh();
          if (!shouldSync) {
            await view.showStoryDetails(story);
          }
        }
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to create story";
        new import_obsidian14.Notice(`Error: ${errorMessage}`, 5e3);
      }
    }).open();
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(STORY_LIST_VIEW_TYPE)[0];
    if (!leaf) {
      const rightLeaf = workspace.getRightLeaf(false);
      if (!rightLeaf) {
        new import_obsidian14.Notice("Could not create view. Please try again.", 3e3);
        return;
      }
      leaf = rightLeaf;
      await leaf.setViewState({
        type: STORY_LIST_VIEW_TYPE,
        active: true
      });
    }
    workspace.revealLeaf(leaf);
  }
  openSettings() {
    const setting = this.app.setting;
    if (setting) {
      setting.open();
      setTimeout(() => {
        setting.openTabById(this.manifest.id);
      }, 100);
    }
  }
};
