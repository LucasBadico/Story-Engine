/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => StoryEnginePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian12 = require("obsidian");

// src/api/client.ts
var StoryEngineClient = class {
  constructor(apiUrl, apiKey, tenantId = "") {
    this.apiUrl = apiUrl;
    this.apiKey = apiKey;
    this.tenantId = tenantId;
  }
  setTenantId(tenantId) {
    this.tenantId = tenantId.trim();
  }
  async request(method, endpoint, body, tenantIdOverride) {
    const url = `${this.apiUrl}${endpoint}`;
    const headers = new Headers();
    headers.set("Content-Type", "application/json");
    if (this.apiKey) {
      headers.set("Authorization", `Bearer ${this.apiKey}`);
    }
    const effectiveTenantId = tenantIdOverride != null ? tenantIdOverride : this.tenantId;
    if (effectiveTenantId) {
      const trimmedTenantId = effectiveTenantId.trim();
      if (trimmedTenantId) {
        headers.set("X-Tenant-ID", trimmedTenantId);
      }
    }
    const options = {
      method,
      headers
    };
    if (body) {
      options.body = JSON.stringify(body);
    }
    const response = await fetch(url, options);
    if (!response.ok) {
      let error;
      try {
        error = await response.json();
      } catch (e) {
        error = {
          error: "unknown_error",
          message: `HTTP ${response.status}: ${response.statusText}`,
          code: "HTTP_ERROR"
        };
      }
      const errorMessage = error.message || error.error || `HTTP ${response.status}: ${response.statusText}`;
      throw new Error(errorMessage);
    }
    return response.json();
  }
  async listStories() {
    if (!this.tenantId || !this.tenantId.trim()) {
      throw new Error("Tenant ID is required");
    }
    const response = await this.request(
      "GET",
      "/api/v1/stories"
    );
    return response.stories || [];
  }
  async getStory(id) {
    const response = await this.request(
      "GET",
      `/api/v1/stories/${id}`
    );
    return response.story;
  }
  async createStory(title) {
    if (!this.tenantId || !this.tenantId.trim()) {
      throw new Error("Tenant ID is required");
    }
    const response = await this.request(
      "POST",
      "/api/v1/stories",
      {
        title: title.trim()
      }
    );
    return response.story;
  }
  async cloneStory(id) {
    if (!this.tenantId || !this.tenantId.trim()) {
      throw new Error("Tenant ID is required");
    }
    const response = await this.request(
      "POST",
      `/api/v1/stories/${id}/clone`,
      {}
    );
    return response.story;
  }
  async getTenant(id) {
    const response = await this.request(
      "GET",
      `/api/v1/tenants/${id}`
    );
    return response.tenant;
  }
  async testConnection() {
    try {
      await this.request("GET", "/health");
      return true;
    } catch (e) {
      return false;
    }
  }
  async updateStory(id, title, status) {
    const body = { title: title.trim() };
    if (status) {
      body.status = status;
    }
    const response = await this.request(
      "PUT",
      `/api/v1/stories/${id}`,
      body
    );
    return response.story;
  }
  async getStoryWithHierarchy(id) {
    const story = await this.getStory(id);
    const chapters = await this.getChapters(id);
    const chaptersWithContent = await Promise.all(
      chapters.map(async (chapter) => {
        const scenes = await this.getScenes(chapter.id);
        const scenesWithBeats = await Promise.all(
          scenes.map(async (scene) => {
            const beats = await this.getBeats(scene.id);
            return { scene, beats };
          })
        );
        return { chapter, scenes: scenesWithBeats };
      })
    );
    return {
      story,
      chapters: chaptersWithContent
    };
  }
  async createChapter(storyId, chapter) {
    const response = await this.request(
      "POST",
      "/api/v1/chapters",
      {
        story_id: storyId,
        number: chapter.number,
        title: chapter.title,
        status: chapter.status
      }
    );
    return response.chapter;
  }
  async updateChapter(id, chapter) {
    const response = await this.request(
      "PUT",
      `/api/v1/chapters/${id}`,
      chapter
    );
    return response.chapter;
  }
  async getChapters(storyId) {
    const response = await this.request(
      "GET",
      `/api/v1/stories/${storyId}/chapters`
    );
    return response.chapters || [];
  }
  async getChapter(id) {
    const response = await this.request(
      "GET",
      `/api/v1/chapters/${id}`
    );
    return response.chapter;
  }
  async deleteChapter(id) {
    await this.request("DELETE", `/api/v1/chapters/${id}`);
  }
  async createScene(scene) {
    const response = await this.request(
      "POST",
      "/api/v1/scenes",
      scene
    );
    return response.scene;
  }
  async updateScene(id, scene) {
    const response = await this.request(
      "PUT",
      `/api/v1/scenes/${id}`,
      scene
    );
    return response.scene;
  }
  async getScenes(chapterId) {
    const response = await this.request(
      "GET",
      `/api/v1/chapters/${chapterId}/scenes`
    );
    return response.scenes || [];
  }
  async getScene(id) {
    const response = await this.request(
      "GET",
      `/api/v1/scenes/${id}`
    );
    return response.scene;
  }
  async deleteScene(id) {
    await this.request("DELETE", `/api/v1/scenes/${id}`);
  }
  async createBeat(beat) {
    const response = await this.request(
      "POST",
      "/api/v1/beats",
      beat
    );
    return response.beat;
  }
  async updateBeat(id, beat) {
    const response = await this.request(
      "PUT",
      `/api/v1/beats/${id}`,
      beat
    );
    return response.beat;
  }
  async getBeats(sceneId) {
    const response = await this.request(
      "GET",
      `/api/v1/scenes/${sceneId}/beats`
    );
    return response.beats || [];
  }
  async getBeat(id) {
    const response = await this.request(
      "GET",
      `/api/v1/beats/${id}`
    );
    return response.beat;
  }
  async deleteBeat(id) {
    await this.request("DELETE", `/api/v1/beats/${id}`);
  }
  // Get all versions of a story (for version history)
  async getStoryVersions(rootStoryId) {
    const response = await this.request(
      "GET",
      `/api/v1/stories/${rootStoryId}/versions`
    );
    return response.stories || [];
  }
  async getScenesByStory(storyId) {
    const response = await this.request(
      "GET",
      `/api/v1/stories/${storyId}/scenes`
    );
    return response.scenes || [];
  }
  async moveScene(sceneId, chapterId) {
    const body = {};
    if (chapterId !== null) {
      body.chapter_id = chapterId;
    } else {
      body.chapter_id = null;
    }
    const response = await this.request(
      "PUT",
      `/api/v1/scenes/${sceneId}/move`,
      body
    );
    return response.scene;
  }
  async getBeatsByStory(storyId) {
    const response = await this.request(
      "GET",
      `/api/v1/stories/${storyId}/beats`
    );
    return response.beats || [];
  }
  async moveBeat(beatId, sceneId) {
    const response = await this.request(
      "PUT",
      `/api/v1/beats/${beatId}/move`,
      { scene_id: sceneId }
    );
    return response.beat;
  }
  async getProseBlocks(chapterId) {
    const response = await this.request(
      "GET",
      `/api/v1/chapters/${chapterId}/prose-blocks`
    );
    return response.prose_blocks || [];
  }
  async getProseBlock(id) {
    const response = await this.request(
      "GET",
      `/api/v1/prose-blocks/${id}`
    );
    return response.prose_block;
  }
  async createProseBlock(chapterId, proseBlock) {
    const response = await this.request(
      "POST",
      `/api/v1/chapters/${chapterId}/prose-blocks`,
      proseBlock
    );
    return response.prose_block;
  }
  async updateProseBlock(id, proseBlock) {
    const response = await this.request(
      "PUT",
      `/api/v1/prose-blocks/${id}`,
      proseBlock
    );
    return response.prose_block;
  }
  async deleteProseBlock(id) {
    await this.request("DELETE", `/api/v1/prose-blocks/${id}`);
  }
  async getProseBlockReferences(proseBlockId) {
    const response = await this.request(
      "GET",
      `/api/v1/prose-blocks/${proseBlockId}/references`
    );
    return response.references || [];
  }
  async getProseBlocksByScene(sceneId) {
    const response = await this.request(
      "GET",
      `/api/v1/scenes/${sceneId}/prose-blocks`
    );
    return response.prose_blocks || [];
  }
  async getProseBlocksByBeat(beatId) {
    const response = await this.request(
      "GET",
      `/api/v1/beats/${beatId}/prose-blocks`
    );
    return response.prose_blocks || [];
  }
  async createProseBlockReference(proseBlockId, entityType, entityId) {
    const response = await this.request(
      "POST",
      `/api/v1/prose-blocks/${proseBlockId}/references`,
      {
        entity_type: entityType,
        entity_id: entityId
      }
    );
    return response.reference;
  }
  async deleteProseBlockReference(id) {
    await this.request("DELETE", `/api/v1/prose-block-references/${id}`);
  }
};

// src/settings.ts
var import_obsidian = require("obsidian");
var StoryEngineSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Story Engine Settings" });
    new import_obsidian.Setting(containerEl).setName("API URL").setDesc("The base URL of the Story Engine API").addText(
      (text) => text.setPlaceholder("http://localhost:8080").setValue(this.plugin.settings.apiUrl).onChange(async (value) => {
        this.plugin.settings.apiUrl = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("API Key").setDesc("API key for authentication (optional for MVP)").addText((text) => {
      text.setPlaceholder("Enter API key").setValue(this.plugin.settings.apiKey).inputEl.type = "password";
      text.onChange(async (value) => {
        this.plugin.settings.apiKey = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Tenant ID").setDesc("Your workspace tenant ID (UUID format)").addText(
      (text) => text.setPlaceholder("00000000-0000-0000-0000-000000000000").setValue(this.plugin.settings.tenantId || "").onChange(async (value) => {
        this.plugin.settings.tenantId = value.trim();
        if (this.plugin.apiClient) {
          this.plugin.apiClient.setTenantId(value.trim());
        }
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Sync Folder Path").setDesc("Folder path where synced stories will be stored").addText(
      (text) => text.setPlaceholder("Stories").setValue(this.plugin.settings.syncFolderPath || "Stories").onChange(async (value) => {
        this.plugin.settings.syncFolderPath = value.trim() || "Stories";
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Auto Version Snapshots").setDesc("Automatically create version snapshots when syncing").addToggle(
      (toggle) => {
        var _a;
        return toggle.setValue((_a = this.plugin.settings.autoVersionSnapshots) != null ? _a : true).onChange(async (value) => {
          this.plugin.settings.autoVersionSnapshots = value;
          await this.plugin.saveSettings();
        });
      }
    );
    new import_obsidian.Setting(containerEl).setName("Conflict Resolution").setDesc("How to resolve conflicts when both local and service have changes").addDropdown(
      (dropdown) => dropdown.addOption("service", "Service Wins").addOption("local", "Local Wins").addOption("manual", "Manual (Newer Wins)").setValue(this.plugin.settings.conflictResolution || "service").onChange(async (value) => {
        this.plugin.settings.conflictResolution = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Test Connection").setDesc("Test connection to the Story Engine API").addButton(
      (button) => button.setButtonText("Test").onClick(async () => {
        button.setButtonText("Testing...");
        button.setDisabled(true);
        try {
          const result = await this.plugin.apiClient.testConnection();
          if (result) {
            button.setButtonText("Success!");
            setTimeout(() => {
              button.setButtonText("Test");
              button.setDisabled(false);
            }, 2e3);
          } else {
            button.setButtonText("Failed");
            setTimeout(() => {
              button.setButtonText("Test");
              button.setDisabled(false);
            }, 2e3);
          }
        } catch (err) {
          button.setButtonText("Error");
          setTimeout(() => {
            button.setButtonText("Test");
            button.setDisabled(false);
          }, 2e3);
        }
      })
    );
  }
};

// src/commands.ts
var import_obsidian3 = require("obsidian");

// src/views/StorySyncModal.ts
var import_obsidian2 = require("obsidian");
var StorySyncModal = class extends import_obsidian2.Modal {
  constructor(plugin, mode) {
    super(plugin.app);
    this.stories = [];
    this.loading = true;
    this.error = null;
    this.plugin = plugin;
    this.mode = mode;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    const title = this.mode === "pull" ? "Sync Story from Service" : "Push Story to Service";
    contentEl.createEl("h2", { text: title });
    await this.loadStories();
    if (this.loading) {
      contentEl.createEl("p", { text: "Loading stories..." });
      return;
    }
    if (this.error) {
      contentEl.createEl("p", {
        text: `Error: ${this.error}`,
        cls: "story-engine-error"
      });
      return;
    }
    if (this.stories.length === 0) {
      contentEl.createEl("p", { text: "No stories found." });
      return;
    }
    const storiesList = contentEl.createEl("div", { cls: "story-engine-list" });
    for (const story of this.stories) {
      const storyItem = storiesList.createEl("div", {
        cls: "story-engine-item"
      });
      const title2 = storyItem.createEl("div", {
        cls: "story-engine-title",
        text: story.title
      });
      const meta = storyItem.createEl("div", {
        cls: "story-engine-meta"
      });
      meta.createEl("span", {
        text: `Version ${story.version_number}`
      });
      meta.createEl("span", {
        text: `Status: ${story.status}`
      });
      storyItem.onclick = async () => {
        this.close();
        try {
          if (this.mode === "pull") {
            await this.plugin.syncService.pullStory(story.id);
          } else {
            const folderPath = this.plugin.fileManager.getStoryFolderPath(
              story.title
            );
            await this.plugin.syncService.pushStory(folderPath);
          }
        } catch (err) {
          const errorMessage = err instanceof Error ? err.message : "Failed to sync story";
          new import_obsidian2.Notice(`Error: ${errorMessage}`, 5e3);
        }
      };
    }
  }
  async loadStories() {
    this.loading = true;
    this.error = null;
    try {
      if (!this.plugin.settings.tenantId) {
        this.error = "Tenant ID not configured";
        this.loading = false;
        return;
      }
      this.stories = await this.plugin.apiClient.listStories();
    } catch (err) {
      this.error = err instanceof Error ? err.message : "Unknown error";
    } finally {
      this.loading = false;
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/commands.ts
function registerCommands(plugin) {
  plugin.addCommand({
    id: "list-stories",
    name: "List Stories",
    callback: () => {
      plugin.activateView();
    }
  });
  plugin.addCommand({
    id: "create-story",
    name: "Create Story",
    callback: () => {
      plugin.createStoryCommand();
    }
  });
  plugin.addCommand({
    id: "sync-story-from-service",
    name: "Sync Story from Service",
    callback: () => {
      new StorySyncModal(plugin, "pull").open();
    }
  });
  plugin.addCommand({
    id: "push-story-to-service",
    name: "Push Story to Service",
    callback: () => {
      new StorySyncModal(plugin, "push").open();
    }
  });
  plugin.addCommand({
    id: "sync-all-stories",
    name: "Sync All Stories",
    callback: async () => {
      if (!plugin.settings.tenantId) {
        new import_obsidian3.Notice("Please configure Tenant ID in settings", 5e3);
        return;
      }
      try {
        new import_obsidian3.Notice("Syncing all stories...");
        await plugin.syncService.pullAllStories();
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to sync stories";
        new import_obsidian3.Notice(`Error: ${errorMessage}`, 5e3);
      }
    }
  });
}

// src/views/CreateStoryModal.ts
var import_obsidian4 = require("obsidian");
var CreateStoryModal = class extends import_obsidian4.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.title = "";
    this.shouldSync = true;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Create New Story" });
    new import_obsidian4.Setting(contentEl).setName("Story Title").setDesc("Enter the title for your new story").addText(
      (text) => text.setPlaceholder("My New Story").setValue(this.title).onChange((value) => {
        this.title = value;
      }).inputEl.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          this.submit();
        }
      })
    );
    new import_obsidian4.Setting(contentEl).setName("Sync to Obsidian").setDesc("Automatically sync the story files to your vault after creation").addToggle(
      (toggle) => toggle.setValue(this.shouldSync).onChange((value) => {
        this.shouldSync = value;
      })
    );
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const createButton = buttonContainer.createEl("button", {
      text: "Create",
      cls: "mod-cta"
    });
    createButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
    const titleInput = contentEl.querySelector("input");
    if (titleInput) {
      titleInput.focus();
    }
  }
  submit() {
    const trimmedTitle = this.title.trim();
    if (!trimmedTitle) {
      new import_obsidian4.Notice("Please enter a story title", 3e3);
      return;
    }
    this.close();
    this.onSubmit(trimmedTitle, this.shouldSync);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/sync/fileManager.ts
var import_obsidian5 = require("obsidian");
var FileManager = class {
  constructor(vault, baseFolder) {
    this.vault = vault;
    this.baseFolder = baseFolder;
  }
  // Expose vault for sync operations
  getVault() {
    return this.vault;
  }
  // Get the folder path for a specific story
  getStoryFolderPath(storyTitle) {
    const sanitized = this.sanitizeFolderName(storyTitle);
    return `${this.baseFolder}/${sanitized}`;
  }
  // Sanitize folder/file names
  sanitizeFolderName(name) {
    return name.replace(/[<>:"/\\|?*]/g, "-").replace(/\s+/g, " ").trim();
  }
  // Generate frontmatter with Obsidian tags
  generateFrontmatter(baseFields, extraFields, options) {
    const fields = { ...baseFields };
    if (extraFields) {
      Object.assign(fields, extraFields);
    }
    const tags = [];
    if (options) {
      tags.push(`story-engine/${options.entityType}`);
      if (options.storyName) {
        const sanitizedStoryName = this.sanitizeFolderName(options.storyName).toLowerCase().replace(/\s+/g, "-");
        tags.push(`story/${sanitizedStoryName}`);
      }
      if (options.date) {
        const date = typeof options.date === "string" ? new Date(options.date) : options.date;
        if (!isNaN(date.getTime())) {
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, "0");
          const day = String(date.getDate()).padStart(2, "0");
          tags.push(`date/${year}/${month}/${day}`);
        }
      }
    }
    const lines = ["---"];
    for (const [key, value] of Object.entries(fields)) {
      if (value === null || value === void 0) {
        lines.push(`${key}: null`);
      } else if (typeof value === "string") {
        const escaped = value.replace(/"/g, '\\"');
        if (value.includes(":") || value.includes("\n") || value.includes('"')) {
          lines.push(`${key}: "${escaped}"`);
        } else {
          lines.push(`${key}: ${escaped}`);
        }
      } else {
        lines.push(`${key}: ${value}`);
      }
    }
    if (tags.length > 0) {
      lines.push(`tags:`);
      for (const tag of tags) {
        lines.push(`  - ${tag}`);
      }
    }
    lines.push("---", "");
    return lines.join("\n");
  }
  // Ensure folder exists
  async ensureFolderExists(path) {
    const folder = this.vault.getAbstractFileByPath(path);
    if (!folder) {
      await this.vault.createFolder(path);
    }
  }
  // Write story metadata (story.md)
  async writeStoryMetadata(story, folderPath, chapters, orphanScenes, orphanBeats, chapterProseData) {
    var _a, _b;
    await this.ensureFolderExists(folderPath);
    const baseFields = {
      id: story.id,
      title: story.title,
      status: story.status,
      version: story.version_number,
      root_story_id: story.root_story_id,
      previous_version_id: story.previous_story_id,
      created_at: story.created_at,
      updated_at: story.updated_at
    };
    const frontmatter = this.generateFrontmatter(baseFields, void 0, {
      entityType: "story",
      storyName: story.title,
      date: story.created_at
    });
    let content = `${frontmatter}
# ${story.title}

Version: ${story.version_number}
Status: ${story.status}

`;
    const temporaryChapterTitles = ["Story Prose", "Scene-Level Prose", "Beat-Level Prose"];
    const filteredChapters = (chapters == null ? void 0 : chapters.filter(
      (c) => !temporaryChapterTitles.includes(c.chapter.title) && c.chapter.number < 9e3
    )) || [];
    if (filteredChapters.length > 0) {
      content += `## Chapters, Scenes & Beats

`;
      content += `> [!info] How to use this list
`;
      content += `> - **Create new item**: Add a line with \`-\` followed by the text
`;
      content += `>   - **Chapter**: No indentation (level 0)
`;
      content += `>   - **Scene**: Use 1 tab indentation (inside a chapter)
`;
      content += `>   - **Beat**: Use 2 tabs indentation (inside a scene)
`;
      content += `> - **Reorder**: Move items up/down to change order
`;
      content += `> - **Links**: Use \`[[link-name|text]]\` to create links to existing files
`;
      content += `> - **Format**:
`;
      content += `>   - **Chapter**:
`;
      content += `>     - Complete: \`Chapter N: title\`
`;
      content += `>     - Simplified: \`title\`
`;
      content += `>   - **Scene**:
`;
      content += `>     - Complete: \`Scene N: goal - timeRef\`
`;
      content += `>     - Simplified:
`;
      content += `>       - \`goal - timeRef\`
`;
      content += `>       - \`goal\`
`;
      content += `>   - **Beat**:
`;
      content += `>     - Complete: \`Beat N: intent -> outcome\`
`;
      content += `>     - Simplified:
`;
      content += `>       - \`intent -> outcome\`
`;
      content += `>       - \`intent\`
`;
      content += `> - **Markers**: \`-\` indicates no associated prose, \`+\` indicates associated prose

`;
      for (const chapterWithContent of filteredChapters) {
        const chapter = chapterWithContent.chapter;
        const chapterFileName = `Chapter-${chapter.number}.md`;
        const chapterLinkName = chapterFileName.replace(/\.md$/, "");
        content += `- [[${chapterLinkName}|Chapter ${chapter.number}: ${chapter.title}]]
`;
        for (const { scene, beats } of chapterWithContent.scenes) {
          const sceneFileName = this.generateSceneFileName(scene);
          const sceneLinkName = sceneFileName.replace(/\.md$/, "");
          const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
          content += `	- [[${sceneLinkName}|Scene ${scene.order_num}: ${sceneDisplayText}]]
`;
          for (const beat of beats) {
            const beatFileName = this.generateBeatFileName(beat);
            const beatLinkName = beatFileName.replace(/\.md$/, "");
            const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
            content += `		- [[${beatLinkName}|Beat ${beat.order_num}: ${beatDisplayText}]]
`;
          }
        }
      }
      content += `
`;
    }
    if (orphanScenes && orphanScenes.length > 0) {
      content += `## Orphan Scenes

`;
      content += `> [!info] Scenes without a chapter
`;
      content += `> These scenes are not associated with any chapter. You can:
`;
      content += `> - **Reorder**: Move items up/down to change order
`;
      content += `> - **Links**: Use \`[[link-name|text]]\` to create links to existing files
`;
      content += `> - **Format**:
`;
      content += `>   - Complete: \`Scene N: goal - timeRef\`
`;
      content += `>   - Simplified:
`;
      content += `>     - \`goal - timeRef\`
`;
      content += `>     - \`goal\`
`;
      content += `> - **Markers**: \`-\` indicates no associated prose, \`+\` indicates associated prose

`;
      for (const { scene, beats } of orphanScenes) {
        const sceneFileName = this.generateSceneFileName(scene);
        const sceneLinkName = sceneFileName.replace(/\.md$/, "");
        const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
        content += `- [[${sceneLinkName}|Scene ${scene.order_num}: ${sceneDisplayText}]]
`;
        for (const beat of beats) {
          const beatFileName = this.generateBeatFileName(beat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
          content += `	- [[${beatLinkName}|Beat ${beat.order_num}: ${beatDisplayText}]]
`;
        }
      }
      content += `
`;
    }
    if (orphanBeats && orphanBeats.length > 0) {
      content += `## Orphan Beats

`;
      content += `> [!info] Beats without a scene
`;
      content += `> These beats are not associated with any scene. You can:
`;
      content += `> - **Reorder**: Move items up/down to change order
`;
      content += `> - **Links**: Use \`[[link-name|text]]\` to create links to existing files
`;
      content += `> - **Format**:
`;
      content += `>   - Complete: \`Beat N: intent -> outcome\`
`;
      content += `>   - Simplified:
`;
      content += `>     - \`intent -> outcome\`
`;
      content += `>     - \`intent\`
`;
      content += `> - **Markers**: \`-\` indicates no associated prose, \`+\` indicates associated prose

`;
      for (const beat of orphanBeats) {
        const beatFileName = this.generateBeatFileName(beat);
        const beatLinkName = beatFileName.replace(/\.md$/, "");
        const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
        content += `- [[${beatLinkName}|Beat ${beat.order_num}: ${beatDisplayText}]]
`;
      }
      content += `
`;
    }
    content += `# Story: ${story.title}

`;
    if (filteredChapters.length > 0) {
      for (const chapterWithContent of filteredChapters) {
        const chapter = chapterWithContent.chapter;
        const chapterFileName = `Chapter-${chapter.number}.md`;
        const chapterLinkName = chapterFileName.replace(/\.md$/, "");
        content += `## Chapter ${chapter.number}: [[${chapterLinkName}|${chapter.title}]]

`;
        const proseData = chapterProseData == null ? void 0 : chapterProseData.get(chapter.id);
        let organization = null;
        if (proseData) {
          organization = this.organizeProseBlocks(
            proseData.proseBlocks,
            proseData.proseBlockRefs,
            chapterWithContent.scenes
          );
          for (const proseBlock of organization.chapterOnly) {
            const fileName = this.generateProseBlockFileName(proseBlock);
            const linkName = fileName.replace(/\.md$/, "");
            content += `[[${linkName}|${proseBlock.content}]]

`;
          }
        }
        for (const { scene, beats } of chapterWithContent.scenes) {
          const sceneFileName = this.generateSceneFileName(scene);
          const sceneLinkName = sceneFileName.replace(/\.md$/, "");
          const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
          content += `### Scene: [[${sceneLinkName}|${sceneDisplayText}]]

`;
          if (organization) {
            const sceneProseBlocks = ((_a = organization.byScene.get(scene.id)) == null ? void 0 : _a.proseBlocks) || [];
            for (const proseBlock of sceneProseBlocks) {
              const fileName = this.generateProseBlockFileName(proseBlock);
              const linkName = fileName.replace(/\.md$/, "");
              content += `[[${linkName}|${proseBlock.content}]]

`;
            }
          }
          for (const beat of beats) {
            const beatFileName = this.generateBeatFileName(beat);
            const beatLinkName = beatFileName.replace(/\.md$/, "");
            const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
            content += `#### Beat: [[${beatLinkName}|${beatDisplayText}]]

`;
            if (organization) {
              const beatProseBlocks = ((_b = organization.byBeat.get(beat.id)) == null ? void 0 : _b.proseBlocks) || [];
              for (const proseBlock of beatProseBlocks) {
                const fileName = this.generateProseBlockFileName(proseBlock);
                const linkName = fileName.replace(/\.md$/, "");
                content += `[[${linkName}|${proseBlock.content}]]

`;
              }
            }
          }
        }
      }
    }
    if (orphanScenes && orphanScenes.length > 0) {
      for (const { scene, beats } of orphanScenes) {
        const sceneFileName = this.generateSceneFileName(scene);
        const sceneLinkName = sceneFileName.replace(/\.md$/, "");
        const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
        content += `### Scene: [[${sceneLinkName}|${sceneDisplayText}]]

`;
        for (const beat of beats) {
          const beatFileName = this.generateBeatFileName(beat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
          content += `#### Beat: [[${beatLinkName}|${beatDisplayText}]]

`;
        }
      }
    }
    const filePath = `${folderPath}/story.md`;
    const file = this.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian5.TFile) {
      await this.vault.modify(file, content);
    } else {
      await this.vault.create(filePath, content);
    }
  }
  // Write chapter file
  async writeChapterFile(chapterWithContent, filePath, storyName, proseBlocks, proseBlockRefs, orphanScenes) {
    var _a, _b, _c, _d;
    const { chapter, scenes } = chapterWithContent;
    const baseFields = {
      id: chapter.id,
      story_id: chapter.story_id,
      number: chapter.number,
      title: chapter.title,
      status: chapter.status,
      created_at: chapter.created_at,
      updated_at: chapter.updated_at
    };
    const frontmatter = this.generateFrontmatter(baseFields, void 0, {
      entityType: "chapter",
      storyName,
      date: chapter.created_at
    });
    let content = `${frontmatter}
# ${chapter.title}

`;
    const organization = this.organizeProseBlocks(
      proseBlocks || [],
      proseBlockRefs || [],
      scenes
    );
    content += `## Scenes & Beats

`;
    content += `> [!info] How to use this list
`;
    content += `> - **Create new item**: Add a line with \`-\` followed by the text
`;
    content += `>   - **Scene**: No indentation (level 0)
`;
    content += `>   - **Beat**: Use 1 tab indentation (inside a scene)
`;
    content += `> - **Reorder**: Move items up/down to change order
`;
    content += `> - **Links**: Use \`[[link-name|text]]\` to create links to existing files
`;
    content += `> - **Format**:
`;
    content += `>   - **Scene**:
`;
    content += `>     - Complete: \`Scene N: goal - timeRef\`
`;
    content += `>     - Simplified:
`;
    content += `>       - \`goal - timeRef\`
`;
    content += `>       - \`goal\`
`;
    content += `>   - **Beat**:
`;
    content += `>     - Complete: \`Beat N: intent -> outcome\`
`;
    content += `>     - Simplified:
`;
    content += `>       - \`intent -> outcome\`
`;
    content += `>       - \`intent\`
`;
    content += `> - **Markers**: \`-\` indicates no associated prose, \`+\` indicates associated prose
`;
    content += `> - **Orphan scenes** (without chapter) are shown below for easy association

`;
    for (const { scene, beats } of scenes) {
      const sceneFileName = this.generateSceneFileName(scene);
      const sceneLinkName = sceneFileName.replace(/\.md$/, "");
      const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
      const sceneProseBlocks = ((_a = organization.byScene.get(scene.id)) == null ? void 0 : _a.proseBlocks) || [];
      const hasSceneProse = sceneProseBlocks.length > 0;
      const sceneMarker = hasSceneProse ? "+" : "-";
      content += `${sceneMarker} [[${sceneLinkName}|Scene ${scene.order_num}: ${sceneDisplayText}]]
`;
      for (const beat of beats) {
        const beatFileName = this.generateBeatFileName(beat);
        const beatLinkName = beatFileName.replace(/\.md$/, "");
        const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
        const beatProseBlocks = ((_b = organization.byBeat.get(beat.id)) == null ? void 0 : _b.proseBlocks) || [];
        const hasBeatProse = beatProseBlocks.length > 0;
        const beatMarker = hasBeatProse ? "+" : "-";
        content += `	${beatMarker} [[${beatLinkName}|Beat ${beat.order_num}: ${beatDisplayText}]]
`;
      }
    }
    if (orphanScenes && orphanScenes.length > 0) {
      content += `
`;
      content += `> [!info] Orphan Scenes (not yet associated with this chapter)
`;
      content += `> You can associate these scenes with this chapter by moving them here.

`;
      for (const { scene, beats } of orphanScenes) {
        const sceneFileName = this.generateSceneFileName(scene);
        const sceneLinkName = sceneFileName.replace(/\.md$/, "");
        const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
        content += `- [[${sceneLinkName}|Scene ${scene.order_num}: ${sceneDisplayText}]]
`;
        for (const beat of beats) {
          const beatFileName = this.generateBeatFileName(beat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
          content += `	- [[${beatLinkName}|Beat ${beat.order_num}: ${beatDisplayText}]]
`;
        }
      }
    }
    content += `
`;
    content += `## Chapter ${chapter.number}: ${chapter.title}

`;
    for (const proseBlock of organization.chapterOnly) {
      const fileName = this.generateProseBlockFileName(proseBlock);
      const linkName = fileName.replace(/\.md$/, "");
      content += `[[${linkName}|${proseBlock.content}]]

`;
    }
    for (const { scene, beats } of scenes) {
      const sceneFileName = this.generateSceneFileName(scene);
      const sceneLinkName = sceneFileName.replace(/\.md$/, "");
      const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
      content += `## Scene: [[${sceneLinkName}|${sceneDisplayText}]]

`;
      const sceneProseBlocks = ((_c = organization.byScene.get(scene.id)) == null ? void 0 : _c.proseBlocks) || [];
      for (const proseBlock of sceneProseBlocks) {
        const fileName = this.generateProseBlockFileName(proseBlock);
        const linkName = fileName.replace(/\.md$/, "");
        content += `[[${linkName}|${proseBlock.content}]]

`;
      }
      for (const beat of beats) {
        const beatFileName = this.generateBeatFileName(beat);
        const beatLinkName = beatFileName.replace(/\.md$/, "");
        const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
        content += `### Beat: [[${beatLinkName}|${beatDisplayText}]]

`;
        const beatProseBlocks = ((_d = organization.byBeat.get(beat.id)) == null ? void 0 : _d.proseBlocks) || [];
        for (const proseBlock of beatProseBlocks) {
          const fileName = this.generateProseBlockFileName(proseBlock);
          const linkName = fileName.replace(/\.md$/, "");
          content += `[[${linkName}|${proseBlock.content}]]

`;
        }
      }
    }
    const file = this.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian5.TFile) {
      await this.vault.modify(file, content);
    } else {
      await this.vault.create(filePath, content);
    }
  }
  // Read story metadata
  async readStoryMetadata(folderPath) {
    const filePath = `${folderPath}/story.md`;
    const file = this.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian5.TFile)) {
      throw new Error(`Story metadata file not found: ${filePath}`);
    }
    const content = await this.vault.read(file);
    const frontmatter = this.parseFrontmatter(content);
    return {
      frontmatter: {
        id: frontmatter.id,
        title: frontmatter.title,
        status: frontmatter.status,
        version: parseInt(frontmatter.version),
        root_story_id: frontmatter.root_story_id,
        previous_version_id: frontmatter.previous_version_id || null,
        created_at: frontmatter.created_at,
        updated_at: frontmatter.updated_at
      },
      content: content.split("---").slice(2).join("---").trim()
    };
  }
  // Parse YAML frontmatter
  parseFrontmatter(content) {
    const match = content.match(/^---\n([\s\S]*?)\n---/);
    if (!match) {
      return {};
    }
    const frontmatterText = match[1];
    const result = {};
    for (const line of frontmatterText.split("\n")) {
      const colonIndex = line.indexOf(":");
      if (colonIndex > 0) {
        const key = line.slice(0, colonIndex).trim();
        const value = line.slice(colonIndex + 1).trim().replace(/^["']|["']$/g, "");
        result[key] = value;
      }
    }
    return result;
  }
  // Copy story folder to versions folder
  async createVersionSnapshot(storyFolderPath, versionNumber) {
    const versionsPath = `${storyFolderPath}/versions`;
    await this.ensureFolderExists(versionsPath);
    const versionFolderPath = `${versionsPath}/v${versionNumber}`;
    const existingVersion = this.vault.getAbstractFileByPath(versionFolderPath);
    if (existingVersion) {
      console.log(`Version v${versionNumber} already exists, skipping snapshot`);
      return;
    }
    await this.ensureFolderExists(versionFolderPath);
    const storyFolder = this.vault.getAbstractFileByPath(storyFolderPath);
    if (!(storyFolder instanceof import_obsidian5.TFolder)) {
      throw new Error(`Story folder not found: ${storyFolderPath}`);
    }
    await this.copyFolderContents(storyFolder, versionFolderPath, "versions");
    console.log(`Created version snapshot: v${versionNumber}`);
  }
  // Recursively copy folder contents
  async copyFolderContents(sourceFolder, destPath, excludeFolderName) {
    for (const child of sourceFolder.children) {
      if (child instanceof import_obsidian5.TFile) {
        const relativePath = child.path.replace(sourceFolder.path + "/", "");
        const destFilePath = `${destPath}/${relativePath}`;
        const content = await this.vault.read(child);
        await this.vault.create(destFilePath, content);
      } else if (child instanceof import_obsidian5.TFolder) {
        if (excludeFolderName && child.name === excludeFolderName) {
          continue;
        }
        const relativePath = child.path.replace(sourceFolder.path + "/", "");
        const destFolderPath = `${destPath}/${relativePath}`;
        await this.ensureFolderExists(destFolderPath);
        await this.copyFolderContents(child, destFolderPath, excludeFolderName);
      }
    }
  }
  // Write scene file
  async writeSceneFile(sceneWithBeats, filePath, storyName, proseBlocks, orphanBeats) {
    var _a;
    const { scene, beats } = sceneWithBeats;
    const baseFields = {
      id: scene.id,
      story_id: scene.story_id,
      chapter_id: (_a = scene.chapter_id) != null ? _a : null,
      order_num: scene.order_num,
      time_ref: scene.time_ref || "",
      goal: scene.goal || "",
      created_at: scene.created_at,
      updated_at: scene.updated_at
    };
    const extraFields = {};
    if (scene.pov_character_id) {
      extraFields.pov_character_id = scene.pov_character_id;
    }
    if (scene.location_id) {
      extraFields.location_id = scene.location_id;
    }
    const frontmatter = this.generateFrontmatter(baseFields, extraFields, {
      entityType: "scene",
      storyName,
      date: scene.created_at
    });
    let content = `${frontmatter}
# Scene ${scene.order_num}

`;
    if (scene.goal) {
      content += `**Goal:** ${scene.goal}

`;
    }
    if (scene.time_ref) {
      content += `**Time:** ${scene.time_ref}

`;
    }
    if (beats.length > 0) {
      content += `## Beats

`;
      content += `> [!info] How to use this list
`;
      content += `> - **Create new item**: Add a line with \`-\` followed by the text
`;
      content += `>   - **Beat**: No indentation (level 0)
`;
      content += `> - **Reorder**: Move items up/down to change order
`;
      content += `> - **Links**: Use \`[[link-name|text]]\` to create links to existing files
`;
      content += `> - **Format**:
`;
      content += `>   - **Beat**:
`;
      content += `>     - Complete: \`Beat N: intent -> outcome\`
`;
      content += `>     - Simplified:
`;
      content += `>       - \`intent -> outcome\`
`;
      content += `>       - \`intent\`
`;
      content += `> - **Markers**: \`-\` indicates no associated prose, \`+\` indicates associated prose
`;
      content += `> - **Orphan beats** (without scene) are shown below for easy association

`;
      const beatsWithProse = /* @__PURE__ */ new Set();
      if (proseBlocks) {
        for (const proseBlock of proseBlocks) {
        }
      }
      for (const beat of beats.sort((a, b) => a.order_num - b.order_num)) {
        const beatFileName = this.generateBeatFileName(beat);
        const beatLinkName = beatFileName.replace(/\.md$/, "");
        const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
        const hasBeatProse = beatsWithProse.has(beat.id);
        const beatMarker = hasBeatProse ? "+" : "-";
        content += `${beatMarker} [[${beatLinkName}|Beat ${beat.order_num}: ${beatDisplayText}]]
`;
      }
      if (orphanBeats && orphanBeats.length > 0) {
        content += `
`;
        content += `> [!info] Orphan Beats (not yet associated with this scene)
`;
        content += `> You can associate these beats with this scene by moving them here.

`;
        for (const beat of orphanBeats) {
          const beatFileName = this.generateBeatFileName(beat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
          content += `- [[${beatLinkName}|Beat ${beat.order_num}: ${beatDisplayText}]]
`;
        }
      }
      content += `
`;
    }
    const sceneFileName = this.generateSceneFileName(scene);
    const sceneLinkName = sceneFileName.replace(/\.md$/, "");
    const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
    content += `## Scene: [[${sceneLinkName}|${sceneDisplayText}]]

`;
    if (proseBlocks && proseBlocks.length > 0) {
      const sortedProseBlocks = [...proseBlocks].sort((a, b) => a.order_num - b.order_num);
      for (const proseBlock of sortedProseBlocks) {
        const fileName = this.generateProseBlockFileName(proseBlock);
        const linkName = fileName.replace(/\.md$/, "");
        content += `[[${linkName}|${proseBlock.content}]]

`;
      }
    }
    for (const beat of beats.sort((a, b) => a.order_num - b.order_num)) {
      const beatFileName = this.generateBeatFileName(beat);
      const beatLinkName = beatFileName.replace(/\.md$/, "");
      const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
      content += `### Beat: [[${beatLinkName}|${beatDisplayText}]]

`;
    }
    const file = this.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian5.TFile) {
      await this.vault.modify(file, content);
    } else {
      await this.vault.create(filePath, content);
    }
  }
  // Write beat file
  async writeBeatFile(beat, filePath, storyName, proseBlocks) {
    const baseFields = {
      id: beat.id,
      scene_id: beat.scene_id,
      order_num: beat.order_num,
      type: beat.type,
      intent: beat.intent || "",
      outcome: beat.outcome || "",
      created_at: beat.created_at,
      updated_at: beat.updated_at
    };
    const frontmatter = this.generateFrontmatter(baseFields, void 0, {
      entityType: "beat",
      storyName,
      date: beat.created_at
    });
    let content = `${frontmatter}
# Beat ${beat.order_num} - ${beat.type}

`;
    if (beat.intent) {
      content += `**Intent:** ${beat.intent}

`;
    }
    if (beat.outcome) {
      content += `**Outcome:** ${beat.outcome}

`;
    }
    const beatFileName = this.generateBeatFileName(beat);
    const beatLinkName = beatFileName.replace(/\.md$/, "");
    const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
    content += `## Beat: [[${beatLinkName}|${beatDisplayText}]]

`;
    if (proseBlocks && proseBlocks.length > 0) {
      const sortedProseBlocks = [...proseBlocks].sort((a, b) => a.order_num - b.order_num);
      for (const proseBlock of sortedProseBlocks) {
        const fileName = this.generateProseBlockFileName(proseBlock);
        const linkName = fileName.replace(/\.md$/, "");
        content += `[[${linkName}|${proseBlock.content}]]

`;
      }
    }
    const file = this.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian5.TFile) {
      await this.vault.modify(file, content);
    } else {
      await this.vault.create(filePath, content);
    }
  }
  // List all chapter files in a story folder
  async listChapterFiles(storyFolderPath) {
    const chaptersPath = `${storyFolderPath}/chapters`;
    const folder = this.vault.getAbstractFileByPath(chaptersPath);
    if (!(folder instanceof import_obsidian5.TFolder)) {
      return [];
    }
    const chapterFiles = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian5.TFile && child.extension === "md") {
        chapterFiles.push(child.path);
      }
    }
    return chapterFiles.sort();
  }
  // List all scene files in a chapter folder
  async listSceneFiles(chapterFolderPath) {
    const scenesPath = `${chapterFolderPath}/scenes`;
    const folder = this.vault.getAbstractFileByPath(scenesPath);
    if (!(folder instanceof import_obsidian5.TFolder)) {
      return [];
    }
    const sceneFiles = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian5.TFile && child.extension === "md") {
        sceneFiles.push(child.path);
      }
    }
    return sceneFiles.sort();
  }
  // List all scene files in a story folder
  async listStorySceneFiles(storyFolderPath) {
    const scenesPath = `${storyFolderPath}/scenes`;
    const folder = this.vault.getAbstractFileByPath(scenesPath);
    if (!(folder instanceof import_obsidian5.TFolder)) {
      return [];
    }
    const sceneFiles = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian5.TFile && child.extension === "md") {
        sceneFiles.push(child.path);
      }
    }
    return sceneFiles.sort();
  }
  // List all beat files in a story folder
  async listStoryBeatFiles(storyFolderPath) {
    const beatsPath = `${storyFolderPath}/beats`;
    const folder = this.vault.getAbstractFileByPath(beatsPath);
    if (!(folder instanceof import_obsidian5.TFolder)) {
      return [];
    }
    const beatFiles = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian5.TFile && child.extension === "md") {
        beatFiles.push(child.path);
      }
    }
    return beatFiles.sort();
  }
  // List all beat files in a scene folder
  async listBeatFiles(sceneFolderPath) {
    const beatsPath = `${sceneFolderPath}/beats`;
    const folder = this.vault.getAbstractFileByPath(beatsPath);
    if (!(folder instanceof import_obsidian5.TFolder)) {
      return [];
    }
    const beatFiles = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian5.TFile && child.extension === "md") {
        beatFiles.push(child.path);
      }
    }
    return beatFiles.sort();
  }
  // Generate filename for prose block based on date and content preview
  generateProseBlockFileName(proseBlock) {
    const date = new Date(proseBlock.created_at);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    const hours = String(date.getHours()).padStart(2, "0");
    const minutes = String(date.getMinutes()).padStart(2, "0");
    const dateStr = `${year}-${month}-${day}T${hours}-${minutes}`;
    const contentPreview = proseBlock.content.substring(0, 30).trim().replace(/[<>:"/\\|?*\n\r\t]/g, "-").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "").toLowerCase();
    const textPart = contentPreview || "prose-block";
    return `${dateStr}_${textPart}.md`;
  }
  // Organize prose blocks by their associations (chapter, scene, beat)
  organizeProseBlocks(proseBlocks, proseBlockRefs, scenes) {
    const organization = {
      chapterOnly: [],
      byScene: /* @__PURE__ */ new Map(),
      byBeat: /* @__PURE__ */ new Map()
    };
    const proseBlockRefsByProseBlock = /* @__PURE__ */ new Map();
    for (const ref of proseBlockRefs) {
      if (!proseBlockRefsByProseBlock.has(ref.prose_block_id)) {
        proseBlockRefsByProseBlock.set(ref.prose_block_id, []);
      }
      proseBlockRefsByProseBlock.get(ref.prose_block_id).push(ref);
    }
    const sceneMap = /* @__PURE__ */ new Map();
    const beatMap = /* @__PURE__ */ new Map();
    for (const { scene, beats } of scenes) {
      sceneMap.set(scene.id, scene);
      for (const beat of beats) {
        beatMap.set(beat.id, beat);
      }
    }
    const sortedProseBlocks = [...proseBlocks].sort((a, b) => a.order_num - b.order_num);
    for (const proseBlock of sortedProseBlocks) {
      const refs = proseBlockRefsByProseBlock.get(proseBlock.id) || [];
      const sceneRef = refs.find((r) => r.entity_type === "scene");
      const beatRef = refs.find((r) => r.entity_type === "beat");
      if (beatRef && beatMap.has(beatRef.entity_id)) {
        const beat = beatMap.get(beatRef.entity_id);
        if (!organization.byBeat.has(beat.id)) {
          organization.byBeat.set(beat.id, { beat, proseBlocks: [] });
        }
        organization.byBeat.get(beat.id).proseBlocks.push(proseBlock);
      } else if (sceneRef && sceneMap.has(sceneRef.entity_id)) {
        const scene = sceneMap.get(sceneRef.entity_id);
        if (!organization.byScene.has(scene.id)) {
          organization.byScene.set(scene.id, { scene, proseBlocks: [] });
        }
        organization.byScene.get(scene.id).proseBlocks.push(proseBlock);
      } else {
        organization.chapterOnly.push(proseBlock);
      }
    }
    return organization;
  }
  // Generate filename for scene based on date and goal
  generateSceneFileName(scene) {
    const date = new Date(scene.created_at);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    const hours = String(date.getHours()).padStart(2, "0");
    const minutes = String(date.getMinutes()).padStart(2, "0");
    const dateStr = `${year}-${month}-${day}T${hours}-${minutes}`;
    const goalSanitized = (scene.goal || "scene").trim().replace(/[<>:"/\\|?*\n\r\t]/g, "-").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "").toLowerCase();
    return `${dateStr}_${goalSanitized}.md`;
  }
  // Generate filename for beat based on date and intent
  generateBeatFileName(beat) {
    const date = new Date(beat.created_at);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    const hours = String(date.getHours()).padStart(2, "0");
    const minutes = String(date.getMinutes()).padStart(2, "0");
    const dateStr = `${year}-${month}-${day}T${hours}-${minutes}`;
    const intentSanitized = (beat.intent || "beat").trim().replace(/[<>:"/\\|?*\n\r\t]/g, "-").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "").toLowerCase();
    return `${dateStr}_${intentSanitized}.md`;
  }
  // Write prose block file
  async writeProseBlockFile(proseBlock, filePath, storyName) {
    const baseFields = {
      id: proseBlock.id,
      chapter_id: proseBlock.chapter_id,
      order_num: proseBlock.order_num,
      kind: proseBlock.kind,
      word_count: proseBlock.word_count,
      created_at: proseBlock.created_at,
      updated_at: proseBlock.updated_at
    };
    const frontmatter = this.generateFrontmatter(baseFields, void 0, {
      entityType: "prose-block",
      storyName,
      date: proseBlock.created_at
    });
    const content = `${frontmatter}${proseBlock.content}`;
    const file = this.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian5.TFile) {
      await this.vault.modify(file, content);
    } else {
      await this.vault.create(filePath, content);
    }
  }
  // Read prose block from file
  async readProseBlockFromFile(filePath) {
    const file = this.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian5.TFile)) {
      return null;
    }
    try {
      const content = await this.vault.read(file);
      const frontmatter = this.parseFrontmatter(content);
      const contentMatch = content.match(/^---\n[\s\S]*?\n---\n([\s\S]*)$/);
      const proseContent = contentMatch ? contentMatch[1].trim() : "";
      if (!frontmatter.id) {
        return null;
      }
      return {
        id: frontmatter.id,
        chapter_id: frontmatter.chapter_id || "",
        order_num: parseInt(frontmatter.order_num || "0", 10),
        kind: frontmatter.kind || "final",
        content: proseContent,
        word_count: parseInt(frontmatter.word_count || "0", 10),
        created_at: frontmatter.created_at || "",
        updated_at: frontmatter.updated_at || ""
      };
    } catch (err) {
      console.error(`Failed to read prose block from ${filePath}:`, err);
      return null;
    }
  }
};

// src/sync/syncService.ts
var import_obsidian7 = require("obsidian");

// src/sync/proseBlockParser.ts
function parseHierarchicalProse(chapterContent) {
  const sections = [];
  const frontmatterMatch = chapterContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = chapterContent.substring(contentStart).trim();
  const chapterSectionMatch = bodyContent.match(/##\s+Chapter\s+\d+:\s+[^\n]+\s*\n+([\s\S]*?)(?=\n##\s+Chapter\s+\d+:|$)/);
  if (!chapterSectionMatch) {
    const chapterSectionMatchSameLine = bodyContent.match(/##\s+Chapter\s+\d+:\s+[^\n]+\s+([^\n]+)/);
    if (chapterSectionMatchSameLine) {
      const proseContent2 = chapterSectionMatchSameLine[1].trim();
      if (proseContent2.length > 0 && !proseContent2.startsWith("#")) {
        const paragraph = {
          content: proseContent2,
          linkName: null,
          originalOrder: 0
        };
        sections.push({
          type: "prose",
          prose: paragraph,
          originalOrder: 0
        });
      }
      return { sections };
    }
    return { sections: [] };
  }
  const proseContent = chapterSectionMatch[1].trim();
  const lines = proseContent.split(/\n/);
  let currentScene = null;
  let currentBeat = null;
  let order = 0;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line) {
      continue;
    }
    const sceneMatch = line.match(/^##\s+Scene:\s*(.+)$/);
    if (sceneMatch) {
      const sceneText = sceneMatch[1].trim();
      const parsedScene = parseSceneHeader(sceneText);
      parsedScene.originalOrder = order++;
      currentScene = parsedScene;
      currentBeat = null;
      sections.push({
        type: "scene",
        scene: parsedScene,
        originalOrder: parsedScene.originalOrder
      });
      continue;
    }
    const beatMatch = line.match(/^###\s+Beat:\s*(.+)$/);
    if (beatMatch) {
      const beatText = beatMatch[1].trim();
      const parsedBeat = parseBeatHeader(beatText);
      parsedBeat.originalOrder = order++;
      currentBeat = parsedBeat;
      sections.push({
        type: "beat",
        beat: parsedBeat,
        originalOrder: parsedBeat.originalOrder
      });
      continue;
    }
    if (line.startsWith("#") && !line.match(/^##\s+Scene:/) && !line.match(/^###\s+Beat:/)) {
      continue;
    }
    const proseMatch = line.match(/^\s*\[\[([^\|]+)\|([^\]]+)\]\]\s*$/);
    if (proseMatch) {
      const linkName = proseMatch[1].trim();
      const content = proseMatch[2].trim();
      const paragraph = {
        content,
        linkName,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
      continue;
    }
    if (line.length > 0 && !line.startsWith("#")) {
      const paragraph = {
        content: line,
        linkName: null,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
    }
  }
  return { sections };
}
function parseSceneHeader(text) {
  const linkMatch = text.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
  if (linkMatch) {
    const linkName = linkMatch[1].trim();
    const displayText = linkMatch[2].trim();
    const { goal: goal2, timeRef: timeRef2 } = parseSceneText(displayText);
    return {
      linkName,
      goal: goal2,
      timeRef: timeRef2,
      originalOrder: 0
      // Will be set by caller
    };
  }
  const simpleLinkMatch = text.match(/^\[\[([^\]]+)\]\]$/);
  if (simpleLinkMatch) {
    return {
      linkName: simpleLinkMatch[1].trim(),
      goal: "",
      timeRef: "",
      originalOrder: 0
    };
  }
  const { goal, timeRef } = parseSceneText(text);
  return {
    linkName: null,
    goal,
    timeRef,
    originalOrder: 0
  };
}
function parseSceneText(text) {
  const parts = text.split(/\s*-\s*/);
  if (parts.length >= 2) {
    return {
      goal: parts[0].trim(),
      timeRef: parts.slice(1).join(" - ").trim()
      // Join in case there are multiple "-"
    };
  }
  return {
    goal: text.trim(),
    timeRef: ""
  };
}
function parseBeatHeader(text) {
  const linkMatch = text.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
  if (linkMatch) {
    const linkName = linkMatch[1].trim();
    const displayText = linkMatch[2].trim();
    const { intent: intent2, outcome: outcome2 } = parseBeatText(displayText);
    return {
      linkName,
      intent: intent2,
      outcome: outcome2,
      originalOrder: 0
      // Will be set by caller
    };
  }
  const simpleLinkMatch = text.match(/^\[\[([^\]]+)\]\]$/);
  if (simpleLinkMatch) {
    return {
      linkName: simpleLinkMatch[1].trim(),
      intent: "",
      outcome: "",
      originalOrder: 0
    };
  }
  const { intent, outcome } = parseBeatText(text);
  return {
    linkName: null,
    intent,
    outcome,
    originalOrder: 0
  };
}
function parseBeatText(text) {
  const parts = text.split(/\s*->\s*/);
  if (parts.length >= 2) {
    return {
      intent: parts[0].trim(),
      outcome: parts.slice(1).join(" -> ").trim()
      // Join in case there are multiple "->"
    };
  }
  return {
    intent: text.trim(),
    outcome: ""
  };
}
function compareProseBlocks(paragraph, localProseBlock, remoteProseBlock) {
  const paragraphContent = paragraph.content.trim();
  if (!paragraph.linkName) {
    if (remoteProseBlock && remoteProseBlock.content.trim() === paragraphContent) {
      if (localProseBlock && localProseBlock.id === remoteProseBlock.id) {
        return "unchanged";
      }
      return "unchanged";
    }
    return "new";
  }
  if (!localProseBlock) {
    if (remoteProseBlock && remoteProseBlock.content.trim() === paragraphContent) {
      return "remote_modified";
    }
    return "new";
  }
  if (!remoteProseBlock) {
    return "local_modified";
  }
  const localContent = localProseBlock.content.trim();
  const remoteContent = remoteProseBlock.content.trim();
  if (localContent === paragraphContent && remoteContent === paragraphContent) {
    return "unchanged";
  }
  if (paragraphContent !== localContent && paragraphContent !== remoteContent && localContent === remoteContent) {
    return "local_modified";
  }
  if (localContent === paragraphContent && remoteContent !== paragraphContent) {
    return "remote_modified";
  }
  if (paragraphContent !== localContent && paragraphContent !== remoteContent && localContent !== remoteContent) {
    return "conflict";
  }
  if (paragraphContent === remoteContent && localContent !== remoteContent) {
    return "remote_modified";
  }
  return "conflict";
}
function parseSceneBeatList(chapterContent) {
  const items = [];
  const frontmatterMatch = chapterContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = chapterContent.substring(contentStart).trim();
  const listSectionMatch = bodyContent.match(/##\s+Scenes\s+&\s+Beats\s*\n+([\s\S]*?)(?=\n##|$)/);
  if (!listSectionMatch) {
    return { items: [] };
  }
  const listContent = listSectionMatch[1].trim();
  const lines = listContent.split(/\n/);
  let order = 0;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    const itemMatch = trimmedLine.match(/^([+-])\s+(.+)$/);
    if (!itemMatch) {
      continue;
    }
    const hasProse = itemMatch[1] === "+";
    const itemText = itemMatch[2].trim();
    const tabMatch = line.match(/^(\t*)/);
    const indentLevel = tabMatch ? tabMatch[1].length : 0;
    const isBeat = indentLevel > 0;
    const linkMatch = itemText.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
    let linkName = null;
    let displayText;
    if (linkMatch) {
      linkName = linkMatch[1].trim();
      displayText = linkMatch[2].trim();
    } else {
      displayText = itemText;
    }
    items.push({
      type: isBeat ? "beat" : "scene",
      linkName,
      displayText,
      hasProse,
      indentLevel: isBeat ? 1 : 0,
      originalOrder: order++
    });
  }
  return { items };
}
function parseChapterList(storyContent) {
  const items = [];
  const frontmatterMatch = storyContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = storyContent.substring(contentStart).trim();
  const listSectionMatch = bodyContent.match(/##\s+Chapters(?:,\s*Scenes\s*&\s*Beats)?\s*\n+([\s\S]*?)(?=\n##|$)/);
  if (!listSectionMatch) {
    return { items: [] };
  }
  const listContent = listSectionMatch[1].trim();
  const lines = listContent.split(/\n/);
  let order = 0;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    const itemMatch = trimmedLine.match(/^([+-])\s+(.+)$/);
    if (!itemMatch) {
      continue;
    }
    const hasProse = itemMatch[1] === "+";
    const itemText = itemMatch[2].trim();
    const tabMatch = line.match(/^(\t*)/);
    const indentLevel = tabMatch ? tabMatch[1].length : 0;
    let type;
    if (indentLevel === 0) {
      type = "chapter";
    } else if (indentLevel === 1) {
      type = "scene";
    } else if (indentLevel === 2) {
      type = "beat";
    } else {
      continue;
    }
    const linkMatch = itemText.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
    let linkName = null;
    let displayText;
    if (linkMatch) {
      linkName = linkMatch[1].trim();
      displayText = linkMatch[2].trim();
    } else {
      displayText = itemText;
    }
    items.push({
      type,
      linkName,
      displayText,
      hasProse,
      indentLevel: indentLevel / 2,
      // Normalize to 0, 1, 2
      originalOrder: order++
    });
  }
  return { items };
}
function parseBeatList(sceneContent) {
  const items = [];
  const frontmatterMatch = sceneContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = sceneContent.substring(contentStart).trim();
  const listSectionMatch = bodyContent.match(/##\s+Beats\s*\n+([\s\S]*?)(?=\n##|$)/);
  if (!listSectionMatch) {
    return { items: [] };
  }
  const listContent = listSectionMatch[1].trim();
  const lines = listContent.split(/\n/);
  let order = 0;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    if (trimmedLine.startsWith(">")) {
      continue;
    }
    const itemMatch = trimmedLine.match(/^([+-])\s+(.+)$/);
    if (!itemMatch) {
      continue;
    }
    const hasProse = itemMatch[1] === "+";
    const itemText = itemMatch[2].trim();
    const linkMatch = itemText.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
    let linkName = null;
    let displayText;
    if (linkMatch) {
      linkName = linkMatch[1].trim();
      displayText = linkMatch[2].trim();
    } else {
      displayText = itemText;
    }
    items.push({
      linkName,
      displayText,
      hasProse,
      originalOrder: order++
    });
  }
  return { items };
}
function parseOrphanScenesList(storyContent) {
  const items = [];
  const frontmatterMatch = storyContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = storyContent.substring(contentStart).trim();
  const listSectionMatch = bodyContent.match(/##\s+Orphan\s+Scenes\s*\n+([\s\S]*?)(?=\n##|$)/);
  if (!listSectionMatch) {
    return { items: [] };
  }
  const listContent = listSectionMatch[1].trim();
  const lines = listContent.split(/\n/);
  let order = 0;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    if (trimmedLine.startsWith(">")) {
      continue;
    }
    const itemMatch = trimmedLine.match(/^([+-])\s+(.+)$/);
    if (!itemMatch) {
      continue;
    }
    const hasProse = itemMatch[1] === "+";
    const itemText = itemMatch[2].trim();
    const tabMatch = line.match(/^(\t*)/);
    const indentLevel = tabMatch ? tabMatch[1].length : 0;
    const isBeat = indentLevel > 0;
    const linkMatch = itemText.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
    let linkName = null;
    let displayText;
    if (linkMatch) {
      linkName = linkMatch[1].trim();
      displayText = linkMatch[2].trim();
    } else {
      displayText = itemText;
    }
    items.push({
      type: isBeat ? "beat" : "scene",
      linkName,
      displayText,
      hasProse,
      indentLevel: isBeat ? 1 : 0,
      originalOrder: order++
    });
  }
  return { items };
}
function parseOrphanBeatsList(storyContent) {
  const items = [];
  const frontmatterMatch = storyContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = storyContent.substring(contentStart).trim();
  const listSectionMatch = bodyContent.match(/##\s+Orphan\s+Beats\s*\n+([\s\S]*?)(?=\n##|$)/);
  if (!listSectionMatch) {
    return { items: [] };
  }
  const listContent = listSectionMatch[1].trim();
  const lines = listContent.split(/\n/);
  let order = 0;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    if (trimmedLine.startsWith(">")) {
      continue;
    }
    const itemMatch = trimmedLine.match(/^([+-])\s+(.+)$/);
    if (!itemMatch) {
      continue;
    }
    const hasProse = itemMatch[1] === "+";
    const itemText = itemMatch[2].trim();
    const linkMatch = itemText.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
    let linkName = null;
    let displayText;
    if (linkMatch) {
      linkName = linkMatch[1].trim();
      displayText = linkMatch[2].trim();
    } else {
      displayText = itemText;
    }
    items.push({
      linkName,
      displayText,
      hasProse,
      originalOrder: order++
    });
  }
  return { items };
}
function parseStoryProse(storyContent) {
  const sections = [];
  const frontmatterMatch = storyContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = storyContent.substring(contentStart).trim();
  const storyHeaderMatch = bodyContent.match(/^(#\s+Story:\s*.+)$/m);
  const chapterHeaderMatch = bodyContent.match(/^(##\s+Chapter\s*\d*:\s*.+)$/m);
  let proseStartIndex = -1;
  if (storyHeaderMatch) {
    proseStartIndex = bodyContent.indexOf(storyHeaderMatch[0]);
  } else if (chapterHeaderMatch) {
    proseStartIndex = bodyContent.indexOf(chapterHeaderMatch[0]);
  }
  if (proseStartIndex === -1) {
    return { sections: [] };
  }
  const proseContent = bodyContent.substring(proseStartIndex);
  const lines = proseContent.split(/\n/);
  let order = 0;
  let currentChapter = null;
  let currentScene = null;
  let currentBeat = null;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    if (trimmedLine.startsWith(">")) {
      continue;
    }
    const storyMatch = trimmedLine.match(/^#\s+Story:\s*(.+)$/i);
    if (storyMatch) {
      continue;
    }
    const chapterMatch = trimmedLine.match(/^##\s+Chapter\s*\d*:\s*(.+)$/i);
    if (chapterMatch) {
      const chapterText = chapterMatch[1].trim();
      const linkMatch = chapterText.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
      if (linkMatch) {
        currentChapter = {
          linkName: linkMatch[1].trim(),
          title: linkMatch[2].trim()
        };
      } else {
        currentChapter = {
          linkName: null,
          title: chapterText
        };
      }
      currentScene = null;
      currentBeat = null;
      continue;
    }
    const sceneMatch = trimmedLine.match(/^###\s+Scene:\s*(.+)$/i);
    if (sceneMatch) {
      const sceneText = sceneMatch[1].trim();
      currentScene = parseSceneHeaderText(sceneText);
      currentScene.originalOrder = order++;
      sections.push({
        type: "scene",
        scene: currentScene,
        originalOrder: currentScene.originalOrder
      });
      currentBeat = null;
      continue;
    }
    const beatMatch = trimmedLine.match(/^####\s+Beat:\s*(.+)$/i);
    if (beatMatch) {
      const beatText = beatMatch[1].trim();
      currentBeat = parseBeatHeaderText(beatText);
      currentBeat.originalOrder = order++;
      sections.push({
        type: "beat",
        beat: currentBeat,
        originalOrder: currentBeat.originalOrder
      });
      continue;
    }
    if (trimmedLine.startsWith("#")) {
      continue;
    }
    if (trimmedLine.match(/^[+-]\s+/)) {
      continue;
    }
    const proseMatch = trimmedLine.match(/^\s*\[\[([^\|]+)\|([^\]]+)\]\]\s*$/);
    if (proseMatch) {
      const linkName = proseMatch[1].trim();
      const content = proseMatch[2].trim();
      const paragraph = {
        content,
        linkName,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
      continue;
    }
    if (trimmedLine.length > 0) {
      const paragraph = {
        content: trimmedLine,
        linkName: null,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
    }
  }
  return { sections };
}
function parseSceneHeaderText(text) {
  const linkMatch = text.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
  if (linkMatch) {
    const linkName = linkMatch[1].trim();
    const displayText = linkMatch[2].trim();
    const parts2 = displayText.split(/\s*-\s*/);
    return {
      linkName,
      goal: parts2[0].trim(),
      timeRef: parts2.length > 1 ? parts2.slice(1).join(" - ").trim() : "",
      originalOrder: 0
    };
  }
  const simpleLinkMatch = text.match(/^\[\[([^\]]+)\]\]$/);
  if (simpleLinkMatch) {
    return {
      linkName: simpleLinkMatch[1].trim(),
      goal: "",
      timeRef: "",
      originalOrder: 0
    };
  }
  const parts = text.split(/\s*-\s*/);
  return {
    linkName: null,
    goal: parts[0].trim(),
    timeRef: parts.length > 1 ? parts.slice(1).join(" - ").trim() : "",
    originalOrder: 0
  };
}
function parseBeatHeaderText(text) {
  const linkMatch = text.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
  if (linkMatch) {
    const linkName = linkMatch[1].trim();
    const displayText = linkMatch[2].trim();
    const parts2 = displayText.split(/\s*->\s*/);
    return {
      linkName,
      intent: parts2[0].trim(),
      outcome: parts2.length > 1 ? parts2.slice(1).join(" -> ").trim() : "",
      originalOrder: 0
    };
  }
  const simpleLinkMatch = text.match(/^\[\[([^\]]+)\]\]$/);
  if (simpleLinkMatch) {
    return {
      linkName: simpleLinkMatch[1].trim(),
      intent: "",
      outcome: "",
      originalOrder: 0
    };
  }
  const parts = text.split(/\s*->\s*/);
  return {
    linkName: null,
    intent: parts[0].trim(),
    outcome: parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "",
    originalOrder: 0
  };
}
function parseSceneProse(sceneContent) {
  const sections = [];
  const frontmatterMatch = sceneContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = sceneContent.substring(contentStart).trim();
  const sceneHeaderMatch = bodyContent.match(/^(###\s+Scene:\s*.+)$/m);
  const beatHeaderMatch = bodyContent.match(/^(#{3,4}\s+Beat:\s*.+)$/m);
  let proseStartIndex = -1;
  if (sceneHeaderMatch) {
    proseStartIndex = bodyContent.indexOf(sceneHeaderMatch[0]);
  } else if (beatHeaderMatch) {
    proseStartIndex = bodyContent.indexOf(beatHeaderMatch[0]);
  } else {
    const beatsListEnd = bodyContent.match(/##\s+Beats\s*\n+[\s\S]*?(?=\n###|\n####|\n[^#\-\+>\s]|$)/);
    if (beatsListEnd) {
      proseStartIndex = bodyContent.indexOf(beatsListEnd[0]) + beatsListEnd[0].length;
    } else {
      const firstNonListContent = bodyContent.match(/(?:^|\n)([^#\-\+>\s\n].+)/);
      if (firstNonListContent) {
        proseStartIndex = bodyContent.indexOf(firstNonListContent[1]);
      }
    }
  }
  if (proseStartIndex === -1) {
    return { sections: [] };
  }
  const proseContent = bodyContent.substring(proseStartIndex);
  const lines = proseContent.split(/\n/);
  let order = 0;
  let currentBeat = null;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    if (trimmedLine.startsWith(">")) {
      continue;
    }
    const sceneMatch = trimmedLine.match(/^###\s+Scene:\s*(.+)$/i);
    if (sceneMatch) {
      const sceneText = sceneMatch[1].trim();
      const parsedScene = parseSceneHeaderText(sceneText);
      parsedScene.originalOrder = order++;
      sections.push({
        type: "scene",
        scene: parsedScene,
        originalOrder: parsedScene.originalOrder
      });
      currentBeat = null;
      continue;
    }
    const beatMatch = trimmedLine.match(/^#{3,4}\s+Beat:\s*(.+)$/i);
    if (beatMatch) {
      const beatText = beatMatch[1].trim();
      currentBeat = parseBeatHeaderText(beatText);
      currentBeat.originalOrder = order++;
      sections.push({
        type: "beat",
        beat: currentBeat,
        originalOrder: currentBeat.originalOrder
      });
      continue;
    }
    if (trimmedLine.startsWith("#")) {
      continue;
    }
    if (trimmedLine.match(/^[+-]\s+/)) {
      continue;
    }
    const proseMatch = trimmedLine.match(/^\s*\[\[([^\|]+)\|([^\]]+)\]\]\s*$/);
    if (proseMatch) {
      const linkName = proseMatch[1].trim();
      const content = proseMatch[2].trim();
      const paragraph = {
        content,
        linkName,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
      continue;
    }
    if (trimmedLine.length > 0) {
      const paragraph = {
        content: trimmedLine,
        linkName: null,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
    }
  }
  return { sections };
}
function parseBeatProse(beatContent) {
  const sections = [];
  const frontmatterMatch = beatContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = beatContent.substring(contentStart).trim();
  const beatHeaderMatch = bodyContent.match(/^(##\s+Beat:\s*.+)$/m);
  let proseStartIndex = -1;
  if (beatHeaderMatch) {
    proseStartIndex = bodyContent.indexOf(beatHeaderMatch[0]);
  }
  if (proseStartIndex === -1) {
    return { sections: [] };
  }
  const proseContent = bodyContent.substring(proseStartIndex);
  const lines = proseContent.split(/\n/);
  let order = 0;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    if (trimmedLine.startsWith(">")) {
      continue;
    }
    const beatMatch = trimmedLine.match(/^##\s+Beat:\s*(.+)$/i);
    if (beatMatch) {
      continue;
    }
    if (trimmedLine.startsWith("#")) {
      continue;
    }
    if (trimmedLine.match(/^[+-]\s+/)) {
      continue;
    }
    const proseMatch = trimmedLine.match(/^\s*\[\[([^\|]+)\|([^\]]+)\]\]\s*$/);
    if (proseMatch) {
      const linkName = proseMatch[1].trim();
      const content = proseMatch[2].trim();
      const paragraph = {
        content,
        linkName,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
      continue;
    }
    if (trimmedLine.length > 0) {
      const paragraph = {
        content: trimmedLine,
        linkName: null,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
    }
  }
  return { sections };
}

// src/views/modals/ConflictModal.ts
var import_obsidian6 = require("obsidian");
var ConflictModal = class extends import_obsidian6.Modal {
  constructor(app, localProseBlock, remoteProseBlock, onResolve) {
    super(app);
    this.resolution = null;
    this.localProseBlock = localProseBlock;
    this.remoteProseBlock = remoteProseBlock;
    this.onResolve = onResolve;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", {
      text: "Prose Block Conflict"
    });
    contentEl.createEl("p", {
      text: "This prose block has been modified both locally and remotely. Choose how to resolve the conflict:"
    });
    const diffContainer = contentEl.createDiv("conflict-diff-container");
    const localDiv = diffContainer.createDiv("conflict-local");
    localDiv.createEl("h3", { text: "Local Version" });
    const localContent = localDiv.createEl("pre", {
      text: this.localProseBlock.content,
      cls: "conflict-content"
    });
    localContent.style.whiteSpace = "pre-wrap";
    localContent.style.maxHeight = "200px";
    localContent.style.overflow = "auto";
    localContent.style.border = "1px solid var(--background-modifier-border)";
    localContent.style.padding = "10px";
    localContent.style.borderRadius = "4px";
    const remoteDiv = diffContainer.createDiv("conflict-remote");
    remoteDiv.createEl("h3", { text: "Remote Version" });
    const remoteContent = remoteDiv.createEl("pre", {
      text: this.remoteProseBlock.content,
      cls: "conflict-content"
    });
    remoteContent.style.whiteSpace = "pre-wrap";
    remoteContent.style.maxHeight = "200px";
    remoteContent.style.overflow = "auto";
    remoteContent.style.border = "1px solid var(--background-modifier-border)";
    remoteContent.style.padding = "10px";
    remoteContent.style.borderRadius = "4px";
    const manualDiv = contentEl.createDiv("conflict-manual");
    manualDiv.createEl("h3", { text: "Manual Merge (Optional)" });
    const manualTextarea = manualDiv.createEl("textarea", {
      text: this.localProseBlock.content,
      cls: "conflict-manual-input"
    });
    manualTextarea.style.width = "100%";
    manualTextarea.style.minHeight = "150px";
    manualTextarea.style.padding = "10px";
    manualTextarea.style.border = "1px solid var(--background-modifier-border)";
    manualTextarea.style.borderRadius = "4px";
    manualTextarea.style.fontFamily = "var(--font-monospace)";
    const buttonContainer = contentEl.createDiv("conflict-buttons");
    buttonContainer.style.marginTop = "20px";
    buttonContainer.style.display = "flex";
    buttonContainer.style.gap = "10px";
    const useLocalBtn = buttonContainer.createEl("button", {
      text: "Use Local",
      cls: "mod-cta"
    });
    useLocalBtn.onclick = async () => {
      this.resolution = { resolution: "local" };
      await this.onResolve(this.resolution);
      this.close();
    };
    const useRemoteBtn = buttonContainer.createEl("button", {
      text: "Use Remote"
    });
    useRemoteBtn.onclick = async () => {
      this.resolution = { resolution: "remote" };
      await this.onResolve(this.resolution);
      this.close();
    };
    const useManualBtn = buttonContainer.createEl("button", {
      text: "Use Manual Merge",
      cls: "mod-primary"
    });
    useManualBtn.onclick = async () => {
      this.resolution = {
        resolution: "manual",
        mergedContent: manualTextarea.value
      };
      await this.onResolve(this.resolution);
      this.close();
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/sync/syncService.ts
var SyncService = class {
  constructor(apiClient, fileManager, settings, app) {
    this.apiClient = apiClient;
    this.fileManager = fileManager;
    this.settings = settings;
    this.app = app;
  }
  // Pull story from service to Obsidian (Service  Obsidian)
  async pullStory(storyId) {
    try {
      const storyData = await this.apiClient.getStoryWithHierarchy(storyId);
      const folderPath = this.fileManager.getStoryFolderPath(
        storyData.story.title
      );
      const allScenes = await this.apiClient.getScenesByStory(storyId);
      const orphanScenes = [];
      for (const scene of allScenes) {
        if (!scene.chapter_id) {
          const beats = await this.apiClient.getBeats(scene.id);
          orphanScenes.push({ scene, beats });
        }
      }
      orphanScenes.sort((a, b) => a.scene.order_num - b.scene.order_num);
      const allBeats = await this.apiClient.getBeatsByStory(storyId);
      const orphanBeats = [];
      const sceneIdSet = new Set(allScenes.map((s) => s.id));
      for (const beat of allBeats) {
        if (!beat.scene_id || !sceneIdSet.has(beat.scene_id)) {
          orphanBeats.push(beat);
        }
      }
      orphanBeats.sort((a, b) => a.order_num - b.order_num);
      const chapterProseData = /* @__PURE__ */ new Map();
      for (const chapterWithContent of storyData.chapters) {
        const proseBlocks = await this.apiClient.getProseBlocks(chapterWithContent.chapter.id);
        const proseBlockRefs = [];
        for (const proseBlock of proseBlocks) {
          const refs = await this.apiClient.getProseBlockReferences(proseBlock.id);
          proseBlockRefs.push(...refs);
        }
        chapterProseData.set(chapterWithContent.chapter.id, { proseBlocks, proseBlockRefs });
      }
      await this.fileManager.writeStoryMetadata(
        storyData.story,
        folderPath,
        storyData.chapters,
        orphanScenes,
        orphanBeats,
        chapterProseData
      );
      const proseBlocksFolderPath = `${folderPath}/prose-blocks`;
      await this.fileManager.ensureFolderExists(proseBlocksFolderPath);
      const chaptersFolderPath = `${folderPath}/chapters`;
      await this.fileManager.ensureFolderExists(chaptersFolderPath);
      for (const chapterWithContent of storyData.chapters) {
        const proseData = chapterProseData.get(chapterWithContent.chapter.id);
        const proseBlocks = (proseData == null ? void 0 : proseData.proseBlocks) || [];
        const proseBlockRefs = (proseData == null ? void 0 : proseData.proseBlockRefs) || [];
        for (const proseBlock of proseBlocks) {
          const proseBlockFileName = this.fileManager.generateProseBlockFileName(proseBlock);
          const proseBlockFilePath = `${proseBlocksFolderPath}/${proseBlockFileName}`;
          await this.fileManager.writeProseBlockFile(
            proseBlock,
            proseBlockFilePath,
            storyData.story.title
          );
        }
        const chapterFileName = `Chapter-${chapterWithContent.chapter.number}.md`;
        const chapterFilePath = `${chaptersFolderPath}/${chapterFileName}`;
        await this.fileManager.writeChapterFile(
          chapterWithContent,
          chapterFilePath,
          storyData.story.title,
          proseBlocks,
          proseBlockRefs,
          orphanScenes
          // Include orphan scenes for easy association
        );
        const scenesFolderPath2 = `${folderPath}/scenes`;
        await this.fileManager.ensureFolderExists(scenesFolderPath2);
        for (const { scene, beats } of chapterWithContent.scenes) {
          const sceneProseBlocks = await this.apiClient.getProseBlocksByScene(scene.id);
          const sceneFileName = this.fileManager.generateSceneFileName(scene);
          const sceneFilePath = `${scenesFolderPath2}/${sceneFileName}`;
          await this.fileManager.writeSceneFile(
            { scene, beats },
            sceneFilePath,
            storyData.story.title,
            sceneProseBlocks,
            orphanBeats
            // Include orphan beats for easy association
          );
          const beatsFolderPath2 = `${folderPath}/beats`;
          await this.fileManager.ensureFolderExists(beatsFolderPath2);
          for (const beat of beats) {
            const beatProseBlocks = await this.apiClient.getProseBlocksByBeat(beat.id);
            const beatFileName = this.fileManager.generateBeatFileName(beat);
            const beatFilePath = `${beatsFolderPath2}/${beatFileName}`;
            await this.fileManager.writeBeatFile(beat, beatFilePath, storyData.story.title, beatProseBlocks);
          }
        }
      }
      const scenesFolderPath = `${folderPath}/scenes`;
      await this.fileManager.ensureFolderExists(scenesFolderPath);
      for (const { scene, beats } of orphanScenes) {
        const sceneProseBlocks = await this.apiClient.getProseBlocksByScene(scene.id);
        const sceneFileName = this.fileManager.generateSceneFileName(scene);
        const sceneFilePath = `${scenesFolderPath}/${sceneFileName}`;
        await this.fileManager.writeSceneFile(
          { scene, beats },
          sceneFilePath,
          storyData.story.title,
          sceneProseBlocks,
          orphanBeats
          // Include orphan beats for easy association
        );
        const beatsFolderPath2 = `${folderPath}/beats`;
        await this.fileManager.ensureFolderExists(beatsFolderPath2);
        for (const beat of beats) {
          const beatProseBlocks = await this.apiClient.getProseBlocksByBeat(beat.id);
          const beatFileName = this.fileManager.generateBeatFileName(beat);
          const beatFilePath = `${beatsFolderPath2}/${beatFileName}`;
          await this.fileManager.writeBeatFile(beat, beatFilePath, storyData.story.title, beatProseBlocks);
        }
      }
      const beatsFolderPath = `${folderPath}/beats`;
      await this.fileManager.ensureFolderExists(beatsFolderPath);
      for (const beat of orphanBeats) {
        const beatProseBlocks = await this.apiClient.getProseBlocksByBeat(beat.id);
        const beatFileName = this.fileManager.generateBeatFileName(beat);
        const beatFilePath = `${beatsFolderPath}/${beatFileName}`;
        await this.fileManager.writeBeatFile(beat, beatFilePath, storyData.story.title, beatProseBlocks);
      }
      const existingMetadata = await this.fileManager.readStoryMetadata(folderPath).catch(() => null);
      if (existingMetadata && existingMetadata.frontmatter.version !== void 0 && existingMetadata.frontmatter.version !== storyData.story.version_number) {
        await this.fileManager.createVersionSnapshot(
          folderPath,
          existingMetadata.frontmatter.version
        );
      }
      await this.syncVersionHistory(storyData.story.root_story_id, folderPath);
      new import_obsidian7.Notice(`Story "${storyData.story.title}" synced successfully`);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to sync story";
      new import_obsidian7.Notice(`Error syncing story: ${errorMessage}`, 5e3);
      throw err;
    }
  }
  // Sync all previous versions of a story
  async syncVersionHistory(rootStoryId, storyFolderPath) {
    try {
      const allStories = await this.apiClient.listStories();
      const versions = allStories.filter((s) => s.root_story_id === rootStoryId);
      versions.sort((a, b) => a.version_number - b.version_number);
      const versionsPath = `${storyFolderPath}/versions`;
      await this.fileManager.ensureFolderExists(versionsPath);
      for (const versionStory of versions) {
        const currentVersion = versions[versions.length - 1].version_number;
        if (versionStory.version_number === currentVersion) {
          continue;
        }
        const versionFolderPath = `${versionsPath}/v${versionStory.version_number}`;
        const existingVersionFolder = this.fileManager.getVault().getAbstractFileByPath(
          versionFolderPath
        );
        if (existingVersionFolder) {
          console.log(`Version v${versionStory.version_number} already exists, skipping`);
          continue;
        }
        const versionData = await this.apiClient.getStoryWithHierarchy(
          versionStory.id
        );
        await this.fileManager.ensureFolderExists(versionFolderPath);
        await this.fileManager.writeStoryMetadata(
          versionData.story,
          versionFolderPath
        );
        const versionProseBlocksFolderPath = `${versionFolderPath}/prose-blocks`;
        await this.fileManager.ensureFolderExists(versionProseBlocksFolderPath);
        const versionChaptersPath = `${versionFolderPath}/chapters`;
        await this.fileManager.ensureFolderExists(versionChaptersPath);
        for (const chapterWithContent of versionData.chapters) {
          const proseBlocks = await this.apiClient.getProseBlocks(chapterWithContent.chapter.id);
          const proseBlockRefs = [];
          for (const proseBlock of proseBlocks) {
            const refs = await this.apiClient.getProseBlockReferences(proseBlock.id);
            proseBlockRefs.push(...refs);
          }
          for (const proseBlock of proseBlocks) {
            const proseBlockFileName = this.fileManager.generateProseBlockFileName(proseBlock);
            const proseBlockFilePath = `${versionProseBlocksFolderPath}/${proseBlockFileName}`;
            await this.fileManager.writeProseBlockFile(
              proseBlock,
              proseBlockFilePath,
              versionData.story.title
            );
          }
          const chapterFileName = `Chapter-${chapterWithContent.chapter.number}.md`;
          const chapterFilePath = `${versionChaptersPath}/${chapterFileName}`;
          await this.fileManager.writeChapterFile(
            chapterWithContent,
            chapterFilePath,
            versionData.story.title,
            proseBlocks,
            proseBlockRefs
          );
          const versionScenesPath = `${versionFolderPath}/scenes`;
          await this.fileManager.ensureFolderExists(versionScenesPath);
          for (const { scene, beats } of chapterWithContent.scenes) {
            const sceneProseBlocks = await this.apiClient.getProseBlocksByScene(scene.id);
            const sceneFileName = this.fileManager.generateSceneFileName(scene);
            const sceneFilePath = `${versionScenesPath}/${sceneFileName}`;
            await this.fileManager.writeSceneFile(
              { scene, beats },
              sceneFilePath,
              versionData.story.title,
              sceneProseBlocks
            );
            const versionBeatsPath = `${versionFolderPath}/beats`;
            await this.fileManager.ensureFolderExists(versionBeatsPath);
            for (const beat of beats) {
              const beatProseBlocks = await this.apiClient.getProseBlocksByBeat(beat.id);
              const beatFileName = this.fileManager.generateBeatFileName(beat);
              const beatFilePath = `${versionBeatsPath}/${beatFileName}`;
              await this.fileManager.writeBeatFile(beat, beatFilePath, versionData.story.title, beatProseBlocks);
            }
          }
        }
        console.log(`Synced version v${versionStory.version_number}`);
      }
    } catch (err) {
      console.error("Error syncing version history:", err);
    }
  }
  // Pull all stories
  async pullAllStories() {
    if (!this.settings.tenantId) {
      throw new Error("Tenant ID is required");
    }
    const stories = await this.apiClient.listStories();
    for (const story of stories) {
      try {
        await this.pullStory(story.id);
      } catch (err) {
        console.error(`Failed to sync story ${story.id}:`, err);
      }
    }
    new import_obsidian7.Notice(`Synced ${stories.length} stories`);
  }
  // Push story from Obsidian to service (Obsidian  Service)
  async pushStory(folderPath) {
    try {
      const { frontmatter: storyFrontmatter } = await this.fileManager.readStoryMetadata(folderPath);
      if (!storyFrontmatter.id) {
        throw new Error("Story metadata missing ID");
      }
      const storyId = storyFrontmatter.id;
      const storyFilePath = `${folderPath}/story.md`;
      const storyFile = this.fileManager.getVault().getAbstractFileByPath(storyFilePath);
      if (storyFile instanceof import_obsidian7.TFile) {
        const storyContent = await this.fileManager.getVault().read(storyFile);
        const chapterList = parseChapterList(storyContent);
        if (chapterList.items.length > 0) {
          await this.processChapterList(chapterList, storyId);
        }
        const orphanScenesList = parseOrphanScenesList(storyContent);
        if (orphanScenesList.items.length > 0) {
          await this.processOrphanScenesList(orphanScenesList, storyId);
        }
        const orphanBeatsList = parseOrphanBeatsList(storyContent);
        if (orphanBeatsList.items.length > 0) {
          await this.processOrphanBeatsList(orphanBeatsList, storyId);
        }
        const storyProse = parseStoryProse(storyContent);
        if (storyProse.sections.length > 0) {
          await this.pushStoryProseBlocks(storyFilePath, folderPath, storyId);
        }
      }
      await this.apiClient.updateStory(
        storyId,
        storyFrontmatter.title,
        storyFrontmatter.status
      );
      const chapterFiles = await this.fileManager.listChapterFiles(folderPath);
      for (const chapterFilePath of chapterFiles) {
        console.log(`Would update chapter: ${chapterFilePath}`);
      }
      for (const chapterFilePath of chapterFiles) {
        await this.pushChapterProseBlocks(chapterFilePath, folderPath);
      }
      const sceneFiles = await this.fileManager.listStorySceneFiles(folderPath);
      for (const sceneFilePath of sceneFiles) {
        await this.pushSceneBeats(sceneFilePath, storyId);
        await this.pushSceneProseBlocks(sceneFilePath, folderPath);
      }
      const beatFiles = await this.fileManager.listStoryBeatFiles(folderPath);
      for (const beatFilePath of beatFiles) {
        await this.pushBeatProseBlocks(beatFilePath, folderPath);
      }
      new import_obsidian7.Notice(`Story "${storyFrontmatter.title}" pushed successfully`);
      try {
        new import_obsidian7.Notice(`Syncing story "${storyFrontmatter.title}" from service...`);
        await this.pullStory(storyId);
        new import_obsidian7.Notice(`Story "${storyFrontmatter.title}" synced successfully`);
      } catch (pullErr) {
        const pullErrorMessage = pullErr instanceof Error ? pullErr.message : "Failed to sync story after push";
        new import_obsidian7.Notice(`Warning: ${pullErrorMessage}`, 5e3);
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to push story";
      new import_obsidian7.Notice(`Error pushing story: ${errorMessage}`, 5e3);
      throw err;
    }
  }
  // Push prose blocks from a chapter file (hierarchical structure)
  async pushChapterProseBlocks(chapterFilePath, storyFolderPath) {
    const file = this.fileManager.getVault().getAbstractFileByPath(chapterFilePath);
    if (!(file instanceof import_obsidian7.TFile)) {
      throw new Error(`Chapter file not found: ${chapterFilePath}`);
    }
    const chapterContent = await this.fileManager.getVault().read(file);
    const frontmatter = this.fileManager.parseFrontmatter(chapterContent);
    if (!frontmatter.id || !frontmatter.story_id) {
      throw new Error("Chapter metadata missing ID or story_id");
    }
    const chapterId = frontmatter.id;
    const storyId = frontmatter.story_id;
    const proseBlocksFolderPath = `${storyFolderPath}/prose-blocks`;
    const sceneBeatList = parseSceneBeatList(chapterContent);
    await this.processSceneBeatList(sceneBeatList, chapterId, storyId);
    const remoteProseBlocks = await this.apiClient.getProseBlocks(chapterId);
    const remoteProseBlocksMap = /* @__PURE__ */ new Map();
    for (const pb of remoteProseBlocks) {
      remoteProseBlocksMap.set(pb.id, pb);
    }
    const existingScenes = await this.apiClient.getScenes(chapterId);
    const sceneMap = /* @__PURE__ */ new Map();
    const sceneIdMap = /* @__PURE__ */ new Map();
    for (const scene of existingScenes) {
      const fileName = this.fileManager.generateSceneFileName(scene);
      const linkName = fileName.replace(/\.md$/, "");
      sceneMap.set(linkName, scene);
      sceneIdMap.set(scene.id, scene);
    }
    const beatMap = /* @__PURE__ */ new Map();
    const beatIdMap = /* @__PURE__ */ new Map();
    for (const scene of existingScenes) {
      const beats = await this.apiClient.getBeats(scene.id);
      for (const beat of beats) {
        const fileName = this.fileManager.generateBeatFileName(beat);
        const linkName = fileName.replace(/\.md$/, "");
        beatMap.set(linkName, beat);
        beatIdMap.set(beat.id, beat);
      }
    }
    const hierarchical = parseHierarchicalProse(chapterContent);
    const updatedSections = [];
    let currentScene = null;
    let currentBeat = null;
    let proseOrderNum = 1;
    let sceneOrderNum = existingScenes.length > 0 ? Math.max(...existingScenes.map((s) => s.order_num)) + 1 : 1;
    for (const section of hierarchical.sections) {
      if (section.type === "scene" && section.scene) {
        const { scene: parsedScene } = section;
        if (parsedScene.linkName) {
          currentScene = sceneMap.get(parsedScene.linkName) || null;
          if (!currentScene) {
            currentScene = sceneIdMap.get(parsedScene.linkName) || null;
          }
          if (currentScene) {
            if (parsedScene.goal !== currentScene.goal || parsedScene.timeRef !== currentScene.time_ref) {
              currentScene = await this.apiClient.updateScene(currentScene.id, {
                goal: parsedScene.goal,
                time_ref: parsedScene.timeRef
              });
            }
          }
        } else {
          currentScene = await this.apiClient.createScene({
            story_id: storyId,
            chapter_id: chapterId,
            order_num: sceneOrderNum++,
            goal: parsedScene.goal,
            time_ref: parsedScene.timeRef
          });
          const sceneFileName = this.fileManager.generateSceneFileName(currentScene);
          const sceneLinkName = sceneFileName.replace(/\.md$/, "");
          sceneMap.set(sceneLinkName, currentScene);
          sceneIdMap.set(currentScene.id, currentScene);
        }
        if (currentScene) {
          const sceneFileName = this.fileManager.generateSceneFileName(currentScene);
          const sceneLinkName = sceneFileName.replace(/\.md$/, "");
          const sceneDisplayText = currentScene.time_ref ? `${currentScene.goal} - ${currentScene.time_ref}` : currentScene.goal;
          updatedSections.push(`## Scene: [[${sceneLinkName}|${sceneDisplayText}]]`);
        }
        currentBeat = null;
      } else if (section.type === "beat" && section.beat) {
        const { beat: parsedBeat } = section;
        if (!currentScene) {
          throw new Error("Beat found without a parent scene");
        }
        if (parsedBeat.linkName) {
          currentBeat = beatMap.get(parsedBeat.linkName) || null;
          if (!currentBeat) {
            currentBeat = beatIdMap.get(parsedBeat.linkName) || null;
          }
          if (currentBeat) {
            if (parsedBeat.intent !== currentBeat.intent || parsedBeat.outcome !== currentBeat.outcome) {
              currentBeat = await this.apiClient.updateBeat(currentBeat.id, {
                intent: parsedBeat.intent,
                outcome: parsedBeat.outcome
              });
            }
          }
        } else {
          const existingBeats = await this.apiClient.getBeats(currentScene.id);
          const beatOrderNum = existingBeats.length > 0 ? Math.max(...existingBeats.map((b) => b.order_num)) + 1 : 1;
          currentBeat = await this.apiClient.createBeat({
            scene_id: currentScene.id,
            order_num: beatOrderNum,
            type: "setup",
            // Default type
            intent: parsedBeat.intent,
            outcome: parsedBeat.outcome
          });
          const beatFileName = this.fileManager.generateBeatFileName(currentBeat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          beatMap.set(beatLinkName, currentBeat);
          beatIdMap.set(currentBeat.id, currentBeat);
        }
        if (currentBeat) {
          const beatFileName = this.fileManager.generateBeatFileName(currentBeat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          const beatDisplayText = currentBeat.outcome ? `${currentBeat.intent} -> ${currentBeat.outcome}` : currentBeat.intent;
          updatedSections.push(`### Beat: [[${beatLinkName}|${beatDisplayText}]]`);
        }
      } else if (section.type === "prose" && section.prose) {
        const { prose: paragraph } = section;
        let localProseBlock = null;
        let remoteProseBlock = null;
        if (paragraph.linkName) {
          const proseBlockFilePath = `${proseBlocksFolderPath}/${paragraph.linkName}.md`;
          localProseBlock = await this.fileManager.readProseBlockFromFile(proseBlockFilePath);
          if (!localProseBlock) {
            localProseBlock = await this.findProseBlockByContent(proseBlocksFolderPath, paragraph.content);
          }
          if (localProseBlock) {
            remoteProseBlock = remoteProseBlocksMap.get(localProseBlock.id) || null;
          } else {
            const normalizedContent = paragraph.content.trim();
            for (const [id, remotePB] of remoteProseBlocksMap.entries()) {
              if (remotePB.content.trim() === normalizedContent) {
                remoteProseBlock = remotePB;
                break;
              }
            }
          }
        } else {
          localProseBlock = await this.findProseBlockByContent(proseBlocksFolderPath, paragraph.content);
          const normalizedContent = paragraph.content.trim();
          for (const [id, remotePB] of remoteProseBlocksMap.entries()) {
            if (remotePB.content.trim() === normalizedContent) {
              remoteProseBlock = remotePB;
              if (!localProseBlock) {
                localProseBlock = await this.findProseBlockById(proseBlocksFolderPath, remotePB.id);
              }
              break;
            }
          }
        }
        const status = compareProseBlocks(paragraph, localProseBlock, remoteProseBlock);
        let finalProseBlock;
        switch (status) {
          case "new": {
            finalProseBlock = await this.apiClient.createProseBlock(chapterId, {
              order_num: proseOrderNum++,
              kind: "final",
              content: paragraph.content
            });
            const fileName = this.fileManager.generateProseBlockFileName(finalProseBlock);
            const filePath = `${proseBlocksFolderPath}/${fileName}`;
            await this.fileManager.writeProseBlockFile(finalProseBlock, filePath, void 0);
            if (currentScene) {
              await this.apiClient.createProseBlockReference(finalProseBlock.id, "scene", currentScene.id);
            }
            if (currentBeat) {
              await this.apiClient.createProseBlockReference(finalProseBlock.id, "beat", currentBeat.id);
            }
            const linkName = fileName.replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
            break;
          }
          case "unchanged": {
            if (!localProseBlock && remoteProseBlock) {
              finalProseBlock = remoteProseBlock;
              const fileName = this.fileManager.generateProseBlockFileName(finalProseBlock);
              const filePath = `${proseBlocksFolderPath}/${fileName}`;
              await this.fileManager.writeProseBlockFile(finalProseBlock, filePath, void 0);
            } else if (localProseBlock) {
              if (localProseBlock.order_num !== proseOrderNum) {
                finalProseBlock = await this.apiClient.updateProseBlock(localProseBlock.id, {
                  order_num: proseOrderNum++
                });
                const fileName = this.fileManager.generateProseBlockFileName(finalProseBlock);
                const filePath = `${proseBlocksFolderPath}/${fileName}`;
                await this.fileManager.writeProseBlockFile(finalProseBlock, filePath, void 0);
              } else {
                finalProseBlock = localProseBlock;
                proseOrderNum++;
              }
            } else {
              finalProseBlock = remoteProseBlock;
              proseOrderNum++;
            }
            if (finalProseBlock) {
              const existingRefs = await this.apiClient.getProseBlockReferences(finalProseBlock.id);
              const hasSceneRef = existingRefs.some((r) => r.entity_type === "scene" && r.entity_id === (currentScene == null ? void 0 : currentScene.id));
              const hasBeatRef = existingRefs.some((r) => r.entity_type === "beat" && r.entity_id === (currentBeat == null ? void 0 : currentBeat.id));
              if (currentScene && !hasSceneRef) {
                await this.apiClient.createProseBlockReference(finalProseBlock.id, "scene", currentScene.id);
              }
              if (currentBeat && !hasBeatRef) {
                await this.apiClient.createProseBlockReference(finalProseBlock.id, "beat", currentBeat.id);
              }
            }
            if (paragraph.linkName) {
              updatedSections.push(`[[${paragraph.linkName}|${paragraph.content}]]`);
            } else {
              const fileName = this.fileManager.generateProseBlockFileName(finalProseBlock);
              const linkName = fileName.replace(/\.md$/, "");
              updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
            }
            break;
          }
          case "local_modified": {
            finalProseBlock = await this.apiClient.updateProseBlock(localProseBlock.id, {
              content: paragraph.content,
              order_num: proseOrderNum++
            });
            const fileName = this.fileManager.generateProseBlockFileName(finalProseBlock);
            const filePath = `${proseBlocksFolderPath}/${fileName}`;
            await this.fileManager.writeProseBlockFile(finalProseBlock, filePath, void 0);
            if (finalProseBlock) {
              const existingRefs = await this.apiClient.getProseBlockReferences(finalProseBlock.id);
              const hasSceneRef = existingRefs.some((r) => r.entity_type === "scene" && r.entity_id === (currentScene == null ? void 0 : currentScene.id));
              const hasBeatRef = existingRefs.some((r) => r.entity_type === "beat" && r.entity_id === (currentBeat == null ? void 0 : currentBeat.id));
              if (currentScene && !hasSceneRef) {
                await this.apiClient.createProseBlockReference(finalProseBlock.id, "scene", currentScene.id);
              }
              if (currentBeat && !hasBeatRef) {
                await this.apiClient.createProseBlockReference(finalProseBlock.id, "beat", currentBeat.id);
              }
            }
            const linkName = fileName.replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
            break;
          }
          case "remote_modified": {
            finalProseBlock = remoteProseBlock;
            const fileName = this.fileManager.generateProseBlockFileName(finalProseBlock);
            const filePath = `${proseBlocksFolderPath}/${fileName}`;
            await this.fileManager.writeProseBlockFile(finalProseBlock, filePath, void 0);
            if (finalProseBlock) {
              const existingRefs = await this.apiClient.getProseBlockReferences(finalProseBlock.id);
              const hasSceneRef = existingRefs.some((r) => r.entity_type === "scene" && r.entity_id === (currentScene == null ? void 0 : currentScene.id));
              const hasBeatRef = existingRefs.some((r) => r.entity_type === "beat" && r.entity_id === (currentBeat == null ? void 0 : currentBeat.id));
              if (currentScene && !hasSceneRef) {
                await this.apiClient.createProseBlockReference(finalProseBlock.id, "scene", currentScene.id);
              }
              if (currentBeat && !hasBeatRef) {
                await this.apiClient.createProseBlockReference(finalProseBlock.id, "beat", currentBeat.id);
              }
            }
            const linkName = fileName.replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${finalProseBlock.content}]]`);
            new import_obsidian7.Notice(`Prose block updated from remote: ${linkName}`, 3e3);
            proseOrderNum++;
            break;
          }
          case "conflict": {
            const resolution = await this.resolveConflict(localProseBlock, remoteProseBlock);
            let resolvedContent;
            if (resolution.resolution === "local") {
              resolvedContent = paragraph.content;
            } else if (resolution.resolution === "remote") {
              resolvedContent = remoteProseBlock.content;
            } else {
              resolvedContent = resolution.mergedContent || paragraph.content;
            }
            finalProseBlock = await this.apiClient.updateProseBlock(localProseBlock.id, {
              content: resolvedContent,
              order_num: proseOrderNum++
            });
            const fileName = this.fileManager.generateProseBlockFileName(finalProseBlock);
            const filePath = `${proseBlocksFolderPath}/${fileName}`;
            await this.fileManager.writeProseBlockFile(finalProseBlock, filePath, void 0);
            if (finalProseBlock) {
              const existingRefs = await this.apiClient.getProseBlockReferences(finalProseBlock.id);
              const hasSceneRef = existingRefs.some((r) => r.entity_type === "scene" && r.entity_id === (currentScene == null ? void 0 : currentScene.id));
              const hasBeatRef = existingRefs.some((r) => r.entity_type === "beat" && r.entity_id === (currentBeat == null ? void 0 : currentBeat.id));
              if (currentScene && !hasSceneRef) {
                await this.apiClient.createProseBlockReference(finalProseBlock.id, "scene", currentScene.id);
              }
              if (currentBeat && !hasBeatRef) {
                await this.apiClient.createProseBlockReference(finalProseBlock.id, "beat", currentBeat.id);
              }
            }
            const linkName = fileName.replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${resolvedContent}]]`);
            break;
          }
        }
      }
    }
    await this.updateChapterFile(chapterContent, updatedSections, file, frontmatter, existingScenes, beatMap, remoteProseBlocks, chapterId);
  }
  // Update chapter file with both scene/beat list and chapter content
  async updateChapterFile(originalContent, updatedSections, file, frontmatter, scenes, beatMap, proseBlocks, chapterId) {
    const allProseBlockRefs = [];
    for (const proseBlock of proseBlocks) {
      const refs = await this.apiClient.getProseBlockReferences(proseBlock.id);
      allProseBlockRefs.push(...refs);
    }
    const proseRefsByScene = /* @__PURE__ */ new Map();
    const proseRefsByBeat = /* @__PURE__ */ new Map();
    for (const ref of allProseBlockRefs) {
      if (ref.entity_type === "scene") {
        if (!proseRefsByScene.has(ref.entity_id)) {
          proseRefsByScene.set(ref.entity_id, []);
        }
        proseRefsByScene.get(ref.entity_id).push(ref);
      } else if (ref.entity_type === "beat") {
        if (!proseRefsByBeat.has(ref.entity_id)) {
          proseRefsByBeat.set(ref.entity_id, []);
        }
        proseRefsByBeat.get(ref.entity_id).push(ref);
      }
    }
    const sceneBeatListItems = [];
    for (const scene of scenes.sort((a, b) => a.order_num - b.order_num)) {
      const sceneFileName = this.fileManager.generateSceneFileName(scene);
      const sceneLinkName = sceneFileName.replace(/\.md$/, "");
      const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
      const sceneProseRefs = proseRefsByScene.get(scene.id) || [];
      const sceneProseBlockIds = new Set(sceneProseRefs.map((r) => r.prose_block_id));
      const hasSceneProse = Array.from(sceneProseBlockIds).some((proseBlockId) => {
        const blockRefs = allProseBlockRefs.filter((r) => r.prose_block_id === proseBlockId);
        return !blockRefs.some((r) => r.entity_type === "beat");
      });
      const sceneMarker = hasSceneProse ? "+" : "-";
      sceneBeatListItems.push(`${sceneMarker} [[${sceneLinkName}|Scene ${scene.order_num}: ${sceneDisplayText}]]`);
      const sceneBeats = [];
      for (const [linkName, beat] of beatMap.entries()) {
        if (beat.scene_id === scene.id) {
          sceneBeats.push(beat);
        }
      }
      for (const beat of sceneBeats.sort((a, b) => a.order_num - b.order_num)) {
        const beatFileName = this.fileManager.generateBeatFileName(beat);
        const beatLinkName = beatFileName.replace(/\.md$/, "");
        const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
        const beatProseRefs = proseRefsByBeat.get(beat.id) || [];
        const hasBeatProse = beatProseRefs.length > 0;
        const beatMarker = hasBeatProse ? "+" : "-";
        sceneBeatListItems.push(`	${beatMarker} [[${beatLinkName}|Beat ${beat.order_num}: ${beatDisplayText}]]`);
      }
    }
    const frontmatterMatch = originalContent.match(/^---\n([\s\S]*?)\n---/);
    const frontmatterText = frontmatterMatch ? frontmatterMatch[0] : "";
    const bodyStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
    const bodyContent = originalContent.substring(bodyStart).trim();
    const chapterNumber = frontmatter.number || "1";
    const chapterTitle = frontmatter.title || "Untitled";
    const listSectionMatch = bodyContent.match(/([\s\S]*?##\s+Scenes\s+&\s+Beats\s*\n+)([\s\S]*?)(?=\n##|$)/);
    const updatedListSection = `## Scenes & Beats

${sceneBeatListItems.join("\n")}

`;
    let updatedBody;
    if (listSectionMatch) {
      const beforeList = listSectionMatch[1];
      const afterList = bodyContent.substring(listSectionMatch.index + listSectionMatch[0].length);
      updatedBody = `${beforeList}${updatedListSection}${afterList}`;
    } else {
      const titleMatch = bodyContent.match(/(#\s+[^\n]+\n+)([\s\S]*)/);
      if (titleMatch) {
        updatedBody = `${titleMatch[1]}${updatedListSection}${titleMatch[2]}`;
      } else {
        updatedBody = `${updatedListSection}${bodyContent}`;
      }
    }
    const chapterHeaderPattern = `##\\s+Chapter\\s+${chapterNumber}:\\s+[^\\n]+`;
    const chapterSectionMatch = updatedBody.match(new RegExp(`([\\s\\S]*?${chapterHeaderPattern}\\s*\\n+)([\\s\\S]*?)(?=\\n##\\s+Chapter\\s+\\d+:|$)`, "i"));
    if (!chapterSectionMatch) {
      const newChapterSection = `

## Chapter ${chapterNumber}: ${chapterTitle}

${updatedSections.join("\n\n")}

`;
      updatedBody = `${updatedBody}${newChapterSection}`;
    } else {
      const beforeChapter = chapterSectionMatch[1];
      const afterChapter = updatedBody.substring(chapterSectionMatch.index + chapterSectionMatch[0].length);
      const newChapterContent = updatedSections.join("\n\n");
      updatedBody = `${beforeChapter}${newChapterContent}

${afterChapter}`;
    }
    const updatedContent = `${frontmatterText}
${updatedBody}`;
    await this.fileManager.getVault().modify(file, updatedContent);
  }
  // Process the "## Chapters, Scenes & Beats" list and update order
  async processChapterList(list, storyId) {
    const existingChapters = await this.apiClient.getChapters(storyId);
    const chapterMap = /* @__PURE__ */ new Map();
    const chapterIdMap = /* @__PURE__ */ new Map();
    for (const chapter of existingChapters) {
      const fileName = `Chapter-${chapter.number}.md`;
      const linkName = fileName.replace(/\.md$/, "");
      chapterMap.set(linkName, chapter);
      chapterIdMap.set(chapter.id, chapter);
    }
    let currentChapter = null;
    let currentScene = null;
    let chapterOrderNum = 1;
    const sceneOrderNums = /* @__PURE__ */ new Map();
    const beatOrderNums = /* @__PURE__ */ new Map();
    for (const item of list.items) {
      if (item.type === "chapter") {
        let title;
        let chapterNumber = null;
        const chapterMatch = item.displayText.match(/Chapter\s+(\d+):\s*(.+)/);
        if (chapterMatch) {
          chapterNumber = parseInt(chapterMatch[1], 10);
          title = chapterMatch[2].trim();
        } else {
          title = item.displayText.trim();
        }
        currentScene = null;
        sceneOrderNums.set("current", 1);
        if (item.linkName) {
          currentChapter = chapterMap.get(item.linkName) || null;
          if (!currentChapter) {
            currentChapter = chapterIdMap.get(item.linkName) || null;
          }
          if (currentChapter) {
            const needsOrderUpdate = currentChapter.number !== chapterOrderNum;
            const needsTitleUpdate = title !== currentChapter.title;
            if (needsOrderUpdate || needsTitleUpdate) {
              currentChapter = await this.apiClient.updateChapter(currentChapter.id, {
                number: chapterOrderNum,
                title: needsTitleUpdate ? title : void 0
              });
              const fileName = `Chapter-${currentChapter.number}.md`;
              const linkName = fileName.replace(/\.md$/, "");
              chapterMap.set(linkName, currentChapter);
              chapterIdMap.set(currentChapter.id, currentChapter);
            }
          }
        } else {
          if (title) {
            currentChapter = await this.apiClient.createChapter(storyId, {
              number: chapterOrderNum,
              title,
              status: "draft"
            });
            const fileName = `Chapter-${currentChapter.number}.md`;
            const linkName = fileName.replace(/\.md$/, "");
            chapterMap.set(linkName, currentChapter);
            chapterIdMap.set(currentChapter.id, currentChapter);
          }
        }
        if (currentChapter) {
          sceneOrderNums.set(currentChapter.id, 1);
        }
        chapterOrderNum++;
      } else if (item.type === "scene" && currentChapter) {
        let goal;
        let timeRef = "";
        const sceneMatch = item.displayText.match(/Scene\s+\d+:\s*(.+)/);
        if (sceneMatch) {
          const sceneText = sceneMatch[1].trim();
          const parts = sceneText.split(/\s*-\s*/);
          goal = parts[0].trim();
          timeRef = parts.length > 1 ? parts.slice(1).join(" - ").trim() : "";
        } else {
          const parts = item.displayText.split(/\s*-\s*/);
          goal = parts[0].trim();
          timeRef = parts.length > 1 ? parts.slice(1).join(" - ").trim() : "";
        }
        const currentSceneOrderNum = sceneOrderNums.get(currentChapter.id) || 1;
        currentScene = null;
        if (item.linkName) {
          const existingScenes = await this.apiClient.getScenes(currentChapter.id);
          const sceneMap = /* @__PURE__ */ new Map();
          const sceneIdMap = /* @__PURE__ */ new Map();
          for (const scene of existingScenes) {
            const fileName = this.fileManager.generateSceneFileName(scene);
            const linkName = fileName.replace(/\.md$/, "");
            sceneMap.set(linkName, scene);
            sceneIdMap.set(scene.id, scene);
          }
          currentScene = sceneMap.get(item.linkName) || null;
          if (!currentScene) {
            currentScene = sceneIdMap.get(item.linkName) || null;
          }
          if (currentScene) {
            const needsOrderUpdate = currentScene.order_num !== currentSceneOrderNum;
            const needsContentUpdate = goal !== currentScene.goal || timeRef !== currentScene.time_ref;
            const needsChapterUpdate = currentScene.chapter_id !== currentChapter.id;
            if (needsOrderUpdate || needsContentUpdate || needsChapterUpdate) {
              currentScene = await this.apiClient.updateScene(currentScene.id, {
                goal,
                time_ref: timeRef,
                order_num: currentSceneOrderNum,
                chapter_id: currentChapter.id
              });
            }
            const existingBeats = await this.apiClient.getBeats(currentScene.id);
            if (existingBeats.length === 0) {
              beatOrderNums.set(currentScene.id, 1);
            } else {
              const maxOrderNum = Math.max(...existingBeats.map((b) => b.order_num));
              beatOrderNums.set(currentScene.id, maxOrderNum + 1);
            }
          }
        } else {
          currentScene = await this.apiClient.createScene({
            story_id: storyId,
            chapter_id: currentChapter.id,
            order_num: currentSceneOrderNum,
            goal,
            time_ref: timeRef
          });
          beatOrderNums.set(currentScene.id, 1);
        }
        sceneOrderNums.set(currentChapter.id, currentSceneOrderNum + 1);
      } else if (item.type === "beat" && currentScene) {
        let intent;
        let outcome = "";
        const beatMatch = item.displayText.match(/Beat\s+\d+:\s*(.+)/);
        if (beatMatch) {
          const beatText = beatMatch[1].trim();
          const parts = beatText.split(/\s*->\s*/);
          intent = parts[0].trim();
          outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
        } else {
          const parts = item.displayText.split(/\s*->\s*/);
          intent = parts[0].trim();
          outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
        }
        const currentBeatOrderNum = beatOrderNums.get(currentScene.id) || 1;
        if (item.linkName) {
          const existingBeats = await this.apiClient.getBeats(currentScene.id);
          const beatMap = /* @__PURE__ */ new Map();
          const beatIdMap = /* @__PURE__ */ new Map();
          for (const beat of existingBeats) {
            const fileName = this.fileManager.generateBeatFileName(beat);
            const linkName = fileName.replace(/\.md$/, "");
            beatMap.set(linkName, beat);
            beatIdMap.set(beat.id, beat);
          }
          let currentBeat = beatMap.get(item.linkName) || null;
          if (!currentBeat) {
            currentBeat = beatIdMap.get(item.linkName) || null;
          }
          if (currentBeat) {
            const needsOrderUpdate = currentBeat.order_num !== currentBeatOrderNum;
            const needsContentUpdate = intent !== currentBeat.intent || outcome !== currentBeat.outcome;
            const needsSceneUpdate = currentBeat.scene_id !== currentScene.id;
            if (needsOrderUpdate || needsContentUpdate || needsSceneUpdate) {
              currentBeat = await this.apiClient.updateBeat(currentBeat.id, {
                intent,
                outcome,
                order_num: currentBeatOrderNum,
                scene_id: currentScene.id
              });
            }
          }
        } else {
          await this.apiClient.createBeat({
            scene_id: currentScene.id,
            order_num: currentBeatOrderNum,
            type: "setup",
            // Default type
            intent,
            outcome
          });
        }
        beatOrderNums.set(currentScene.id, currentBeatOrderNum + 1);
      }
    }
  }
  // Process the "## Beats" list from a scene file and update beat order
  async pushSceneBeats(sceneFilePath, storyId) {
    const file = this.fileManager.getVault().getAbstractFileByPath(sceneFilePath);
    if (!(file instanceof import_obsidian7.TFile)) {
      return;
    }
    const sceneContent = await this.fileManager.getVault().read(file);
    const frontmatter = this.fileManager.parseFrontmatter(sceneContent);
    if (!frontmatter.id) {
      return;
    }
    const sceneId = frontmatter.id;
    const beatList = parseBeatList(sceneContent);
    if (beatList.items.length === 0) {
      return;
    }
    const existingBeats = await this.apiClient.getBeats(sceneId);
    const beatMap = /* @__PURE__ */ new Map();
    const beatIdMap = /* @__PURE__ */ new Map();
    for (const beat of existingBeats) {
      const fileName = this.fileManager.generateBeatFileName(beat);
      const linkName = fileName.replace(/\.md$/, "");
      beatMap.set(linkName, beat);
      beatIdMap.set(beat.id, beat);
    }
    let beatOrderNum = 1;
    for (const item of beatList.items) {
      let intent;
      let outcome = "";
      const beatMatch = item.displayText.match(/Beat\s+\d+:\s*(.+)/);
      if (beatMatch) {
        const beatText = beatMatch[1].trim();
        const parts = beatText.split(/\s*->\s*/);
        intent = parts[0].trim();
        outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
      } else {
        const parts = item.displayText.split(/\s*->\s*/);
        intent = parts[0].trim();
        outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
      }
      if (item.linkName) {
        let currentBeat = beatMap.get(item.linkName) || null;
        if (!currentBeat) {
          currentBeat = beatIdMap.get(item.linkName) || null;
        }
        if (currentBeat) {
          const needsOrderUpdate = currentBeat.order_num !== beatOrderNum;
          const needsContentUpdate = intent !== currentBeat.intent || outcome !== currentBeat.outcome;
          if (needsOrderUpdate || needsContentUpdate) {
            currentBeat = await this.apiClient.updateBeat(currentBeat.id, {
              intent,
              outcome,
              order_num: beatOrderNum
            });
          }
        }
      } else {
        await this.apiClient.createBeat({
          scene_id: sceneId,
          order_num: beatOrderNum,
          type: "setup",
          // Default type
          intent,
          outcome
        });
      }
      beatOrderNum++;
    }
  }
  // Push prose blocks from a story file with hierarchical structure
  // Format: # Story: title, ## Chapter: title, ### Scene: title, #### Beat: title
  async pushStoryProseBlocks(storyFilePath, storyFolderPath, storyId) {
    const file = this.fileManager.getVault().getAbstractFileByPath(storyFilePath);
    if (!(file instanceof import_obsidian7.TFile)) {
      throw new Error(`Story file not found: ${storyFilePath}`);
    }
    const storyContent = await this.fileManager.getVault().read(file);
    const proseBlocksFolderPath = `${storyFolderPath}/prose-blocks`;
    const storyProse = parseStoryProse(storyContent);
    if (storyProse.sections.length === 0) {
      return;
    }
    const existingChapters = await this.apiClient.getChapters(storyId);
    const chapterByTitle = /* @__PURE__ */ new Map();
    for (const ch of existingChapters) {
      chapterByTitle.set(ch.title.toLowerCase(), ch);
    }
    let currentChapter = null;
    let currentScene = null;
    let currentBeat = null;
    let proseOrderNum = 1;
    const sceneMap = /* @__PURE__ */ new Map();
    const beatMap = /* @__PURE__ */ new Map();
    for (const section of storyProse.sections) {
      if (section.type === "scene" && section.scene) {
        const { scene: parsedScene } = section;
        if (!currentChapter) {
          currentChapter = chapterByTitle.get("story prose") || null;
          if (!currentChapter) {
            currentChapter = await this.apiClient.createChapter(storyId, {
              number: 9999,
              title: "Story Prose",
              status: "draft"
            });
            chapterByTitle.set("story prose", currentChapter);
          }
        }
        if (parsedScene.linkName) {
          currentScene = sceneMap.get(parsedScene.linkName) || null;
        }
        if (!currentScene && parsedScene.goal) {
          const allScenes = await this.apiClient.getScenes(currentChapter.id);
          currentScene = allScenes.find((s) => s.goal === parsedScene.goal) || null;
        }
        if (!currentScene) {
          const existingScenes = await this.apiClient.getScenes(currentChapter.id);
          const sceneOrderNum = existingScenes.length > 0 ? Math.max(...existingScenes.map((s) => s.order_num)) + 1 : 1;
          currentScene = await this.apiClient.createScene({
            story_id: storyId,
            chapter_id: currentChapter.id,
            order_num: sceneOrderNum,
            goal: parsedScene.goal,
            time_ref: parsedScene.timeRef
          });
        }
        if (currentScene) {
          const sceneFileName = this.fileManager.generateSceneFileName(currentScene);
          const sceneLinkName = sceneFileName.replace(/\.md$/, "");
          sceneMap.set(sceneLinkName, currentScene);
        }
        currentBeat = null;
        proseOrderNum = 1;
      } else if (section.type === "beat" && section.beat) {
        const { beat: parsedBeat } = section;
        if (!currentScene) {
          continue;
        }
        if (parsedBeat.linkName) {
          currentBeat = beatMap.get(parsedBeat.linkName) || null;
        }
        if (!currentBeat && parsedBeat.intent) {
          const allBeats = await this.apiClient.getBeats(currentScene.id);
          currentBeat = allBeats.find((b) => b.intent === parsedBeat.intent) || null;
        }
        if (!currentBeat) {
          const existingBeats = await this.apiClient.getBeats(currentScene.id);
          const beatOrderNum = existingBeats.length > 0 ? Math.max(...existingBeats.map((b) => b.order_num)) + 1 : 1;
          currentBeat = await this.apiClient.createBeat({
            scene_id: currentScene.id,
            order_num: beatOrderNum,
            type: "setup",
            intent: parsedBeat.intent,
            outcome: parsedBeat.outcome
          });
        }
        if (currentBeat) {
          const beatFileName = this.fileManager.generateBeatFileName(currentBeat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          beatMap.set(beatLinkName, currentBeat);
        }
      } else if (section.type === "prose" && section.prose) {
        const { prose: paragraph } = section;
        if (!currentChapter) {
          currentChapter = chapterByTitle.get("story prose") || null;
          if (!currentChapter) {
            currentChapter = await this.apiClient.createChapter(storyId, {
              number: 9999,
              title: "Story Prose",
              status: "draft"
            });
            chapterByTitle.set("story prose", currentChapter);
          }
        }
        const remoteProseBlocks = await this.apiClient.getProseBlocks(currentChapter.id);
        const remoteProseBlocksMap = /* @__PURE__ */ new Map();
        for (const pb of remoteProseBlocks) {
          remoteProseBlocksMap.set(pb.id, pb);
        }
        let localProseBlock = null;
        let remoteProseBlock = null;
        if (paragraph.linkName) {
          const proseBlockFilePath = `${proseBlocksFolderPath}/${paragraph.linkName}.md`;
          localProseBlock = await this.fileManager.readProseBlockFromFile(proseBlockFilePath);
          if (!localProseBlock) {
            localProseBlock = await this.findProseBlockByContent(proseBlocksFolderPath, paragraph.content);
          }
          if (localProseBlock) {
            remoteProseBlock = remoteProseBlocksMap.get(localProseBlock.id) || null;
          } else {
            const normalizedContent = paragraph.content.trim();
            for (const [, remotePB] of remoteProseBlocksMap.entries()) {
              if (remotePB.content.trim() === normalizedContent) {
                remoteProseBlock = remotePB;
                break;
              }
            }
          }
        } else {
          localProseBlock = await this.findProseBlockByContent(proseBlocksFolderPath, paragraph.content);
          const normalizedContent = paragraph.content.trim();
          for (const [, remotePB] of remoteProseBlocksMap.entries()) {
            if (remotePB.content.trim() === normalizedContent) {
              remoteProseBlock = remotePB;
              if (!localProseBlock) {
                localProseBlock = await this.findProseBlockById(proseBlocksFolderPath, remotePB.id);
              }
              break;
            }
          }
        }
        const status = compareProseBlocks(paragraph, localProseBlock, remoteProseBlock);
        let finalProseBlock;
        switch (status) {
          case "new": {
            finalProseBlock = await this.apiClient.createProseBlock(currentChapter.id, {
              order_num: proseOrderNum++,
              kind: "final",
              content: paragraph.content
            });
            const fileName = this.fileManager.generateProseBlockFileName(finalProseBlock);
            const filePath = `${proseBlocksFolderPath}/${fileName}`;
            await this.fileManager.writeProseBlockFile(finalProseBlock, filePath, void 0);
            if (currentScene) {
              await this.apiClient.createProseBlockReference(finalProseBlock.id, "scene", currentScene.id);
            }
            if (currentBeat) {
              await this.apiClient.createProseBlockReference(finalProseBlock.id, "beat", currentBeat.id);
            }
            break;
          }
          case "unchanged": {
            if (!localProseBlock && remoteProseBlock) {
              finalProseBlock = remoteProseBlock;
              const fileName = this.fileManager.generateProseBlockFileName(finalProseBlock);
              const filePath = `${proseBlocksFolderPath}/${fileName}`;
              await this.fileManager.writeProseBlockFile(finalProseBlock, filePath, void 0);
            } else if (localProseBlock) {
              finalProseBlock = localProseBlock;
              proseOrderNum++;
            } else {
              finalProseBlock = remoteProseBlock;
              proseOrderNum++;
            }
            break;
          }
          case "local_modified": {
            finalProseBlock = await this.apiClient.updateProseBlock(localProseBlock.id, {
              content: paragraph.content,
              order_num: proseOrderNum++
            });
            const fileName = this.fileManager.generateProseBlockFileName(finalProseBlock);
            const filePath = `${proseBlocksFolderPath}/${fileName}`;
            await this.fileManager.writeProseBlockFile(finalProseBlock, filePath, void 0);
            break;
          }
          case "remote_modified": {
            finalProseBlock = remoteProseBlock;
            const fileName = this.fileManager.generateProseBlockFileName(finalProseBlock);
            const filePath = `${proseBlocksFolderPath}/${fileName}`;
            await this.fileManager.writeProseBlockFile(finalProseBlock, filePath, void 0);
            proseOrderNum++;
            break;
          }
          case "conflict": {
            const resolution = await this.resolveConflict(localProseBlock, remoteProseBlock);
            let resolvedContent = resolution.resolution === "local" ? paragraph.content : resolution.resolution === "remote" ? remoteProseBlock.content : resolution.mergedContent || paragraph.content;
            finalProseBlock = await this.apiClient.updateProseBlock(localProseBlock.id, {
              content: resolvedContent,
              order_num: proseOrderNum++
            });
            const fileName = this.fileManager.generateProseBlockFileName(finalProseBlock);
            const filePath = `${proseBlocksFolderPath}/${fileName}`;
            await this.fileManager.writeProseBlockFile(finalProseBlock, filePath, void 0);
            break;
          }
        }
      }
    }
  }
  // Push prose blocks from a scene file (scene-level prose, not inside chapters)
  async pushSceneProseBlocks(sceneFilePath, storyFolderPath) {
    const file = this.fileManager.getVault().getAbstractFileByPath(sceneFilePath);
    if (!(file instanceof import_obsidian7.TFile)) {
      return;
    }
    const sceneContent = await this.fileManager.getVault().read(file);
    const frontmatter = this.fileManager.parseFrontmatter(sceneContent);
    if (!frontmatter.id || !frontmatter.story_id) {
      return;
    }
    const sceneId = frontmatter.id;
    const storyId = frontmatter.story_id;
    const proseBlocksFolderPath = `${storyFolderPath}/prose-blocks`;
    const sceneProse = parseSceneProse(sceneContent);
    if (sceneProse.sections.length === 0) {
      return;
    }
    const chapters = await this.apiClient.getChapters(storyId);
    let tempChapter = chapters.find((c) => c.title === "Scene-Level Prose");
    if (!tempChapter) {
      tempChapter = await this.apiClient.createChapter(storyId, {
        number: 9998,
        // High number to keep it at the end
        title: "Scene-Level Prose",
        status: "draft"
      });
    }
    const remoteProseBlocks = await this.apiClient.getProseBlocks(tempChapter.id);
    const remoteProseBlocksMap = /* @__PURE__ */ new Map();
    for (const pb of remoteProseBlocks) {
      remoteProseBlocksMap.set(pb.id, pb);
    }
    const existingBeats = await this.apiClient.getBeats(sceneId);
    const beatMap = /* @__PURE__ */ new Map();
    const beatIdMap = /* @__PURE__ */ new Map();
    for (const beat of existingBeats) {
      const fileName = this.fileManager.generateBeatFileName(beat);
      const linkName = fileName.replace(/\.md$/, "");
      beatMap.set(linkName, beat);
      beatIdMap.set(beat.id, beat);
    }
    let proseOrderNum = 1;
    let currentBeat = null;
    const updatedSections = [];
    for (const section of sceneProse.sections) {
      if (section.type === "beat" && section.beat) {
        const { beat: parsedBeat } = section;
        if (parsedBeat.linkName) {
          currentBeat = beatMap.get(parsedBeat.linkName) || null;
          if (!currentBeat) {
            currentBeat = beatIdMap.get(parsedBeat.linkName) || null;
          }
        }
        if (currentBeat) {
          const beatFileName = this.fileManager.generateBeatFileName(currentBeat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          const beatDisplayText = currentBeat.outcome ? `${currentBeat.intent} -> ${currentBeat.outcome}` : currentBeat.intent;
          updatedSections.push(`### Beat: [[${beatLinkName}|${beatDisplayText}]]`);
        }
      } else if (section.type === "prose" && section.prose) {
        const { prose: paragraph } = section;
        let localProseBlock = null;
        let remoteProseBlock = null;
        if (paragraph.linkName) {
          const proseBlockFilePath = `${proseBlocksFolderPath}/${paragraph.linkName}.md`;
          localProseBlock = await this.fileManager.readProseBlockFromFile(proseBlockFilePath);
          if (!localProseBlock) {
            localProseBlock = await this.findProseBlockByContent(proseBlocksFolderPath, paragraph.content);
          }
          if (localProseBlock) {
            remoteProseBlock = remoteProseBlocksMap.get(localProseBlock.id) || null;
          } else {
            const normalizedContent = paragraph.content.trim();
            for (const [id, remotePB] of remoteProseBlocksMap.entries()) {
              if (remotePB.content.trim() === normalizedContent) {
                remoteProseBlock = remotePB;
                break;
              }
            }
          }
        } else {
          localProseBlock = await this.findProseBlockByContent(proseBlocksFolderPath, paragraph.content);
          const normalizedContent = paragraph.content.trim();
          for (const [id, remotePB] of remoteProseBlocksMap.entries()) {
            if (remotePB.content.trim() === normalizedContent) {
              remoteProseBlock = remotePB;
              if (!localProseBlock) {
                localProseBlock = await this.findProseBlockById(proseBlocksFolderPath, remotePB.id);
              }
              break;
            }
          }
        }
        const status = compareProseBlocks(paragraph, localProseBlock, remoteProseBlock);
        let finalProseBlock;
        switch (status) {
          case "new": {
            finalProseBlock = await this.apiClient.createProseBlock(tempChapter.id, {
              order_num: proseOrderNum++,
              kind: "final",
              content: paragraph.content
            });
            const fileName = this.fileManager.generateProseBlockFileName(finalProseBlock);
            const filePath = `${proseBlocksFolderPath}/${fileName}`;
            await this.fileManager.writeProseBlockFile(finalProseBlock, filePath, void 0);
            await this.apiClient.createProseBlockReference(finalProseBlock.id, "scene", sceneId);
            if (currentBeat) {
              await this.apiClient.createProseBlockReference(finalProseBlock.id, "beat", currentBeat.id);
            }
            const linkName = fileName.replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
            break;
          }
          case "unchanged": {
            if (!localProseBlock && remoteProseBlock) {
              finalProseBlock = remoteProseBlock;
              const fileName = this.fileManager.generateProseBlockFileName(finalProseBlock);
              const filePath = `${proseBlocksFolderPath}/${fileName}`;
              await this.fileManager.writeProseBlockFile(finalProseBlock, filePath, void 0);
            } else if (localProseBlock) {
              if (localProseBlock.order_num !== proseOrderNum) {
                finalProseBlock = await this.apiClient.updateProseBlock(localProseBlock.id, {
                  order_num: proseOrderNum++
                });
                const fileName = this.fileManager.generateProseBlockFileName(finalProseBlock);
                const filePath = `${proseBlocksFolderPath}/${fileName}`;
                await this.fileManager.writeProseBlockFile(finalProseBlock, filePath, void 0);
              } else {
                finalProseBlock = localProseBlock;
                proseOrderNum++;
              }
            } else {
              finalProseBlock = remoteProseBlock;
              proseOrderNum++;
            }
            if (paragraph.linkName) {
              updatedSections.push(`[[${paragraph.linkName}|${paragraph.content}]]`);
            } else {
              const fileName = this.fileManager.generateProseBlockFileName(finalProseBlock);
              const linkName = fileName.replace(/\.md$/, "");
              updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
            }
            break;
          }
          case "local_modified": {
            finalProseBlock = await this.apiClient.updateProseBlock(localProseBlock.id, {
              content: paragraph.content,
              order_num: proseOrderNum++
            });
            const fileName = this.fileManager.generateProseBlockFileName(finalProseBlock);
            const filePath = `${proseBlocksFolderPath}/${fileName}`;
            await this.fileManager.writeProseBlockFile(finalProseBlock, filePath, void 0);
            const linkName = fileName.replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
            break;
          }
          case "remote_modified": {
            finalProseBlock = remoteProseBlock;
            const fileName = this.fileManager.generateProseBlockFileName(finalProseBlock);
            const filePath = `${proseBlocksFolderPath}/${fileName}`;
            await this.fileManager.writeProseBlockFile(finalProseBlock, filePath, void 0);
            const linkName = fileName.replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${finalProseBlock.content}]]`);
            new import_obsidian7.Notice(`Scene prose block updated from remote: ${linkName}`, 3e3);
            proseOrderNum++;
            break;
          }
          case "conflict": {
            const resolution = await this.resolveConflict(localProseBlock, remoteProseBlock);
            let resolvedContent;
            if (resolution.resolution === "local") {
              resolvedContent = paragraph.content;
            } else if (resolution.resolution === "remote") {
              resolvedContent = remoteProseBlock.content;
            } else {
              resolvedContent = resolution.mergedContent || paragraph.content;
            }
            finalProseBlock = await this.apiClient.updateProseBlock(localProseBlock.id, {
              content: resolvedContent,
              order_num: proseOrderNum++
            });
            const fileName = this.fileManager.generateProseBlockFileName(finalProseBlock);
            const filePath = `${proseBlocksFolderPath}/${fileName}`;
            await this.fileManager.writeProseBlockFile(finalProseBlock, filePath, void 0);
            const linkName = fileName.replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${resolvedContent}]]`);
            break;
          }
        }
      }
    }
    if (updatedSections.length > 0) {
      const frontmatterMatch = sceneContent.match(/^---\n([\s\S]*?)\n---/);
      const frontmatterEnd = frontmatterMatch ? frontmatterMatch[0].length : 0;
      const afterFrontmatter = sceneContent.substring(frontmatterEnd).trim();
      const beatsSectionMatch = afterFrontmatter.match(/\n##\s+Beats\s*\n/);
      const insertionPoint = beatsSectionMatch ? frontmatterEnd + afterFrontmatter.indexOf(beatsSectionMatch[0]) : sceneContent.length;
      const beforeProse = sceneContent.substring(0, insertionPoint).trimEnd();
      const afterProse = sceneContent.substring(insertionPoint);
      const updatedContent = `${beforeProse}

${updatedSections.join("\n\n")}
${afterProse}`;
      await this.fileManager.getVault().modify(file, updatedContent);
    }
  }
  // Push prose blocks from a beat file
  async pushBeatProseBlocks(beatFilePath, storyFolderPath) {
    const file = this.fileManager.getVault().getAbstractFileByPath(beatFilePath);
    if (!(file instanceof import_obsidian7.TFile)) {
      return;
    }
    const beatContent = await this.fileManager.getVault().read(file);
    const frontmatter = this.fileManager.parseFrontmatter(beatContent);
    if (!frontmatter.id || !frontmatter.scene_id) {
      return;
    }
    const beatId = frontmatter.id;
    const sceneId = frontmatter.scene_id;
    const proseBlocksFolderPath = `${storyFolderPath}/prose-blocks`;
    const beatProse = parseBeatProse(beatContent);
    if (beatProse.sections.length === 0) {
      return;
    }
    const scene = await this.apiClient.getScene(sceneId);
    if (!scene) {
      return;
    }
    const storyId = scene.story_id;
    const chapters = await this.apiClient.getChapters(storyId);
    let tempChapter = chapters.find((c) => c.title === "Beat-Level Prose");
    if (!tempChapter) {
      tempChapter = await this.apiClient.createChapter(storyId, {
        number: 9997,
        // High number to keep it at the end
        title: "Beat-Level Prose",
        status: "draft"
      });
    }
    const remoteProseBlocks = await this.apiClient.getProseBlocks(tempChapter.id);
    const remoteProseBlocksMap = /* @__PURE__ */ new Map();
    for (const pb of remoteProseBlocks) {
      remoteProseBlocksMap.set(pb.id, pb);
    }
    let proseOrderNum = 1;
    const updatedSections = [];
    const beat = await this.apiClient.getBeat(beatId);
    if (beat) {
      const beatFileName = this.fileManager.generateBeatFileName(beat);
      const beatLinkName = beatFileName.replace(/\.md$/, "");
      const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
      updatedSections.push(`## Beat: [[${beatLinkName}|${beatDisplayText}]]`);
    }
    for (const section of beatProse.sections) {
      if (section.type === "prose" && section.prose) {
        const { prose: paragraph } = section;
        let localProseBlock = null;
        let remoteProseBlock = null;
        if (paragraph.linkName) {
          const proseBlockFilePath = `${proseBlocksFolderPath}/${paragraph.linkName}.md`;
          localProseBlock = await this.fileManager.readProseBlockFromFile(proseBlockFilePath);
          if (!localProseBlock) {
            localProseBlock = await this.findProseBlockByContent(proseBlocksFolderPath, paragraph.content);
          }
          if (localProseBlock) {
            remoteProseBlock = remoteProseBlocksMap.get(localProseBlock.id) || null;
          } else {
            const normalizedContent = paragraph.content.trim();
            for (const [, remotePB] of remoteProseBlocksMap.entries()) {
              if (remotePB.content.trim() === normalizedContent) {
                remoteProseBlock = remotePB;
                break;
              }
            }
          }
        } else {
          localProseBlock = await this.findProseBlockByContent(proseBlocksFolderPath, paragraph.content);
          const normalizedContent = paragraph.content.trim();
          for (const [, remotePB] of remoteProseBlocksMap.entries()) {
            if (remotePB.content.trim() === normalizedContent) {
              remoteProseBlock = remotePB;
              if (!localProseBlock) {
                localProseBlock = await this.findProseBlockById(proseBlocksFolderPath, remotePB.id);
              }
              break;
            }
          }
        }
        const status = compareProseBlocks(paragraph, localProseBlock, remoteProseBlock);
        let finalProseBlock;
        switch (status) {
          case "new": {
            finalProseBlock = await this.apiClient.createProseBlock(tempChapter.id, {
              order_num: proseOrderNum++,
              kind: "final",
              content: paragraph.content
            });
            const fileName = this.fileManager.generateProseBlockFileName(finalProseBlock);
            const filePath = `${proseBlocksFolderPath}/${fileName}`;
            await this.fileManager.writeProseBlockFile(finalProseBlock, filePath, void 0);
            await this.apiClient.createProseBlockReference(finalProseBlock.id, "scene", sceneId);
            await this.apiClient.createProseBlockReference(finalProseBlock.id, "beat", beatId);
            const linkName = fileName.replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
            break;
          }
          case "unchanged": {
            if (!localProseBlock && remoteProseBlock) {
              finalProseBlock = remoteProseBlock;
              const fileName = this.fileManager.generateProseBlockFileName(finalProseBlock);
              const filePath = `${proseBlocksFolderPath}/${fileName}`;
              await this.fileManager.writeProseBlockFile(finalProseBlock, filePath, void 0);
              const linkName = fileName.replace(/\.md$/, "");
              updatedSections.push(`[[${linkName}|${remoteProseBlock.content}]]`);
            } else if (localProseBlock) {
              finalProseBlock = localProseBlock;
              const fileName = this.fileManager.generateProseBlockFileName(finalProseBlock);
              const linkName = fileName.replace(/\.md$/, "");
              updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
              proseOrderNum++;
            } else {
              proseOrderNum++;
              continue;
            }
            break;
          }
          case "local_modified": {
            finalProseBlock = await this.apiClient.updateProseBlock(localProseBlock.id, {
              content: paragraph.content,
              order_num: proseOrderNum++
            });
            const fileName = this.fileManager.generateProseBlockFileName(finalProseBlock);
            const filePath = `${proseBlocksFolderPath}/${fileName}`;
            await this.fileManager.writeProseBlockFile(finalProseBlock, filePath, void 0);
            const linkName = fileName.replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
            break;
          }
          case "remote_modified": {
            finalProseBlock = remoteProseBlock;
            const fileName = this.fileManager.generateProseBlockFileName(finalProseBlock);
            const filePath = `${proseBlocksFolderPath}/${fileName}`;
            await this.fileManager.writeProseBlockFile(finalProseBlock, filePath, void 0);
            proseOrderNum++;
            const linkName = fileName.replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${remoteProseBlock.content}]]`);
            break;
          }
          case "conflict": {
            const resolution = await this.resolveConflict(localProseBlock, remoteProseBlock);
            let resolvedContent;
            if (resolution.resolution === "local") {
              resolvedContent = paragraph.content;
            } else if (resolution.resolution === "remote") {
              resolvedContent = remoteProseBlock.content;
            } else {
              resolvedContent = resolution.mergedContent || paragraph.content;
            }
            finalProseBlock = await this.apiClient.updateProseBlock(localProseBlock.id, {
              content: resolvedContent,
              order_num: proseOrderNum++
            });
            const fileName = this.fileManager.generateProseBlockFileName(finalProseBlock);
            const filePath = `${proseBlocksFolderPath}/${fileName}`;
            await this.fileManager.writeProseBlockFile(finalProseBlock, filePath, void 0);
            const linkName = fileName.replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${resolvedContent}]]`);
            break;
          }
        }
      }
    }
    if (updatedSections.length > 1) {
      const frontmatterMatch = beatContent.match(/^---\n([\s\S]*?)\n---/);
      const frontmatterEnd = frontmatterMatch ? frontmatterMatch[0].length : 0;
      const afterFrontmatter = beatContent.substring(frontmatterEnd).trim();
      const beatSectionMatch = afterFrontmatter.match(/##\s+Beat:\s*.+[\s\S]*/);
      if (beatSectionMatch) {
        const beforeBeatSection = beatContent.substring(0, frontmatterEnd + afterFrontmatter.indexOf(beatSectionMatch[0]));
        const updatedContent = `${beforeBeatSection.trimEnd()}

${updatedSections.join("\n\n")}
`;
        await this.fileManager.getVault().modify(file, updatedContent);
      } else {
        const updatedContent = `${beatContent.trimEnd()}

${updatedSections.join("\n\n")}
`;
        await this.fileManager.getVault().modify(file, updatedContent);
      }
    }
  }
  // Process the "## Orphan Scenes" list and update orphan scenes order
  async processOrphanScenesList(list, storyId) {
    const allScenes = await this.apiClient.getScenesByStory(storyId);
    const sceneMap = /* @__PURE__ */ new Map();
    const sceneIdMap = /* @__PURE__ */ new Map();
    const orphanScenes = allScenes.filter((s) => !s.chapter_id);
    for (const scene of orphanScenes) {
      const fileName = this.fileManager.generateSceneFileName(scene);
      const linkName = fileName.replace(/\.md$/, "");
      sceneMap.set(linkName, scene);
      sceneIdMap.set(scene.id, scene);
    }
    const beatMap = /* @__PURE__ */ new Map();
    const beatIdMap = /* @__PURE__ */ new Map();
    for (const scene of orphanScenes) {
      const beats = await this.apiClient.getBeats(scene.id);
      for (const beat of beats) {
        const fileName = this.fileManager.generateBeatFileName(beat);
        const linkName = fileName.replace(/\.md$/, "");
        beatMap.set(linkName, beat);
        beatIdMap.set(beat.id, beat);
      }
    }
    let currentScene = null;
    let sceneOrderNum = 1;
    const beatOrderNums = /* @__PURE__ */ new Map();
    for (const item of list.items) {
      if (item.type === "scene") {
        let goal;
        let timeRef = "";
        const sceneMatch = item.displayText.match(/Scene\s+\d+:\s*(.+)/);
        if (sceneMatch) {
          const sceneText = sceneMatch[1].trim();
          const parts = sceneText.split(/\s*-\s*/);
          goal = parts[0].trim();
          timeRef = parts.length > 1 ? parts.slice(1).join(" - ").trim() : "";
        } else {
          const parts = item.displayText.split(/\s*-\s*/);
          goal = parts[0].trim();
          timeRef = parts.length > 1 ? parts.slice(1).join(" - ").trim() : "";
        }
        if (item.linkName) {
          currentScene = sceneMap.get(item.linkName) || null;
          if (!currentScene) {
            currentScene = sceneIdMap.get(item.linkName) || null;
          }
          if (currentScene) {
            const needsOrderUpdate = currentScene.order_num !== sceneOrderNum;
            const needsContentUpdate = goal !== currentScene.goal || timeRef !== currentScene.time_ref;
            if (needsOrderUpdate || needsContentUpdate) {
              currentScene = await this.apiClient.updateScene(currentScene.id, {
                goal,
                time_ref: timeRef,
                order_num: sceneOrderNum
              });
            }
            const existingBeats = await this.apiClient.getBeats(currentScene.id);
            if (existingBeats.length === 0) {
              beatOrderNums.set(currentScene.id, 1);
            } else {
              const maxOrderNum = Math.max(...existingBeats.map((b) => b.order_num));
              beatOrderNums.set(currentScene.id, maxOrderNum + 1);
            }
          }
        } else {
          currentScene = await this.apiClient.createScene({
            story_id: storyId,
            chapter_id: null,
            // Orphan scene
            order_num: sceneOrderNum,
            goal,
            time_ref: timeRef
          });
          const sceneFileName = this.fileManager.generateSceneFileName(currentScene);
          const sceneLinkName = sceneFileName.replace(/\.md$/, "");
          sceneMap.set(sceneLinkName, currentScene);
          sceneIdMap.set(currentScene.id, currentScene);
          beatOrderNums.set(currentScene.id, 1);
        }
        sceneOrderNum++;
      } else if (item.type === "beat" && currentScene) {
        let intent;
        let outcome = "";
        const beatMatch = item.displayText.match(/Beat\s+\d+:\s*(.+)/);
        if (beatMatch) {
          const beatText = beatMatch[1].trim();
          const parts = beatText.split(/\s*->\s*/);
          intent = parts[0].trim();
          outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
        } else {
          const parts = item.displayText.split(/\s*->\s*/);
          intent = parts[0].trim();
          outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
        }
        const currentBeatOrderNum = beatOrderNums.get(currentScene.id) || 1;
        if (item.linkName) {
          let currentBeat = beatMap.get(item.linkName) || null;
          if (!currentBeat) {
            currentBeat = beatIdMap.get(item.linkName) || null;
          }
          if (currentBeat) {
            const needsOrderUpdate = currentBeat.order_num !== currentBeatOrderNum;
            const needsContentUpdate = intent !== currentBeat.intent || outcome !== currentBeat.outcome;
            const needsSceneUpdate = currentBeat.scene_id !== currentScene.id;
            if (needsOrderUpdate || needsContentUpdate || needsSceneUpdate) {
              currentBeat = await this.apiClient.updateBeat(currentBeat.id, {
                intent,
                outcome,
                order_num: currentBeatOrderNum,
                scene_id: currentScene.id
              });
            }
          }
        } else {
          await this.apiClient.createBeat({
            scene_id: currentScene.id,
            order_num: currentBeatOrderNum,
            type: "setup",
            // Default type
            intent,
            outcome
          });
        }
        beatOrderNums.set(currentScene.id, currentBeatOrderNum + 1);
      }
    }
  }
  // Process the "## Orphan Beats" list and update orphan beats order
  async processOrphanBeatsList(list, storyId) {
    const allBeats = await this.apiClient.getBeatsByStory(storyId);
    const allScenes = await this.apiClient.getScenesByStory(storyId);
    const sceneIdSet = new Set(allScenes.map((s) => s.id));
    const orphanBeats = allBeats.filter((b) => !b.scene_id || !sceneIdSet.has(b.scene_id));
    const beatMap = /* @__PURE__ */ new Map();
    const beatIdMap = /* @__PURE__ */ new Map();
    for (const beat of orphanBeats) {
      const fileName = this.fileManager.generateBeatFileName(beat);
      const linkName = fileName.replace(/\.md$/, "");
      beatMap.set(linkName, beat);
      beatIdMap.set(beat.id, beat);
    }
    let beatOrderNum = 1;
    for (const item of list.items) {
      let intent;
      let outcome = "";
      const beatMatch = item.displayText.match(/Beat\s+\d+:\s*(.+)/);
      if (beatMatch) {
        const beatText = beatMatch[1].trim();
        const parts = beatText.split(/\s*->\s*/);
        intent = parts[0].trim();
        outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
      } else {
        const parts = item.displayText.split(/\s*->\s*/);
        intent = parts[0].trim();
        outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
      }
      if (item.linkName) {
        let currentBeat = beatMap.get(item.linkName) || null;
        if (!currentBeat) {
          currentBeat = beatIdMap.get(item.linkName) || null;
        }
        if (currentBeat) {
          const needsOrderUpdate = currentBeat.order_num !== beatOrderNum;
          const needsContentUpdate = intent !== currentBeat.intent || outcome !== currentBeat.outcome;
          if (needsOrderUpdate || needsContentUpdate) {
            currentBeat = await this.apiClient.updateBeat(currentBeat.id, {
              intent,
              outcome,
              order_num: beatOrderNum
              // Keep scene_id as null or invalid (orphan) - don't update it
            });
          }
        }
      } else {
        const allScenes2 = await this.apiClient.getScenesByStory(storyId);
        let orphanBeatScene = allScenes2.find((s) => !s.chapter_id && s.goal.startsWith("Orphan Beats Container"));
        if (!orphanBeatScene) {
          orphanBeatScene = await this.apiClient.createScene({
            story_id: storyId,
            chapter_id: null,
            order_num: 9999,
            // High number to keep it at the end
            goal: "Orphan Beats Container",
            time_ref: ""
          });
        }
        await this.apiClient.createBeat({
          scene_id: orphanBeatScene.id,
          order_num: beatOrderNum,
          type: "setup",
          // Default type
          intent,
          outcome
        });
      }
      beatOrderNum++;
    }
  }
  // Process the "## Scenes & Beats" list and create/update/delete scenes and beats
  async processSceneBeatList(list, chapterId, storyId) {
    const existingScenes = await this.apiClient.getScenes(chapterId);
    const sceneMap = /* @__PURE__ */ new Map();
    const sceneIdMap = /* @__PURE__ */ new Map();
    for (const scene of existingScenes) {
      const fileName = this.fileManager.generateSceneFileName(scene);
      const linkName = fileName.replace(/\.md$/, "");
      sceneMap.set(linkName, scene);
      sceneIdMap.set(scene.id, scene);
    }
    const beatMap = /* @__PURE__ */ new Map();
    const beatIdMap = /* @__PURE__ */ new Map();
    for (const scene of existingScenes) {
      const beats = await this.apiClient.getBeats(scene.id);
      for (const beat of beats) {
        const fileName = this.fileManager.generateBeatFileName(beat);
        const linkName = fileName.replace(/\.md$/, "");
        beatMap.set(linkName, beat);
        beatIdMap.set(beat.id, beat);
      }
    }
    let currentScene = null;
    let sceneOrderNum = 1;
    const beatOrderNums = /* @__PURE__ */ new Map();
    for (const item of list.items) {
      if (item.type === "scene") {
        currentScene = null;
        let goal;
        let timeRef = "";
        const sceneMatch = item.displayText.match(/Scene\s+\d+:\s*(.+)/);
        if (sceneMatch) {
          const sceneText = sceneMatch[1].trim();
          const parts = sceneText.split(/\s*-\s*/);
          goal = parts[0].trim();
          timeRef = parts.length > 1 ? parts.slice(1).join(" - ").trim() : "";
        } else {
          const parts = item.displayText.split(/\s*-\s*/);
          goal = parts[0].trim();
          timeRef = parts.length > 1 ? parts.slice(1).join(" - ").trim() : "";
        }
        currentScene = null;
        if (item.linkName) {
          currentScene = sceneMap.get(item.linkName) || null;
          if (!currentScene) {
            currentScene = sceneIdMap.get(item.linkName) || null;
          }
          if (currentScene) {
            const needsOrderUpdate = currentScene.order_num !== sceneOrderNum;
            const needsContentUpdate = goal !== currentScene.goal || timeRef !== currentScene.time_ref;
            if (needsOrderUpdate || needsContentUpdate) {
              currentScene = await this.apiClient.updateScene(currentScene.id, {
                goal,
                time_ref: timeRef,
                order_num: sceneOrderNum
              });
            }
            const existingBeats = await this.apiClient.getBeats(currentScene.id);
            if (existingBeats.length === 0) {
              beatOrderNums.set(currentScene.id, 1);
            } else {
              const maxOrderNum = Math.max(...existingBeats.map((b) => b.order_num));
              beatOrderNums.set(currentScene.id, maxOrderNum + 1);
            }
          }
        } else {
          currentScene = await this.apiClient.createScene({
            story_id: storyId,
            chapter_id: chapterId,
            order_num: sceneOrderNum,
            goal,
            time_ref: timeRef
          });
          const sceneFileName = this.fileManager.generateSceneFileName(currentScene);
          const sceneLinkName = sceneFileName.replace(/\.md$/, "");
          sceneMap.set(sceneLinkName, currentScene);
          sceneIdMap.set(currentScene.id, currentScene);
          beatOrderNums.set(currentScene.id, 1);
        }
        sceneOrderNum++;
      } else if (item.type === "beat" && currentScene) {
        let intent;
        let outcome = "";
        const beatMatch = item.displayText.match(/Beat\s+\d+:\s*(.+)/);
        if (beatMatch) {
          const beatText = beatMatch[1].trim();
          const parts = beatText.split(/\s*->\s*/);
          intent = parts[0].trim();
          outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
        } else {
          const parts = item.displayText.split(/\s*->\s*/);
          intent = parts[0].trim();
          outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
        }
        const currentBeatOrderNum = beatOrderNums.get(currentScene.id) || 1;
        if (item.linkName) {
          let currentBeat = beatMap.get(item.linkName) || null;
          if (!currentBeat) {
            currentBeat = beatIdMap.get(item.linkName) || null;
          }
          if (currentBeat) {
            const needsOrderUpdate = currentBeat.order_num !== currentBeatOrderNum;
            const needsContentUpdate = intent !== currentBeat.intent || outcome !== currentBeat.outcome;
            const needsSceneUpdate = currentBeat.scene_id !== currentScene.id;
            if (needsOrderUpdate || needsContentUpdate || needsSceneUpdate) {
              currentBeat = await this.apiClient.updateBeat(currentBeat.id, {
                intent,
                outcome,
                order_num: currentBeatOrderNum,
                scene_id: currentScene.id
              });
              if (needsSceneUpdate) {
                const beatFileName = this.fileManager.generateBeatFileName(currentBeat);
                const beatLinkName = beatFileName.replace(/\.md$/, "");
                beatMap.set(beatLinkName, currentBeat);
                beatIdMap.set(currentBeat.id, currentBeat);
              }
            }
          }
        } else {
          const newBeat = await this.apiClient.createBeat({
            scene_id: currentScene.id,
            order_num: currentBeatOrderNum,
            type: "setup",
            // Default type
            intent,
            outcome
          });
          const beatFileName = this.fileManager.generateBeatFileName(newBeat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          beatMap.set(beatLinkName, newBeat);
          beatIdMap.set(newBeat.id, newBeat);
        }
        beatOrderNums.set(currentScene.id, currentBeatOrderNum + 1);
      }
    }
  }
  // Find prose block by content when file name doesn't match
  async findProseBlockByContent(proseBlocksFolderPath, content) {
    try {
      const folder = this.fileManager.getVault().getAbstractFileByPath(proseBlocksFolderPath);
      if (!(folder instanceof import_obsidian7.TFolder)) {
        return null;
      }
      const normalizedContent = content.trim();
      for (const child of folder.children) {
        if (child instanceof import_obsidian7.TFile && child.extension === "md") {
          const proseBlock = await this.fileManager.readProseBlockFromFile(child.path);
          if (proseBlock && proseBlock.content.trim() === normalizedContent) {
            return proseBlock;
          }
        }
      }
    } catch (err) {
      console.error("Error searching for prose block by content:", err);
    }
    return null;
  }
  // Find prose block by ID when we have remote ID but need local file
  async findProseBlockById(proseBlocksFolderPath, id) {
    try {
      const folder = this.fileManager.getVault().getAbstractFileByPath(proseBlocksFolderPath);
      if (!(folder instanceof import_obsidian7.TFolder)) {
        return null;
      }
      for (const child of folder.children) {
        if (child instanceof import_obsidian7.TFile && child.extension === "md") {
          const proseBlock = await this.fileManager.readProseBlockFromFile(child.path);
          if (proseBlock && proseBlock.id === id) {
            return proseBlock;
          }
        }
      }
    } catch (err) {
      console.error("Error searching for prose block by ID:", err);
    }
    return null;
  }
  // Resolve conflict using modal
  async resolveConflict(localProseBlock, remoteProseBlock) {
    return new Promise((resolve) => {
      const modal = new ConflictModal(
        this.app,
        localProseBlock,
        remoteProseBlock,
        async (result) => {
          resolve(result);
        }
      );
      modal.open();
    });
  }
  // Update the Chapter section in chapter file (hierarchical structure)
  async updateChapterProseSectionHierarchical(originalContent, updatedSections, file, frontmatter) {
    const frontmatterMatch = originalContent.match(/^---\n([\s\S]*?)\n---/);
    const frontmatterText = frontmatterMatch ? frontmatterMatch[0] : "";
    const bodyStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
    const bodyContent = originalContent.substring(bodyStart).trim();
    const chapterNumber = frontmatter.number || "1";
    const chapterTitle = frontmatter.title || "Untitled";
    const chapterHeaderPattern = `##\\s+Chapter\\s+${chapterNumber}:\\s+[^\\n]+`;
    const chapterSectionMatch = bodyContent.match(new RegExp(`([\\s\\S]*?${chapterHeaderPattern}\\s*\\n+)([\\s\\S]*?)(?=\\n##\\s+Chapter\\s+\\d+:|$)`, "i"));
    if (!chapterSectionMatch) {
      const newChapterSection = `

## Chapter ${chapterNumber}: ${chapterTitle}

${updatedSections.join("\n\n")}

`;
      const updatedContent2 = `${frontmatterText}
${bodyContent}${newChapterSection}`;
      await this.fileManager.getVault().modify(file, updatedContent2);
      return;
    }
    const beforeChapter = chapterSectionMatch[1];
    const afterChapter = bodyContent.substring(chapterSectionMatch.index + chapterSectionMatch[0].length);
    const newChapterContent = updatedSections.join("\n\n");
    const updatedBody = `${beforeChapter}${newChapterContent}

${afterChapter}`;
    const updatedContent = `${frontmatterText}
${updatedBody}`;
    await this.fileManager.getVault().modify(file, updatedContent);
  }
  // Update the Prose section in chapter file
  async updateChapterProseSection(originalContent, updatedParagraphs, file) {
    const frontmatterMatch = originalContent.match(/^---\n([\s\S]*?)\n---/);
    const frontmatter = frontmatterMatch ? frontmatterMatch[0] : "";
    const bodyStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
    const bodyContent = originalContent.substring(bodyStart).trim();
    const proseSectionMatch = bodyContent.match(/([\s\S]*?##\s+Prose\s*\n\n)([\s\S]*?)(?=\n##|\n*$)/);
    if (!proseSectionMatch) {
      const newProseSection = `

## Prose

${updatedParagraphs.join("\n\n")}

`;
      const updatedContent2 = `${frontmatter}
${bodyContent}${newProseSection}`;
      await this.fileManager.getVault().modify(file, updatedContent2);
      return;
    }
    const beforeProse = proseSectionMatch[1];
    const newProseContent = updatedParagraphs.join("\n\n");
    const afterProse = bodyContent.substring(proseSectionMatch.index + proseSectionMatch[0].length);
    const updatedBody = `${beforeProse}${newProseContent}

${afterProse}`;
    const updatedContent = `${frontmatter}
${updatedBody}`;
    await this.fileManager.getVault().modify(file, updatedContent);
  }
};

// src/views/StoryListView.ts
var import_obsidian11 = require("obsidian");

// src/views/modals/ChapterModal.ts
var import_obsidian8 = require("obsidian");
var ChapterModal = class extends import_obsidian8.Modal {
  constructor(app, onSubmit, existingChapters = [], chapter) {
    super(app);
    this.chapter = {
      title: "",
      status: "draft"
    };
    this.isEdit = false;
    this.existingChapters = [];
    this.onSubmit = onSubmit;
    this.existingChapters = existingChapters;
    if (chapter) {
      this.isEdit = true;
      this.chapter = {
        number: chapter.number,
        title: chapter.title,
        status: chapter.status
      };
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", {
      text: this.isEdit ? "Edit Chapter" : "Create Chapter"
    });
    if (this.isEdit) {
      new import_obsidian8.Setting(contentEl).setName("Chapter Number").setDesc("The chapter number").addText(
        (text) => {
          var _a;
          return text.setPlaceholder("1").setValue(((_a = this.chapter.number) == null ? void 0 : _a.toString()) || "1").onChange((value) => {
            const num = parseInt(value);
            if (!isNaN(num) && num > 0) {
              this.chapter.number = num;
            }
          });
        }
      );
    }
    new import_obsidian8.Setting(contentEl).setName("Title").setDesc("Chapter title").addText(
      (text) => text.setPlaceholder("Chapter Title").setValue(this.chapter.title || "").onChange((value) => {
        this.chapter.title = value;
      }).inputEl.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          this.submit();
        }
      })
    );
    new import_obsidian8.Setting(contentEl).setName("Status").setDesc("Chapter status").addDropdown(
      (dropdown) => dropdown.addOption("draft", "Draft").addOption("in_progress", "In Progress").addOption("completed", "Completed").setValue(this.chapter.status || "draft").onChange((value) => {
        this.chapter.status = value;
      })
    );
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const submitButton = buttonContainer.createEl("button", {
      text: this.isEdit ? "Update" : "Create",
      cls: "mod-cta"
    });
    submitButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
    const titleInput = contentEl.querySelector("input[placeholder='Chapter Title']");
    if (titleInput) {
      titleInput.focus();
    }
  }
  async submit() {
    var _a;
    if (!((_a = this.chapter.title) == null ? void 0 : _a.trim())) {
      new import_obsidian8.Notice("Please enter a chapter title", 3e3);
      return;
    }
    if (!this.isEdit) {
      const maxNumber = this.existingChapters.length > 0 ? Math.max(...this.existingChapters.map((c) => c.number)) : 0;
      this.chapter.number = maxNumber + 1;
    } else {
      if (!this.chapter.number || this.chapter.number < 1) {
        new import_obsidian8.Notice("Chapter number must be greater than 0", 3e3);
        return;
      }
    }
    try {
      await this.onSubmit(this.chapter);
      this.close();
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to save chapter";
      new import_obsidian8.Notice(`Error: ${errorMessage}`, 5e3);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/modals/SceneModal.ts
var import_obsidian9 = require("obsidian");
var SceneModal = class extends import_obsidian9.Modal {
  constructor(app, storyId, chapters, onSubmit, existingScenes = [], scene) {
    super(app);
    this.scene = {
      time_ref: "",
      goal: ""
    };
    this.isEdit = false;
    this.chapters = [];
    this.existingScenes = [];
    this.storyId = storyId;
    this.chapters = chapters;
    this.existingScenes = existingScenes;
    this.onSubmit = onSubmit;
    if (scene) {
      this.isEdit = true;
      this.scene = {
        story_id: scene.story_id,
        chapter_id: scene.chapter_id || null,
        order_num: scene.order_num,
        time_ref: scene.time_ref,
        goal: scene.goal,
        pov_character_id: scene.pov_character_id,
        location_id: scene.location_id
      };
    } else {
      this.scene.story_id = storyId;
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", {
      text: this.isEdit ? "Edit Scene" : "Create Scene"
    });
    new import_obsidian9.Setting(contentEl).setName("Chapter").setDesc("Select the chapter for this scene (optional)").addDropdown((dropdown) => {
      dropdown.addOption("", "No Chapter");
      for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
        dropdown.addOption(
          chapter.id,
          `Chapter ${chapter.number}: ${chapter.title}`
        );
      }
      dropdown.setValue(this.scene.chapter_id || "");
      dropdown.onChange((value) => {
        this.scene.chapter_id = value || null;
      });
    });
    if (this.isEdit) {
      new import_obsidian9.Setting(contentEl).setName("Order Number").setDesc("Scene order within chapter").addText(
        (text) => {
          var _a;
          return text.setPlaceholder("1").setValue(((_a = this.scene.order_num) == null ? void 0 : _a.toString()) || "1").onChange((value) => {
            const num = parseInt(value);
            if (!isNaN(num) && num > 0) {
              this.scene.order_num = num;
            }
          });
        }
      );
    }
    new import_obsidian9.Setting(contentEl).setName("Goal").setDesc("Scene goal or description").addTextArea(
      (text) => text.setPlaceholder("What happens in this scene?").setValue(this.scene.goal || "").onChange((value) => {
        this.scene.goal = value;
      })
    );
    new import_obsidian9.Setting(contentEl).setName("Time Reference").setDesc("When does this scene take place?").addText(
      (text) => text.setPlaceholder("Morning, Evening, etc.").setValue(this.scene.time_ref || "").onChange((value) => {
        this.scene.time_ref = value;
      })
    );
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const submitButton = buttonContainer.createEl("button", {
      text: this.isEdit ? "Update" : "Create",
      cls: "mod-cta"
    });
    submitButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
    const goalInput = contentEl.querySelector("textarea");
    if (goalInput) {
      goalInput.focus();
    }
  }
  async submit() {
    if (!this.isEdit) {
      const chapterId = this.scene.chapter_id || null;
      const scenesInChapter = this.existingScenes.filter(
        (s) => (s.chapter_id || null) === chapterId
      );
      const maxOrderNum = scenesInChapter.length > 0 ? Math.max(...scenesInChapter.map((s) => s.order_num)) : 0;
      this.scene.order_num = maxOrderNum + 1;
    } else {
      if (!this.scene.order_num || this.scene.order_num < 1) {
        new import_obsidian9.Notice("Order number must be greater than 0", 3e3);
        return;
      }
    }
    try {
      await this.onSubmit(this.scene);
      this.close();
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to save scene";
      new import_obsidian9.Notice(`Error: ${errorMessage}`, 5e3);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/modals/BeatModal.ts
var import_obsidian10 = require("obsidian");
var BeatModal = class extends import_obsidian10.Modal {
  constructor(app, storyId, scenes, onSubmit, existingBeats = [], beat) {
    super(app);
    this.beat = {
      type: "setup",
      intent: "",
      outcome: ""
    };
    this.isEdit = false;
    this.scenes = [];
    this.existingBeats = [];
    this.storyId = storyId;
    this.scenes = scenes;
    this.existingBeats = existingBeats;
    this.onSubmit = onSubmit;
    if (beat) {
      this.isEdit = true;
      this.beat = {
        scene_id: beat.scene_id,
        order_num: beat.order_num,
        type: beat.type,
        intent: beat.intent,
        outcome: beat.outcome
      };
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", {
      text: this.isEdit ? "Edit Beat" : "Create Beat"
    });
    new import_obsidian10.Setting(contentEl).setName("Scene").setDesc("Select the scene for this beat").addDropdown((dropdown) => {
      const scenesByChapter = /* @__PURE__ */ new Map();
      for (const scene of this.scenes) {
        const chapterId = scene.chapter_id || null;
        if (!scenesByChapter.has(chapterId)) {
          scenesByChapter.set(chapterId, []);
        }
        scenesByChapter.get(chapterId).push(scene);
      }
      for (const [chapterId, chapterScenes] of scenesByChapter.entries()) {
        const label = chapterId ? `Chapter ${chapterId.substring(0, 8)}...` : "No Chapter";
        for (const scene of chapterScenes.sort((a, b) => a.order_num - b.order_num)) {
          dropdown.addOption(
            scene.id,
            `${label} > Scene ${scene.order_num}: ${scene.goal || "Untitled"}`
          );
        }
      }
      dropdown.setValue(this.beat.scene_id || "");
      dropdown.onChange((value) => {
        this.beat.scene_id = value;
      });
    });
    if (this.isEdit) {
      new import_obsidian10.Setting(contentEl).setName("Order Number").setDesc("Beat order within scene").addText(
        (text) => {
          var _a;
          return text.setPlaceholder("1").setValue(((_a = this.beat.order_num) == null ? void 0 : _a.toString()) || "1").onChange((value) => {
            const num = parseInt(value);
            if (!isNaN(num) && num > 0) {
              this.beat.order_num = num;
            }
          });
        }
      );
    }
    new import_obsidian10.Setting(contentEl).setName("Type").setDesc("Beat type").addDropdown(
      (dropdown) => dropdown.addOption("setup", "Setup").addOption("turn", "Turn").addOption("reveal", "Reveal").addOption("conflict", "Conflict").addOption("climax", "Climax").addOption("resolution", "Resolution").addOption("hook", "Hook").addOption("transition", "Transition").setValue(this.beat.type || "setup").onChange((value) => {
        this.beat.type = value;
      })
    );
    new import_obsidian10.Setting(contentEl).setName("Intent").setDesc("What is the intent of this beat?").addTextArea(
      (text) => text.setPlaceholder("What does the character want?").setValue(this.beat.intent || "").onChange((value) => {
        this.beat.intent = value;
      })
    );
    new import_obsidian10.Setting(contentEl).setName("Outcome").setDesc("What is the outcome of this beat?").addTextArea(
      (text) => text.setPlaceholder("What happens as a result?").setValue(this.beat.outcome || "").onChange((value) => {
        this.beat.outcome = value;
      })
    );
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const submitButton = buttonContainer.createEl("button", {
      text: this.isEdit ? "Update" : "Create",
      cls: "mod-cta"
    });
    submitButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
    const intentInput = contentEl.querySelector("textarea");
    if (intentInput) {
      intentInput.focus();
    }
  }
  async submit() {
    if (!this.beat.scene_id) {
      new import_obsidian10.Notice("Please select a scene", 3e3);
      return;
    }
    if (!this.beat.type) {
      new import_obsidian10.Notice("Please select a beat type", 3e3);
      return;
    }
    if (!this.isEdit) {
      const beatsInScene = this.existingBeats.filter((b) => b.scene_id === this.beat.scene_id);
      const maxOrderNum = beatsInScene.length > 0 ? Math.max(...beatsInScene.map((b) => b.order_num)) : 0;
      this.beat.order_num = maxOrderNum + 1;
    } else {
      if (!this.beat.order_num || this.beat.order_num < 1) {
        new import_obsidian10.Notice("Order number must be greater than 0", 3e3);
        return;
      }
    }
    try {
      await this.onSubmit(this.beat);
      this.close();
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to save beat";
      new import_obsidian10.Notice(`Error: ${errorMessage}`, 5e3);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/StoryListView.ts
var STORY_LIST_VIEW_TYPE = "story-engine-list-view";
var StoryListView = class extends import_obsidian11.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.stories = [];
    this.loading = true;
    this.error = null;
    this.currentStory = null;
    this.viewMode = "list";
    this.currentTab = "chapters";
    this.chapters = [];
    this.scenes = [];
    this.beats = [];
    this.loadingHierarchy = false;
    this.plugin = plugin;
  }
  getViewType() {
    return STORY_LIST_VIEW_TYPE;
  }
  getDisplayText() {
    if (this.viewMode === "details" && this.currentStory) {
      return this.currentStory.title;
    }
    return "Stories";
  }
  getIcon() {
    return "book-open";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("story-engine-view-container");
    await this.render(container);
    await this.loadStories();
  }
  async onClose() {
  }
  async render(container) {
    container.empty();
    this.headerEl = container.createDiv({ cls: "story-engine-view-header" });
    this.contentEl = container.createDiv({ cls: "story-engine-view-content" });
    if (this.viewMode === "details" && this.currentStory) {
      this.renderDetails();
    } else {
      this.renderListHeader();
    }
  }
  renderListHeader() {
    if (!this.headerEl)
      return;
    this.headerEl.empty();
    this.headerEl.createEl("h2", { text: "Stories" });
    const headerActions = this.headerEl.createDiv({ cls: "story-engine-header-actions" });
    const refreshButton = headerActions.createEl("button", {
      text: "Refresh",
      cls: "story-engine-refresh-btn"
    });
    refreshButton.onclick = async () => {
      await this.loadStories();
    };
    const syncAllButton = headerActions.createEl("button", {
      text: "Sync All",
      cls: "story-engine-sync-all-btn"
    });
    syncAllButton.onclick = async () => {
      if (!this.plugin.settings.tenantId) {
        new import_obsidian11.Notice("Please configure Tenant ID in settings", 5e3);
        return;
      }
      try {
        new import_obsidian11.Notice("Syncing all stories...");
        await this.plugin.syncService.pullAllStories();
        await this.loadStories();
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to sync stories";
        new import_obsidian11.Notice(`Error: ${errorMessage}`, 5e3);
      }
    };
    const createButton = headerActions.createEl("button", {
      text: "Create Story",
      cls: "mod-cta story-engine-create-btn"
    });
    createButton.onclick = () => {
      this.plugin.createStoryCommand();
    };
  }
  renderDetailsHeader() {
    var _a;
    if (!this.headerEl)
      return;
    this.headerEl.empty();
    const headerLeft = this.headerEl.createDiv({ cls: "story-engine-header-left" });
    const backButton = headerLeft.createEl("button", {
      text: "\u2190 Back",
      cls: "story-engine-back-btn"
    });
    backButton.onclick = () => {
      this.showList();
    };
    headerLeft.createEl("h2", { text: ((_a = this.currentStory) == null ? void 0 : _a.title) || "Story Details" });
    const headerActions = this.headerEl.createDiv({ cls: "story-engine-header-actions" });
    if (this.currentStory) {
      const cloneButton = headerActions.createEl("button", {
        text: "Clone Story",
        cls: "mod-cta story-engine-clone-btn"
      });
      cloneButton.onclick = async () => {
        await this.cloneStory();
      };
      const copyIdButton = headerActions.createEl("button", {
        text: "Copy ID",
        cls: "story-engine-copy-id-btn"
      });
      copyIdButton.onclick = () => {
        this.copyStoryId();
      };
    }
  }
  renderStories() {
    if (!this.contentEl)
      return;
    this.contentEl.empty();
    if (this.loading) {
      this.contentEl.createEl("p", { text: "Loading stories..." });
      return;
    }
    if (this.error) {
      this.contentEl.createEl("p", {
        text: `Error: ${this.error}`,
        cls: "story-engine-error"
      });
      return;
    }
    if (this.stories.length === 0) {
      this.contentEl.createEl("p", { text: "No stories found." });
      return;
    }
    const storiesList = this.contentEl.createDiv({ cls: "story-engine-list" });
    for (const story of this.stories) {
      const storyItem = storiesList.createDiv({
        cls: "story-engine-item"
      });
      const title = storyItem.createDiv({
        cls: "story-engine-title",
        text: story.title
      });
      const meta = storyItem.createDiv({
        cls: "story-engine-meta"
      });
      meta.createEl("span", {
        text: `Version ${story.version_number}`
      });
      meta.createEl("span", {
        text: `Status: ${story.status}`
      });
      storyItem.onclick = async () => {
        await this.showStoryDetails(story);
      };
    }
  }
  async loadStories() {
    this.loading = true;
    this.error = null;
    this.renderStories();
    try {
      if (!this.plugin.settings.tenantId) {
        this.error = "Tenant ID not configured";
        this.loading = false;
        this.renderStories();
        return;
      }
      this.stories = await this.plugin.apiClient.listStories();
    } catch (err) {
      this.error = err instanceof Error ? err.message : "Unknown error";
    } finally {
      this.loading = false;
      this.renderStories();
    }
  }
  // Method to refresh the view
  async refresh() {
    await this.loadStories();
  }
  async showStoryDetails(story) {
    this.currentStory = story;
    this.viewMode = "details";
    this.currentTab = "chapters";
    await this.loadHierarchy();
    this.renderDetails();
  }
  async loadHierarchy() {
    if (!this.currentStory)
      return;
    this.loadingHierarchy = true;
    try {
      this.chapters = await this.plugin.apiClient.getChapters(this.currentStory.id);
      this.scenes = await this.plugin.apiClient.getScenesByStory(this.currentStory.id);
      this.beats = await this.plugin.apiClient.getBeatsByStory(this.currentStory.id);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to load hierarchy";
      new import_obsidian11.Notice(`Error: ${errorMessage}`, 5e3);
    } finally {
      this.loadingHierarchy = false;
    }
  }
  showList() {
    this.currentStory = null;
    this.viewMode = "list";
    this.renderListHeader();
    this.renderStories();
  }
  renderDetails() {
    if (!this.contentEl || !this.currentStory)
      return;
    this.renderDetailsHeader();
    this.contentEl.empty();
    const story = this.currentStory;
    const details = this.contentEl.createDiv({ cls: "story-engine-details" });
    details.createEl("p", {
      text: `Status: ${story.status}`
    });
    details.createEl("p", {
      text: `Version: ${story.version_number}`
    });
    details.createEl("p", {
      text: `Created: ${new Date(story.created_at).toLocaleString()}`
    });
    details.createEl("p", {
      text: `Updated: ${new Date(story.updated_at).toLocaleString()}`
    });
    details.createEl("p", {
      text: `ID: ${story.id}`,
      cls: "story-engine-id"
    });
    const actionsSection = this.contentEl.createDiv({ cls: "story-engine-details-actions" });
    const syncButton = actionsSection.createEl("button", {
      text: "Sync from Service",
      cls: "story-engine-sync-btn"
    });
    syncButton.onclick = async () => {
      try {
        new import_obsidian11.Notice(`Syncing story "${story.title}"...`);
        await this.plugin.syncService.pullStory(story.id);
        await this.loadHierarchy();
        this.renderTabContent();
        new import_obsidian11.Notice(`Story synced successfully!`);
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to sync story";
        new import_obsidian11.Notice(`Error: ${errorMessage}`, 5e3);
      }
    };
    const pushButton = actionsSection.createEl("button", {
      text: "Push to Service",
      cls: "story-engine-push-btn"
    });
    pushButton.onclick = async () => {
      try {
        const folderPath = this.plugin.fileManager.getStoryFolderPath(story.title);
        new import_obsidian11.Notice(`Pushing story "${story.title}"...`);
        await this.plugin.syncService.pushStory(folderPath);
        new import_obsidian11.Notice(`Story pushed successfully!`);
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to push story";
        new import_obsidian11.Notice(`Error: ${errorMessage}`, 5e3);
      }
    };
    this.renderTabs();
    this.renderTabContent();
  }
  renderTabs() {
    if (!this.contentEl)
      return;
    const existingTabs = this.contentEl.querySelector(".story-engine-tabs");
    if (existingTabs) {
      existingTabs.remove();
    }
    const tabsContainer = this.contentEl.createDiv({ cls: "story-engine-tabs" });
    const chaptersTab = tabsContainer.createEl("button", {
      text: "Chapters",
      cls: `story-engine-tab ${this.currentTab === "chapters" ? "is-active" : ""}`
    });
    chaptersTab.onclick = () => {
      this.currentTab = "chapters";
      this.renderTabs();
      this.renderTabContent();
    };
    const scenesTab = tabsContainer.createEl("button", {
      text: "Scenes",
      cls: `story-engine-tab ${this.currentTab === "scenes" ? "is-active" : ""}`
    });
    scenesTab.onclick = () => {
      this.currentTab = "scenes";
      this.renderTabs();
      this.renderTabContent();
    };
    const beatsTab = tabsContainer.createEl("button", {
      text: "Beats",
      cls: `story-engine-tab ${this.currentTab === "beats" ? "is-active" : ""}`
    });
    beatsTab.onclick = () => {
      this.currentTab = "beats";
      this.renderTabs();
      this.renderTabContent();
    };
  }
  renderTabContent() {
    if (!this.contentEl)
      return;
    const existingContent = this.contentEl.querySelector(".story-engine-tab-content");
    if (existingContent) {
      existingContent.remove();
    }
    const tabContent = this.contentEl.createDiv({ cls: "story-engine-tab-content" });
    if (this.loadingHierarchy) {
      tabContent.createEl("p", { text: "Loading..." });
      return;
    }
    switch (this.currentTab) {
      case "chapters":
        this.renderChaptersTab(tabContent);
        break;
      case "scenes":
        this.renderScenesTab(tabContent);
        break;
      case "beats":
        this.renderBeatsTab(tabContent);
        break;
    }
  }
  renderChaptersTab(container) {
    container.empty();
    const header = container.createDiv({ cls: "story-engine-tab-header" });
    const createButton = header.createEl("button", {
      text: "Create Chapter",
      cls: "mod-cta"
    });
    createButton.onclick = () => {
      if (!this.currentStory)
        return;
      new ChapterModal(this.app, async (chapter) => {
        try {
          await this.plugin.apiClient.createChapter(this.currentStory.id, chapter);
          await this.loadHierarchy();
          this.renderTabContent();
          new import_obsidian11.Notice("Chapter created successfully");
        } catch (err) {
          throw err;
        }
      }, this.chapters).open();
    };
    const list = container.createDiv({ cls: "story-engine-list" });
    if (this.chapters.length === 0) {
      list.createEl("p", { text: "No chapters found." });
      return;
    }
    for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
      const item = list.createDiv({ cls: "story-engine-item" });
      item.createDiv({
        cls: "story-engine-title",
        text: `Chapter ${chapter.number}: ${chapter.title}`
      });
      const meta = item.createDiv({ cls: "story-engine-meta" });
      meta.createEl("span", { text: `Status: ${chapter.status}` });
      const actions = item.createDiv({ cls: "story-engine-item-actions" });
      actions.createEl("button", { text: "Edit" }).onclick = () => {
        new ChapterModal(this.app, async (updatedChapter) => {
          try {
            await this.plugin.apiClient.updateChapter(chapter.id, updatedChapter);
            await this.loadHierarchy();
            this.renderTabContent();
            new import_obsidian11.Notice("Chapter updated successfully");
          } catch (err) {
            throw err;
          }
        }, this.chapters, chapter).open();
      };
      actions.createEl("button", { text: "Delete" }).onclick = async () => {
        if (confirm("Delete this chapter?")) {
          try {
            await this.plugin.apiClient.deleteChapter(chapter.id);
            await this.loadHierarchy();
            this.renderTabContent();
            new import_obsidian11.Notice("Chapter deleted");
          } catch (err) {
            new import_obsidian11.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
          }
        }
      };
    }
  }
  renderScenesTab(container) {
    container.empty();
    const scenesByChapter = /* @__PURE__ */ new Map();
    for (const scene of this.scenes) {
      const chapterId = scene.chapter_id || null;
      if (!scenesByChapter.has(chapterId)) {
        scenesByChapter.set(chapterId, []);
      }
      scenesByChapter.get(chapterId).push(scene);
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
      const chapterScenes = scenesByChapter.get(chapter.id) || [];
      const group = list.createDiv({ cls: "story-engine-group" });
      const groupHeader = group.createDiv({ cls: "story-engine-group-header" });
      groupHeader.createEl("h3", { text: `Chapter ${chapter.number}: ${chapter.title}` });
      const addButton = groupHeader.createEl("button", {
        text: "+ Add Scene",
        cls: "story-engine-add-btn"
      });
      addButton.onclick = () => {
        if (!this.currentStory)
          return;
        new SceneModal(this.app, this.currentStory.id, this.chapters, async (scene) => {
          try {
            scene.chapter_id = chapter.id;
            await this.plugin.apiClient.createScene(scene);
            await this.loadHierarchy();
            this.renderTabContent();
            new import_obsidian11.Notice("Scene created successfully");
          } catch (err) {
            throw err;
          }
        }, this.scenes).open();
      };
      const groupItems = group.createDiv({ cls: "story-engine-group-items" });
      if (chapterScenes.length === 0) {
        groupItems.createEl("p", { text: "No scenes in this chapter." });
      } else {
        for (const scene of chapterScenes.sort((a, b) => a.order_num - b.order_num)) {
          this.renderSceneItem(groupItems, scene);
        }
      }
    }
    const orphanScenes = scenesByChapter.get(null) || [];
    if (orphanScenes.length > 0 || scenesByChapter.size === 0) {
      const group = list.createDiv({ cls: "story-engine-group" });
      const groupHeader = group.createDiv({ cls: "story-engine-group-header" });
      groupHeader.createEl("h3", { text: "Sem Chapter" });
      const addButton = groupHeader.createEl("button", {
        text: "+ Add Scene",
        cls: "story-engine-add-btn"
      });
      addButton.onclick = () => {
        if (!this.currentStory)
          return;
        new SceneModal(this.app, this.currentStory.id, this.chapters, async (scene) => {
          try {
            scene.chapter_id = null;
            await this.plugin.apiClient.createScene(scene);
            await this.loadHierarchy();
            this.renderTabContent();
            new import_obsidian11.Notice("Scene created successfully");
          } catch (err) {
            throw err;
          }
        }, this.scenes).open();
      };
      const groupItems = group.createDiv({ cls: "story-engine-group-items" });
      for (const scene of orphanScenes.sort((a, b) => a.order_num - b.order_num)) {
        this.renderSceneItem(groupItems, scene);
      }
    }
  }
  renderSceneItem(container, scene) {
    const item = container.createDiv({ cls: "story-engine-item" });
    item.createDiv({
      cls: "story-engine-title",
      text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`
    });
    const meta = item.createDiv({ cls: "story-engine-meta" });
    if (scene.time_ref) {
      meta.createEl("span", { text: `Time: ${scene.time_ref}` });
    }
    const actions = item.createDiv({ cls: "story-engine-item-actions" });
    actions.createEl("button", { text: "Edit" }).onclick = () => {
      if (!this.currentStory)
        return;
      new SceneModal(this.app, this.currentStory.id, this.chapters, async (updatedScene) => {
        try {
          await this.plugin.apiClient.updateScene(scene.id, updatedScene);
          await this.loadHierarchy();
          this.renderTabContent();
          new import_obsidian11.Notice("Scene updated successfully");
        } catch (err) {
          throw err;
        }
      }, this.scenes, scene).open();
    };
    actions.createEl("button", { text: "Move" }).onclick = async () => {
      await this.showMoveSceneModal(scene);
    };
    actions.createEl("button", { text: "Delete" }).onclick = async () => {
      if (confirm("Delete this scene?")) {
        try {
          await this.plugin.apiClient.deleteScene(scene.id);
          await this.loadHierarchy();
          this.renderTabContent();
          new import_obsidian11.Notice("Scene deleted");
        } catch (err) {
          new import_obsidian11.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
        }
      }
    };
  }
  renderBeatsTab(container) {
    container.empty();
    const beatsByScene = /* @__PURE__ */ new Map();
    for (const beat of this.beats) {
      if (!beatsByScene.has(beat.scene_id)) {
        beatsByScene.set(beat.scene_id, []);
      }
      beatsByScene.get(beat.scene_id).push(beat);
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
      const chapterScenes = this.scenes.filter((s) => s.chapter_id === chapter.id).sort((a, b) => a.order_num - b.order_num);
      if (chapterScenes.length > 0) {
        const chapterGroup = list.createDiv({ cls: "story-engine-chapter-group" });
        const chapterHeader = chapterGroup.createDiv({ cls: "story-engine-chapter-group-header" });
        chapterHeader.createEl("h2", {
          text: `Chapter ${chapter.number}: ${chapter.title}`
        });
        const chapterContent = chapterGroup.createDiv({ cls: "story-engine-chapter-group-content" });
        for (const scene of chapterScenes) {
          const sceneBeats = beatsByScene.get(scene.id) || [];
          const sceneGroup = chapterContent.createDiv({ cls: "story-engine-group" });
          const sceneHeader = sceneGroup.createDiv({ cls: "story-engine-group-header" });
          sceneHeader.createEl("h3", {
            text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`
          });
          const addButton = sceneHeader.createEl("button", {
            text: "+ Add Beat",
            cls: "story-engine-add-btn"
          });
          addButton.onclick = () => {
            if (!this.currentStory)
              return;
            new BeatModal(this.app, this.currentStory.id, this.scenes, async (beat) => {
              try {
                beat.scene_id = scene.id;
                await this.plugin.apiClient.createBeat(beat);
                await this.loadHierarchy();
                this.renderTabContent();
                new import_obsidian11.Notice("Beat created successfully");
              } catch (err) {
                throw err;
              }
            }, this.beats).open();
          };
          const sceneItems = sceneGroup.createDiv({ cls: "story-engine-group-items" });
          if (sceneBeats.length === 0) {
            sceneItems.createEl("p", { text: "No beats in this scene." });
          } else {
            for (const beat of sceneBeats.sort((a, b) => a.order_num - b.order_num)) {
              this.renderBeatItem(sceneItems, beat);
            }
          }
        }
      }
    }
    const orphanBeats = this.beats.filter((b) => {
      const scene = this.scenes.find((s) => s.id === b.scene_id);
      return !scene || !scene.chapter_id;
    });
    if (orphanBeats.length > 0 || this.scenes.some((s) => !s.chapter_id)) {
      const orphanGroup = list.createDiv({ cls: "story-engine-chapter-group" });
      const orphanHeader = orphanGroup.createDiv({ cls: "story-engine-chapter-group-header" });
      orphanHeader.createEl("h2", { text: "Sem Chapter" });
      const orphanContent = orphanGroup.createDiv({ cls: "story-engine-chapter-group-content" });
      const orphanScenes = this.scenes.filter((s) => !s.chapter_id).sort((a, b) => a.order_num - b.order_num);
      for (const scene of orphanScenes) {
        const sceneBeats = beatsByScene.get(scene.id) || [];
        const sceneGroup = orphanContent.createDiv({ cls: "story-engine-group" });
        const sceneHeader = sceneGroup.createDiv({ cls: "story-engine-group-header" });
        sceneHeader.createEl("h3", {
          text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`
        });
        const addButton = sceneHeader.createEl("button", {
          text: "+ Add Beat",
          cls: "story-engine-add-btn"
        });
        addButton.onclick = () => {
          if (!this.currentStory)
            return;
          new BeatModal(this.app, this.currentStory.id, this.scenes, async (beat) => {
            try {
              beat.scene_id = scene.id;
              await this.plugin.apiClient.createBeat(beat);
              await this.loadHierarchy();
              this.renderTabContent();
              new import_obsidian11.Notice("Beat created successfully");
            } catch (err) {
              throw err;
            }
          }, this.beats).open();
        };
        const sceneItems = sceneGroup.createDiv({ cls: "story-engine-group-items" });
        if (sceneBeats.length === 0) {
          sceneItems.createEl("p", { text: "No beats in this scene." });
        } else {
          for (const beat of sceneBeats.sort((a, b) => a.order_num - b.order_num)) {
            this.renderBeatItem(sceneItems, beat);
          }
        }
      }
      const beatsWithoutScene = orphanBeats.filter((b) => {
        const scene = this.scenes.find((s) => s.id === b.scene_id);
        return !scene;
      });
      if (beatsWithoutScene.length > 0) {
        const sceneGroup = orphanContent.createDiv({ cls: "story-engine-group" });
        const sceneHeader = sceneGroup.createDiv({ cls: "story-engine-group-header" });
        sceneHeader.createEl("h3", { text: "Sem Scene" });
        const sceneItems = sceneGroup.createDiv({ cls: "story-engine-group-items" });
        for (const beat of beatsWithoutScene.sort((a, b) => a.order_num - b.order_num)) {
          this.renderBeatItem(sceneItems, beat);
        }
      }
    }
  }
  renderBeatItem(container, beat) {
    const item = container.createDiv({ cls: "story-engine-item" });
    item.createDiv({
      cls: "story-engine-title",
      text: `Beat ${beat.order_num}: ${beat.type}`
    });
    const meta = item.createDiv({ cls: "story-engine-meta" });
    if (beat.intent) {
      meta.createEl("span", { text: `Intent: ${beat.intent}` });
    }
    if (beat.outcome) {
      meta.createEl("span", { text: `Outcome: ${beat.outcome}` });
    }
    const actions = item.createDiv({ cls: "story-engine-item-actions" });
    actions.createEl("button", { text: "Edit" }).onclick = () => {
      if (!this.currentStory)
        return;
      new BeatModal(this.app, this.currentStory.id, this.scenes, async (updatedBeat) => {
        try {
          await this.plugin.apiClient.updateBeat(beat.id, updatedBeat);
          await this.loadHierarchy();
          this.renderTabContent();
          new import_obsidian11.Notice("Beat updated successfully");
        } catch (err) {
          throw err;
        }
      }, this.beats, beat).open();
    };
    actions.createEl("button", { text: "Move" }).onclick = async () => {
      await this.showMoveBeatModal(beat);
    };
    actions.createEl("button", { text: "Delete" }).onclick = async () => {
      if (confirm("Delete this beat?")) {
        try {
          await this.plugin.apiClient.deleteBeat(beat.id);
          await this.loadHierarchy();
          this.renderTabContent();
          new import_obsidian11.Notice("Beat deleted");
        } catch (err) {
          new import_obsidian11.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
        }
      }
    };
  }
  async cloneStory() {
    var _a;
    if (!this.currentStory)
      return;
    const cloneButton = (_a = this.headerEl) == null ? void 0 : _a.querySelector(".story-engine-clone-btn");
    if (cloneButton) {
      cloneButton.disabled = true;
      cloneButton.setText("Cloning...");
    }
    try {
      if (!this.plugin.settings.tenantId) {
        throw new Error("Tenant ID not configured");
      }
      const clonedStory = await this.plugin.apiClient.cloneStory(
        this.currentStory.id
      );
      new import_obsidian11.Notice(`Story "${clonedStory.title}" cloned successfully!`);
      await this.loadStories();
      await this.showStoryDetails(clonedStory);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Clone failed";
      new import_obsidian11.Notice(`Error: ${errorMessage}`, 5e3);
      if (cloneButton) {
        cloneButton.setText("Clone Story");
        cloneButton.disabled = false;
      }
    }
  }
  copyStoryId() {
    var _a;
    if (!this.currentStory)
      return;
    const textarea = document.createElement("textarea");
    textarea.value = this.currentStory.id;
    textarea.style.position = "fixed";
    textarea.style.opacity = "0";
    textarea.style.left = "-9999px";
    document.body.appendChild(textarea);
    textarea.select();
    try {
      const doc = document;
      if (doc.execCommand) {
        doc.execCommand("copy");
        const copyButton = (_a = this.headerEl) == null ? void 0 : _a.querySelector(".story-engine-copy-id-btn");
        if (copyButton) {
          copyButton.setText("Copied!");
          setTimeout(() => {
            copyButton.setText("Copy ID");
          }, 2e3);
        }
        new import_obsidian11.Notice("Story ID copied to clipboard");
      }
    } catch (err) {
      console.error("Failed to copy ID:", err);
      new import_obsidian11.Notice("Failed to copy ID", 3e3);
    }
    document.body.removeChild(textarea);
  }
  async showMoveSceneModal(scene) {
    if (!this.currentStory)
      return;
    const modal = new import_obsidian11.Modal(this.app);
    modal.titleEl.setText("Move Scene");
    const content = modal.contentEl;
    content.createEl("p", { text: `Move scene "${scene.goal || `Scene ${scene.order_num}`}" to:` });
    const select = content.createEl("select", { cls: "story-engine-move-select" });
    const noChapterOption = select.createEl("option", { text: "No Chapter", value: "" });
    for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
      const option = select.createEl("option", {
        text: `Chapter ${chapter.number}: ${chapter.title}`,
        value: chapter.id
      });
      if (scene.chapter_id === chapter.id) {
        option.selected = true;
      }
    }
    if (!scene.chapter_id) {
      noChapterOption.selected = true;
    }
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const moveButton = buttonContainer.createEl("button", {
      text: "Move",
      cls: "mod-cta"
    });
    moveButton.onclick = async () => {
      const selectedChapterId = select.value || null;
      try {
        await this.plugin.apiClient.moveScene(scene.id, selectedChapterId);
        await this.loadHierarchy();
        this.renderTabContent();
        modal.close();
        new import_obsidian11.Notice("Scene moved successfully");
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to move scene";
        new import_obsidian11.Notice(`Error: ${errorMessage}`, 5e3);
      }
    };
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.onclick = () => modal.close();
    modal.open();
  }
  async showMoveBeatModal(beat) {
    if (!this.currentStory)
      return;
    const modal = new import_obsidian11.Modal(this.app);
    modal.titleEl.setText("Move Beat");
    const content = modal.contentEl;
    content.createEl("p", { text: `Move beat "${beat.type}" to:` });
    const select = content.createEl("select", { cls: "story-engine-move-select" });
    for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
      const chapterScenes = this.scenes.filter((s) => s.chapter_id === chapter.id).sort((a, b) => a.order_num - b.order_num);
      if (chapterScenes.length > 0) {
        const optgroup = select.createEl("optgroup");
        optgroup.label = `Chapter ${chapter.number}: ${chapter.title}`;
        for (const scene of chapterScenes) {
          const option = optgroup.createEl("option", {
            text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`,
            value: scene.id
          });
          if (beat.scene_id === scene.id) {
            option.selected = true;
          }
        }
      }
    }
    const orphanScenes = this.scenes.filter((s) => !s.chapter_id);
    if (orphanScenes.length > 0) {
      const optgroup = select.createEl("optgroup");
      optgroup.label = "No Chapter";
      for (const scene of orphanScenes.sort((a, b) => a.order_num - b.order_num)) {
        const option = optgroup.createEl("option", {
          text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`,
          value: scene.id
        });
        if (beat.scene_id === scene.id) {
          option.selected = true;
        }
      }
    }
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const moveButton = buttonContainer.createEl("button", {
      text: "Move",
      cls: "mod-cta"
    });
    moveButton.onclick = async () => {
      const selectedSceneId = select.value;
      if (!selectedSceneId) {
        new import_obsidian11.Notice("Please select a scene", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.moveBeat(beat.id, selectedSceneId);
        await this.loadHierarchy();
        this.renderTabContent();
        modal.close();
        new import_obsidian11.Notice("Beat moved successfully");
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to move beat";
        new import_obsidian11.Notice(`Error: ${errorMessage}`, 5e3);
      }
    };
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.onclick = () => modal.close();
    modal.open();
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  apiUrl: "http://localhost:8080",
  apiKey: "",
  tenantId: "",
  tenantName: "",
  syncFolderPath: "Stories",
  autoVersionSnapshots: true,
  conflictResolution: "service"
};
var StoryEnginePlugin = class extends import_obsidian12.Plugin {
  async onload() {
    await this.loadSettings();
    this.apiClient = new StoryEngineClient(
      this.settings.apiUrl,
      this.settings.apiKey,
      this.settings.tenantId || ""
    );
    this.fileManager = new FileManager(
      this.app.vault,
      this.settings.syncFolderPath || "Stories"
    );
    this.syncService = new SyncService(
      this.apiClient,
      this.fileManager,
      this.settings,
      this.app
    );
    this.addSettingTab(new StoryEngineSettingTab(this.app, this));
    this.registerView(
      STORY_LIST_VIEW_TYPE,
      (leaf) => new StoryListView(leaf, this)
    );
    this.addRibbonIcon("book-open", "Story Engine", () => {
      this.activateView();
    });
    registerCommands(this);
  }
  async onunload() {
    this.app.workspace.detachLeavesOfType(STORY_LIST_VIEW_TYPE);
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.apiClient) {
      this.apiClient.setTenantId(this.settings.tenantId || "");
    } else {
      this.apiClient = new StoryEngineClient(
        this.settings.apiUrl,
        this.settings.apiKey,
        this.settings.tenantId || ""
      );
    }
    this.fileManager = new FileManager(
      this.app.vault,
      this.settings.syncFolderPath || "Stories"
    );
    this.syncService = new SyncService(
      this.apiClient,
      this.fileManager,
      this.settings,
      this.app
    );
  }
  async createStoryCommand() {
    var _a;
    const tenantId = (_a = this.settings.tenantId) == null ? void 0 : _a.trim();
    if (!tenantId) {
      new import_obsidian12.Notice("Please configure Tenant ID in settings", 5e3);
      return;
    }
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    if (!uuidRegex.test(tenantId)) {
      new import_obsidian12.Notice("Invalid Tenant ID format. Please check your settings.", 5e3);
      return;
    }
    new CreateStoryModal(this.app, async (title, shouldSync) => {
      try {
        new import_obsidian12.Notice(`Creating story "${title}"...`);
        const story = await this.apiClient.createStory(title);
        new import_obsidian12.Notice(`Story "${title}" created successfully`);
        if (shouldSync) {
          try {
            new import_obsidian12.Notice(`Syncing story to Obsidian...`);
            await this.syncService.pullStory(story.id);
            new import_obsidian12.Notice(`Story synced to your vault!`);
          } catch (syncErr) {
            const syncErrorMessage = syncErr instanceof Error ? syncErr.message : "Failed to sync story";
            new import_obsidian12.Notice(`Story created but sync failed: ${syncErrorMessage}`, 5e3);
          }
        }
        const openView = this.app.workspace.getLeavesOfType(STORY_LIST_VIEW_TYPE)[0];
        if (openView) {
          const view = openView.view;
          await view.refresh();
          if (!shouldSync) {
            await view.showStoryDetails(story);
          }
        }
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to create story";
        new import_obsidian12.Notice(`Error: ${errorMessage}`, 5e3);
      }
    }).open();
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(STORY_LIST_VIEW_TYPE)[0];
    if (!leaf) {
      const rightLeaf = workspace.getRightLeaf(false);
      if (!rightLeaf) {
        new import_obsidian12.Notice("Could not create view. Please try again.", 3e3);
        return;
      }
      leaf = rightLeaf;
      await leaf.setViewState({
        type: STORY_LIST_VIEW_TYPE,
        active: true
      });
    }
    workspace.revealLeaf(leaf);
  }
};
