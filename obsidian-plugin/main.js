/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => StoryEnginePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian18 = require("obsidian");

// src/sync/apiUpdateNotifier.ts
var ApiUpdateNotifier = class {
  constructor() {
    this.subscribers = /* @__PURE__ */ new Set();
  }
  subscribe(subscriber) {
    this.subscribers.add(subscriber);
    return () => {
      this.subscribers.delete(subscriber);
    };
  }
  async notify(payload) {
    for (const subscriber of this.subscribers) {
      try {
        await subscriber(payload);
      } catch (err) {
        console.error("Auto sync subscriber failed", err);
      }
    }
  }
};
var apiUpdateNotifier = new ApiUpdateNotifier();

// src/api/client.ts
var StoryEngineClient = class {
  constructor(apiUrl, apiKey, tenantId = "") {
    this.apiUrl = apiUrl;
    this.apiKey = apiKey;
    this.tenantId = tenantId;
    this.mode = "remote";
    this.autoSyncOnApiUpdates = true;
  }
  setTenantId(tenantId) {
    this.tenantId = tenantId.trim();
  }
  setMode(mode) {
    this.mode = mode;
  }
  setAutoSyncOnApiUpdates(enabled) {
    this.autoSyncOnApiUpdates = enabled;
  }
  async request(method, endpoint, body, tenantIdOverride) {
    const url = `${this.apiUrl}${endpoint}`;
    const headers = new Headers();
    headers.set("Content-Type", "application/json");
    if (this.apiKey) {
      headers.set("Authorization", `Bearer ${this.apiKey}`);
    }
    const effectiveTenantId = tenantIdOverride != null ? tenantIdOverride : this.tenantId;
    if (effectiveTenantId) {
      const trimmedTenantId = effectiveTenantId.trim();
      if (trimmedTenantId) {
        headers.set("X-Tenant-ID", trimmedTenantId);
      }
    }
    const options = {
      method,
      headers
    };
    if (body) {
      options.body = JSON.stringify(body);
    }
    const response = await fetch(url, options);
    if (!response.ok) {
      let error;
      try {
        error = await response.json();
      } catch (e) {
        error = {
          error: "unknown_error",
          message: `HTTP ${response.status}: ${response.statusText}`,
          code: "HTTP_ERROR"
        };
      }
      const errorMessage = error.message || error.error || `HTTP ${response.status}: ${response.statusText}`;
      throw new Error(errorMessage);
    }
    return response.json();
  }
  async listStories() {
    if (this.mode === "remote" && (!this.tenantId || !this.tenantId.trim())) {
      throw new Error("Tenant ID is required");
    }
    const response = await this.request(
      "GET",
      "/api/v1/stories"
    );
    return response.stories || [];
  }
  async getStory(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/stories/${id2}`
    );
    return response.story;
  }
  async createStory(title, worldId) {
    if (this.mode === "remote" && (!this.tenantId || !this.tenantId.trim())) {
      throw new Error("Tenant ID is required");
    }
    const body = { title: title.trim() };
    if (worldId) {
      body.world_id = worldId;
    }
    const response = await this.request(
      "POST",
      "/api/v1/stories",
      body
    );
    return response.story;
  }
  async cloneStory(id2) {
    if (!this.tenantId || !this.tenantId.trim()) {
      throw new Error("Tenant ID is required");
    }
    const response = await this.request(
      "POST",
      `/api/v1/stories/${id2}/clone`,
      {}
    );
    return response.story;
  }
  async getTenant(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/tenants/${id2}`
    );
    return response.tenant;
  }
  async testConnection() {
    try {
      await this.request("GET", "/health");
      return true;
    } catch (e) {
      return false;
    }
  }
  async updateStory(id2, title, status) {
    const body = { title: title.trim() };
    if (status) {
      body.status = status;
    }
    const response = await this.request(
      "PUT",
      `/api/v1/stories/${id2}`,
      body
    );
    return response.story;
  }
  async getStoryWithHierarchy(id2) {
    const story = await this.getStory(id2);
    const chapters = await this.getChapters(id2);
    const chaptersWithContent = await Promise.all(
      chapters.map(async (chapter) => {
        const scenes = await this.getScenes(chapter.id);
        const scenesWithBeats = await Promise.all(
          scenes.map(async (scene) => {
            const beats = await this.getBeats(scene.id);
            return { scene, beats };
          })
        );
        return { chapter, scenes: scenesWithBeats };
      })
    );
    return {
      story,
      chapters: chaptersWithContent
    };
  }
  async createChapter(storyId, chapter) {
    const response = await this.request(
      "POST",
      "/api/v1/chapters",
      {
        story_id: storyId,
        number: chapter.number,
        title: chapter.title,
        status: chapter.status
      }
    );
    void this.publishChapterUpdate(response.chapter.id);
    return response.chapter;
  }
  async updateChapter(id2, chapter) {
    const response = await this.request(
      "PUT",
      `/api/v1/chapters/${id2}`,
      chapter
    );
    void this.publishChapterUpdate(response.chapter.id);
    return response.chapter;
  }
  async getChapters(storyId) {
    const response = await this.request(
      "GET",
      `/api/v1/stories/${storyId}/chapters`
    );
    return response.chapters || [];
  }
  async getChapter(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/chapters/${id2}`
    );
    return response.chapter;
  }
  async deleteChapter(id2) {
    await this.request("DELETE", `/api/v1/chapters/${id2}`);
  }
  async createScene(scene) {
    const response = await this.request(
      "POST",
      "/api/v1/scenes",
      scene
    );
    void this.publishSceneTree(response.scene.id);
    return response.scene;
  }
  async updateScene(id2, scene) {
    const response = await this.request(
      "PUT",
      `/api/v1/scenes/${id2}`,
      scene
    );
    void this.publishSceneTree(response.scene.id);
    return response.scene;
  }
  async getScenes(chapterId) {
    const response = await this.request(
      "GET",
      `/api/v1/chapters/${chapterId}/scenes`
    );
    return response.scenes || [];
  }
  async getScene(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/scenes/${id2}`
    );
    return response.scene;
  }
  async deleteScene(id2) {
    await this.request("DELETE", `/api/v1/scenes/${id2}`);
  }
  async createBeat(beat) {
    if (!beat.scene_id) {
      throw new Error("scene_id is required to create a beat");
    }
    const payload = { ...beat };
    if (!payload.order_num || payload.order_num <= 0) {
      const existingBeats = await this.getBeats(beat.scene_id);
      const nextOrder = existingBeats.length > 0 ? Math.max(...existingBeats.map((b) => b.order_num || 0)) + 1 : 1;
      payload.order_num = nextOrder;
    }
    const response = await this.request(
      "POST",
      "/api/v1/beats",
      payload
    );
    void this.publishSceneTree(response.beat.scene_id);
    return response.beat;
  }
  async updateBeat(id2, beat) {
    const response = await this.request(
      "PUT",
      `/api/v1/beats/${id2}`,
      beat
    );
    void this.publishSceneTree(response.beat.scene_id);
    return response.beat;
  }
  async getBeats(sceneId) {
    const response = await this.request(
      "GET",
      `/api/v1/scenes/${sceneId}/beats`
    );
    return response.beats || [];
  }
  async getBeat(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/beats/${id2}`
    );
    return response.beat;
  }
  async deleteBeat(id2) {
    await this.request("DELETE", `/api/v1/beats/${id2}`);
  }
  // Get all versions of a story (for version history)
  async getStoryVersions(rootStoryId) {
    const response = await this.request(
      "GET",
      `/api/v1/stories/${rootStoryId}/versions`
    );
    return response.stories || [];
  }
  async getScenesByStory(storyId) {
    const response = await this.request(
      "GET",
      `/api/v1/stories/${storyId}/scenes`
    );
    return response.scenes || [];
  }
  async moveScene(sceneId, chapterId) {
    const body = {};
    if (chapterId !== null) {
      body.chapter_id = chapterId;
    } else {
      body.chapter_id = null;
    }
    const response = await this.request(
      "PUT",
      `/api/v1/scenes/${sceneId}/move`,
      body
    );
    void this.publishSceneTree(response.scene.id);
    return response.scene;
  }
  async getBeatsByStory(storyId) {
    const response = await this.request(
      "GET",
      `/api/v1/stories/${storyId}/beats`
    );
    return response.beats || [];
  }
  async moveBeat(beatId, sceneId) {
    const response = await this.request(
      "PUT",
      `/api/v1/beats/${beatId}/move`,
      { scene_id: sceneId }
    );
    void this.publishSceneTree(response.beat.scene_id);
    return response.beat;
  }
  async getContentBlocks(chapterId) {
    const response = await this.request(
      "GET",
      `/api/v1/chapters/${chapterId}/content-blocks`
    );
    return response.content_blocks || [];
  }
  async getContentBlock(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/content-blocks/${id2}`
    );
    return response.content_block;
  }
  async createContentBlock(chapterId, contentBlock) {
    const response = await this.request(
      "POST",
      `/api/v1/chapters/${chapterId}/content-blocks`,
      contentBlock
    );
    void this.publishContentBlockUpdate(response.content_block.id);
    return response.content_block;
  }
  async updateContentBlock(id2, contentBlock) {
    const response = await this.request(
      "PUT",
      `/api/v1/content-blocks/${id2}`,
      contentBlock
    );
    void this.publishContentBlockUpdate(response.content_block.id);
    return response.content_block;
  }
  async deleteContentBlock(id2) {
    await this.request("DELETE", `/api/v1/content-blocks/${id2}`);
  }
  async getContentAnchors(contentBlockId) {
    const response = await this.request(
      "GET",
      `/api/v1/content-blocks/${contentBlockId}/anchors`
    );
    return response.anchors || [];
  }
  async getContentBlocksByScene(sceneId) {
    const response = await this.request(
      "GET",
      `/api/v1/scenes/${sceneId}/content-blocks`
    );
    return response.content_blocks || [];
  }
  async getContentBlocksByBeat(beatId) {
    const response = await this.request(
      "GET",
      `/api/v1/beats/${beatId}/content-blocks`
    );
    return response.content_blocks || [];
  }
  async createContentAnchor(contentBlockId, entityType, entityId) {
    const response = await this.request(
      "POST",
      `/api/v1/content-blocks/${contentBlockId}/anchors`,
      {
        entity_type: entityType,
        entity_id: entityId
      }
    );
    return response.anchor;
  }
  async deleteContentAnchor(id2) {
    await this.request("DELETE", `/api/v1/content-anchors/${id2}`);
  }
  async getWorlds() {
    const response = await this.request(
      "GET",
      "/api/v1/worlds"
    );
    return response.worlds || [];
  }
  async getWorld(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/worlds/${id2}`
    );
    return response.world;
  }
  async createWorld(name, description, genre) {
    const response = await this.request(
      "POST",
      "/api/v1/worlds",
      {
        name: name.trim(),
        description: description.trim(),
        genre: genre.trim()
      }
    );
    return response.world;
  }
  async updateWorld(id2, name, description, genre) {
    const response = await this.request(
      "PUT",
      `/api/v1/worlds/${id2}`,
      {
        name: name.trim(),
        description: description.trim(),
        genre: genre.trim()
      }
    );
    return response.world;
  }
  async getRPGSystems() {
    const response = await this.request(
      "GET",
      "/api/v1/rpg-systems"
    );
    return response.rpg_systems || [];
  }
  async getRPGSystem(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/rpg-systems/${id2}`
    );
    return response.rpg_system;
  }
  // Character methods
  async getCharacters(worldId) {
    const response = await this.request(
      "GET",
      `/api/v1/worlds/${worldId}/characters`
    );
    return response.characters || [];
  }
  async getCharacter(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/characters/${id2}`
    );
    return response.character;
  }
  async createCharacter(worldId, data) {
    const response = await this.request(
      "POST",
      `/api/v1/worlds/${worldId}/characters`,
      data
    );
    return response.character;
  }
  async updateCharacter(id2, data) {
    const response = await this.request(
      "PUT",
      `/api/v1/characters/${id2}`,
      data
    );
    return response.character;
  }
  async deleteCharacter(id2) {
    await this.request("DELETE", `/api/v1/characters/${id2}`);
  }
  // Location methods
  async getLocations(worldId) {
    const response = await this.request(
      "GET",
      `/api/v1/worlds/${worldId}/locations`
    );
    return response.locations || [];
  }
  async getLocation(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/locations/${id2}`
    );
    return response.location;
  }
  async createLocation(worldId, data) {
    const response = await this.request(
      "POST",
      `/api/v1/worlds/${worldId}/locations`,
      data
    );
    return response.location;
  }
  async updateLocation(id2, data) {
    const response = await this.request(
      "PUT",
      `/api/v1/locations/${id2}`,
      data
    );
    return response.location;
  }
  async deleteLocation(id2) {
    await this.request("DELETE", `/api/v1/locations/${id2}`);
  }
  // Artifact methods
  async getArtifacts(worldId) {
    const response = await this.request(
      "GET",
      `/api/v1/worlds/${worldId}/artifacts`
    );
    return response.artifacts || [];
  }
  async getArtifact(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/artifacts/${id2}`
    );
    return response.artifact;
  }
  async createArtifact(worldId, data) {
    const response = await this.request(
      "POST",
      `/api/v1/worlds/${worldId}/artifacts`,
      data
    );
    return response.artifact;
  }
  async updateArtifact(id2, data) {
    const response = await this.request(
      "PUT",
      `/api/v1/artifacts/${id2}`,
      data
    );
    return response.artifact;
  }
  async deleteArtifact(id2) {
    await this.request("DELETE", `/api/v1/artifacts/${id2}`);
  }
  // Event methods
  async getEvents(worldId) {
    const response = await this.request(
      "GET",
      `/api/v1/worlds/${worldId}/events`
    );
    return response.events || [];
  }
  async getEvent(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/events/${id2}`
    );
    return response.event;
  }
  async createEvent(worldId, data) {
    const response = await this.request(
      "POST",
      `/api/v1/worlds/${worldId}/events`,
      data
    );
    return response.event;
  }
  async updateEvent(id2, data) {
    const response = await this.request(
      "PUT",
      `/api/v1/events/${id2}`,
      data
    );
    return response.event;
  }
  async deleteEvent(id2) {
    await this.request("DELETE", `/api/v1/events/${id2}`);
  }
  async moveEvent(id2, parentId) {
    const response = await this.request(
      "PUT",
      `/api/v1/events/${id2}/move`,
      { parent_id: parentId }
    );
    return response.event;
  }
  // Trait methods
  async getTraits() {
    const response = await this.request(
      "GET",
      "/api/v1/traits"
    );
    return response.traits || [];
  }
  async getTrait(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/traits/${id2}`
    );
    return response.trait;
  }
  async createTrait(data) {
    const response = await this.request(
      "POST",
      "/api/v1/traits",
      data
    );
    return response.trait;
  }
  async updateTrait(id2, data) {
    const response = await this.request(
      "PUT",
      `/api/v1/traits/${id2}`,
      data
    );
    return response.trait;
  }
  async deleteTrait(id2) {
    await this.request("DELETE", `/api/v1/traits/${id2}`);
  }
  // Archetype methods
  async getArchetypes() {
    const response = await this.request(
      "GET",
      "/api/v1/archetypes"
    );
    return response.archetypes || [];
  }
  async getArchetype(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/archetypes/${id2}`
    );
    return response.archetype;
  }
  async createArchetype(data) {
    const response = await this.request(
      "POST",
      "/api/v1/archetypes",
      data
    );
    return response.archetype;
  }
  async updateArchetype(id2, data) {
    const response = await this.request(
      "PUT",
      `/api/v1/archetypes/${id2}`,
      data
    );
    return response.archetype;
  }
  async deleteArchetype(id2) {
    await this.request("DELETE", `/api/v1/archetypes/${id2}`);
  }
  async getArchetypeTraits(archetypeId) {
    const response = await this.request(
      "GET",
      `/api/v1/archetypes/${archetypeId}/traits`
    );
    return response.archetype_traits || [];
  }
  async addArchetypeTrait(archetypeId, traitId, defaultValue) {
    await this.request(
      "POST",
      `/api/v1/archetypes/${archetypeId}/traits`,
      {
        trait_id: traitId,
        default_value: defaultValue
      }
    );
  }
  async removeArchetypeTrait(archetypeId, traitId) {
    await this.request(
      "DELETE",
      `/api/v1/archetypes/${archetypeId}/traits/${traitId}`
    );
  }
  // Faction methods
  async getFactions(worldId) {
    const response = await this.request(
      "GET",
      `/api/v1/worlds/${worldId}/factions`
    );
    return response.factions || [];
  }
  async getFaction(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/factions/${id2}`
    );
    return response.faction;
  }
  async createFaction(worldId, data) {
    const response = await this.request(
      "POST",
      `/api/v1/worlds/${worldId}/factions`,
      data
    );
    return response.faction;
  }
  async updateFaction(id2, data) {
    const response = await this.request(
      "PUT",
      `/api/v1/factions/${id2}`,
      data
    );
    return response.faction;
  }
  async deleteFaction(id2) {
    await this.request("DELETE", `/api/v1/factions/${id2}`);
  }
  async getFactionChildren(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/factions/${id2}/children`
    );
    return response.factions || [];
  }
  async getFactionReferences(factionId) {
    const response = await this.request(
      "GET",
      `/api/v1/factions/${factionId}/references`
    );
    return response.references || [];
  }
  async addFactionReference(factionId, entityType, entityId, role, notes) {
    const response = await this.request(
      "POST",
      `/api/v1/factions/${factionId}/references`,
      {
        entity_type: entityType,
        entity_id: entityId,
        role,
        notes
      }
    );
    return response.reference;
  }
  async updateFactionReference(id2, role, notes) {
    const response = await this.request(
      "PUT",
      `/api/v1/faction-references/${id2}`,
      {
        role,
        notes
      }
    );
    return response.reference;
  }
  async removeFactionReference(factionId, entityType, entityId) {
    await this.request(
      "DELETE",
      `/api/v1/factions/${factionId}/references/${entityType}/${entityId}`
    );
  }
  // Lore methods
  async getLores(worldId) {
    const response = await this.request(
      "GET",
      `/api/v1/worlds/${worldId}/lores`
    );
    return response.lores || [];
  }
  async getLore(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/lores/${id2}`
    );
    return response.lore;
  }
  async createLore(worldId, data) {
    const response = await this.request(
      "POST",
      `/api/v1/worlds/${worldId}/lores`,
      data
    );
    return response.lore;
  }
  async updateLore(id2, data) {
    const response = await this.request(
      "PUT",
      `/api/v1/lores/${id2}`,
      data
    );
    return response.lore;
  }
  async deleteLore(id2) {
    await this.request("DELETE", `/api/v1/lores/${id2}`);
  }
  async getLoreChildren(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/lores/${id2}/children`
    );
    return response.lores || [];
  }
  async getLoreReferences(loreId) {
    const response = await this.request(
      "GET",
      `/api/v1/lores/${loreId}/references`
    );
    return response.references || [];
  }
  async addLoreReference(loreId, entityType, entityId, relationshipType, notes) {
    const response = await this.request(
      "POST",
      `/api/v1/lores/${loreId}/references`,
      {
        entity_type: entityType,
        entity_id: entityId,
        relationship_type: relationshipType,
        notes
      }
    );
    return response.reference;
  }
  async updateLoreReference(id2, relationshipType, notes) {
    const response = await this.request(
      "PUT",
      `/api/v1/lore-references/${id2}`,
      {
        relationship_type: relationshipType,
        notes
      }
    );
    return response.reference;
  }
  async removeLoreReference(loreId, entityType, entityId) {
    await this.request(
      "DELETE",
      `/api/v1/lores/${loreId}/references/${entityType}/${entityId}`
    );
  }
  // Character Traits methods
  async getCharacterTraits(characterId) {
    const response = await this.request(
      "GET",
      `/api/v1/characters/${characterId}/traits`
    );
    return response.character_traits || [];
  }
  async addCharacterTrait(characterId, traitId, value, notes) {
    const response = await this.request(
      "POST",
      `/api/v1/characters/${characterId}/traits`,
      {
        trait_id: traitId,
        value,
        notes
      }
    );
    return response.character_trait;
  }
  async updateCharacterTrait(characterId, traitId, value, notes) {
    const response = await this.request(
      "PUT",
      `/api/v1/characters/${characterId}/traits/${traitId}`,
      {
        value,
        notes
      }
    );
    return response.character_trait;
  }
  async removeCharacterTrait(characterId, traitId) {
    await this.request(
      "DELETE",
      `/api/v1/characters/${characterId}/traits/${traitId}`
    );
  }
  // Character Events methods
  async getCharacterEvents(characterId) {
    const response = await this.request(
      "GET",
      `/api/v1/characters/${characterId}/events`
    );
    return response.event_characters || [];
  }
  // Character Relationships methods
  async getCharacterRelationships(characterId) {
    const response = await this.request(
      "GET",
      `/api/v1/characters/${characterId}/relationships`
    );
    return response.relationships || [];
  }
  async createCharacterRelationship(characterId, data) {
    const response = await this.request(
      "POST",
      `/api/v1/characters/${characterId}/relationships`,
      data
    );
    return response.relationship;
  }
  async updateCharacterRelationship(id2, data) {
    const response = await this.request(
      "PUT",
      `/api/v1/character-relationships/${id2}`,
      data
    );
    return response.relationship;
  }
  async deleteCharacterRelationship(id2) {
    await this.request("DELETE", `/api/v1/character-relationships/${id2}`);
  }
  async createEntityRelation(input) {
    var _a;
    const response = await this.request(
      "POST",
      "/api/v1/relations",
      {
        world_id: input.world_id,
        source_type: input.source_type,
        source_id: input.source_id,
        target_type: input.target_type,
        target_id: input.target_id,
        relation_type: input.relation_type,
        summary: input.summary,
        create_mirror: (_a = input.create_mirror) != null ? _a : false
      }
    );
    return response.relation;
  }
  // Event Characters/References methods
  async getEventCharacters(eventId) {
    const response = await this.request(
      "GET",
      `/api/v1/events/${eventId}/characters`
    );
    return response.event_characters || [];
  }
  async addEventCharacter(eventId, characterId, role) {
    const response = await this.request(
      "POST",
      `/api/v1/events/${eventId}/characters`,
      {
        character_id: characterId,
        role
      }
    );
    return response.event_character;
  }
  async removeEventCharacter(eventId, characterId) {
    await this.request(
      "DELETE",
      `/api/v1/events/${eventId}/characters/${characterId}`
    );
  }
  async getEventReferences(eventId) {
    const response = await this.request(
      "GET",
      `/api/v1/events/${eventId}/references`
    );
    return response.references || [];
  }
  async addEventReference(eventId, entityType, entityId, relationshipType, notes) {
    const response = await this.request(
      "POST",
      `/api/v1/events/${eventId}/references`,
      {
        entity_type: entityType,
        entity_id: entityId,
        relationship_type: relationshipType,
        notes
      }
    );
    return response.reference;
  }
  async updateEventReference(id2, relationshipType, notes) {
    const response = await this.request(
      "PUT",
      `/api/v1/event-references/${id2}`,
      {
        relationship_type: relationshipType,
        notes
      }
    );
    return response.reference;
  }
  async removeEventReference(eventId, entityType, entityId) {
    await this.request(
      "DELETE",
      `/api/v1/events/${eventId}/references/${entityType}/${entityId}`
    );
  }
  // Scene References methods
  async getSceneReferences(sceneId) {
    const response = await this.request(
      "GET",
      `/api/v1/scenes/${sceneId}/references`
    );
    return response.references || [];
  }
  async addSceneReference(sceneId, entityType, entityId) {
    const response = await this.request(
      "POST",
      `/api/v1/scenes/${sceneId}/references`,
      {
        entity_type: entityType,
        entity_id: entityId
      }
    );
    return response.reference;
  }
  async removeSceneReference(sceneId, entityType, entityId) {
    await this.request(
      "DELETE",
      `/api/v1/scenes/${sceneId}/references/${entityType}/${entityId}`
    );
  }
  // Timeline methods
  async getTimeline(worldId, fromPos, toPos) {
    const queryParams = new URLSearchParams();
    if (fromPos !== void 0) {
      queryParams.append("from_pos", fromPos.toString());
    }
    if (toPos !== void 0) {
      queryParams.append("to_pos", toPos.toString());
    }
    const queryString = queryParams.toString();
    const endpoint = `/api/v1/worlds/${worldId}/timeline${queryString ? `?${queryString}` : ""}`;
    const response = await this.request(
      "GET",
      endpoint
    );
    return response.events || [];
  }
  // World TimeConfig methods
  async updateWorldTimeConfig(worldId, timeConfig) {
    const response = await this.request(
      "PUT",
      `/api/v1/worlds/${worldId}/time-config`,
      timeConfig
    );
    return response.world;
  }
  isAutoSyncEnabled() {
    return this.autoSyncOnApiUpdates;
  }
  async publishChapterUpdate(chapterId) {
    if (!this.isAutoSyncEnabled()) {
      return;
    }
    try {
      const chapter = await this.getChapter(chapterId);
      const story = await this.getStory(chapter.story_id);
      const scenes = await this.getScenes(chapterId);
      const scenesWithBeats = await Promise.all(
        scenes.map(async (scene) => {
          const beats = await this.getBeats(scene.id);
          return { scene, beats };
        })
      );
      const contentBlocks = await this.getContentBlocks(chapterId);
      const contentBlockRefs = [];
      for (const block of contentBlocks) {
        const refs = await this.getContentAnchors(block.id);
        contentBlockRefs.push(...refs);
      }
      await this.notifyEntityUpdate({
        type: "chapter",
        story,
        chapter,
        scenes: scenesWithBeats,
        contentBlocks,
        contentBlockRefs
      });
    } catch (err) {
      console.error("Failed to auto-sync chapter update", err);
    }
  }
  async publishSceneTree(sceneId) {
    if (!this.isAutoSyncEnabled()) {
      return;
    }
    try {
      const scene = await this.getScene(sceneId);
      if (scene.chapter_id) {
        await this.publishChapterUpdate(scene.chapter_id);
        return;
      }
      const story = await this.getStory(scene.story_id);
      const beats = await this.getBeats(scene.id);
      const sceneContentBlocks = await this.getContentBlocksByScene(scene.id);
      const beatContentBlocks = {};
      for (const beat of beats) {
        beatContentBlocks[beat.id] = await this.getContentBlocksByBeat(beat.id);
      }
      await this.notifyEntityUpdate({
        type: "scene",
        story,
        scene,
        beats,
        sceneContentBlocks,
        beatContentBlocks
      });
    } catch (err) {
      console.error("Failed to auto-sync scene update", err);
    }
  }
  async publishContentBlockUpdate(contentBlockId) {
    if (!this.isAutoSyncEnabled()) {
      return;
    }
    try {
      const contentBlock = await this.getContentBlock(contentBlockId);
      let story = null;
      if (contentBlock.chapter_id) {
        const chapter = await this.getChapter(contentBlock.chapter_id);
        story = await this.getStory(chapter.story_id);
      } else {
        const anchors = await this.getContentAnchors(contentBlock.id);
        const sceneAnchor = anchors.find((anchor) => anchor.entity_type === "scene");
        if (sceneAnchor) {
          const scene = await this.getScene(sceneAnchor.entity_id);
          story = await this.getStory(scene.story_id);
        }
      }
      if (!story) {
        console.warn("Unable to resolve story for content block auto-sync", contentBlockId);
        return;
      }
      await this.notifyEntityUpdate({
        type: "content",
        story,
        contentBlock
      });
    } catch (err) {
      console.error("Failed to auto-sync content block update", err);
    }
  }
  async notifyEntityUpdate(payload) {
    await apiUpdateNotifier.notify(payload);
  }
};

// src/settings.ts
var import_obsidian = require("obsidian");
var StoryEngineSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Story Engine Settings" });
    let tenantIdSetting = null;
    let videoLinkSetting = null;
    let conflictResolutionSetting = null;
    const modeSetting = new import_obsidian.Setting(containerEl).setName("Connection Mode").setDesc("Choose between local (offline) or remote (cloud) mode").addDropdown(
      (dropdown) => dropdown.addOption("local", "Local").addOption("remote", "Remote").setValue(this.plugin.settings.mode || "local").onChange(async (value) => {
        this.plugin.settings.mode = value;
        if (value === "local") {
          this.plugin.settings.conflictResolution = "local";
          if (conflictResolutionSetting) {
            conflictResolutionSetting.settingEl.style.display = "none";
          }
        } else {
          if (conflictResolutionSetting) {
            conflictResolutionSetting.settingEl.style.display = "";
          }
        }
        if (tenantIdSetting) {
          tenantIdSetting.settingEl.style.display = value === "remote" ? "" : "none";
        }
        if (videoLinkSetting) {
          videoLinkSetting.settingEl.style.display = value === "local" ? "" : "none";
        }
        if (this.plugin.apiClient) {
          this.plugin.apiClient.setMode(value);
        }
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("API URL").setDesc("The base URL of the Story Engine API").addText(
      (text) => text.setPlaceholder("http://localhost:8080").setValue(this.plugin.settings.apiUrl).onChange(async (value) => {
        this.plugin.settings.apiUrl = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("LLM Gateway URL").setDesc("The base URL of the LLM Gateway service").addText(
      (text) => text.setPlaceholder("http://localhost:8081").setValue(this.plugin.settings.llmGatewayUrl).onChange(async (value) => {
        this.plugin.settings.llmGatewayUrl = value.trim();
        await this.plugin.saveSettings();
      })
    );
    tenantIdSetting = new import_obsidian.Setting(containerEl).setName("Tenant ID").setDesc("Your workspace tenant ID (UUID format) - Required in remote mode").addText(
      (text) => text.setPlaceholder("00000000-0000-0000-0000-000000000000").setValue(this.plugin.settings.tenantId || "").onChange(async (value) => {
        this.plugin.settings.tenantId = value.trim();
        if (this.plugin.apiClient) {
          this.plugin.apiClient.setTenantId(value.trim());
        }
        await this.plugin.saveSettings();
      })
    );
    if (this.plugin.settings.mode === "local") {
      tenantIdSetting.settingEl.style.display = "none";
    }
    const videoUrl = this.plugin.settings.localModeVideoUrl || "https://example.com/setup-video";
    videoLinkSetting = new import_obsidian.Setting(containerEl).setName("Setup Guide").setDesc(`\u{1F4F9} Learn how to setup local mode: ${videoUrl}`).addButton((button) => {
      button.setButtonText("Open Video").onClick(() => {
        window.open(videoUrl, "_blank");
      });
    });
    if (this.plugin.settings.mode === "remote") {
      videoLinkSetting.settingEl.style.display = "none";
    }
    new import_obsidian.Setting(containerEl).setName("API Key").setDesc("API key for authentication (optional for MVP)").addText((text) => {
      text.setPlaceholder("Enter API key").setValue(this.plugin.settings.apiKey).inputEl.type = "password";
      text.onChange(async (value) => {
        this.plugin.settings.apiKey = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Sync Folder Path").setDesc("Folder path where synced stories will be stored").addText(
      (text) => text.setPlaceholder("Stories").setValue(this.plugin.settings.syncFolderPath || "Stories").onChange(async (value) => {
        this.plugin.settings.syncFolderPath = value.trim() || "Stories";
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Auto Version Snapshots").setDesc("Automatically create version snapshots when syncing").addToggle(
      (toggle) => {
        var _a;
        return toggle.setValue((_a = this.plugin.settings.autoVersionSnapshots) != null ? _a : true).onChange(async (value) => {
          this.plugin.settings.autoVersionSnapshots = value;
          await this.plugin.saveSettings();
        });
      }
    );
    new import_obsidian.Setting(containerEl).setName("Auto Sync on API Updates").setDesc("Apply API update payloads directly to local files when available").addToggle(
      (toggle) => {
        var _a;
        return toggle.setValue((_a = this.plugin.settings.autoSyncOnApiUpdates) != null ? _a : true).onChange(async (value) => {
          this.plugin.settings.autoSyncOnApiUpdates = value;
          await this.plugin.saveSettings();
        });
      }
    );
    new import_obsidian.Setting(containerEl).setName("Auto Push on Blur/Idle").setDesc("When you leave a chapter/scene/beat or stay idle for 1 min, push changes upstream automatically").addToggle(
      (toggle) => {
        var _a;
        return toggle.setValue((_a = this.plugin.settings.autoPushOnFileBlur) != null ? _a : true).onChange(async (value) => {
          this.plugin.settings.autoPushOnFileBlur = value;
          await this.plugin.saveSettings();
        });
      }
    );
    conflictResolutionSetting = new import_obsidian.Setting(containerEl).setName("Conflict Resolution").setDesc("How to resolve conflicts when both local and service have changes").addDropdown(
      (dropdown) => dropdown.addOption("service", "Service Wins").addOption("local", "Local Wins").addOption("manual", "Manual (Newer Wins)").setValue(this.plugin.settings.conflictResolution || "service").onChange(async (value) => {
        this.plugin.settings.conflictResolution = value;
        await this.plugin.saveSettings();
      })
    );
    if (this.plugin.settings.mode === "local") {
      conflictResolutionSetting.settingEl.style.display = "none";
    }
    new import_obsidian.Setting(containerEl).setName("Show Help Box in MD Files").setDesc("Enable/disable info/help boxes in markdown files").addToggle(
      (toggle) => {
        var _a;
        return toggle.setValue((_a = this.plugin.settings.showHelpBox) != null ? _a : true).onChange(async (value) => {
          this.plugin.settings.showHelpBox = value;
          await this.plugin.saveSettings();
        });
      }
    );
    new import_obsidian.Setting(containerEl).setName("Unsplash Access Key").setDesc("Application ID / Access Key for Unsplash API (get one at https://unsplash.com/developers)").addText((text) => {
      text.setPlaceholder("Enter Unsplash access key").setValue(this.plugin.settings.unsplashAccessKey || "").inputEl.type = "password";
      text.onChange(async (value) => {
        this.plugin.settings.unsplashAccessKey = value.trim();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Unsplash Secret Key").setDesc("Secret Key for Unsplash API (optional, needed for some operations)").addText((text) => {
      text.setPlaceholder("Enter Unsplash secret key").setValue(this.plugin.settings.unsplashSecretKey || "").inputEl.type = "password";
      text.onChange(async (value) => {
        this.plugin.settings.unsplashSecretKey = value.trim();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Test Connection").setDesc("Test connection to the Story Engine API").addButton(
      (button) => button.setButtonText("Test").onClick(async () => {
        button.setButtonText("Testing...");
        button.setDisabled(true);
        try {
          const result = await this.plugin.apiClient.testConnection();
          if (result) {
            button.setButtonText("Success!");
            setTimeout(() => {
              button.setButtonText("Test");
              button.setDisabled(false);
            }, 2e3);
          } else {
            button.setButtonText("Failed");
            setTimeout(() => {
              button.setButtonText("Test");
              button.setDisabled(false);
            }, 2e3);
          }
        } catch (err) {
          button.setButtonText("Error");
          setTimeout(() => {
            button.setButtonText("Test");
            button.setDisabled(false);
          }, 2e3);
        }
      })
    );
  }
};

// src/commands.ts
var import_obsidian3 = require("obsidian");

// src/views/StorySyncModal.ts
var import_obsidian2 = require("obsidian");
var StorySyncModal = class extends import_obsidian2.Modal {
  constructor(plugin, mode) {
    super(plugin.app);
    this.stories = [];
    this.loading = true;
    this.error = null;
    this.plugin = plugin;
    this.mode = mode;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    const title = this.mode === "pull" ? "Sync Story from Service" : "Push Story to Service";
    contentEl.createEl("h2", { text: title });
    await this.loadStories();
    if (this.loading) {
      contentEl.createEl("p", { text: "Loading stories..." });
      return;
    }
    if (this.error) {
      contentEl.createEl("p", {
        text: `Error: ${this.error}`,
        cls: "story-engine-error"
      });
      return;
    }
    if (this.stories.length === 0) {
      contentEl.createEl("p", { text: "No stories found." });
      return;
    }
    const storiesList = contentEl.createEl("div", { cls: "story-engine-list" });
    for (const story of this.stories) {
      const storyItem = storiesList.createEl("div", {
        cls: "story-engine-item"
      });
      const title2 = storyItem.createEl("div", {
        cls: "story-engine-title",
        text: story.title
      });
      const meta = storyItem.createEl("div", {
        cls: "story-engine-meta"
      });
      meta.createEl("span", {
        text: `Version ${story.version_number}`
      });
      meta.createEl("span", {
        text: `Status: ${story.status}`
      });
      storyItem.onclick = async () => {
        this.close();
        try {
          if (this.mode === "pull") {
            await this.plugin.syncService.pullStory(story.id);
          } else {
            const folderPath = this.plugin.fileManager.getStoryFolderPath(
              story.title
            );
            await this.plugin.syncService.pushStory(folderPath);
          }
        } catch (err) {
          const errorMessage = err instanceof Error ? err.message : "Failed to sync story";
          new import_obsidian2.Notice(`Error: ${errorMessage}`, 5e3);
        }
      };
    }
  }
  async loadStories() {
    this.loading = true;
    this.error = null;
    try {
      if (!this.plugin.settings.tenantId) {
        this.error = "Tenant ID not configured";
        this.loading = false;
        return;
      }
      this.stories = await this.plugin.apiClient.listStories();
    } catch (err) {
      this.error = err instanceof Error ? err.message : "Unknown error";
    } finally {
      this.loading = false;
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/commands.ts
function registerCommands(plugin) {
  plugin.addCommand({
    id: "list-stories",
    name: "List Stories",
    callback: () => {
      plugin.activateView();
    }
  });
  plugin.addCommand({
    id: "create-story",
    name: "Create Story",
    callback: () => {
      plugin.createStoryCommand();
    }
  });
  plugin.addCommand({
    id: "sync-story-from-service",
    name: "Sync Story from Service",
    callback: () => {
      new StorySyncModal(plugin, "pull").open();
    }
  });
  plugin.addCommand({
    id: "push-story-to-service",
    name: "Push Story to Service",
    callback: () => {
      new StorySyncModal(plugin, "push").open();
    }
  });
  plugin.addCommand({
    id: "sync-all-stories",
    name: "Sync All Stories",
    callback: async () => {
      if (plugin.settings.mode === "remote" && !plugin.settings.tenantId) {
        new import_obsidian3.Notice("Please configure Tenant ID in settings", 5e3);
        return;
      }
      try {
        new import_obsidian3.Notice("Syncing all stories...");
        await plugin.syncService.pullAllStories();
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to sync stories";
        new import_obsidian3.Notice(`Error: ${errorMessage}`, 5e3);
      }
    }
  });
  plugin.addCommand({
    id: "extract-entities-from-selection",
    name: "Extract Entities and Relations from Selection",
    editorCallback: (editor) => {
      const selection2 = editor.getSelection();
      if (!selection2.trim()) {
        new import_obsidian3.Notice("Select text to extract entities and relations", 3e3);
        return;
      }
      plugin.extractSelectionCommand(selection2, true);
    }
  });
  plugin.addCommand({
    id: "extract-entities-only-from-selection",
    name: "Extract Entities Only from Selection",
    editorCallback: (editor) => {
      const selection2 = editor.getSelection();
      if (!selection2.trim()) {
        new import_obsidian3.Notice("Select text to extract entities", 3e3);
        return;
      }
      plugin.extractSelectionCommand(selection2, false);
    }
  });
}

// src/views/CreateStoryModal.ts
var import_obsidian5 = require("obsidian");

// src/views/CreateWorldModal.ts
var import_obsidian4 = require("obsidian");
var CreateWorldModal = class extends import_obsidian4.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.name = "";
    this.description = "";
    this.genre = "";
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Create New World" });
    new import_obsidian4.Setting(contentEl).setName("World Name").setDesc("Enter the name for your new world").addText(
      (text) => text.setPlaceholder("My New World").setValue(this.name).onChange((value) => {
        this.name = value;
      }).inputEl.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          const descriptionInput = contentEl.querySelector("textarea");
          if (descriptionInput) {
            descriptionInput.focus();
          }
        }
      })
    );
    new import_obsidian4.Setting(contentEl).setName("Description").setDesc("Enter a description for your world").addTextArea(
      (text) => text.setPlaceholder("A brief description of your world...").setValue(this.description).onChange((value) => {
        this.description = value;
      })
    );
    new import_obsidian4.Setting(contentEl).setName("Genre").setDesc("Enter the genre of your world").addText(
      (text) => text.setPlaceholder("Fantasy, Sci-Fi, Contemporary, etc.").setValue(this.genre).onChange((value) => {
        this.genre = value;
      }).inputEl.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          this.submit();
        }
      })
    );
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const createButton = buttonContainer.createEl("button", {
      text: "Create",
      cls: "mod-cta"
    });
    createButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
    const nameInput = contentEl.querySelector("input");
    if (nameInput) {
      nameInput.focus();
    }
  }
  submit() {
    const trimmedName = this.name.trim();
    const trimmedDescription = this.description.trim();
    const trimmedGenre = this.genre.trim();
    if (!trimmedName) {
      new import_obsidian4.Notice("Please enter a world name", 3e3);
      return;
    }
    if (!trimmedGenre) {
      new import_obsidian4.Notice("Please enter a genre", 3e3);
      return;
    }
    this.close();
    this.onSubmit(trimmedName, trimmedDescription, trimmedGenre);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/CreateStoryModal.ts
var CreateStoryModal = class extends import_obsidian5.Modal {
  constructor(app, plugin, onSubmit) {
    super(app);
    this.title = "";
    this.selectedWorldId = "";
    this.shouldSync = true;
    this.worlds = [];
    this.plugin = plugin;
    this.onSubmit = onSubmit;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Create New Story" });
    try {
      this.worlds = await this.plugin.apiClient.getWorlds();
    } catch (err) {
      console.error("Failed to load worlds:", err);
      this.worlds = [];
    }
    new import_obsidian5.Setting(contentEl).setName("Story Title").setDesc("Enter the title for your new story").addText(
      (text) => text.setPlaceholder("My New Story").setValue(this.title).onChange((value) => {
        this.title = value;
      }).inputEl.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          this.submit();
        }
      })
    );
    const worldOptions = {
      "": "No World"
    };
    for (const world of this.worlds) {
      worldOptions[world.id] = world.name;
    }
    worldOptions["__create_new__"] = "Create new world...";
    new import_obsidian5.Setting(contentEl).setName("World").setDesc("Select a world for this story (optional)").addDropdown((dropdown) => {
      for (const [value, label] of Object.entries(worldOptions)) {
        dropdown.addOption(value, label);
      }
      dropdown.setValue(this.selectedWorldId || "");
      dropdown.onChange(async (value) => {
        if (value === "__create_new__") {
          new CreateWorldModal(this.app, async (name, description, genre) => {
            try {
              const newWorld = await this.plugin.apiClient.createWorld(name, description, genre);
              this.worlds.push(newWorld);
              this.onClose();
              this.onOpen();
              this.selectedWorldId = newWorld.id;
            } catch (err) {
              const errorMessage = err instanceof Error ? err.message : "Failed to create world";
              new import_obsidian5.Notice(`Error: ${errorMessage}`, 5e3);
            }
          }).open();
        } else {
          this.selectedWorldId = value;
        }
      });
    });
    new import_obsidian5.Setting(contentEl).setName("Sync to Obsidian").setDesc("Automatically sync the story files to your vault after creation").addToggle(
      (toggle) => toggle.setValue(this.shouldSync).onChange((value) => {
        this.shouldSync = value;
      })
    );
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const createButton = buttonContainer.createEl("button", {
      text: "Create",
      cls: "mod-cta"
    });
    createButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
    const titleInput = contentEl.querySelector("input");
    if (titleInput) {
      titleInput.focus();
    }
  }
  submit() {
    const trimmedTitle = this.title.trim();
    if (!trimmedTitle) {
      new import_obsidian5.Notice("Please enter a story title", 3e3);
      return;
    }
    this.close();
    const worldId = this.selectedWorldId && this.selectedWorldId !== "__create_new__" ? this.selectedWorldId : void 0;
    this.onSubmit(trimmedTitle, worldId, this.shouldSync);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/sync/fileManager.ts
var import_obsidian6 = require("obsidian");
var FileManager = class {
  constructor(vault, baseFolder) {
    this.vault = vault;
    this.baseFolder = baseFolder;
  }
  // Expose vault for sync operations
  getVault() {
    return this.vault;
  }
  // Get the folder path for a specific story
  getStoryFolderPath(storyTitle) {
    const sanitized = this.sanitizeFolderName(storyTitle);
    return `${this.baseFolder}/${sanitized}`;
  }
  // Sanitize folder/file names
  sanitizeFolderName(name) {
    return name.replace(/[<>:"/\\|?*]/g, "-").replace(/\s+/g, " ").trim();
  }
  // Generate frontmatter with Obsidian tags
  generateFrontmatter(baseFields, extraFields, options) {
    const fields = { ...baseFields };
    if (extraFields) {
      Object.assign(fields, extraFields);
    }
    const tags = [];
    if (options) {
      tags.push(`story-engine/${options.entityType}`);
      if (options.storyName) {
        const sanitizedStoryName = this.sanitizeFolderName(options.storyName).toLowerCase().replace(/\s+/g, "-");
        tags.push(`story/${sanitizedStoryName}`);
      }
      if (options.date) {
        const date = typeof options.date === "string" ? new Date(options.date) : options.date;
        if (!isNaN(date.getTime())) {
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, "0");
          const day = String(date.getDate()).padStart(2, "0");
          tags.push(`date/${year}/${month}/${day}`);
        }
      }
    }
    const lines = ["---"];
    for (const [key, value] of Object.entries(fields)) {
      if (value === null || value === void 0) {
        lines.push(`${key}: null`);
      } else if (typeof value === "string") {
        const escaped = value.replace(/"/g, '\\"');
        if (value.includes(":") || value.includes("\n") || value.includes('"')) {
          lines.push(`${key}: "${escaped}"`);
        } else {
          lines.push(`${key}: ${escaped}`);
        }
      } else {
        lines.push(`${key}: ${value}`);
      }
    }
    if (tags.length > 0) {
      lines.push(`tags:`);
      for (const tag of tags) {
        lines.push(`  - ${tag}`);
      }
    }
    lines.push("---", "");
    return lines.join("\n");
  }
  // Ensure folder exists
  async ensureFolderExists(path) {
    const folder = this.vault.getAbstractFileByPath(path);
    if (!folder) {
      await this.vault.createFolder(path);
    }
  }
  // Write story metadata (story.md)
  async writeStoryMetadata(story, folderPath, chapters, orphanScenes, orphanBeats, chapterContentData) {
    var _a, _b;
    await this.ensureFolderExists(folderPath);
    const baseFields = {
      id: story.id,
      title: story.title,
      status: story.status,
      version: story.version_number,
      root_story_id: story.root_story_id,
      previous_version_id: story.previous_story_id,
      created_at: story.created_at,
      updated_at: story.updated_at
    };
    const frontmatter = this.generateFrontmatter(baseFields, void 0, {
      entityType: "story",
      storyName: story.title,
      date: story.created_at
    });
    let content = `${frontmatter}
# ${story.title}

Version: ${story.version_number}
Status: ${story.status}

`;
    const temporaryChapterTitles = ["Story Prose", "Scene-Level Prose", "Beat-Level Prose"];
    const filteredChapters = (chapters == null ? void 0 : chapters.filter(
      (c) => !temporaryChapterTitles.includes(c.chapter.title) && c.chapter.number < 9e3
    )) || [];
    if (filteredChapters.length > 0) {
      content += `## Chapters, Scenes & Beats

`;
      content += `> [!info] How to use this list
`;
      content += `> - **Create new item**: Add a line with \`-\` followed by the text
`;
      content += `>   - **Chapter**: No indentation (level 0)
`;
      content += `>   - **Scene**: Use 1 tab indentation (inside a chapter)
`;
      content += `>   - **Beat**: Use 2 tabs indentation (inside a scene)
`;
      content += `> - **Reorder**: Move items up/down to change order
`;
      content += `> - **Links**: Use \`[[link-name|text]]\` to create links to existing files
`;
      content += `> - **Format**:
`;
      content += `>   - **Chapter**:
`;
      content += `>     - Complete: \`Chapter N: title\`
`;
      content += `>     - Simplified: \`title\`
`;
      content += `>   - **Scene**:
`;
      content += `>     - Complete: \`Scene N: goal - timeRef\`
`;
      content += `>     - Simplified:
`;
      content += `>       - \`goal - timeRef\`
`;
      content += `>       - \`goal\`
`;
      content += `>   - **Beat**:
`;
      content += `>     - Complete: \`Beat N: intent -> outcome\`
`;
      content += `>     - Simplified:
`;
      content += `>       - \`intent -> outcome\`
`;
      content += `>       - \`intent\`
`;
      content += `> - **Markers**: \`-\` indicates no associated prose, \`+\` indicates associated prose

`;
      for (const chapterWithContent of filteredChapters) {
        const chapter = chapterWithContent.chapter;
        const chapterFileName = `Chapter-${chapter.number}.md`;
        const chapterLinkName = chapterFileName.replace(/\.md$/, "");
        content += `- [[${chapterLinkName}|Chapter ${chapter.number}: ${chapter.title}]]
`;
        for (const { scene, beats } of chapterWithContent.scenes) {
          const sceneFileName = this.generateSceneFileName(scene);
          const sceneLinkName = sceneFileName.replace(/\.md$/, "");
          const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
          content += `	- [[${sceneLinkName}|Scene ${scene.order_num}: ${sceneDisplayText}]]
`;
          for (const beat of beats) {
            const beatFileName = this.generateBeatFileName(beat);
            const beatLinkName = beatFileName.replace(/\.md$/, "");
            const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
            content += `		- [[${beatLinkName}|Beat ${beat.order_num}: ${beatDisplayText}]]
`;
          }
        }
      }
      content += `
`;
    }
    if (orphanScenes && orphanScenes.length > 0) {
      content += `## Orphan Scenes

`;
      content += `> [!info] Scenes without a chapter
`;
      content += `> These scenes are not associated with any chapter. You can:
`;
      content += `> - **Reorder**: Move items up/down to change order
`;
      content += `> - **Links**: Use \`[[link-name|text]]\` to create links to existing files
`;
      content += `> - **Format**:
`;
      content += `>   - Complete: \`Scene N: goal - timeRef\`
`;
      content += `>   - Simplified:
`;
      content += `>     - \`goal - timeRef\`
`;
      content += `>     - \`goal\`
`;
      content += `> - **Markers**: \`-\` indicates no associated prose, \`+\` indicates associated prose

`;
      for (const { scene, beats } of orphanScenes) {
        const sceneFileName = this.generateSceneFileName(scene);
        const sceneLinkName = sceneFileName.replace(/\.md$/, "");
        const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
        content += `- [[${sceneLinkName}|Scene ${scene.order_num}: ${sceneDisplayText}]]
`;
        for (const beat of beats) {
          const beatFileName = this.generateBeatFileName(beat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
          content += `	- [[${beatLinkName}|Beat ${beat.order_num}: ${beatDisplayText}]]
`;
        }
      }
      content += `
`;
    }
    if (orphanBeats && orphanBeats.length > 0) {
      content += `## Orphan Beats

`;
      content += `> [!info] Beats without a scene
`;
      content += `> These beats are not associated with any scene. You can:
`;
      content += `> - **Reorder**: Move items up/down to change order
`;
      content += `> - **Links**: Use \`[[link-name|text]]\` to create links to existing files
`;
      content += `> - **Format**:
`;
      content += `>   - Complete: \`Beat N: intent -> outcome\`
`;
      content += `>   - Simplified:
`;
      content += `>     - \`intent -> outcome\`
`;
      content += `>     - \`intent\`
`;
      content += `> - **Markers**: \`-\` indicates no associated prose, \`+\` indicates associated prose

`;
      for (const beat of orphanBeats) {
        const beatFileName = this.generateBeatFileName(beat);
        const beatLinkName = beatFileName.replace(/\.md$/, "");
        const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
        content += `- [[${beatLinkName}|Beat ${beat.order_num}: ${beatDisplayText}]]
`;
      }
      content += `
`;
    }
    content += `# Story: ${story.title}

`;
    if (filteredChapters.length > 0) {
      for (const chapterWithContent of filteredChapters) {
        const chapter = chapterWithContent.chapter;
        const chapterFileName = `Chapter-${chapter.number}.md`;
        const chapterLinkName = chapterFileName.replace(/\.md$/, "");
        content += `## Chapter ${chapter.number}: [[${chapterLinkName}|${chapter.title}]]

`;
        const contentData = chapterContentData == null ? void 0 : chapterContentData.get(chapter.id);
        let organization = null;
        if (contentData) {
          organization = this.organizeContentBlocks(
            contentData.contentBlocks,
            contentData.contentBlockRefs,
            chapterWithContent.scenes
          );
          for (const contentBlock of organization.chapterOnly) {
            const fileName = this.generateContentBlockFileName(contentBlock);
            const linkName = fileName.replace(/\.md$/, "");
            content += `[[${linkName}|${contentBlock.content.substring(0, 50)}...]]

`;
          }
        }
        for (const { scene, beats } of chapterWithContent.scenes) {
          const sceneFileName = this.generateSceneFileName(scene);
          const sceneLinkName = sceneFileName.replace(/\.md$/, "");
          const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
          content += `### Scene: [[${sceneLinkName}|${sceneDisplayText}]]

`;
          if (organization) {
            const sceneContentBlocks = ((_a = organization.byScene.get(scene.id)) == null ? void 0 : _a.contentBlocks) || [];
            for (const contentBlock of sceneContentBlocks) {
              const fileName = this.generateContentBlockFileName(contentBlock);
              const linkName = fileName.replace(/\.md$/, "");
              content += `[[${linkName}|${contentBlock.content.substring(0, 50)}...]]

`;
            }
          }
          for (const beat of beats) {
            const beatFileName = this.generateBeatFileName(beat);
            const beatLinkName = beatFileName.replace(/\.md$/, "");
            const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
            content += `#### Beat: [[${beatLinkName}|${beatDisplayText}]]

`;
            if (organization) {
              const beatContentBlocks = ((_b = organization.byBeat.get(beat.id)) == null ? void 0 : _b.contentBlocks) || [];
              for (const contentBlock of beatContentBlocks) {
                const fileName = this.generateContentBlockFileName(contentBlock);
                const linkName = fileName.replace(/\.md$/, "");
                content += `[[${linkName}|${contentBlock.content.substring(0, 50)}...]]

`;
              }
            }
          }
        }
      }
    }
    if (orphanScenes && orphanScenes.length > 0) {
      for (const { scene, beats } of orphanScenes) {
        const sceneFileName = this.generateSceneFileName(scene);
        const sceneLinkName = sceneFileName.replace(/\.md$/, "");
        const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
        content += `### Scene: [[${sceneLinkName}|${sceneDisplayText}]]

`;
        for (const beat of beats) {
          const beatFileName = this.generateBeatFileName(beat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
          content += `#### Beat: [[${beatLinkName}|${beatDisplayText}]]

`;
        }
      }
    }
    const filePath = `${folderPath}/story.md`;
    const file = this.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian6.TFile) {
      await this.vault.modify(file, content);
    } else {
      await this.vault.create(filePath, content);
    }
  }
  // Write chapter file
  async writeChapterFile(chapterWithContent, filePath, storyName, contentBlocks, contentBlockRefs, orphanScenes) {
    var _a, _b, _c, _d;
    const { chapter, scenes } = chapterWithContent;
    const baseFields = {
      id: chapter.id,
      story_id: chapter.story_id,
      number: chapter.number,
      title: chapter.title,
      status: chapter.status,
      created_at: chapter.created_at,
      updated_at: chapter.updated_at
    };
    const frontmatter = this.generateFrontmatter(baseFields, void 0, {
      entityType: "chapter",
      storyName,
      date: chapter.created_at
    });
    let content = `${frontmatter}
# ${chapter.title}

`;
    const organization = this.organizeContentBlocks(
      contentBlocks || [],
      contentBlockRefs || [],
      scenes
    );
    content += `## Scenes & Beats

`;
    content += `> [!info] How to use this list
`;
    content += `> - **Create new item**: Add a line with \`-\` followed by the text
`;
    content += `>   - **Scene**: No indentation (level 0)
`;
    content += `>   - **Beat**: Use 1 tab indentation (inside a scene)
`;
    content += `> - **Reorder**: Move items up/down to change order
`;
    content += `> - **Links**: Use \`[[link-name|text]]\` to create links to existing files
`;
    content += `> - **Format**:
`;
    content += `>   - **Scene**:
`;
    content += `>     - Complete: \`Scene N: goal - timeRef\`
`;
    content += `>     - Simplified:
`;
    content += `>       - \`goal - timeRef\`
`;
    content += `>       - \`goal\`
`;
    content += `>   - **Beat**:
`;
    content += `>     - Complete: \`Beat N: intent -> outcome\`
`;
    content += `>     - Simplified:
`;
    content += `>       - \`intent -> outcome\`
`;
    content += `>       - \`intent\`
`;
    content += `> - **Markers**: \`-\` indicates no associated prose, \`+\` indicates associated prose
`;
    content += `> - **Orphan scenes** (without chapter) are shown below for easy association

`;
    for (const { scene, beats } of scenes) {
      const sceneFileName = this.generateSceneFileName(scene);
      const sceneLinkName = sceneFileName.replace(/\.md$/, "");
      const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
      const sceneContentBlocks = ((_a = organization.byScene.get(scene.id)) == null ? void 0 : _a.contentBlocks) || [];
      const hasSceneContent = sceneContentBlocks.length > 0;
      const sceneMarker = hasSceneContent ? "+" : "-";
      content += `${sceneMarker} [[${sceneLinkName}|Scene ${scene.order_num}: ${sceneDisplayText}]]
`;
      for (const beat of beats) {
        const beatFileName = this.generateBeatFileName(beat);
        const beatLinkName = beatFileName.replace(/\.md$/, "");
        const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
        const beatContentBlocks = ((_b = organization.byBeat.get(beat.id)) == null ? void 0 : _b.contentBlocks) || [];
        const hasBeatContent = beatContentBlocks.length > 0;
        const beatMarker = hasBeatContent ? "+" : "-";
        content += `	${beatMarker} [[${beatLinkName}|Beat ${beat.order_num}: ${beatDisplayText}]]
`;
      }
    }
    if (orphanScenes && orphanScenes.length > 0) {
      content += `
`;
      content += `> [!info] Orphan Scenes (not yet associated with this chapter)
`;
      content += `> You can associate these scenes with this chapter by moving them here.

`;
      for (const { scene, beats } of orphanScenes) {
        const sceneFileName = this.generateSceneFileName(scene);
        const sceneLinkName = sceneFileName.replace(/\.md$/, "");
        const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
        content += `- [[${sceneLinkName}|Scene ${scene.order_num}: ${sceneDisplayText}]]
`;
        for (const beat of beats) {
          const beatFileName = this.generateBeatFileName(beat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
          content += `	- [[${beatLinkName}|Beat ${beat.order_num}: ${beatDisplayText}]]
`;
        }
      }
    }
    content += `
`;
    content += `## Chapter ${chapter.number}: ${chapter.title}

`;
    for (const contentBlock of organization.chapterOnly) {
      const fileName = this.generateContentBlockFileName(contentBlock);
      const linkName = fileName.replace(/\.md$/, "");
      content += `[[${linkName}|${contentBlock.content.substring(0, 50)}...]]

`;
    }
    for (const { scene, beats } of scenes) {
      const sceneFileName = this.generateSceneFileName(scene);
      const sceneLinkName = sceneFileName.replace(/\.md$/, "");
      const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
      content += `## Scene: [[${sceneLinkName}|${sceneDisplayText}]]

`;
      const sceneContentBlocks = ((_c = organization.byScene.get(scene.id)) == null ? void 0 : _c.contentBlocks) || [];
      for (const contentBlock of sceneContentBlocks) {
        const fileName = this.generateContentBlockFileName(contentBlock);
        const linkName = fileName.replace(/\.md$/, "");
        content += `[[${linkName}|${contentBlock.content.substring(0, 50)}...]]

`;
      }
      for (const beat of beats) {
        const beatFileName = this.generateBeatFileName(beat);
        const beatLinkName = beatFileName.replace(/\.md$/, "");
        const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
        content += `### Beat: [[${beatLinkName}|${beatDisplayText}]]

`;
        const beatContentBlocks = ((_d = organization.byBeat.get(beat.id)) == null ? void 0 : _d.contentBlocks) || [];
        for (const contentBlock of beatContentBlocks) {
          const fileName = this.generateContentBlockFileName(contentBlock);
          const linkName = fileName.replace(/\.md$/, "");
          content += `[[${linkName}|${contentBlock.content.substring(0, 50)}...]]

`;
        }
      }
    }
    const file = this.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian6.TFile) {
      await this.vault.modify(file, content);
    } else {
      await this.vault.create(filePath, content);
    }
  }
  // Read story metadata
  async readStoryMetadata(folderPath) {
    const filePath = `${folderPath}/story.md`;
    const file = this.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian6.TFile)) {
      throw new Error(`Story metadata file not found: ${filePath}`);
    }
    const content = await this.vault.read(file);
    const frontmatter = this.parseFrontmatter(content);
    return {
      frontmatter: {
        id: frontmatter.id,
        title: frontmatter.title,
        status: frontmatter.status,
        version: parseInt(frontmatter.version),
        root_story_id: frontmatter.root_story_id,
        previous_version_id: frontmatter.previous_version_id || null,
        created_at: frontmatter.created_at,
        updated_at: frontmatter.updated_at
      },
      content: content.split("---").slice(2).join("---").trim()
    };
  }
  // Parse YAML frontmatter
  parseFrontmatter(content) {
    const match = content.match(/^---\n([\s\S]*?)\n---/);
    if (!match) {
      return {};
    }
    const frontmatterText = match[1];
    const result = {};
    for (const line of frontmatterText.split("\n")) {
      const colonIndex = line.indexOf(":");
      if (colonIndex > 0) {
        const key = line.slice(0, colonIndex).trim();
        const value = line.slice(colonIndex + 1).trim().replace(/^["']|["']$/g, "");
        result[key] = value;
      }
    }
    return result;
  }
  // Copy story folder to versions folder
  async createVersionSnapshot(storyFolderPath, versionNumber) {
    const versionsPath = `${storyFolderPath}/versions`;
    await this.ensureFolderExists(versionsPath);
    const versionFolderPath = `${versionsPath}/v${versionNumber}`;
    const existingVersion = this.vault.getAbstractFileByPath(versionFolderPath);
    if (existingVersion) {
      console.log(`Version v${versionNumber} already exists, skipping snapshot`);
      return;
    }
    await this.ensureFolderExists(versionFolderPath);
    const storyFolder = this.vault.getAbstractFileByPath(storyFolderPath);
    if (!(storyFolder instanceof import_obsidian6.TFolder)) {
      throw new Error(`Story folder not found: ${storyFolderPath}`);
    }
    await this.copyFolderContents(storyFolder, versionFolderPath, "versions");
    console.log(`Created version snapshot: v${versionNumber}`);
  }
  // Recursively copy folder contents
  async copyFolderContents(sourceFolder, destPath, excludeFolderName) {
    for (const child of sourceFolder.children) {
      if (child instanceof import_obsidian6.TFile) {
        const relativePath = child.path.replace(sourceFolder.path + "/", "");
        const destFilePath = `${destPath}/${relativePath}`;
        const content = await this.vault.read(child);
        await this.vault.create(destFilePath, content);
      } else if (child instanceof import_obsidian6.TFolder) {
        if (excludeFolderName && child.name === excludeFolderName) {
          continue;
        }
        const relativePath = child.path.replace(sourceFolder.path + "/", "");
        const destFolderPath = `${destPath}/${relativePath}`;
        await this.ensureFolderExists(destFolderPath);
        await this.copyFolderContents(child, destFolderPath, excludeFolderName);
      }
    }
  }
  // Write scene file
  async writeSceneFile(sceneWithBeats, filePath, storyName, contentBlocks, orphanBeats) {
    var _a;
    const { scene, beats } = sceneWithBeats;
    const baseFields = {
      id: scene.id,
      story_id: scene.story_id,
      chapter_id: (_a = scene.chapter_id) != null ? _a : null,
      order_num: scene.order_num,
      time_ref: scene.time_ref || "",
      goal: scene.goal || "",
      created_at: scene.created_at,
      updated_at: scene.updated_at
    };
    const extraFields = {};
    if (scene.pov_character_id) {
      extraFields.pov_character_id = scene.pov_character_id;
    }
    if (scene.location_id) {
      extraFields.location_id = scene.location_id;
    }
    const frontmatter = this.generateFrontmatter(baseFields, extraFields, {
      entityType: "scene",
      storyName,
      date: scene.created_at
    });
    let content = `${frontmatter}
# Scene ${scene.order_num}

`;
    if (scene.goal) {
      content += `**Goal:** ${scene.goal}

`;
    }
    if (scene.time_ref) {
      content += `**Time:** ${scene.time_ref}

`;
    }
    if (beats.length > 0) {
      content += `## Beats

`;
      content += `> [!info] How to use this list
`;
      content += `> - **Create new item**: Add a line with \`-\` followed by the text
`;
      content += `>   - **Beat**: No indentation (level 0)
`;
      content += `> - **Reorder**: Move items up/down to change order
`;
      content += `> - **Links**: Use \`[[link-name|text]]\` to create links to existing files
`;
      content += `> - **Format**:
`;
      content += `>   - **Beat**:
`;
      content += `>     - Complete: \`Beat N: intent -> outcome\`
`;
      content += `>     - Simplified:
`;
      content += `>       - \`intent -> outcome\`
`;
      content += `>       - \`intent\`
`;
      content += `> - **Markers**: \`-\` indicates no associated prose, \`+\` indicates associated prose
`;
      content += `> - **Orphan beats** (without scene) are shown below for easy association

`;
      const beatsWithProse = /* @__PURE__ */ new Set();
      if (contentBlocks) {
        for (const contentBlock of contentBlocks) {
        }
      }
      for (const beat of beats.sort((a, b) => a.order_num - b.order_num)) {
        const beatFileName = this.generateBeatFileName(beat);
        const beatLinkName = beatFileName.replace(/\.md$/, "");
        const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
        const hasBeatProse = beatsWithProse.has(beat.id);
        const beatMarker = hasBeatProse ? "+" : "-";
        content += `${beatMarker} [[${beatLinkName}|Beat ${beat.order_num}: ${beatDisplayText}]]
`;
      }
      if (orphanBeats && orphanBeats.length > 0) {
        content += `
`;
        content += `> [!info] Orphan Beats (not yet associated with this scene)
`;
        content += `> You can associate these beats with this scene by moving them here.

`;
        for (const beat of orphanBeats) {
          const beatFileName = this.generateBeatFileName(beat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
          content += `- [[${beatLinkName}|Beat ${beat.order_num}: ${beatDisplayText}]]
`;
        }
      }
      content += `
`;
    }
    const sceneFileName = this.generateSceneFileName(scene);
    const sceneLinkName = sceneFileName.replace(/\.md$/, "");
    const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
    content += `## Scene: [[${sceneLinkName}|${sceneDisplayText}]]

`;
    if (contentBlocks && contentBlocks.length > 0) {
      const sortedContentBlocks = [...contentBlocks].sort((a, b) => (a.order_num || 0) - (b.order_num || 0));
      for (const contentBlock of sortedContentBlocks) {
        const fileName = this.generateContentBlockFileName(contentBlock);
        const linkName = fileName.replace(/\.md$/, "");
        content += `[[${linkName}|${contentBlock.content.substring(0, 50)}...]]

`;
      }
    }
    for (const beat of beats.sort((a, b) => a.order_num - b.order_num)) {
      const beatFileName = this.generateBeatFileName(beat);
      const beatLinkName = beatFileName.replace(/\.md$/, "");
      const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
      content += `### Beat: [[${beatLinkName}|${beatDisplayText}]]

`;
    }
    const file = this.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian6.TFile) {
      await this.vault.modify(file, content);
    } else {
      await this.vault.create(filePath, content);
    }
  }
  // Write beat file
  async writeBeatFile(beat, filePath, storyName, contentBlocks) {
    const baseFields = {
      id: beat.id,
      scene_id: beat.scene_id,
      order_num: beat.order_num,
      type: beat.type,
      intent: beat.intent || "",
      outcome: beat.outcome || "",
      created_at: beat.created_at,
      updated_at: beat.updated_at
    };
    const frontmatter = this.generateFrontmatter(baseFields, void 0, {
      entityType: "beat",
      storyName,
      date: beat.created_at
    });
    let content = `${frontmatter}
# Beat ${beat.order_num} - ${beat.type}

`;
    if (beat.intent) {
      content += `**Intent:** ${beat.intent}

`;
    }
    if (beat.outcome) {
      content += `**Outcome:** ${beat.outcome}

`;
    }
    const beatFileName = this.generateBeatFileName(beat);
    const beatLinkName = beatFileName.replace(/\.md$/, "");
    const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
    content += `## Beat: [[${beatLinkName}|${beatDisplayText}]]

`;
    if (contentBlocks && contentBlocks.length > 0) {
      const sortedContentBlocks = [...contentBlocks].sort((a, b) => (a.order_num || 0) - (b.order_num || 0));
      for (const contentBlock of sortedContentBlocks) {
        const fileName = this.generateContentBlockFileName(contentBlock);
        const linkName = fileName.replace(/\.md$/, "");
        content += `[[${linkName}|${contentBlock.content.substring(0, 50)}...]]

`;
      }
    }
    const file = this.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian6.TFile) {
      await this.vault.modify(file, content);
    } else {
      await this.vault.create(filePath, content);
    }
  }
  // List all chapter files in a story folder
  async listChapterFiles(storyFolderPath) {
    const chaptersPath = `${storyFolderPath}/00-chapters`;
    const folder = this.vault.getAbstractFileByPath(chaptersPath);
    if (!(folder instanceof import_obsidian6.TFolder)) {
      return [];
    }
    const chapterFiles = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian6.TFile && child.extension === "md") {
        chapterFiles.push(child.path);
      }
    }
    return chapterFiles.sort();
  }
  // List all scene files in a chapter folder
  async listSceneFiles(chapterFolderPath) {
    const scenesPath = `${chapterFolderPath}/01-scenes`;
    const folder = this.vault.getAbstractFileByPath(scenesPath);
    if (!(folder instanceof import_obsidian6.TFolder)) {
      return [];
    }
    const sceneFiles = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian6.TFile && child.extension === "md") {
        sceneFiles.push(child.path);
      }
    }
    return sceneFiles.sort();
  }
  // List all scene files in a story folder
  async listStorySceneFiles(storyFolderPath) {
    const scenesPath = `${storyFolderPath}/01-scenes`;
    const folder = this.vault.getAbstractFileByPath(scenesPath);
    if (!(folder instanceof import_obsidian6.TFolder)) {
      return [];
    }
    const sceneFiles = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian6.TFile && child.extension === "md") {
        sceneFiles.push(child.path);
      }
    }
    return sceneFiles.sort();
  }
  // List all beat files in a story folder
  async listStoryBeatFiles(storyFolderPath) {
    const beatsPath = `${storyFolderPath}/02-beats`;
    const folder = this.vault.getAbstractFileByPath(beatsPath);
    if (!(folder instanceof import_obsidian6.TFolder)) {
      return [];
    }
    const beatFiles = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian6.TFile && child.extension === "md") {
        beatFiles.push(child.path);
      }
    }
    return beatFiles.sort();
  }
  // List all beat files in a scene folder
  async listBeatFiles(sceneFolderPath) {
    const beatsPath = `${sceneFolderPath}/02-beats`;
    const folder = this.vault.getAbstractFileByPath(beatsPath);
    if (!(folder instanceof import_obsidian6.TFolder)) {
      return [];
    }
    const beatFiles = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian6.TFile && child.extension === "md") {
        beatFiles.push(child.path);
      }
    }
    return beatFiles.sort();
  }
  // Get the subfolder name for a content block type
  getContentTypeFolder(type2) {
    const typeFolders = {
      text: "00-texts",
      image: "01-images",
      video: "02-videos",
      audio: "03-audios",
      embed: "04-embeds",
      link: "05-links"
    };
    return typeFolders[type2] || "99-other";
  }
  // Get the full folder path for content blocks of a specific type
  getContentBlockFolderPath(storyFolderPath, type2) {
    const typeFolder = this.getContentTypeFolder(type2);
    return `${storyFolderPath}/03-contents/${typeFolder}`;
  }
  // Generate filename for content block based on date and content preview
  generateContentBlockFileName(contentBlock) {
    const date = new Date(contentBlock.created_at);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    const hours = String(date.getHours()).padStart(2, "0");
    const minutes = String(date.getMinutes()).padStart(2, "0");
    const dateStr = `${year}-${month}-${day}T${hours}-${minutes}`;
    let textPart;
    const type2 = contentBlock.type || "text";
    if (type2 === "text") {
      textPart = contentBlock.content.substring(0, 30).trim().replace(/[<>:"/\\|?*\n\r\t]/g, "-").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "").toLowerCase() || "content";
    } else if (type2 === "image" || type2 === "video" || type2 === "audio") {
      const meta = contentBlock.metadata || {};
      textPart = (meta.alt_text || meta.caption || meta.title || type2).substring(0, 30).trim().replace(/[<>:"/\\|?*\n\r\t]/g, "-").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "").toLowerCase();
    } else if (type2 === "embed") {
      const meta = contentBlock.metadata || {};
      textPart = (meta.provider || meta.title || "embed").substring(0, 30).trim().replace(/[<>:"/\\|?*\n\r\t]/g, "-").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "").toLowerCase();
    } else if (type2 === "link") {
      const meta = contentBlock.metadata || {};
      textPart = (meta.title || meta.site_name || "link").substring(0, 30).trim().replace(/[<>:"/\\|?*\n\r\t]/g, "-").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "").toLowerCase();
    } else {
      textPart = "content";
    }
    return `${dateStr}_${textPart}.md`;
  }
  // Organize content blocks by their associations (chapter, scene, beat)
  organizeContentBlocks(contentBlocks, contentBlockRefs, scenes) {
    const organization = {
      chapterOnly: [],
      byScene: /* @__PURE__ */ new Map(),
      byBeat: /* @__PURE__ */ new Map()
    };
    const contentBlockRefsByContentBlock = /* @__PURE__ */ new Map();
    for (const ref of contentBlockRefs) {
      if (!contentBlockRefsByContentBlock.has(ref.content_block_id)) {
        contentBlockRefsByContentBlock.set(ref.content_block_id, []);
      }
      contentBlockRefsByContentBlock.get(ref.content_block_id).push(ref);
    }
    const sceneMap = /* @__PURE__ */ new Map();
    const beatMap = /* @__PURE__ */ new Map();
    for (const { scene, beats } of scenes) {
      sceneMap.set(scene.id, scene);
      for (const beat of beats) {
        beatMap.set(beat.id, beat);
      }
    }
    const sortedContentBlocks = [...contentBlocks].sort((a, b) => (a.order_num || 0) - (b.order_num || 0));
    for (const contentBlock of sortedContentBlocks) {
      const refs = contentBlockRefsByContentBlock.get(contentBlock.id) || [];
      const sceneRef = refs.find((r) => r.entity_type === "scene");
      const beatRef = refs.find((r) => r.entity_type === "beat");
      if (beatRef && beatMap.has(beatRef.entity_id)) {
        const beat = beatMap.get(beatRef.entity_id);
        if (!organization.byBeat.has(beat.id)) {
          organization.byBeat.set(beat.id, { beat, contentBlocks: [] });
        }
        organization.byBeat.get(beat.id).contentBlocks.push(contentBlock);
      } else if (sceneRef && sceneMap.has(sceneRef.entity_id)) {
        const scene = sceneMap.get(sceneRef.entity_id);
        if (!organization.byScene.has(scene.id)) {
          organization.byScene.set(scene.id, { scene, contentBlocks: [] });
        }
        organization.byScene.get(scene.id).contentBlocks.push(contentBlock);
      } else {
        organization.chapterOnly.push(contentBlock);
      }
    }
    return organization;
  }
  // Generate filename for scene based on date and goal
  generateSceneFileName(scene) {
    const date = new Date(scene.created_at);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    const hours = String(date.getHours()).padStart(2, "0");
    const minutes = String(date.getMinutes()).padStart(2, "0");
    const dateStr = `${year}-${month}-${day}T${hours}-${minutes}`;
    const goalSanitized = (scene.goal || "scene").trim().replace(/[<>:"/\\|?*\n\r\t]/g, "-").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "").toLowerCase();
    return `${dateStr}_${goalSanitized}.md`;
  }
  // Generate filename for beat based on date and intent
  generateBeatFileName(beat) {
    const date = new Date(beat.created_at);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    const hours = String(date.getHours()).padStart(2, "0");
    const minutes = String(date.getMinutes()).padStart(2, "0");
    const dateStr = `${year}-${month}-${day}T${hours}-${minutes}`;
    const intentSanitized = (beat.intent || "beat").trim().replace(/[<>:"/\\|?*\n\r\t]/g, "-").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "").toLowerCase();
    return `${dateStr}_${intentSanitized}.md`;
  }
  // Write content block file
  async writeContentBlockFile(contentBlock, filePath, storyName) {
    const type2 = contentBlock.type || "text";
    const baseFields = {
      id: contentBlock.id,
      chapter_id: contentBlock.chapter_id || null,
      order_num: contentBlock.order_num || 0,
      type: type2,
      kind: contentBlock.kind,
      created_at: contentBlock.created_at,
      updated_at: contentBlock.updated_at
    };
    const meta = contentBlock.metadata || {};
    if (type2 === "text" && meta.word_count) {
      baseFields.word_count = meta.word_count;
    } else if (type2 === "image") {
      if (contentBlock.content && contentBlock.content.startsWith("http")) {
        baseFields.original_url = contentBlock.content;
      }
      if (meta.alt_text)
        baseFields.alt_text = meta.alt_text;
      if (meta.caption)
        baseFields.caption = meta.caption;
      if (meta.width)
        baseFields.width = meta.width;
      if (meta.height)
        baseFields.height = meta.height;
      if (meta.mime_type)
        baseFields.mime_type = meta.mime_type;
      if (meta.source)
        baseFields.source = meta.source;
      if (meta.author_name)
        baseFields.author_name = meta.author_name;
      if (meta.attribution)
        baseFields.attribution = meta.attribution;
      if (meta.attribution_url)
        baseFields.attribution_url = meta.attribution_url;
    } else if (type2 === "video" || type2 === "audio") {
      if (meta.provider)
        baseFields.provider = meta.provider;
      if (meta.video_id)
        baseFields.video_id = meta.video_id;
      if (meta.duration)
        baseFields.duration = meta.duration;
      if (meta.thumbnail_url)
        baseFields.thumbnail_url = meta.thumbnail_url;
    } else if (type2 === "embed") {
      if (meta.provider)
        baseFields.provider = meta.provider;
      if (meta.html)
        baseFields.embed_html = meta.html;
    } else if (type2 === "link") {
      if (meta.title)
        baseFields.link_title = meta.title;
      if (meta.description)
        baseFields.link_description = meta.description;
      if (meta.image_url)
        baseFields.link_image = meta.image_url;
      if (meta.site_name)
        baseFields.site_name = meta.site_name;
    }
    const frontmatter = this.generateFrontmatter(baseFields, void 0, {
      entityType: "content-block",
      storyName,
      date: contentBlock.created_at
    });
    let fileContent;
    if (type2 === "text") {
      fileContent = `${frontmatter}${contentBlock.content}`;
    } else if (type2 === "image") {
      let localImagePath = contentBlock.content || "";
      if (contentBlock.content && !contentBlock.content.startsWith("http")) {
        localImagePath = contentBlock.content;
      } else if (contentBlock.content) {
        try {
          localImagePath = await this.downloadImage(contentBlock.content, filePath, contentBlock.id);
        } catch (err) {
          console.error("Failed to download image:", err);
          localImagePath = contentBlock.content;
        }
      }
      const altText = meta.alt_text || "";
      fileContent = `${frontmatter}![${altText}](${localImagePath})`;
      if (meta.caption) {
        fileContent += `

*${meta.caption}*`;
      }
    } else if (type2 === "video") {
      fileContent = `${frontmatter}[Video](${contentBlock.content})`;
      if (meta.thumbnail_url) {
        fileContent += `

![Thumbnail](${meta.thumbnail_url})`;
      }
    } else if (type2 === "audio") {
      fileContent = `${frontmatter}[Audio](${contentBlock.content})`;
    } else if (type2 === "embed") {
      fileContent = `${frontmatter}${meta.html || contentBlock.content}`;
    } else if (type2 === "link") {
      const title = meta.title || contentBlock.content;
      fileContent = `${frontmatter}[${title}](${contentBlock.content})`;
      if (meta.description) {
        fileContent += `

${meta.description}`;
      }
    } else {
      fileContent = `${frontmatter}${contentBlock.content}`;
    }
    const file = this.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian6.TFile) {
      await this.vault.modify(file, fileContent);
    } else {
      await this.vault.create(filePath, fileContent);
    }
  }
  // Download image from URL and save locally (same folder as content block .md)
  async downloadImage(imageUrl, contentBlockFilePath, contentBlockId) {
    try {
      const response = await fetch(imageUrl);
      if (!response.ok) {
        throw new Error(`Failed to fetch image: ${response.statusText}`);
      }
      const blob = await response.blob();
      const arrayBuffer = await blob.arrayBuffer();
      let extension = "jpg";
      const contentType = response.headers.get("content-type");
      if (contentType) {
        if (contentType.includes("png"))
          extension = "png";
        else if (contentType.includes("gif"))
          extension = "gif";
        else if (contentType.includes("webp"))
          extension = "webp";
        else if (contentType.includes("svg"))
          extension = "svg";
      } else {
        const urlMatch = imageUrl.match(/\.(jpg|jpeg|png|gif|webp|svg)(\?|$)/i);
        if (urlMatch) {
          extension = urlMatch[1].toLowerCase();
        }
      }
      const contentBlockDir = contentBlockFilePath.substring(0, contentBlockFilePath.lastIndexOf("/"));
      const imageFileName = `${contentBlockId}.${extension}`;
      const imagePath = `${contentBlockDir}/${imageFileName}`;
      const existingFile = this.vault.getAbstractFileByPath(imagePath);
      if (existingFile instanceof import_obsidian6.TFile) {
        await this.vault.modifyBinary(existingFile, arrayBuffer);
      } else {
        await this.vault.createBinary(imagePath, arrayBuffer);
      }
      return imageFileName;
    } catch (err) {
      console.error("Error downloading image:", err);
      throw err;
    }
  }
  // Read content block from file
  async readContentBlockFromFile(filePath) {
    const file = this.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian6.TFile)) {
      return null;
    }
    try {
      const fileContent = await this.vault.read(file);
      const frontmatter = this.parseFrontmatter(fileContent);
      const contentMatch = fileContent.match(/^---\n[\s\S]*?\n---\n([\s\S]*)$/);
      let blockContent = contentMatch ? contentMatch[1].trim() : "";
      if (!frontmatter.id) {
        return null;
      }
      const type2 = frontmatter.type || "text";
      const metadata = {};
      if (type2 === "image") {
        const imgMatch = blockContent.match(/!\[[^\]]*\]\(([^)]+)\)/);
        if (imgMatch) {
          blockContent = imgMatch[1];
          if (!blockContent.startsWith("http") && frontmatter.original_url) {
            blockContent = frontmatter.original_url;
          }
        }
      } else if (type2 === "video" || type2 === "audio" || type2 === "link") {
        const linkMatch = blockContent.match(/\[[^\]]*\]\(([^)]+)\)/);
        if (linkMatch) {
          blockContent = linkMatch[1];
        }
      }
      if (frontmatter.word_count)
        metadata.word_count = parseInt(frontmatter.word_count, 10);
      if (frontmatter.alt_text)
        metadata.alt_text = frontmatter.alt_text;
      if (frontmatter.caption)
        metadata.caption = frontmatter.caption;
      if (frontmatter.width)
        metadata.width = parseInt(frontmatter.width, 10);
      if (frontmatter.height)
        metadata.height = parseInt(frontmatter.height, 10);
      if (frontmatter.mime_type)
        metadata.mime_type = frontmatter.mime_type;
      if (frontmatter.source)
        metadata.source = frontmatter.source;
      if (frontmatter.author_name)
        metadata.author_name = frontmatter.author_name;
      if (frontmatter.attribution)
        metadata.attribution = frontmatter.attribution;
      if (frontmatter.attribution_url)
        metadata.attribution_url = frontmatter.attribution_url;
      if (frontmatter.provider)
        metadata.provider = frontmatter.provider;
      if (frontmatter.video_id)
        metadata.video_id = frontmatter.video_id;
      if (frontmatter.duration)
        metadata.duration = parseInt(frontmatter.duration, 10);
      if (frontmatter.thumbnail_url)
        metadata.thumbnail_url = frontmatter.thumbnail_url;
      if (frontmatter.embed_html)
        metadata.html = frontmatter.embed_html;
      if (frontmatter.link_title)
        metadata.title = frontmatter.link_title;
      if (frontmatter.link_description)
        metadata.description = frontmatter.link_description;
      if (frontmatter.link_image)
        metadata.image_url = frontmatter.link_image;
      if (frontmatter.site_name)
        metadata.site_name = frontmatter.site_name;
      return {
        id: frontmatter.id,
        chapter_id: frontmatter.chapter_id || null,
        order_num: parseInt(frontmatter.order_num || "0", 10),
        type: type2,
        kind: frontmatter.kind || "final",
        content: blockContent,
        metadata,
        created_at: frontmatter.created_at || "",
        updated_at: frontmatter.updated_at || ""
      };
    } catch (err) {
      console.error(`Failed to read content block from ${filePath}:`, err);
      return null;
    }
  }
  // List all content block files in a story folder (across all type subfolders)
  async listContentBlockFiles(storyFolderPath) {
    const contentsPath = `${storyFolderPath}/03-contents`;
    const folder = this.vault.getAbstractFileByPath(contentsPath);
    if (!(folder instanceof import_obsidian6.TFolder)) {
      return [];
    }
    const contentFiles = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian6.TFolder) {
        for (const file of child.children) {
          if (file instanceof import_obsidian6.TFile && file.extension === "md") {
            contentFiles.push(file.path);
          }
        }
      }
    }
    return contentFiles.sort();
  }
};

// src/sync/syncService.ts
var import_obsidian8 = require("obsidian");

// src/sync/contentBlockParser.ts
function parseHierarchicalProse(chapterContent) {
  const sections = [];
  const frontmatterMatch = chapterContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = chapterContent.substring(contentStart).trim();
  const chapterSectionMatch = bodyContent.match(/##\s+Chapter\s+\d+:\s+[^\n]+\s*\n+([\s\S]*?)(?=\n##\s+Chapter\s+\d+:|$)/);
  if (!chapterSectionMatch) {
    const chapterSectionMatchSameLine = bodyContent.match(/##\s+Chapter\s+\d+:\s+[^\n]+\s+([^\n]+)/);
    if (chapterSectionMatchSameLine) {
      const proseContent2 = chapterSectionMatchSameLine[1].trim();
      if (proseContent2.length > 0 && !proseContent2.startsWith("#")) {
        const paragraph = {
          content: proseContent2,
          linkName: null,
          originalOrder: 0
        };
        sections.push({
          type: "prose",
          prose: paragraph,
          originalOrder: 0
        });
      }
      return { sections };
    }
    return { sections: [] };
  }
  const proseContent = chapterSectionMatch[1].trim();
  const lines = proseContent.split(/\n/);
  let currentScene = null;
  let currentBeat = null;
  let order = 0;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line) {
      continue;
    }
    const sceneMatch = line.match(/^##\s+Scene:\s*(.+)$/);
    if (sceneMatch) {
      const sceneText = sceneMatch[1].trim();
      const parsedScene = parseSceneHeader(sceneText);
      parsedScene.originalOrder = order++;
      currentScene = parsedScene;
      currentBeat = null;
      sections.push({
        type: "scene",
        scene: parsedScene,
        originalOrder: parsedScene.originalOrder
      });
      continue;
    }
    const beatMatch = line.match(/^###\s+Beat:\s*(.+)$/);
    if (beatMatch) {
      const beatText = beatMatch[1].trim();
      const parsedBeat = parseBeatHeader(beatText);
      parsedBeat.originalOrder = order++;
      currentBeat = parsedBeat;
      sections.push({
        type: "beat",
        beat: parsedBeat,
        originalOrder: parsedBeat.originalOrder
      });
      continue;
    }
    if (line.startsWith("#") && !line.match(/^##\s+Scene:/) && !line.match(/^###\s+Beat:/)) {
      continue;
    }
    const proseMatch = line.match(/^\s*\[\[([^\|]+)\|([^\]]+)\]\]\s*$/);
    if (proseMatch) {
      const linkName = proseMatch[1].trim();
      const content = proseMatch[2].trim();
      const paragraph = {
        content,
        linkName,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
      continue;
    }
    if (line.length > 0 && !line.startsWith("#")) {
      const paragraph = {
        content: line,
        linkName: null,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
    }
  }
  return { sections };
}
function parseSceneHeader(text) {
  const linkMatch = text.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
  if (linkMatch) {
    const linkName = linkMatch[1].trim();
    const displayText = linkMatch[2].trim();
    const { goal: goal2, timeRef: timeRef2 } = parseSceneText(displayText);
    return {
      linkName,
      goal: goal2,
      timeRef: timeRef2,
      originalOrder: 0
      // Will be set by caller
    };
  }
  const simpleLinkMatch = text.match(/^\[\[([^\]]+)\]\]$/);
  if (simpleLinkMatch) {
    return {
      linkName: simpleLinkMatch[1].trim(),
      goal: "",
      timeRef: "",
      originalOrder: 0
    };
  }
  const { goal, timeRef } = parseSceneText(text);
  return {
    linkName: null,
    goal,
    timeRef,
    originalOrder: 0
  };
}
function parseSceneText(text) {
  const parts = text.split(/\s*-\s*/);
  if (parts.length >= 2) {
    return {
      goal: parts[0].trim(),
      timeRef: parts.slice(1).join(" - ").trim()
      // Join in case there are multiple "-"
    };
  }
  return {
    goal: text.trim(),
    timeRef: ""
  };
}
function parseBeatHeader(text) {
  const linkMatch = text.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
  if (linkMatch) {
    const linkName = linkMatch[1].trim();
    const displayText = linkMatch[2].trim();
    const { intent: intent2, outcome: outcome2 } = parseBeatText(displayText);
    return {
      linkName,
      intent: intent2,
      outcome: outcome2,
      originalOrder: 0
      // Will be set by caller
    };
  }
  const simpleLinkMatch = text.match(/^\[\[([^\]]+)\]\]$/);
  if (simpleLinkMatch) {
    return {
      linkName: simpleLinkMatch[1].trim(),
      intent: "",
      outcome: "",
      originalOrder: 0
    };
  }
  const { intent, outcome } = parseBeatText(text);
  return {
    linkName: null,
    intent,
    outcome,
    originalOrder: 0
  };
}
function parseBeatText(text) {
  const parts = text.split(/\s*->\s*/);
  if (parts.length >= 2) {
    return {
      intent: parts[0].trim(),
      outcome: parts.slice(1).join(" -> ").trim()
      // Join in case there are multiple "->"
    };
  }
  return {
    intent: text.trim(),
    outcome: ""
  };
}
function compareContentBlocks(paragraph, localContentBlock, remoteContentBlock) {
  const paragraphContent = paragraph.content.trim();
  if (!paragraph.linkName) {
    if (remoteContentBlock && remoteContentBlock.content.trim() === paragraphContent) {
      if (localContentBlock && localContentBlock.id === remoteContentBlock.id) {
        return "unchanged";
      }
      return "unchanged";
    }
    return "new";
  }
  if (!localContentBlock) {
    if (remoteContentBlock && remoteContentBlock.content.trim() === paragraphContent) {
      return "remote_modified";
    }
    return "new";
  }
  if (!remoteContentBlock) {
    return "local_modified";
  }
  const localContent = localContentBlock.content.trim();
  const remoteContent = remoteContentBlock.content.trim();
  if (localContent === paragraphContent && remoteContent === paragraphContent) {
    return "unchanged";
  }
  if (paragraphContent !== localContent && paragraphContent !== remoteContent && localContent === remoteContent) {
    return "local_modified";
  }
  if (localContent === paragraphContent && remoteContent !== paragraphContent) {
    return "remote_modified";
  }
  if (paragraphContent !== localContent && paragraphContent !== remoteContent && localContent !== remoteContent) {
    return "conflict";
  }
  if (paragraphContent === remoteContent && localContent !== remoteContent) {
    return "remote_modified";
  }
  return "conflict";
}
function parseSceneBeatList(chapterContent) {
  const items = [];
  const frontmatterMatch = chapterContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = chapterContent.substring(contentStart).trim();
  const listSectionMatch = bodyContent.match(/##\s+Scenes\s+&\s+Beats\s*\n+([\s\S]*?)(?=\n##|$)/);
  if (!listSectionMatch) {
    return { items: [] };
  }
  const listContent = listSectionMatch[1].trim();
  const lines = listContent.split(/\n/);
  let order = 0;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    const itemMatch = trimmedLine.match(/^([+-])\s+(.+)$/);
    if (!itemMatch) {
      continue;
    }
    const hasProse = itemMatch[1] === "+";
    const itemText = itemMatch[2].trim();
    const tabMatch = line.match(/^(\t*)/);
    const indentLevel = tabMatch ? tabMatch[1].length : 0;
    const isBeat = indentLevel > 0;
    const linkMatch = itemText.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
    let linkName = null;
    let displayText;
    if (linkMatch) {
      linkName = linkMatch[1].trim();
      displayText = linkMatch[2].trim();
    } else {
      displayText = itemText;
    }
    items.push({
      type: isBeat ? "beat" : "scene",
      linkName,
      displayText,
      hasProse,
      indentLevel: isBeat ? 1 : 0,
      originalOrder: order++
    });
  }
  return { items };
}
function parseChapterList(storyContent) {
  const items = [];
  const frontmatterMatch = storyContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = storyContent.substring(contentStart).trim();
  const listSectionMatch = bodyContent.match(/##\s+Chapters(?:,\s*Scenes\s*&\s*Beats)?\s*\n+([\s\S]*?)(?=\n##|$)/);
  if (!listSectionMatch) {
    return { items: [] };
  }
  const listContent = listSectionMatch[1].trim();
  const lines = listContent.split(/\n/);
  let order = 0;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    const itemMatch = trimmedLine.match(/^([+-])\s+(.+)$/);
    if (!itemMatch) {
      continue;
    }
    const hasProse = itemMatch[1] === "+";
    const itemText = itemMatch[2].trim();
    const tabMatch = line.match(/^(\t*)/);
    const indentLevel = tabMatch ? tabMatch[1].length : 0;
    let type2;
    if (indentLevel === 0) {
      type2 = "chapter";
    } else if (indentLevel === 1) {
      type2 = "scene";
    } else if (indentLevel === 2) {
      type2 = "beat";
    } else {
      continue;
    }
    const linkMatch = itemText.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
    let linkName = null;
    let displayText;
    if (linkMatch) {
      linkName = linkMatch[1].trim();
      displayText = linkMatch[2].trim();
    } else {
      displayText = itemText;
    }
    items.push({
      type: type2,
      linkName,
      displayText,
      hasProse,
      indentLevel: indentLevel / 2,
      // Normalize to 0, 1, 2
      originalOrder: order++
    });
  }
  return { items };
}
function parseBeatList(sceneContent) {
  const items = [];
  const frontmatterMatch = sceneContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = sceneContent.substring(contentStart).trim();
  const listSectionMatch = bodyContent.match(/##\s+Beats\s*\n+([\s\S]*?)(?=\n##|$)/);
  if (!listSectionMatch) {
    return { items: [] };
  }
  const listContent = listSectionMatch[1].trim();
  const lines = listContent.split(/\n/);
  let order = 0;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    if (trimmedLine.startsWith(">")) {
      continue;
    }
    const itemMatch = trimmedLine.match(/^([+-])\s+(.+)$/);
    if (!itemMatch) {
      continue;
    }
    const hasProse = itemMatch[1] === "+";
    const itemText = itemMatch[2].trim();
    const linkMatch = itemText.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
    let linkName = null;
    let displayText;
    if (linkMatch) {
      linkName = linkMatch[1].trim();
      displayText = linkMatch[2].trim();
    } else {
      displayText = itemText;
    }
    items.push({
      linkName,
      displayText,
      hasProse,
      originalOrder: order++
    });
  }
  return { items };
}
function parseOrphanScenesList(storyContent) {
  const items = [];
  const frontmatterMatch = storyContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = storyContent.substring(contentStart).trim();
  const listSectionMatch = bodyContent.match(/##\s+Orphan\s+Scenes\s*\n+([\s\S]*?)(?=\n##|$)/);
  if (!listSectionMatch) {
    return { items: [] };
  }
  const listContent = listSectionMatch[1].trim();
  const lines = listContent.split(/\n/);
  let order = 0;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    if (trimmedLine.startsWith(">")) {
      continue;
    }
    const itemMatch = trimmedLine.match(/^([+-])\s+(.+)$/);
    if (!itemMatch) {
      continue;
    }
    const hasProse = itemMatch[1] === "+";
    const itemText = itemMatch[2].trim();
    const tabMatch = line.match(/^(\t*)/);
    const indentLevel = tabMatch ? tabMatch[1].length : 0;
    const isBeat = indentLevel > 0;
    const linkMatch = itemText.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
    let linkName = null;
    let displayText;
    if (linkMatch) {
      linkName = linkMatch[1].trim();
      displayText = linkMatch[2].trim();
    } else {
      displayText = itemText;
    }
    items.push({
      type: isBeat ? "beat" : "scene",
      linkName,
      displayText,
      hasProse,
      indentLevel: isBeat ? 1 : 0,
      originalOrder: order++
    });
  }
  return { items };
}
function parseOrphanBeatsList(storyContent) {
  const items = [];
  const frontmatterMatch = storyContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = storyContent.substring(contentStart).trim();
  const listSectionMatch = bodyContent.match(/##\s+Orphan\s+Beats\s*\n+([\s\S]*?)(?=\n##|$)/);
  if (!listSectionMatch) {
    return { items: [] };
  }
  const listContent = listSectionMatch[1].trim();
  const lines = listContent.split(/\n/);
  let order = 0;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    if (trimmedLine.startsWith(">")) {
      continue;
    }
    const itemMatch = trimmedLine.match(/^([+-])\s+(.+)$/);
    if (!itemMatch) {
      continue;
    }
    const hasProse = itemMatch[1] === "+";
    const itemText = itemMatch[2].trim();
    const linkMatch = itemText.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
    let linkName = null;
    let displayText;
    if (linkMatch) {
      linkName = linkMatch[1].trim();
      displayText = linkMatch[2].trim();
    } else {
      displayText = itemText;
    }
    items.push({
      linkName,
      displayText,
      hasProse,
      originalOrder: order++
    });
  }
  return { items };
}
function parseStoryProse(storyContent) {
  const sections = [];
  const frontmatterMatch = storyContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = storyContent.substring(contentStart).trim();
  const storyHeaderMatch = bodyContent.match(/^(#\s+Story:\s*.+)$/m);
  const chapterHeaderMatch = bodyContent.match(/^(##\s+Chapter\s*\d*:\s*.+)$/m);
  let proseStartIndex = -1;
  if (storyHeaderMatch) {
    proseStartIndex = bodyContent.indexOf(storyHeaderMatch[0]);
  } else if (chapterHeaderMatch) {
    proseStartIndex = bodyContent.indexOf(chapterHeaderMatch[0]);
  }
  if (proseStartIndex === -1) {
    return { sections: [] };
  }
  const proseContent = bodyContent.substring(proseStartIndex);
  const lines = proseContent.split(/\n/);
  let order = 0;
  let currentChapter = null;
  let currentScene = null;
  let currentBeat = null;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    if (trimmedLine.startsWith(">")) {
      continue;
    }
    const storyMatch = trimmedLine.match(/^#\s+Story:\s*(.+)$/i);
    if (storyMatch) {
      continue;
    }
    const chapterMatch = trimmedLine.match(/^##\s+Chapter\s*\d*:\s*(.+)$/i);
    if (chapterMatch) {
      const chapterText = chapterMatch[1].trim();
      const linkMatch = chapterText.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
      if (linkMatch) {
        currentChapter = {
          linkName: linkMatch[1].trim(),
          title: linkMatch[2].trim()
        };
      } else {
        currentChapter = {
          linkName: null,
          title: chapterText
        };
      }
      currentScene = null;
      currentBeat = null;
      continue;
    }
    const sceneMatch = trimmedLine.match(/^###\s+Scene:\s*(.+)$/i);
    if (sceneMatch) {
      const sceneText = sceneMatch[1].trim();
      currentScene = parseSceneHeaderText(sceneText);
      currentScene.originalOrder = order++;
      sections.push({
        type: "scene",
        scene: currentScene,
        originalOrder: currentScene.originalOrder
      });
      currentBeat = null;
      continue;
    }
    const beatMatch = trimmedLine.match(/^####\s+Beat:\s*(.+)$/i);
    if (beatMatch) {
      const beatText = beatMatch[1].trim();
      currentBeat = parseBeatHeaderText(beatText);
      currentBeat.originalOrder = order++;
      sections.push({
        type: "beat",
        beat: currentBeat,
        originalOrder: currentBeat.originalOrder
      });
      continue;
    }
    if (trimmedLine.startsWith("#")) {
      continue;
    }
    if (trimmedLine.match(/^[+-]\s+/)) {
      continue;
    }
    const proseMatch = trimmedLine.match(/^\s*\[\[([^\|]+)\|([^\]]+)\]\]\s*$/);
    if (proseMatch) {
      const linkName = proseMatch[1].trim();
      const content = proseMatch[2].trim();
      const paragraph = {
        content,
        linkName,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
      continue;
    }
    if (trimmedLine.length > 0) {
      const paragraph = {
        content: trimmedLine,
        linkName: null,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
    }
  }
  return { sections };
}
function parseSceneHeaderText(text) {
  const linkMatch = text.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
  if (linkMatch) {
    const linkName = linkMatch[1].trim();
    const displayText = linkMatch[2].trim();
    const parts2 = displayText.split(/\s*-\s*/);
    return {
      linkName,
      goal: parts2[0].trim(),
      timeRef: parts2.length > 1 ? parts2.slice(1).join(" - ").trim() : "",
      originalOrder: 0
    };
  }
  const simpleLinkMatch = text.match(/^\[\[([^\]]+)\]\]$/);
  if (simpleLinkMatch) {
    return {
      linkName: simpleLinkMatch[1].trim(),
      goal: "",
      timeRef: "",
      originalOrder: 0
    };
  }
  const parts = text.split(/\s*-\s*/);
  return {
    linkName: null,
    goal: parts[0].trim(),
    timeRef: parts.length > 1 ? parts.slice(1).join(" - ").trim() : "",
    originalOrder: 0
  };
}
function parseBeatHeaderText(text) {
  const linkMatch = text.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
  if (linkMatch) {
    const linkName = linkMatch[1].trim();
    const displayText = linkMatch[2].trim();
    const parts2 = displayText.split(/\s*->\s*/);
    return {
      linkName,
      intent: parts2[0].trim(),
      outcome: parts2.length > 1 ? parts2.slice(1).join(" -> ").trim() : "",
      originalOrder: 0
    };
  }
  const simpleLinkMatch = text.match(/^\[\[([^\]]+)\]\]$/);
  if (simpleLinkMatch) {
    return {
      linkName: simpleLinkMatch[1].trim(),
      intent: "",
      outcome: "",
      originalOrder: 0
    };
  }
  const parts = text.split(/\s*->\s*/);
  return {
    linkName: null,
    intent: parts[0].trim(),
    outcome: parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "",
    originalOrder: 0
  };
}
function parseSceneProse(sceneContent) {
  const sections = [];
  const frontmatterMatch = sceneContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = sceneContent.substring(contentStart).trim();
  const sceneHeaderMatch = bodyContent.match(/^(###\s+Scene:\s*.+)$/m);
  const beatHeaderMatch = bodyContent.match(/^(#{3,4}\s+Beat:\s*.+)$/m);
  let proseStartIndex = -1;
  if (sceneHeaderMatch) {
    proseStartIndex = bodyContent.indexOf(sceneHeaderMatch[0]);
  } else if (beatHeaderMatch) {
    proseStartIndex = bodyContent.indexOf(beatHeaderMatch[0]);
  } else {
    const beatsListEnd = bodyContent.match(/##\s+Beats\s*\n+[\s\S]*?(?=\n###|\n####|\n[^#\-\+>\s]|$)/);
    if (beatsListEnd) {
      proseStartIndex = bodyContent.indexOf(beatsListEnd[0]) + beatsListEnd[0].length;
    } else {
      const firstNonListContent = bodyContent.match(/(?:^|\n)([^#\-\+>\s\n].+)/);
      if (firstNonListContent) {
        proseStartIndex = bodyContent.indexOf(firstNonListContent[1]);
      }
    }
  }
  if (proseStartIndex === -1) {
    return { sections: [] };
  }
  const proseContent = bodyContent.substring(proseStartIndex);
  const lines = proseContent.split(/\n/);
  let order = 0;
  let currentBeat = null;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    if (trimmedLine.startsWith(">")) {
      continue;
    }
    const sceneMatch = trimmedLine.match(/^###\s+Scene:\s*(.+)$/i);
    if (sceneMatch) {
      const sceneText = sceneMatch[1].trim();
      const parsedScene = parseSceneHeaderText(sceneText);
      parsedScene.originalOrder = order++;
      sections.push({
        type: "scene",
        scene: parsedScene,
        originalOrder: parsedScene.originalOrder
      });
      currentBeat = null;
      continue;
    }
    const beatMatch = trimmedLine.match(/^#{3,4}\s+Beat:\s*(.+)$/i);
    if (beatMatch) {
      const beatText = beatMatch[1].trim();
      currentBeat = parseBeatHeaderText(beatText);
      currentBeat.originalOrder = order++;
      sections.push({
        type: "beat",
        beat: currentBeat,
        originalOrder: currentBeat.originalOrder
      });
      continue;
    }
    if (trimmedLine.startsWith("#")) {
      continue;
    }
    if (trimmedLine.match(/^[+-]\s+/)) {
      continue;
    }
    const proseMatch = trimmedLine.match(/^\s*\[\[([^\|]+)\|([^\]]+)\]\]\s*$/);
    if (proseMatch) {
      const linkName = proseMatch[1].trim();
      const content = proseMatch[2].trim();
      const paragraph = {
        content,
        linkName,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
      continue;
    }
    if (trimmedLine.length > 0) {
      const paragraph = {
        content: trimmedLine,
        linkName: null,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
    }
  }
  return { sections };
}
function parseBeatProse(beatContent) {
  const sections = [];
  const frontmatterMatch = beatContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = beatContent.substring(contentStart).trim();
  const beatHeaderMatch = bodyContent.match(/^(##\s+Beat:\s*.+)$/m);
  let proseStartIndex = -1;
  if (beatHeaderMatch) {
    proseStartIndex = bodyContent.indexOf(beatHeaderMatch[0]);
  }
  if (proseStartIndex === -1) {
    return { sections: [] };
  }
  const proseContent = bodyContent.substring(proseStartIndex);
  const lines = proseContent.split(/\n/);
  let order = 0;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    if (trimmedLine.startsWith(">")) {
      continue;
    }
    const beatMatch = trimmedLine.match(/^##\s+Beat:\s*(.+)$/i);
    if (beatMatch) {
      continue;
    }
    if (trimmedLine.startsWith("#")) {
      continue;
    }
    if (trimmedLine.match(/^[+-]\s+/)) {
      continue;
    }
    const proseMatch = trimmedLine.match(/^\s*\[\[([^\|]+)\|([^\]]+)\]\]\s*$/);
    if (proseMatch) {
      const linkName = proseMatch[1].trim();
      const content = proseMatch[2].trim();
      const paragraph = {
        content,
        linkName,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
      continue;
    }
    if (trimmedLine.length > 0) {
      const paragraph = {
        content: trimmedLine,
        linkName: null,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
    }
  }
  return { sections };
}

// src/views/modals/ConflictModal.ts
var import_obsidian7 = require("obsidian");
var ConflictModal = class extends import_obsidian7.Modal {
  constructor(app, localContentBlock, remoteContentBlock, onResolve) {
    super(app);
    this.resolution = null;
    this.localContentBlock = localContentBlock;
    this.remoteContentBlock = remoteContentBlock;
    this.onResolve = onResolve;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", {
      text: "Content Block Conflict"
    });
    contentEl.createEl("p", {
      text: "This content block has been modified both locally and remotely. Choose how to resolve the conflict:"
    });
    const diffContainer = contentEl.createDiv("conflict-diff-container");
    const localDiv = diffContainer.createDiv("conflict-local");
    localDiv.createEl("h3", { text: "Local Version" });
    const localContent = localDiv.createEl("pre", {
      text: this.localContentBlock.content,
      cls: "conflict-content"
    });
    localContent.style.whiteSpace = "pre-wrap";
    localContent.style.maxHeight = "200px";
    localContent.style.overflow = "auto";
    localContent.style.border = "1px solid var(--background-modifier-border)";
    localContent.style.padding = "10px";
    localContent.style.borderRadius = "4px";
    const remoteDiv = diffContainer.createDiv("conflict-remote");
    remoteDiv.createEl("h3", { text: "Remote Version" });
    const remoteContent = remoteDiv.createEl("pre", {
      text: this.remoteContentBlock.content,
      cls: "conflict-content"
    });
    remoteContent.style.whiteSpace = "pre-wrap";
    remoteContent.style.maxHeight = "200px";
    remoteContent.style.overflow = "auto";
    remoteContent.style.border = "1px solid var(--background-modifier-border)";
    remoteContent.style.padding = "10px";
    remoteContent.style.borderRadius = "4px";
    const manualDiv = contentEl.createDiv("conflict-manual");
    manualDiv.createEl("h3", { text: "Manual Merge (Optional)" });
    const manualTextarea = manualDiv.createEl("textarea", {
      text: this.localContentBlock.content,
      cls: "conflict-manual-input"
    });
    manualTextarea.style.width = "100%";
    manualTextarea.style.minHeight = "150px";
    manualTextarea.style.padding = "10px";
    manualTextarea.style.border = "1px solid var(--background-modifier-border)";
    manualTextarea.style.borderRadius = "4px";
    manualTextarea.style.fontFamily = "var(--font-monospace)";
    const buttonContainer = contentEl.createDiv("conflict-buttons");
    buttonContainer.style.marginTop = "20px";
    buttonContainer.style.display = "flex";
    buttonContainer.style.gap = "10px";
    const useLocalBtn = buttonContainer.createEl("button", {
      text: "Use Local",
      cls: "mod-cta"
    });
    useLocalBtn.onclick = async () => {
      this.resolution = { resolution: "local" };
      await this.onResolve(this.resolution);
      this.close();
    };
    const useRemoteBtn = buttonContainer.createEl("button", {
      text: "Use Remote"
    });
    useRemoteBtn.onclick = async () => {
      this.resolution = { resolution: "remote" };
      await this.onResolve(this.resolution);
      this.close();
    };
    const useManualBtn = buttonContainer.createEl("button", {
      text: "Use Manual Merge",
      cls: "mod-primary"
    });
    useManualBtn.onclick = async () => {
      this.resolution = {
        resolution: "manual",
        mergedContent: manualTextarea.value
      };
      await this.onResolve(this.resolution);
      this.close();
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/sync/syncService.ts
var SyncService = class {
  constructor(apiClient, fileManager, settings, app) {
    this.apiClient = apiClient;
    this.fileManager = fileManager;
    this.settings = settings;
    this.app = app;
    if (this.settings.autoSyncOnApiUpdates) {
      this.unsubscribeFromNotifier = apiUpdateNotifier.subscribe(async (payload) => {
        try {
          await this.applyEntityData(payload);
        } catch (err) {
          console.error("Failed to auto-sync entity data", err);
        }
      });
    }
  }
  dispose() {
    if (this.unsubscribeFromNotifier) {
      this.unsubscribeFromNotifier();
      this.unsubscribeFromNotifier = void 0;
    }
  }
  // Pull story from service to Obsidian (Service  Obsidian)
  async pullStory(storyId, target) {
    try {
      if (target) {
        await this.pullSingleEntity(storyId, target);
        return;
      }
      const storyData = await this.apiClient.getStoryWithHierarchy(storyId);
      const folderPath = this.fileManager.getStoryFolderPath(
        storyData.story.title
      );
      const existingMetadata = await this.fileManager.readStoryMetadata(folderPath).catch(() => null);
      const allScenes = await this.apiClient.getScenesByStory(storyId);
      const orphanScenes = [];
      for (const scene of allScenes) {
        if (!scene.chapter_id) {
          const beats = await this.apiClient.getBeats(scene.id);
          orphanScenes.push({ scene, beats });
        }
      }
      orphanScenes.sort((a, b) => a.scene.order_num - b.scene.order_num);
      const allBeats = await this.apiClient.getBeatsByStory(storyId);
      const orphanBeats = [];
      const sceneIdSet = new Set(allScenes.map((s) => s.id));
      for (const beat of allBeats) {
        if (!beat.scene_id || !sceneIdSet.has(beat.scene_id)) {
          orphanBeats.push(beat);
        }
      }
      orphanBeats.sort((a, b) => a.order_num - b.order_num);
      const chapterContentData = /* @__PURE__ */ new Map();
      for (const chapterWithContent of storyData.chapters) {
        const contentBlocks = await this.apiClient.getContentBlocks(chapterWithContent.chapter.id);
        const contentBlockRefs = [];
        for (const contentBlock of contentBlocks) {
          const refs = await this.apiClient.getContentAnchors(contentBlock.id);
          contentBlockRefs.push(...refs);
        }
        chapterContentData.set(chapterWithContent.chapter.id, { contentBlocks, contentBlockRefs });
      }
      await this.fileManager.writeStoryMetadata(
        storyData.story,
        folderPath,
        storyData.chapters,
        orphanScenes,
        orphanBeats,
        chapterContentData
      );
      const contentsFolderPath = `${folderPath}/03-contents`;
      await this.fileManager.ensureFolderExists(contentsFolderPath);
      for (const typeFolder of ["00-texts", "01-images", "02-videos", "03-audios", "04-embeds", "05-links"]) {
        await this.fileManager.ensureFolderExists(`${contentsFolderPath}/${typeFolder}`);
      }
      const chaptersFolderPath = `${folderPath}/00-chapters`;
      await this.fileManager.ensureFolderExists(chaptersFolderPath);
      for (const chapterWithContent of storyData.chapters) {
        const contentData = chapterContentData.get(chapterWithContent.chapter.id);
        const contentBlocks = (contentData == null ? void 0 : contentData.contentBlocks) || [];
        const contentBlockRefs = (contentData == null ? void 0 : contentData.contentBlockRefs) || [];
        for (const contentBlock of contentBlocks) {
          const contentBlockFileName = this.fileManager.generateContentBlockFileName(contentBlock);
          const typeFolderPath = this.fileManager.getContentBlockFolderPath(folderPath, contentBlock.type || "text");
          await this.fileManager.ensureFolderExists(typeFolderPath);
          const contentBlockFilePath = `${typeFolderPath}/${contentBlockFileName}`;
          await this.fileManager.writeContentBlockFile(
            contentBlock,
            contentBlockFilePath,
            storyData.story.title
          );
        }
        const chapterFileName = `Chapter-${chapterWithContent.chapter.number}.md`;
        const chapterFilePath = `${chaptersFolderPath}/${chapterFileName}`;
        await this.fileManager.writeChapterFile(
          chapterWithContent,
          chapterFilePath,
          storyData.story.title,
          contentBlocks,
          contentBlockRefs,
          orphanScenes
          // Include orphan scenes for easy association
        );
        const scenesFolderPath2 = `${folderPath}/01-scenes`;
        await this.fileManager.ensureFolderExists(scenesFolderPath2);
        for (const { scene, beats } of chapterWithContent.scenes) {
          const sceneContentBlocks = await this.apiClient.getContentBlocksByScene(scene.id);
          const sceneFileName = this.fileManager.generateSceneFileName(scene);
          const sceneFilePath = `${scenesFolderPath2}/${sceneFileName}`;
          await this.fileManager.writeSceneFile(
            { scene, beats },
            sceneFilePath,
            storyData.story.title,
            sceneContentBlocks,
            orphanBeats
            // Include orphan beats for easy association
          );
          const beatsFolderPath2 = `${folderPath}/02-beats`;
          await this.fileManager.ensureFolderExists(beatsFolderPath2);
          for (const beat of beats) {
            const beatContentBlocks = await this.apiClient.getContentBlocksByBeat(beat.id);
            const beatFileName = this.fileManager.generateBeatFileName(beat);
            const beatFilePath = `${beatsFolderPath2}/${beatFileName}`;
            await this.fileManager.writeBeatFile(beat, beatFilePath, storyData.story.title, beatContentBlocks);
          }
        }
      }
      const scenesFolderPath = `${folderPath}/01-scenes`;
      await this.fileManager.ensureFolderExists(scenesFolderPath);
      for (const { scene, beats } of orphanScenes) {
        const sceneContentBlocks = await this.apiClient.getContentBlocksByScene(scene.id);
        const sceneFileName = this.fileManager.generateSceneFileName(scene);
        const sceneFilePath = `${scenesFolderPath}/${sceneFileName}`;
        await this.fileManager.writeSceneFile(
          { scene, beats },
          sceneFilePath,
          storyData.story.title,
          sceneContentBlocks,
          orphanBeats
          // Include orphan beats for easy association
        );
        const beatsFolderPath2 = `${folderPath}/02-beats`;
        await this.fileManager.ensureFolderExists(beatsFolderPath2);
        for (const beat of beats) {
          const beatContentBlocks = await this.apiClient.getContentBlocksByBeat(beat.id);
          const beatFileName = this.fileManager.generateBeatFileName(beat);
          const beatFilePath = `${beatsFolderPath2}/${beatFileName}`;
          await this.fileManager.writeBeatFile(beat, beatFilePath, storyData.story.title, beatContentBlocks);
        }
      }
      const beatsFolderPath = `${folderPath}/02-beats`;
      await this.fileManager.ensureFolderExists(beatsFolderPath);
      for (const beat of orphanBeats) {
        const beatContentBlocks = await this.apiClient.getContentBlocksByBeat(beat.id);
        const beatFileName = this.fileManager.generateBeatFileName(beat);
        const beatFilePath = `${beatsFolderPath}/${beatFileName}`;
        await this.fileManager.writeBeatFile(beat, beatFilePath, storyData.story.title, beatContentBlocks);
      }
      if (existingMetadata && existingMetadata.frontmatter.version !== void 0 && existingMetadata.frontmatter.version !== storyData.story.version_number) {
        await this.fileManager.createVersionSnapshot(
          folderPath,
          existingMetadata.frontmatter.version
        );
      }
      await this.syncVersionHistory(storyData.story.root_story_id, folderPath);
      new import_obsidian8.Notice(`Story "${storyData.story.title}" synced successfully`);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to sync story";
      new import_obsidian8.Notice(`Error syncing story: ${errorMessage}`, 5e3);
      throw err;
    }
  }
  // Sync all previous versions of a story
  async syncVersionHistory(rootStoryId, storyFolderPath) {
    try {
      const allStories = await this.apiClient.listStories();
      const versions = allStories.filter((s) => s.root_story_id === rootStoryId);
      versions.sort((a, b) => a.version_number - b.version_number);
      const versionsPath = `${storyFolderPath}/versions`;
      await this.fileManager.ensureFolderExists(versionsPath);
      for (const versionStory of versions) {
        const currentVersion = versions[versions.length - 1].version_number;
        if (versionStory.version_number === currentVersion) {
          continue;
        }
        const versionFolderPath = `${versionsPath}/v${versionStory.version_number}`;
        const existingVersionFolder = this.fileManager.getVault().getAbstractFileByPath(
          versionFolderPath
        );
        if (existingVersionFolder) {
          console.log(`Version v${versionStory.version_number} already exists, skipping`);
          continue;
        }
        const versionData = await this.apiClient.getStoryWithHierarchy(
          versionStory.id
        );
        await this.fileManager.ensureFolderExists(versionFolderPath);
        await this.fileManager.writeStoryMetadata(
          versionData.story,
          versionFolderPath
        );
        const versionContentsFolderPath = `${versionFolderPath}/03-contents`;
        await this.fileManager.ensureFolderExists(versionContentsFolderPath);
        for (const typeFolder of ["00-texts", "01-images", "02-videos", "03-audios", "04-embeds", "05-links"]) {
          await this.fileManager.ensureFolderExists(`${versionContentsFolderPath}/${typeFolder}`);
        }
        const versionChaptersPath = `${versionFolderPath}/00-chapters`;
        await this.fileManager.ensureFolderExists(versionChaptersPath);
        for (const chapterWithContent of versionData.chapters) {
          const contentBlocks = await this.apiClient.getContentBlocks(chapterWithContent.chapter.id);
          const contentBlockRefs = [];
          for (const contentBlock of contentBlocks) {
            const refs = await this.apiClient.getContentAnchors(contentBlock.id);
            contentBlockRefs.push(...refs);
          }
          for (const contentBlock of contentBlocks) {
            const contentBlockFileName = this.fileManager.generateContentBlockFileName(contentBlock);
            const typeFolderPath = this.fileManager.getContentBlockFolderPath(versionFolderPath, contentBlock.type || "text");
            await this.fileManager.ensureFolderExists(typeFolderPath);
            const contentBlockFilePath = `${typeFolderPath}/${contentBlockFileName}`;
            await this.fileManager.writeContentBlockFile(
              contentBlock,
              contentBlockFilePath,
              versionData.story.title
            );
          }
          const chapterFileName = `Chapter-${chapterWithContent.chapter.number}.md`;
          const chapterFilePath = `${versionChaptersPath}/${chapterFileName}`;
          await this.fileManager.writeChapterFile(
            chapterWithContent,
            chapterFilePath,
            versionData.story.title,
            contentBlocks,
            contentBlockRefs
          );
          const versionScenesPath = `${versionFolderPath}/01-scenes`;
          await this.fileManager.ensureFolderExists(versionScenesPath);
          for (const { scene, beats } of chapterWithContent.scenes) {
            const sceneContentBlocks = await this.apiClient.getContentBlocksByScene(scene.id);
            const sceneFileName = this.fileManager.generateSceneFileName(scene);
            const sceneFilePath = `${versionScenesPath}/${sceneFileName}`;
            await this.fileManager.writeSceneFile(
              { scene, beats },
              sceneFilePath,
              versionData.story.title,
              sceneContentBlocks
            );
            const versionBeatsPath = `${versionFolderPath}/02-beats`;
            await this.fileManager.ensureFolderExists(versionBeatsPath);
            for (const beat of beats) {
              const beatContentBlocks = await this.apiClient.getContentBlocksByBeat(beat.id);
              const beatFileName = this.fileManager.generateBeatFileName(beat);
              const beatFilePath = `${versionBeatsPath}/${beatFileName}`;
              await this.fileManager.writeBeatFile(beat, beatFilePath, versionData.story.title, beatContentBlocks);
            }
          }
        }
        console.log(`Synced version v${versionStory.version_number}`);
      }
    } catch (err) {
      console.error("Error syncing version history:", err);
    }
  }
  // Pull all stories
  async pullAllStories() {
    if (this.settings.mode === "remote" && !this.settings.tenantId) {
      throw new Error("Tenant ID is required");
    }
    try {
      await this.apiClient.getWorlds();
    } catch (err) {
      console.error("Failed to load worlds:", err);
    }
    const stories = await this.apiClient.listStories();
    for (const story of stories) {
      try {
        await this.pullStory(story.id);
      } catch (err) {
        console.error(`Failed to sync story ${story.id}:`, err);
      }
    }
    new import_obsidian8.Notice(`Synced ${stories.length} stories`);
  }
  // Apply entity data received from API without fetching
  async applyEntityData(payload) {
    switch (payload.type) {
      case "chapter": {
        await this.writeChapterBundle({
          story: payload.story,
          chapter: payload.chapter,
          scenes: payload.scenes,
          contentBlocks: payload.contentBlocks,
          contentBlockRefs: payload.contentBlockRefs
        });
        new import_obsidian8.Notice(`Chapter "${payload.chapter.title}" synced successfully`);
        break;
      }
      case "scene": {
        const beatContentBlockMap = /* @__PURE__ */ new Map();
        if (payload.beatContentBlocks) {
          for (const [beatId, blocks] of Object.entries(payload.beatContentBlocks)) {
            beatContentBlockMap.set(beatId, blocks);
          }
        }
        const folderPath = this.fileManager.getStoryFolderPath(payload.story.title);
        await this.ensureStoryFolders(folderPath);
        await this.writeSceneBundle({
          storyTitle: payload.story.title,
          folderPath,
          scene: payload.scene,
          beats: payload.beats,
          sceneContentBlocks: payload.sceneContentBlocks,
          beatContentBlockMap,
          skipRemoteContentFetch: true
        });
        if (payload.sceneContentBlocks) {
          for (const contentBlock of payload.sceneContentBlocks) {
            await this.writeContentBlockToFolder(folderPath, payload.story.title, contentBlock);
          }
        }
        for (const blocks of beatContentBlockMap.values()) {
          for (const contentBlock of blocks) {
            await this.writeContentBlockToFolder(folderPath, payload.story.title, contentBlock);
          }
        }
        new import_obsidian8.Notice(`Scene "${payload.scene.goal}" synced successfully`);
        break;
      }
      case "content": {
        const folderPath = this.fileManager.getStoryFolderPath(payload.story.title);
        await this.ensureContentFolders(folderPath);
        await this.writeContentBlockToFolder(
          folderPath,
          payload.story.title,
          payload.contentBlock
        );
        new import_obsidian8.Notice("Content block synced successfully");
        break;
      }
    }
  }
  // Push story from Obsidian to service (Obsidian  Service)
  async pushStory(folderPath, target) {
    try {
      const { frontmatter: storyFrontmatter } = await this.fileManager.readStoryMetadata(folderPath);
      if (!storyFrontmatter.id) {
        throw new Error("Story metadata missing ID");
      }
      const storyId = storyFrontmatter.id;
      if (target) {
        await this.pushSingleEntity(folderPath, target, storyId, storyFrontmatter.title);
        return;
      }
      const storyFilePath = `${folderPath}/story.md`;
      const storyFile = this.fileManager.getVault().getAbstractFileByPath(storyFilePath);
      if (storyFile instanceof import_obsidian8.TFile) {
        const storyContent = await this.fileManager.getVault().read(storyFile);
        const chapterList = parseChapterList(storyContent);
        if (chapterList.items.length > 0) {
          await this.processChapterList(chapterList, storyId);
        }
        const orphanScenesList = parseOrphanScenesList(storyContent);
        if (orphanScenesList.items.length > 0) {
          await this.processOrphanScenesList(orphanScenesList, storyId);
        }
        const orphanBeatsList = parseOrphanBeatsList(storyContent);
        if (orphanBeatsList.items.length > 0) {
          await this.processOrphanBeatsList(orphanBeatsList, storyId);
        }
        const storyProse = parseStoryProse(storyContent);
        if (storyProse.sections.length > 0) {
          await this.pushStoryContentBlocks(storyFilePath, folderPath, storyId);
        }
      }
      await this.apiClient.updateStory(
        storyId,
        storyFrontmatter.title,
        storyFrontmatter.status
      );
      const chapterFiles = await this.fileManager.listChapterFiles(folderPath);
      for (const chapterFilePath of chapterFiles) {
        console.log(`Would update chapter: ${chapterFilePath}`);
      }
      for (const chapterFilePath of chapterFiles) {
        await this.pushChapterContentBlocks(chapterFilePath, folderPath);
      }
      const sceneFiles = await this.fileManager.listStorySceneFiles(folderPath);
      for (const sceneFilePath of sceneFiles) {
        await this.pushSceneBeats(sceneFilePath, storyId);
        await this.pushSceneContentBlocks(sceneFilePath, folderPath);
      }
      const beatFiles = await this.fileManager.listStoryBeatFiles(folderPath);
      for (const beatFilePath of beatFiles) {
        await this.pushBeatContentBlocks(beatFilePath, folderPath);
      }
      new import_obsidian8.Notice(`Story "${storyFrontmatter.title}" pushed successfully`);
      try {
        new import_obsidian8.Notice(`Syncing story "${storyFrontmatter.title}" from service...`);
        await this.pullStory(storyId);
        new import_obsidian8.Notice(`Story "${storyFrontmatter.title}" synced successfully`);
      } catch (pullErr) {
        const pullErrorMessage = pullErr instanceof Error ? pullErr.message : "Failed to sync story after push";
        new import_obsidian8.Notice(`Warning: ${pullErrorMessage}`, 5e3);
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to push story";
      new import_obsidian8.Notice(`Error pushing story: ${errorMessage}`, 5e3);
      throw err;
    }
  }
  // Push prose blocks from a chapter file (hierarchical structure)
  async pushChapterContentBlocks(chapterFilePath, storyFolderPath) {
    const file = this.fileManager.getVault().getAbstractFileByPath(chapterFilePath);
    if (!(file instanceof import_obsidian8.TFile)) {
      throw new Error(`Chapter file not found: ${chapterFilePath}`);
    }
    const chapterContent = await this.fileManager.getVault().read(file);
    const frontmatter = this.fileManager.parseFrontmatter(chapterContent);
    if (!frontmatter.id || !frontmatter.story_id) {
      throw new Error("Chapter metadata missing ID or story_id");
    }
    const chapterId = frontmatter.id;
    const storyId = frontmatter.story_id;
    const contentsFolderPath = `${storyFolderPath}/03-contents`;
    const sceneBeatList = parseSceneBeatList(chapterContent);
    await this.processSceneBeatList(sceneBeatList, chapterId, storyId);
    const remoteContentBlocks = await this.apiClient.getContentBlocks(chapterId);
    const remoteContentBlocksMap = /* @__PURE__ */ new Map();
    for (const pb of remoteContentBlocks) {
      remoteContentBlocksMap.set(pb.id, pb);
    }
    const existingScenes = await this.apiClient.getScenes(chapterId);
    const sceneMap = /* @__PURE__ */ new Map();
    const sceneIdMap = /* @__PURE__ */ new Map();
    for (const scene of existingScenes) {
      const fileName = this.fileManager.generateSceneFileName(scene);
      const linkName = fileName.replace(/\.md$/, "");
      sceneMap.set(linkName, scene);
      sceneIdMap.set(scene.id, scene);
    }
    const beatMap = /* @__PURE__ */ new Map();
    const beatIdMap = /* @__PURE__ */ new Map();
    for (const scene of existingScenes) {
      const beats = await this.apiClient.getBeats(scene.id);
      for (const beat of beats) {
        const fileName = this.fileManager.generateBeatFileName(beat);
        const linkName = fileName.replace(/\.md$/, "");
        beatMap.set(linkName, beat);
        beatIdMap.set(beat.id, beat);
      }
    }
    const hierarchical = parseHierarchicalProse(chapterContent);
    const updatedSections = [];
    let currentScene = null;
    let currentBeat = null;
    let proseOrderNum = 1;
    let sceneOrderNum = existingScenes.length > 0 ? Math.max(...existingScenes.map((s) => s.order_num)) + 1 : 1;
    for (const section of hierarchical.sections) {
      if (section.type === "scene" && section.scene) {
        const { scene: parsedScene } = section;
        if (parsedScene.linkName) {
          currentScene = sceneMap.get(parsedScene.linkName) || null;
          if (!currentScene) {
            currentScene = sceneIdMap.get(parsedScene.linkName) || null;
          }
          if (currentScene) {
            if (parsedScene.goal !== currentScene.goal || parsedScene.timeRef !== currentScene.time_ref) {
              currentScene = await this.apiClient.updateScene(currentScene.id, {
                goal: parsedScene.goal,
                time_ref: parsedScene.timeRef
              });
            }
          }
        } else {
          currentScene = await this.apiClient.createScene({
            story_id: storyId,
            chapter_id: chapterId,
            order_num: sceneOrderNum++,
            goal: parsedScene.goal,
            time_ref: parsedScene.timeRef
          });
          const sceneFileName = this.fileManager.generateSceneFileName(currentScene);
          const sceneLinkName = sceneFileName.replace(/\.md$/, "");
          sceneMap.set(sceneLinkName, currentScene);
          sceneIdMap.set(currentScene.id, currentScene);
        }
        if (currentScene) {
          const sceneFileName = this.fileManager.generateSceneFileName(currentScene);
          const sceneLinkName = sceneFileName.replace(/\.md$/, "");
          const sceneDisplayText = currentScene.time_ref ? `${currentScene.goal} - ${currentScene.time_ref}` : currentScene.goal;
          updatedSections.push(`## Scene: [[${sceneLinkName}|${sceneDisplayText}]]`);
        }
        currentBeat = null;
      } else if (section.type === "beat" && section.beat) {
        const { beat: parsedBeat } = section;
        if (!currentScene) {
          throw new Error("Beat found without a parent scene");
        }
        if (parsedBeat.linkName) {
          currentBeat = beatMap.get(parsedBeat.linkName) || null;
          if (!currentBeat) {
            currentBeat = beatIdMap.get(parsedBeat.linkName) || null;
          }
          if (currentBeat) {
            if (parsedBeat.intent !== currentBeat.intent || parsedBeat.outcome !== currentBeat.outcome) {
              currentBeat = await this.apiClient.updateBeat(currentBeat.id, {
                intent: parsedBeat.intent,
                outcome: parsedBeat.outcome
              });
            }
          }
        } else {
          const existingBeats = await this.apiClient.getBeats(currentScene.id);
          const beatOrderNum = existingBeats.length > 0 ? Math.max(...existingBeats.map((b) => b.order_num)) + 1 : 1;
          currentBeat = await this.apiClient.createBeat({
            scene_id: currentScene.id,
            order_num: beatOrderNum,
            type: "setup",
            // Default type
            intent: parsedBeat.intent,
            outcome: parsedBeat.outcome
          });
          const beatFileName = this.fileManager.generateBeatFileName(currentBeat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          beatMap.set(beatLinkName, currentBeat);
          beatIdMap.set(currentBeat.id, currentBeat);
        }
        if (currentBeat) {
          const beatFileName = this.fileManager.generateBeatFileName(currentBeat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          const beatDisplayText = currentBeat.outcome ? `${currentBeat.intent} -> ${currentBeat.outcome}` : currentBeat.intent;
          updatedSections.push(`### Beat: [[${beatLinkName}|${beatDisplayText}]]`);
        }
      } else if (section.type === "prose" && section.prose) {
        const { prose: paragraph } = section;
        let localContentBlock = null;
        let remoteContentBlock = null;
        if (paragraph.linkName) {
          const contentBlockFilePath = await this.findContentBlockFileByLinkName(contentsFolderPath, paragraph.linkName);
          if (contentBlockFilePath) {
            localContentBlock = await this.fileManager.readContentBlockFromFile(contentBlockFilePath);
          }
          if (!localContentBlock) {
            localContentBlock = await this.findContentBlockByContent(contentsFolderPath, paragraph.content);
          }
          if (localContentBlock) {
            remoteContentBlock = remoteContentBlocksMap.get(localContentBlock.id) || null;
          } else {
            const normalizedContent = paragraph.content.trim();
            for (const [id2, remotePB] of remoteContentBlocksMap.entries()) {
              if (remotePB.content.trim() === normalizedContent) {
                remoteContentBlock = remotePB;
                break;
              }
            }
          }
        } else {
          localContentBlock = await this.findContentBlockByContent(contentsFolderPath, paragraph.content);
          const normalizedContent = paragraph.content.trim();
          for (const [id2, remotePB] of remoteContentBlocksMap.entries()) {
            if (remotePB.content.trim() === normalizedContent) {
              remoteContentBlock = remotePB;
              if (!localContentBlock) {
                localContentBlock = await this.findContentBlockById(contentsFolderPath, remotePB.id);
              }
              break;
            }
          }
        }
        const status = compareContentBlocks(paragraph, localContentBlock, remoteContentBlock);
        let finalContentBlock;
        switch (status) {
          case "new": {
            finalContentBlock = await this.apiClient.createContentBlock(chapterId, {
              order_num: proseOrderNum++,
              kind: "final",
              content: paragraph.content
            });
            const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            if (currentScene) {
              await this.apiClient.createContentAnchor(finalContentBlock.id, "scene", currentScene.id);
            }
            if (currentBeat) {
              await this.apiClient.createContentAnchor(finalContentBlock.id, "beat", currentBeat.id);
            }
            const linkName = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
            break;
          }
          case "unchanged": {
            if (!localContentBlock && remoteContentBlock) {
              finalContentBlock = remoteContentBlock;
              const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
              await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            } else if (localContentBlock) {
              if (localContentBlock.order_num !== proseOrderNum) {
                finalContentBlock = await this.apiClient.updateContentBlock(localContentBlock.id, {
                  order_num: proseOrderNum++
                });
                const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
                await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
              } else {
                finalContentBlock = localContentBlock;
                proseOrderNum++;
              }
            } else {
              finalContentBlock = remoteContentBlock;
              proseOrderNum++;
            }
            if (finalContentBlock) {
              const existingRefs = await this.apiClient.getContentAnchors(finalContentBlock.id);
              const hasSceneRef = existingRefs.some((r) => r.entity_type === "scene" && r.entity_id === (currentScene == null ? void 0 : currentScene.id));
              const hasBeatRef = existingRefs.some((r) => r.entity_type === "beat" && r.entity_id === (currentBeat == null ? void 0 : currentBeat.id));
              if (currentScene && !hasSceneRef) {
                await this.apiClient.createContentAnchor(finalContentBlock.id, "scene", currentScene.id);
              }
              if (currentBeat && !hasBeatRef) {
                await this.apiClient.createContentAnchor(finalContentBlock.id, "beat", currentBeat.id);
              }
            }
            if (paragraph.linkName) {
              updatedSections.push(`[[${paragraph.linkName}|${paragraph.content}]]`);
            } else {
              const linkName = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
              updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
            }
            break;
          }
          case "local_modified": {
            finalContentBlock = await this.apiClient.updateContentBlock(localContentBlock.id, {
              content: paragraph.content,
              order_num: proseOrderNum++
            });
            const filePathLocalMod = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePathLocalMod, void 0);
            if (finalContentBlock) {
              const existingRefs = await this.apiClient.getContentAnchors(finalContentBlock.id);
              const hasSceneRef = existingRefs.some((r) => r.entity_type === "scene" && r.entity_id === (currentScene == null ? void 0 : currentScene.id));
              const hasBeatRef = existingRefs.some((r) => r.entity_type === "beat" && r.entity_id === (currentBeat == null ? void 0 : currentBeat.id));
              if (currentScene && !hasSceneRef) {
                await this.apiClient.createContentAnchor(finalContentBlock.id, "scene", currentScene.id);
              }
              if (currentBeat && !hasBeatRef) {
                await this.apiClient.createContentAnchor(finalContentBlock.id, "beat", currentBeat.id);
              }
            }
            const linkNameLocalMod = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
            updatedSections.push(`[[${linkNameLocalMod}|${paragraph.content}]]`);
            break;
          }
          case "remote_modified": {
            finalContentBlock = remoteContentBlock;
            const filePathRemoteMod = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePathRemoteMod, void 0);
            if (finalContentBlock) {
              const existingRefs = await this.apiClient.getContentAnchors(finalContentBlock.id);
              const hasSceneRef = existingRefs.some((r) => r.entity_type === "scene" && r.entity_id === (currentScene == null ? void 0 : currentScene.id));
              const hasBeatRef = existingRefs.some((r) => r.entity_type === "beat" && r.entity_id === (currentBeat == null ? void 0 : currentBeat.id));
              if (currentScene && !hasSceneRef) {
                await this.apiClient.createContentAnchor(finalContentBlock.id, "scene", currentScene.id);
              }
              if (currentBeat && !hasBeatRef) {
                await this.apiClient.createContentAnchor(finalContentBlock.id, "beat", currentBeat.id);
              }
            }
            const linkNameRemoteMod = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
            updatedSections.push(`[[${linkNameRemoteMod}|${finalContentBlock.content}]]`);
            new import_obsidian8.Notice(`Prose block updated from remote: ${linkNameRemoteMod}`, 3e3);
            proseOrderNum++;
            break;
          }
          case "conflict": {
            const resolution = await this.resolveConflict(localContentBlock, remoteContentBlock);
            let resolvedContent;
            if (resolution.resolution === "local") {
              resolvedContent = paragraph.content;
            } else if (resolution.resolution === "remote") {
              resolvedContent = remoteContentBlock.content;
            } else {
              resolvedContent = resolution.mergedContent || paragraph.content;
            }
            finalContentBlock = await this.apiClient.updateContentBlock(localContentBlock.id, {
              content: resolvedContent,
              order_num: proseOrderNum++
            });
            const filePathConflict = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePathConflict, void 0);
            if (finalContentBlock) {
              const existingRefs = await this.apiClient.getContentAnchors(finalContentBlock.id);
              const hasSceneRef = existingRefs.some((r) => r.entity_type === "scene" && r.entity_id === (currentScene == null ? void 0 : currentScene.id));
              const hasBeatRef = existingRefs.some((r) => r.entity_type === "beat" && r.entity_id === (currentBeat == null ? void 0 : currentBeat.id));
              if (currentScene && !hasSceneRef) {
                await this.apiClient.createContentAnchor(finalContentBlock.id, "scene", currentScene.id);
              }
              if (currentBeat && !hasBeatRef) {
                await this.apiClient.createContentAnchor(finalContentBlock.id, "beat", currentBeat.id);
              }
            }
            const linkNameConflict = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
            updatedSections.push(`[[${linkNameConflict}|${resolvedContent}]]`);
            break;
          }
        }
      }
    }
    await this.updateChapterFile(chapterContent, updatedSections, file, frontmatter, existingScenes, beatMap, remoteContentBlocks, chapterId);
  }
  // Update chapter file with both scene/beat list and chapter content
  async updateChapterFile(originalContent, updatedSections, file, frontmatter, scenes, beatMap, contentBlocks, chapterId) {
    const allContentAnchors = [];
    for (const contentBlock of contentBlocks) {
      const refs = await this.apiClient.getContentAnchors(contentBlock.id);
      allContentAnchors.push(...refs);
    }
    const proseRefsByScene = /* @__PURE__ */ new Map();
    const proseRefsByBeat = /* @__PURE__ */ new Map();
    for (const ref of allContentAnchors) {
      if (ref.entity_type === "scene") {
        if (!proseRefsByScene.has(ref.entity_id)) {
          proseRefsByScene.set(ref.entity_id, []);
        }
        proseRefsByScene.get(ref.entity_id).push(ref);
      } else if (ref.entity_type === "beat") {
        if (!proseRefsByBeat.has(ref.entity_id)) {
          proseRefsByBeat.set(ref.entity_id, []);
        }
        proseRefsByBeat.get(ref.entity_id).push(ref);
      }
    }
    const sceneBeatListItems = [];
    for (const scene of scenes.sort((a, b) => a.order_num - b.order_num)) {
      const sceneFileName = this.fileManager.generateSceneFileName(scene);
      const sceneLinkName = sceneFileName.replace(/\.md$/, "");
      const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
      const sceneProseRefs = proseRefsByScene.get(scene.id) || [];
      const sceneContentBlockIds = new Set(sceneProseRefs.map((r) => r.content_block_id));
      const hasSceneProse = Array.from(sceneContentBlockIds).some((contentBlockId) => {
        const blockRefs = allContentAnchors.filter((r) => r.content_block_id === contentBlockId);
        return !blockRefs.some((r) => r.entity_type === "beat");
      });
      const sceneMarker = hasSceneProse ? "+" : "-";
      sceneBeatListItems.push(`${sceneMarker} [[${sceneLinkName}|Scene ${scene.order_num}: ${sceneDisplayText}]]`);
      const sceneBeats = [];
      for (const [linkName, beat] of beatMap.entries()) {
        if (beat.scene_id === scene.id) {
          sceneBeats.push(beat);
        }
      }
      for (const beat of sceneBeats.sort((a, b) => a.order_num - b.order_num)) {
        const beatFileName = this.fileManager.generateBeatFileName(beat);
        const beatLinkName = beatFileName.replace(/\.md$/, "");
        const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
        const beatProseRefs = proseRefsByBeat.get(beat.id) || [];
        const hasBeatProse = beatProseRefs.length > 0;
        const beatMarker = hasBeatProse ? "+" : "-";
        sceneBeatListItems.push(`	${beatMarker} [[${beatLinkName}|Beat ${beat.order_num}: ${beatDisplayText}]]`);
      }
    }
    const frontmatterMatch = originalContent.match(/^---\n([\s\S]*?)\n---/);
    const frontmatterText = frontmatterMatch ? frontmatterMatch[0] : "";
    const bodyStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
    const bodyContent = originalContent.substring(bodyStart).trim();
    const chapterNumber = frontmatter.number || "1";
    const chapterTitle = frontmatter.title || "Untitled";
    const listSectionMatch = bodyContent.match(/([\s\S]*?##\s+Scenes\s+&\s+Beats\s*\n+)([\s\S]*?)(?=\n##|$)/);
    const updatedListSection = `## Scenes & Beats

${sceneBeatListItems.join("\n")}

`;
    let updatedBody;
    if (listSectionMatch) {
      const beforeList = listSectionMatch[1];
      const afterList = bodyContent.substring(listSectionMatch.index + listSectionMatch[0].length);
      updatedBody = `${beforeList}${updatedListSection}${afterList}`;
    } else {
      const titleMatch = bodyContent.match(/(#\s+[^\n]+\n+)([\s\S]*)/);
      if (titleMatch) {
        updatedBody = `${titleMatch[1]}${updatedListSection}${titleMatch[2]}`;
      } else {
        updatedBody = `${updatedListSection}${bodyContent}`;
      }
    }
    const chapterHeaderPattern = `##\\s+Chapter\\s+${chapterNumber}:\\s+[^\\n]+`;
    const chapterSectionMatch = updatedBody.match(new RegExp(`([\\s\\S]*?${chapterHeaderPattern}\\s*\\n+)([\\s\\S]*?)(?=\\n##\\s+Chapter\\s+\\d+:|$)`, "i"));
    if (!chapterSectionMatch) {
      const newChapterSection = `

## Chapter ${chapterNumber}: ${chapterTitle}

${updatedSections.join("\n\n")}

`;
      updatedBody = `${updatedBody}${newChapterSection}`;
    } else {
      const beforeChapter = chapterSectionMatch[1];
      const afterChapter = updatedBody.substring(chapterSectionMatch.index + chapterSectionMatch[0].length);
      const newChapterContent = updatedSections.join("\n\n");
      updatedBody = `${beforeChapter}${newChapterContent}

${afterChapter}`;
    }
    const updatedContent = `${frontmatterText}
${updatedBody}`;
    await this.fileManager.getVault().modify(file, updatedContent);
  }
  // Process the "## Chapters, Scenes & Beats" list and update order
  async processChapterList(list, storyId) {
    const existingChapters = await this.apiClient.getChapters(storyId);
    const chapterMap = /* @__PURE__ */ new Map();
    const chapterIdMap = /* @__PURE__ */ new Map();
    for (const chapter of existingChapters) {
      const fileName = `Chapter-${chapter.number}.md`;
      const linkName = fileName.replace(/\.md$/, "");
      chapterMap.set(linkName, chapter);
      chapterIdMap.set(chapter.id, chapter);
    }
    let currentChapter = null;
    let currentScene = null;
    let chapterOrderNum = 1;
    const sceneOrderNums = /* @__PURE__ */ new Map();
    const beatOrderNums = /* @__PURE__ */ new Map();
    for (const item of list.items) {
      if (item.type === "chapter") {
        let title;
        let chapterNumber = null;
        const chapterMatch = item.displayText.match(/Chapter\s+(\d+):\s*(.+)/);
        if (chapterMatch) {
          chapterNumber = parseInt(chapterMatch[1], 10);
          title = chapterMatch[2].trim();
        } else {
          title = item.displayText.trim();
        }
        currentScene = null;
        sceneOrderNums.set("current", 1);
        if (item.linkName) {
          currentChapter = chapterMap.get(item.linkName) || null;
          if (!currentChapter) {
            currentChapter = chapterIdMap.get(item.linkName) || null;
          }
          if (currentChapter) {
            const needsOrderUpdate = currentChapter.number !== chapterOrderNum;
            const needsTitleUpdate = title !== currentChapter.title;
            if (needsOrderUpdate || needsTitleUpdate) {
              currentChapter = await this.apiClient.updateChapter(currentChapter.id, {
                number: chapterOrderNum,
                title: needsTitleUpdate ? title : void 0
              });
              const fileName = `Chapter-${currentChapter.number}.md`;
              const linkName = fileName.replace(/\.md$/, "");
              chapterMap.set(linkName, currentChapter);
              chapterIdMap.set(currentChapter.id, currentChapter);
            }
          }
        } else {
          if (title) {
            currentChapter = await this.apiClient.createChapter(storyId, {
              number: chapterOrderNum,
              title,
              status: "draft"
            });
            const fileName = `Chapter-${currentChapter.number}.md`;
            const linkName = fileName.replace(/\.md$/, "");
            chapterMap.set(linkName, currentChapter);
            chapterIdMap.set(currentChapter.id, currentChapter);
          }
        }
        if (currentChapter) {
          sceneOrderNums.set(currentChapter.id, 1);
        }
        chapterOrderNum++;
      } else if (item.type === "scene" && currentChapter) {
        let goal;
        let timeRef = "";
        const sceneMatch = item.displayText.match(/Scene\s+\d+:\s*(.+)/);
        if (sceneMatch) {
          const sceneText = sceneMatch[1].trim();
          const parts = sceneText.split(/\s*-\s*/);
          goal = parts[0].trim();
          timeRef = parts.length > 1 ? parts.slice(1).join(" - ").trim() : "";
        } else {
          const parts = item.displayText.split(/\s*-\s*/);
          goal = parts[0].trim();
          timeRef = parts.length > 1 ? parts.slice(1).join(" - ").trim() : "";
        }
        const currentSceneOrderNum = sceneOrderNums.get(currentChapter.id) || 1;
        currentScene = null;
        if (item.linkName) {
          const existingScenes = await this.apiClient.getScenes(currentChapter.id);
          const sceneMap = /* @__PURE__ */ new Map();
          const sceneIdMap = /* @__PURE__ */ new Map();
          for (const scene of existingScenes) {
            const fileName = this.fileManager.generateSceneFileName(scene);
            const linkName = fileName.replace(/\.md$/, "");
            sceneMap.set(linkName, scene);
            sceneIdMap.set(scene.id, scene);
          }
          currentScene = sceneMap.get(item.linkName) || null;
          if (!currentScene) {
            currentScene = sceneIdMap.get(item.linkName) || null;
          }
          if (currentScene) {
            const needsOrderUpdate = currentScene.order_num !== currentSceneOrderNum;
            const needsContentUpdate = goal !== currentScene.goal || timeRef !== currentScene.time_ref;
            const needsChapterUpdate = currentScene.chapter_id !== currentChapter.id;
            if (needsOrderUpdate || needsContentUpdate || needsChapterUpdate) {
              currentScene = await this.apiClient.updateScene(currentScene.id, {
                goal,
                time_ref: timeRef,
                order_num: currentSceneOrderNum,
                chapter_id: currentChapter.id
              });
            }
            const existingBeats = await this.apiClient.getBeats(currentScene.id);
            if (existingBeats.length === 0) {
              beatOrderNums.set(currentScene.id, 1);
            } else {
              const maxOrderNum = Math.max(...existingBeats.map((b) => b.order_num));
              beatOrderNums.set(currentScene.id, maxOrderNum + 1);
            }
          }
        } else {
          currentScene = await this.apiClient.createScene({
            story_id: storyId,
            chapter_id: currentChapter.id,
            order_num: currentSceneOrderNum,
            goal,
            time_ref: timeRef
          });
          beatOrderNums.set(currentScene.id, 1);
        }
        sceneOrderNums.set(currentChapter.id, currentSceneOrderNum + 1);
      } else if (item.type === "beat" && currentScene) {
        let intent;
        let outcome = "";
        const beatMatch = item.displayText.match(/Beat\s+\d+:\s*(.+)/);
        if (beatMatch) {
          const beatText = beatMatch[1].trim();
          const parts = beatText.split(/\s*->\s*/);
          intent = parts[0].trim();
          outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
        } else {
          const parts = item.displayText.split(/\s*->\s*/);
          intent = parts[0].trim();
          outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
        }
        const currentBeatOrderNum = beatOrderNums.get(currentScene.id) || 1;
        if (item.linkName) {
          const existingBeats = await this.apiClient.getBeats(currentScene.id);
          const beatMap = /* @__PURE__ */ new Map();
          const beatIdMap = /* @__PURE__ */ new Map();
          for (const beat of existingBeats) {
            const fileName = this.fileManager.generateBeatFileName(beat);
            const linkName = fileName.replace(/\.md$/, "");
            beatMap.set(linkName, beat);
            beatIdMap.set(beat.id, beat);
          }
          let currentBeat = beatMap.get(item.linkName) || null;
          if (!currentBeat) {
            currentBeat = beatIdMap.get(item.linkName) || null;
          }
          if (currentBeat) {
            const needsOrderUpdate = currentBeat.order_num !== currentBeatOrderNum;
            const needsContentUpdate = intent !== currentBeat.intent || outcome !== currentBeat.outcome;
            const needsSceneUpdate = currentBeat.scene_id !== currentScene.id;
            if (needsOrderUpdate || needsContentUpdate || needsSceneUpdate) {
              currentBeat = await this.apiClient.updateBeat(currentBeat.id, {
                intent,
                outcome,
                order_num: currentBeatOrderNum,
                scene_id: currentScene.id
              });
            }
          }
        } else {
          await this.apiClient.createBeat({
            scene_id: currentScene.id,
            order_num: currentBeatOrderNum,
            type: "setup",
            // Default type
            intent,
            outcome
          });
        }
        beatOrderNums.set(currentScene.id, currentBeatOrderNum + 1);
      }
    }
  }
  // Process the "## Beats" list from a scene file and update beat order
  async pushSceneBeats(sceneFilePath, storyId) {
    const file = this.fileManager.getVault().getAbstractFileByPath(sceneFilePath);
    if (!(file instanceof import_obsidian8.TFile)) {
      return;
    }
    const sceneContent = await this.fileManager.getVault().read(file);
    const frontmatter = this.fileManager.parseFrontmatter(sceneContent);
    if (!frontmatter.id) {
      return;
    }
    const sceneId = frontmatter.id;
    const beatList = parseBeatList(sceneContent);
    if (beatList.items.length === 0) {
      return;
    }
    const existingBeats = await this.apiClient.getBeats(sceneId);
    const beatMap = /* @__PURE__ */ new Map();
    const beatIdMap = /* @__PURE__ */ new Map();
    for (const beat of existingBeats) {
      const fileName = this.fileManager.generateBeatFileName(beat);
      const linkName = fileName.replace(/\.md$/, "");
      beatMap.set(linkName, beat);
      beatIdMap.set(beat.id, beat);
    }
    let beatOrderNum = 1;
    for (const item of beatList.items) {
      let intent;
      let outcome = "";
      const beatMatch = item.displayText.match(/Beat\s+\d+:\s*(.+)/);
      if (beatMatch) {
        const beatText = beatMatch[1].trim();
        const parts = beatText.split(/\s*->\s*/);
        intent = parts[0].trim();
        outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
      } else {
        const parts = item.displayText.split(/\s*->\s*/);
        intent = parts[0].trim();
        outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
      }
      if (item.linkName) {
        let currentBeat = beatMap.get(item.linkName) || null;
        if (!currentBeat) {
          currentBeat = beatIdMap.get(item.linkName) || null;
        }
        if (currentBeat) {
          const needsOrderUpdate = currentBeat.order_num !== beatOrderNum;
          const needsContentUpdate = intent !== currentBeat.intent || outcome !== currentBeat.outcome;
          if (needsOrderUpdate || needsContentUpdate) {
            currentBeat = await this.apiClient.updateBeat(currentBeat.id, {
              intent,
              outcome,
              order_num: beatOrderNum
            });
          }
        }
      } else {
        await this.apiClient.createBeat({
          scene_id: sceneId,
          order_num: beatOrderNum,
          type: "setup",
          // Default type
          intent,
          outcome
        });
      }
      beatOrderNum++;
    }
  }
  // Push prose blocks from a story file with hierarchical structure
  // Format: # Story: title, ## Chapter: title, ### Scene: title, #### Beat: title
  async pushStoryContentBlocks(storyFilePath, storyFolderPath, storyId) {
    const file = this.fileManager.getVault().getAbstractFileByPath(storyFilePath);
    if (!(file instanceof import_obsidian8.TFile)) {
      throw new Error(`Story file not found: ${storyFilePath}`);
    }
    const storyContent = await this.fileManager.getVault().read(file);
    const contentsFolderPath = `${storyFolderPath}/03-contents`;
    const storyProse = parseStoryProse(storyContent);
    if (storyProse.sections.length === 0) {
      return;
    }
    const existingChapters = await this.apiClient.getChapters(storyId);
    const chapterByTitle = /* @__PURE__ */ new Map();
    for (const ch of existingChapters) {
      chapterByTitle.set(ch.title.toLowerCase(), ch);
    }
    let currentChapter = null;
    let currentScene = null;
    let currentBeat = null;
    let proseOrderNum = 1;
    const sceneMap = /* @__PURE__ */ new Map();
    const beatMap = /* @__PURE__ */ new Map();
    const remoteContentBlocksCache = /* @__PURE__ */ new Map();
    const getRemoteContentBlocksMap = async (chapterId) => {
      if (!remoteContentBlocksCache.has(chapterId)) {
        const blocks = await this.apiClient.getContentBlocks(chapterId);
        const map2 = /* @__PURE__ */ new Map();
        for (const pb of blocks) {
          map2.set(pb.id, pb);
        }
        remoteContentBlocksCache.set(chapterId, map2);
      }
      return remoteContentBlocksCache.get(chapterId);
    };
    for (const section of storyProse.sections) {
      if (section.type === "scene" && section.scene) {
        const { scene: parsedScene } = section;
        if (!currentChapter) {
          currentChapter = chapterByTitle.get("story prose") || null;
          if (!currentChapter) {
            currentChapter = await this.apiClient.createChapter(storyId, {
              number: 9999,
              title: "Story Prose",
              status: "draft"
            });
            chapterByTitle.set("story prose", currentChapter);
          }
        }
        if (parsedScene.linkName) {
          currentScene = sceneMap.get(parsedScene.linkName) || null;
        }
        if (!currentScene && parsedScene.goal) {
          const allScenes = await this.apiClient.getScenes(currentChapter.id);
          currentScene = allScenes.find((s) => s.goal === parsedScene.goal) || null;
        }
        if (!currentScene) {
          const existingScenes = await this.apiClient.getScenes(currentChapter.id);
          const sceneOrderNum = existingScenes.length > 0 ? Math.max(...existingScenes.map((s) => s.order_num)) + 1 : 1;
          currentScene = await this.apiClient.createScene({
            story_id: storyId,
            chapter_id: currentChapter.id,
            order_num: sceneOrderNum,
            goal: parsedScene.goal,
            time_ref: parsedScene.timeRef
          });
        }
        if (currentScene) {
          const sceneFileName = this.fileManager.generateSceneFileName(currentScene);
          const sceneLinkName = sceneFileName.replace(/\.md$/, "");
          sceneMap.set(sceneLinkName, currentScene);
        }
        currentBeat = null;
        proseOrderNum = 1;
      } else if (section.type === "beat" && section.beat) {
        const { beat: parsedBeat } = section;
        if (!currentScene) {
          continue;
        }
        if (parsedBeat.linkName) {
          currentBeat = beatMap.get(parsedBeat.linkName) || null;
        }
        if (!currentBeat && parsedBeat.intent) {
          const allBeats = await this.apiClient.getBeats(currentScene.id);
          currentBeat = allBeats.find((b) => b.intent === parsedBeat.intent) || null;
        }
        if (!currentBeat) {
          const existingBeats = await this.apiClient.getBeats(currentScene.id);
          const beatOrderNum = existingBeats.length > 0 ? Math.max(...existingBeats.map((b) => b.order_num)) + 1 : 1;
          currentBeat = await this.apiClient.createBeat({
            scene_id: currentScene.id,
            order_num: beatOrderNum,
            type: "setup",
            intent: parsedBeat.intent,
            outcome: parsedBeat.outcome
          });
        }
        if (currentBeat) {
          const beatFileName = this.fileManager.generateBeatFileName(currentBeat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          beatMap.set(beatLinkName, currentBeat);
        }
      } else if (section.type === "prose" && section.prose) {
        const { prose: paragraph } = section;
        if (!currentChapter) {
          currentChapter = chapterByTitle.get("story prose") || null;
          if (!currentChapter) {
            currentChapter = await this.apiClient.createChapter(storyId, {
              number: 9999,
              title: "Story Prose",
              status: "draft"
            });
            chapterByTitle.set("story prose", currentChapter);
          }
        }
        const remoteContentBlocksMap = await getRemoteContentBlocksMap(currentChapter.id);
        let localContentBlock = null;
        let remoteContentBlock = null;
        if (paragraph.linkName) {
          const contentBlockFilePath = await this.findContentBlockFileByLinkName(contentsFolderPath, paragraph.linkName);
          if (contentBlockFilePath) {
            localContentBlock = await this.fileManager.readContentBlockFromFile(contentBlockFilePath);
          }
          if (!localContentBlock) {
            localContentBlock = await this.findContentBlockByContent(contentsFolderPath, paragraph.content);
          }
          if (localContentBlock) {
            remoteContentBlock = remoteContentBlocksMap.get(localContentBlock.id) || null;
          } else {
            const normalizedContent = paragraph.content.trim();
            for (const [, remotePB] of remoteContentBlocksMap.entries()) {
              if (remotePB.content.trim() === normalizedContent) {
                remoteContentBlock = remotePB;
                break;
              }
            }
          }
        } else {
          localContentBlock = await this.findContentBlockByContent(contentsFolderPath, paragraph.content);
          const normalizedContent = paragraph.content.trim();
          for (const [, remotePB] of remoteContentBlocksMap.entries()) {
            if (remotePB.content.trim() === normalizedContent) {
              remoteContentBlock = remotePB;
              if (!localContentBlock) {
                localContentBlock = await this.findContentBlockById(contentsFolderPath, remotePB.id);
              }
              break;
            }
          }
        }
        const status = compareContentBlocks(paragraph, localContentBlock, remoteContentBlock);
        let finalContentBlock;
        switch (status) {
          case "new": {
            finalContentBlock = await this.apiClient.createContentBlock(currentChapter.id, {
              order_num: proseOrderNum++,
              kind: "final",
              content: paragraph.content
            });
            const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            if (currentScene) {
              await this.apiClient.createContentAnchor(finalContentBlock.id, "scene", currentScene.id);
            }
            if (currentBeat) {
              await this.apiClient.createContentAnchor(finalContentBlock.id, "beat", currentBeat.id);
            }
            break;
          }
          case "unchanged": {
            if (!localContentBlock && remoteContentBlock) {
              finalContentBlock = remoteContentBlock;
              const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
              await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            } else if (localContentBlock) {
              finalContentBlock = localContentBlock;
              proseOrderNum++;
            } else {
              finalContentBlock = remoteContentBlock;
              proseOrderNum++;
            }
            break;
          }
          case "local_modified": {
            finalContentBlock = await this.apiClient.updateContentBlock(localContentBlock.id, {
              content: paragraph.content,
              order_num: proseOrderNum++
            });
            const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            break;
          }
          case "remote_modified": {
            finalContentBlock = remoteContentBlock;
            const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            proseOrderNum++;
            break;
          }
          case "conflict": {
            const resolution = await this.resolveConflict(localContentBlock, remoteContentBlock);
            let resolvedContent = resolution.resolution === "local" ? paragraph.content : resolution.resolution === "remote" ? remoteContentBlock.content : resolution.mergedContent || paragraph.content;
            finalContentBlock = await this.apiClient.updateContentBlock(localContentBlock.id, {
              content: resolvedContent,
              order_num: proseOrderNum++
            });
            const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            break;
          }
        }
      }
    }
  }
  // Push prose blocks from a scene file (scene-level prose, not inside chapters)
  async pushSceneContentBlocks(sceneFilePath, storyFolderPath) {
    const file = this.fileManager.getVault().getAbstractFileByPath(sceneFilePath);
    if (!(file instanceof import_obsidian8.TFile)) {
      return;
    }
    const sceneContent = await this.fileManager.getVault().read(file);
    const frontmatter = this.fileManager.parseFrontmatter(sceneContent);
    if (!frontmatter.id || !frontmatter.story_id) {
      return;
    }
    const sceneId = frontmatter.id;
    const storyId = frontmatter.story_id;
    const contentsFolderPath = `${storyFolderPath}/03-contents`;
    const sceneProse = parseSceneProse(sceneContent);
    if (sceneProse.sections.length === 0) {
      return;
    }
    const chapters = await this.apiClient.getChapters(storyId);
    let tempChapter = chapters.find((c) => c.title === "Scene-Level Prose");
    if (!tempChapter) {
      tempChapter = await this.apiClient.createChapter(storyId, {
        number: 9998,
        // High number to keep it at the end
        title: "Scene-Level Prose",
        status: "draft"
      });
    }
    const remoteContentBlocks = await this.apiClient.getContentBlocks(tempChapter.id);
    const remoteContentBlocksMap = /* @__PURE__ */ new Map();
    for (const pb of remoteContentBlocks) {
      remoteContentBlocksMap.set(pb.id, pb);
    }
    const existingBeats = await this.apiClient.getBeats(sceneId);
    const beatMap = /* @__PURE__ */ new Map();
    const beatIdMap = /* @__PURE__ */ new Map();
    for (const beat of existingBeats) {
      const fileName = this.fileManager.generateBeatFileName(beat);
      const linkName = fileName.replace(/\.md$/, "");
      beatMap.set(linkName, beat);
      beatIdMap.set(beat.id, beat);
    }
    let proseOrderNum = 1;
    let currentBeat = null;
    const updatedSections = [];
    for (const section of sceneProse.sections) {
      if (section.type === "beat" && section.beat) {
        const { beat: parsedBeat } = section;
        if (parsedBeat.linkName) {
          currentBeat = beatMap.get(parsedBeat.linkName) || null;
          if (!currentBeat) {
            currentBeat = beatIdMap.get(parsedBeat.linkName) || null;
          }
        }
        if (currentBeat) {
          const beatFileName = this.fileManager.generateBeatFileName(currentBeat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          const beatDisplayText = currentBeat.outcome ? `${currentBeat.intent} -> ${currentBeat.outcome}` : currentBeat.intent;
          updatedSections.push(`### Beat: [[${beatLinkName}|${beatDisplayText}]]`);
        }
      } else if (section.type === "prose" && section.prose) {
        const { prose: paragraph } = section;
        let localContentBlock = null;
        let remoteContentBlock = null;
        if (paragraph.linkName) {
          const contentBlockFilePath = await this.findContentBlockFileByLinkName(contentsFolderPath, paragraph.linkName);
          if (contentBlockFilePath) {
            localContentBlock = await this.fileManager.readContentBlockFromFile(contentBlockFilePath);
          }
          if (!localContentBlock) {
            localContentBlock = await this.findContentBlockByContent(contentsFolderPath, paragraph.content);
          }
          if (localContentBlock) {
            remoteContentBlock = remoteContentBlocksMap.get(localContentBlock.id) || null;
          } else {
            const normalizedContent = paragraph.content.trim();
            for (const [id2, remotePB] of remoteContentBlocksMap.entries()) {
              if (remotePB.content.trim() === normalizedContent) {
                remoteContentBlock = remotePB;
                break;
              }
            }
          }
        } else {
          localContentBlock = await this.findContentBlockByContent(contentsFolderPath, paragraph.content);
          const normalizedContent = paragraph.content.trim();
          for (const [id2, remotePB] of remoteContentBlocksMap.entries()) {
            if (remotePB.content.trim() === normalizedContent) {
              remoteContentBlock = remotePB;
              if (!localContentBlock) {
                localContentBlock = await this.findContentBlockById(contentsFolderPath, remotePB.id);
              }
              break;
            }
          }
        }
        const status = compareContentBlocks(paragraph, localContentBlock, remoteContentBlock);
        let finalContentBlock;
        switch (status) {
          case "new": {
            finalContentBlock = await this.apiClient.createContentBlock(tempChapter.id, {
              order_num: proseOrderNum++,
              kind: "final",
              content: paragraph.content
            });
            const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            await this.apiClient.createContentAnchor(finalContentBlock.id, "scene", sceneId);
            if (currentBeat) {
              await this.apiClient.createContentAnchor(finalContentBlock.id, "beat", currentBeat.id);
            }
            const linkName = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
            break;
          }
          case "unchanged": {
            if (!localContentBlock && remoteContentBlock) {
              finalContentBlock = remoteContentBlock;
              const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
              await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            } else if (localContentBlock) {
              if (localContentBlock.order_num !== proseOrderNum) {
                finalContentBlock = await this.apiClient.updateContentBlock(localContentBlock.id, {
                  order_num: proseOrderNum++
                });
                const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
                await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
              } else {
                finalContentBlock = localContentBlock;
                proseOrderNum++;
              }
            } else {
              finalContentBlock = remoteContentBlock;
              proseOrderNum++;
            }
            if (paragraph.linkName) {
              updatedSections.push(`[[${paragraph.linkName}|${paragraph.content}]]`);
            } else {
              const linkName = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
              updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
            }
            break;
          }
          case "local_modified": {
            finalContentBlock = await this.apiClient.updateContentBlock(localContentBlock.id, {
              content: paragraph.content,
              order_num: proseOrderNum++
            });
            const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            const linkName = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
            break;
          }
          case "remote_modified": {
            finalContentBlock = remoteContentBlock;
            const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            const linkName = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${finalContentBlock.content}]]`);
            new import_obsidian8.Notice(`Scene prose block updated from remote: ${linkName}`, 3e3);
            proseOrderNum++;
            break;
          }
          case "conflict": {
            const resolution = await this.resolveConflict(localContentBlock, remoteContentBlock);
            let resolvedContent;
            if (resolution.resolution === "local") {
              resolvedContent = paragraph.content;
            } else if (resolution.resolution === "remote") {
              resolvedContent = remoteContentBlock.content;
            } else {
              resolvedContent = resolution.mergedContent || paragraph.content;
            }
            finalContentBlock = await this.apiClient.updateContentBlock(localContentBlock.id, {
              content: resolvedContent,
              order_num: proseOrderNum++
            });
            const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            const linkName = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${resolvedContent}]]`);
            break;
          }
        }
      }
    }
    if (updatedSections.length > 0) {
      const frontmatterMatch = sceneContent.match(/^---\n([\s\S]*?)\n---/);
      const frontmatterEnd = frontmatterMatch ? frontmatterMatch[0].length : 0;
      const afterFrontmatter = sceneContent.substring(frontmatterEnd).trim();
      const beatsSectionMatch = afterFrontmatter.match(/\n##\s+Beats\s*\n/);
      const insertionPoint = beatsSectionMatch ? frontmatterEnd + afterFrontmatter.indexOf(beatsSectionMatch[0]) : sceneContent.length;
      const beforeProse = sceneContent.substring(0, insertionPoint).trimEnd();
      const afterProse = sceneContent.substring(insertionPoint);
      const updatedContent = `${beforeProse}

${updatedSections.join("\n\n")}
${afterProse}`;
      await this.fileManager.getVault().modify(file, updatedContent);
    }
  }
  // Push prose blocks from a beat file
  async pushBeatContentBlocks(beatFilePath, storyFolderPath) {
    const file = this.fileManager.getVault().getAbstractFileByPath(beatFilePath);
    if (!(file instanceof import_obsidian8.TFile)) {
      return;
    }
    const beatContent = await this.fileManager.getVault().read(file);
    const frontmatter = this.fileManager.parseFrontmatter(beatContent);
    if (!frontmatter.id || !frontmatter.scene_id) {
      return;
    }
    const beatId = frontmatter.id;
    const sceneId = frontmatter.scene_id;
    const contentsFolderPath = `${storyFolderPath}/03-contents`;
    const beatProse = parseBeatProse(beatContent);
    if (beatProse.sections.length === 0) {
      return;
    }
    const scene = await this.apiClient.getScene(sceneId);
    if (!scene) {
      return;
    }
    const storyId = scene.story_id;
    const chapters = await this.apiClient.getChapters(storyId);
    let tempChapter = chapters.find((c) => c.title === "Beat-Level Prose");
    if (!tempChapter) {
      tempChapter = await this.apiClient.createChapter(storyId, {
        number: 9997,
        // High number to keep it at the end
        title: "Beat-Level Prose",
        status: "draft"
      });
    }
    const remoteContentBlocks = await this.apiClient.getContentBlocks(tempChapter.id);
    const remoteContentBlocksMap = /* @__PURE__ */ new Map();
    for (const pb of remoteContentBlocks) {
      remoteContentBlocksMap.set(pb.id, pb);
    }
    let proseOrderNum = 1;
    const updatedSections = [];
    const beat = await this.apiClient.getBeat(beatId);
    if (beat) {
      const beatFileName = this.fileManager.generateBeatFileName(beat);
      const beatLinkName = beatFileName.replace(/\.md$/, "");
      const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
      updatedSections.push(`## Beat: [[${beatLinkName}|${beatDisplayText}]]`);
    }
    for (const section of beatProse.sections) {
      if (section.type === "prose" && section.prose) {
        const { prose: paragraph } = section;
        let localContentBlock = null;
        let remoteContentBlock = null;
        if (paragraph.linkName) {
          const contentBlockFilePath = await this.findContentBlockFileByLinkName(contentsFolderPath, paragraph.linkName);
          if (contentBlockFilePath) {
            localContentBlock = await this.fileManager.readContentBlockFromFile(contentBlockFilePath);
          }
          if (!localContentBlock) {
            localContentBlock = await this.findContentBlockByContent(contentsFolderPath, paragraph.content);
          }
          if (localContentBlock) {
            remoteContentBlock = remoteContentBlocksMap.get(localContentBlock.id) || null;
          } else {
            const normalizedContent = paragraph.content.trim();
            for (const [, remotePB] of remoteContentBlocksMap.entries()) {
              if (remotePB.content.trim() === normalizedContent) {
                remoteContentBlock = remotePB;
                break;
              }
            }
          }
        } else {
          localContentBlock = await this.findContentBlockByContent(contentsFolderPath, paragraph.content);
          const normalizedContent = paragraph.content.trim();
          for (const [, remotePB] of remoteContentBlocksMap.entries()) {
            if (remotePB.content.trim() === normalizedContent) {
              remoteContentBlock = remotePB;
              if (!localContentBlock) {
                localContentBlock = await this.findContentBlockById(contentsFolderPath, remotePB.id);
              }
              break;
            }
          }
        }
        const status = compareContentBlocks(paragraph, localContentBlock, remoteContentBlock);
        let finalContentBlock;
        switch (status) {
          case "new": {
            finalContentBlock = await this.apiClient.createContentBlock(tempChapter.id, {
              order_num: proseOrderNum++,
              kind: "final",
              content: paragraph.content
            });
            const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            await this.apiClient.createContentAnchor(finalContentBlock.id, "scene", sceneId);
            await this.apiClient.createContentAnchor(finalContentBlock.id, "beat", beatId);
            const linkName = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
            break;
          }
          case "unchanged": {
            if (!localContentBlock && remoteContentBlock) {
              finalContentBlock = remoteContentBlock;
              const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
              await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
              const linkName = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
              updatedSections.push(`[[${linkName}|${remoteContentBlock.content}]]`);
            } else if (localContentBlock) {
              finalContentBlock = localContentBlock;
              const linkName = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
              updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
              proseOrderNum++;
            } else {
              proseOrderNum++;
              continue;
            }
            break;
          }
          case "local_modified": {
            finalContentBlock = await this.apiClient.updateContentBlock(localContentBlock.id, {
              content: paragraph.content,
              order_num: proseOrderNum++
            });
            const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            const linkName = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
            break;
          }
          case "remote_modified": {
            finalContentBlock = remoteContentBlock;
            const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            proseOrderNum++;
            const linkName = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${remoteContentBlock.content}]]`);
            break;
          }
          case "conflict": {
            const resolution = await this.resolveConflict(localContentBlock, remoteContentBlock);
            let resolvedContent;
            if (resolution.resolution === "local") {
              resolvedContent = paragraph.content;
            } else if (resolution.resolution === "remote") {
              resolvedContent = remoteContentBlock.content;
            } else {
              resolvedContent = resolution.mergedContent || paragraph.content;
            }
            finalContentBlock = await this.apiClient.updateContentBlock(localContentBlock.id, {
              content: resolvedContent,
              order_num: proseOrderNum++
            });
            const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            const linkName = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${resolvedContent}]]`);
            break;
          }
        }
      }
    }
    if (updatedSections.length > 1) {
      const frontmatterMatch = beatContent.match(/^---\n([\s\S]*?)\n---/);
      const frontmatterEnd = frontmatterMatch ? frontmatterMatch[0].length : 0;
      const afterFrontmatter = beatContent.substring(frontmatterEnd).trim();
      const beatSectionMatch = afterFrontmatter.match(/##\s+Beat:\s*.+[\s\S]*/);
      if (beatSectionMatch) {
        const beforeBeatSection = beatContent.substring(0, frontmatterEnd + afterFrontmatter.indexOf(beatSectionMatch[0]));
        const updatedContent = `${beforeBeatSection.trimEnd()}

${updatedSections.join("\n\n")}
`;
        await this.fileManager.getVault().modify(file, updatedContent);
      } else {
        const updatedContent = `${beatContent.trimEnd()}

${updatedSections.join("\n\n")}
`;
        await this.fileManager.getVault().modify(file, updatedContent);
      }
    }
  }
  // Process the "## Orphan Scenes" list and update orphan scenes order
  async processOrphanScenesList(list, storyId) {
    const allScenes = await this.apiClient.getScenesByStory(storyId);
    const sceneMap = /* @__PURE__ */ new Map();
    const sceneIdMap = /* @__PURE__ */ new Map();
    const orphanScenes = allScenes.filter((s) => !s.chapter_id);
    for (const scene of orphanScenes) {
      const fileName = this.fileManager.generateSceneFileName(scene);
      const linkName = fileName.replace(/\.md$/, "");
      sceneMap.set(linkName, scene);
      sceneIdMap.set(scene.id, scene);
    }
    const beatMap = /* @__PURE__ */ new Map();
    const beatIdMap = /* @__PURE__ */ new Map();
    for (const scene of orphanScenes) {
      const beats = await this.apiClient.getBeats(scene.id);
      for (const beat of beats) {
        const fileName = this.fileManager.generateBeatFileName(beat);
        const linkName = fileName.replace(/\.md$/, "");
        beatMap.set(linkName, beat);
        beatIdMap.set(beat.id, beat);
      }
    }
    let currentScene = null;
    let sceneOrderNum = 1;
    const beatOrderNums = /* @__PURE__ */ new Map();
    for (const item of list.items) {
      if (item.type === "scene") {
        let goal;
        let timeRef = "";
        const sceneMatch = item.displayText.match(/Scene\s+\d+:\s*(.+)/);
        if (sceneMatch) {
          const sceneText = sceneMatch[1].trim();
          const parts = sceneText.split(/\s*-\s*/);
          goal = parts[0].trim();
          timeRef = parts.length > 1 ? parts.slice(1).join(" - ").trim() : "";
        } else {
          const parts = item.displayText.split(/\s*-\s*/);
          goal = parts[0].trim();
          timeRef = parts.length > 1 ? parts.slice(1).join(" - ").trim() : "";
        }
        if (item.linkName) {
          currentScene = sceneMap.get(item.linkName) || null;
          if (!currentScene) {
            currentScene = sceneIdMap.get(item.linkName) || null;
          }
          if (currentScene) {
            const needsOrderUpdate = currentScene.order_num !== sceneOrderNum;
            const needsContentUpdate = goal !== currentScene.goal || timeRef !== currentScene.time_ref;
            if (needsOrderUpdate || needsContentUpdate) {
              currentScene = await this.apiClient.updateScene(currentScene.id, {
                goal,
                time_ref: timeRef,
                order_num: sceneOrderNum
              });
            }
            const existingBeats = await this.apiClient.getBeats(currentScene.id);
            if (existingBeats.length === 0) {
              beatOrderNums.set(currentScene.id, 1);
            } else {
              const maxOrderNum = Math.max(...existingBeats.map((b) => b.order_num));
              beatOrderNums.set(currentScene.id, maxOrderNum + 1);
            }
          }
        } else {
          currentScene = await this.apiClient.createScene({
            story_id: storyId,
            chapter_id: null,
            // Orphan scene
            order_num: sceneOrderNum,
            goal,
            time_ref: timeRef
          });
          const sceneFileName = this.fileManager.generateSceneFileName(currentScene);
          const sceneLinkName = sceneFileName.replace(/\.md$/, "");
          sceneMap.set(sceneLinkName, currentScene);
          sceneIdMap.set(currentScene.id, currentScene);
          beatOrderNums.set(currentScene.id, 1);
        }
        sceneOrderNum++;
      } else if (item.type === "beat" && currentScene) {
        let intent;
        let outcome = "";
        const beatMatch = item.displayText.match(/Beat\s+\d+:\s*(.+)/);
        if (beatMatch) {
          const beatText = beatMatch[1].trim();
          const parts = beatText.split(/\s*->\s*/);
          intent = parts[0].trim();
          outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
        } else {
          const parts = item.displayText.split(/\s*->\s*/);
          intent = parts[0].trim();
          outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
        }
        const currentBeatOrderNum = beatOrderNums.get(currentScene.id) || 1;
        if (item.linkName) {
          let currentBeat = beatMap.get(item.linkName) || null;
          if (!currentBeat) {
            currentBeat = beatIdMap.get(item.linkName) || null;
          }
          if (currentBeat) {
            const needsOrderUpdate = currentBeat.order_num !== currentBeatOrderNum;
            const needsContentUpdate = intent !== currentBeat.intent || outcome !== currentBeat.outcome;
            const needsSceneUpdate = currentBeat.scene_id !== currentScene.id;
            if (needsOrderUpdate || needsContentUpdate || needsSceneUpdate) {
              currentBeat = await this.apiClient.updateBeat(currentBeat.id, {
                intent,
                outcome,
                order_num: currentBeatOrderNum,
                scene_id: currentScene.id
              });
            }
          }
        } else {
          await this.apiClient.createBeat({
            scene_id: currentScene.id,
            order_num: currentBeatOrderNum,
            type: "setup",
            // Default type
            intent,
            outcome
          });
        }
        beatOrderNums.set(currentScene.id, currentBeatOrderNum + 1);
      }
    }
  }
  // Process the "## Orphan Beats" list and update orphan beats order
  async processOrphanBeatsList(list, storyId) {
    const allBeats = await this.apiClient.getBeatsByStory(storyId);
    const allScenes = await this.apiClient.getScenesByStory(storyId);
    const sceneIdSet = new Set(allScenes.map((s) => s.id));
    const orphanBeats = allBeats.filter((b) => !b.scene_id || !sceneIdSet.has(b.scene_id));
    const beatMap = /* @__PURE__ */ new Map();
    const beatIdMap = /* @__PURE__ */ new Map();
    for (const beat of orphanBeats) {
      const fileName = this.fileManager.generateBeatFileName(beat);
      const linkName = fileName.replace(/\.md$/, "");
      beatMap.set(linkName, beat);
      beatIdMap.set(beat.id, beat);
    }
    let beatOrderNum = 1;
    for (const item of list.items) {
      let intent;
      let outcome = "";
      const beatMatch = item.displayText.match(/Beat\s+\d+:\s*(.+)/);
      if (beatMatch) {
        const beatText = beatMatch[1].trim();
        const parts = beatText.split(/\s*->\s*/);
        intent = parts[0].trim();
        outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
      } else {
        const parts = item.displayText.split(/\s*->\s*/);
        intent = parts[0].trim();
        outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
      }
      if (item.linkName) {
        let currentBeat = beatMap.get(item.linkName) || null;
        if (!currentBeat) {
          currentBeat = beatIdMap.get(item.linkName) || null;
        }
        if (currentBeat) {
          const needsOrderUpdate = currentBeat.order_num !== beatOrderNum;
          const needsContentUpdate = intent !== currentBeat.intent || outcome !== currentBeat.outcome;
          if (needsOrderUpdate || needsContentUpdate) {
            currentBeat = await this.apiClient.updateBeat(currentBeat.id, {
              intent,
              outcome,
              order_num: beatOrderNum
              // Keep scene_id as null or invalid (orphan) - don't update it
            });
          }
        }
      } else {
        const allScenes2 = await this.apiClient.getScenesByStory(storyId);
        let orphanBeatScene = allScenes2.find((s) => !s.chapter_id && s.goal.startsWith("Orphan Beats Container"));
        if (!orphanBeatScene) {
          orphanBeatScene = await this.apiClient.createScene({
            story_id: storyId,
            chapter_id: null,
            order_num: 9999,
            // High number to keep it at the end
            goal: "Orphan Beats Container",
            time_ref: ""
          });
        }
        await this.apiClient.createBeat({
          scene_id: orphanBeatScene.id,
          order_num: beatOrderNum,
          type: "setup",
          // Default type
          intent,
          outcome
        });
      }
      beatOrderNum++;
    }
  }
  // Process the "## Scenes & Beats" list and create/update/delete scenes and beats
  async processSceneBeatList(list, chapterId, storyId) {
    const existingScenes = await this.apiClient.getScenes(chapterId);
    const sceneMap = /* @__PURE__ */ new Map();
    const sceneIdMap = /* @__PURE__ */ new Map();
    for (const scene of existingScenes) {
      const fileName = this.fileManager.generateSceneFileName(scene);
      const linkName = fileName.replace(/\.md$/, "");
      sceneMap.set(linkName, scene);
      sceneIdMap.set(scene.id, scene);
    }
    const beatMap = /* @__PURE__ */ new Map();
    const beatIdMap = /* @__PURE__ */ new Map();
    for (const scene of existingScenes) {
      const beats = await this.apiClient.getBeats(scene.id);
      for (const beat of beats) {
        const fileName = this.fileManager.generateBeatFileName(beat);
        const linkName = fileName.replace(/\.md$/, "");
        beatMap.set(linkName, beat);
        beatIdMap.set(beat.id, beat);
      }
    }
    let currentScene = null;
    let sceneOrderNum = 1;
    const beatOrderNums = /* @__PURE__ */ new Map();
    for (const item of list.items) {
      if (item.type === "scene") {
        currentScene = null;
        let goal;
        let timeRef = "";
        const sceneMatch = item.displayText.match(/Scene\s+\d+:\s*(.+)/);
        if (sceneMatch) {
          const sceneText = sceneMatch[1].trim();
          const parts = sceneText.split(/\s*-\s*/);
          goal = parts[0].trim();
          timeRef = parts.length > 1 ? parts.slice(1).join(" - ").trim() : "";
        } else {
          const parts = item.displayText.split(/\s*-\s*/);
          goal = parts[0].trim();
          timeRef = parts.length > 1 ? parts.slice(1).join(" - ").trim() : "";
        }
        currentScene = null;
        if (item.linkName) {
          currentScene = sceneMap.get(item.linkName) || null;
          if (!currentScene) {
            currentScene = sceneIdMap.get(item.linkName) || null;
          }
          if (currentScene) {
            const needsOrderUpdate = currentScene.order_num !== sceneOrderNum;
            const needsContentUpdate = goal !== currentScene.goal || timeRef !== currentScene.time_ref;
            if (needsOrderUpdate || needsContentUpdate) {
              currentScene = await this.apiClient.updateScene(currentScene.id, {
                goal,
                time_ref: timeRef,
                order_num: sceneOrderNum
              });
            }
            const existingBeats = await this.apiClient.getBeats(currentScene.id);
            if (existingBeats.length === 0) {
              beatOrderNums.set(currentScene.id, 1);
            } else {
              const maxOrderNum = Math.max(...existingBeats.map((b) => b.order_num));
              beatOrderNums.set(currentScene.id, maxOrderNum + 1);
            }
          }
        } else {
          currentScene = await this.apiClient.createScene({
            story_id: storyId,
            chapter_id: chapterId,
            order_num: sceneOrderNum,
            goal,
            time_ref: timeRef
          });
          const sceneFileName = this.fileManager.generateSceneFileName(currentScene);
          const sceneLinkName = sceneFileName.replace(/\.md$/, "");
          sceneMap.set(sceneLinkName, currentScene);
          sceneIdMap.set(currentScene.id, currentScene);
          beatOrderNums.set(currentScene.id, 1);
        }
        sceneOrderNum++;
      } else if (item.type === "beat" && currentScene) {
        let intent;
        let outcome = "";
        const beatMatch = item.displayText.match(/Beat\s+\d+:\s*(.+)/);
        if (beatMatch) {
          const beatText = beatMatch[1].trim();
          const parts = beatText.split(/\s*->\s*/);
          intent = parts[0].trim();
          outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
        } else {
          const parts = item.displayText.split(/\s*->\s*/);
          intent = parts[0].trim();
          outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
        }
        const currentBeatOrderNum = beatOrderNums.get(currentScene.id) || 1;
        if (item.linkName) {
          let currentBeat = beatMap.get(item.linkName) || null;
          if (!currentBeat) {
            currentBeat = beatIdMap.get(item.linkName) || null;
          }
          if (currentBeat) {
            const needsOrderUpdate = currentBeat.order_num !== currentBeatOrderNum;
            const needsContentUpdate = intent !== currentBeat.intent || outcome !== currentBeat.outcome;
            const needsSceneUpdate = currentBeat.scene_id !== currentScene.id;
            if (needsOrderUpdate || needsContentUpdate || needsSceneUpdate) {
              currentBeat = await this.apiClient.updateBeat(currentBeat.id, {
                intent,
                outcome,
                order_num: currentBeatOrderNum,
                scene_id: currentScene.id
              });
              if (needsSceneUpdate) {
                const beatFileName = this.fileManager.generateBeatFileName(currentBeat);
                const beatLinkName = beatFileName.replace(/\.md$/, "");
                beatMap.set(beatLinkName, currentBeat);
                beatIdMap.set(currentBeat.id, currentBeat);
              }
            }
          }
        } else {
          const newBeat = await this.apiClient.createBeat({
            scene_id: currentScene.id,
            order_num: currentBeatOrderNum,
            type: "setup",
            // Default type
            intent,
            outcome
          });
          const beatFileName = this.fileManager.generateBeatFileName(newBeat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          beatMap.set(beatLinkName, newBeat);
          beatIdMap.set(newBeat.id, newBeat);
        }
        beatOrderNums.set(currentScene.id, currentBeatOrderNum + 1);
      }
    }
  }
  // Find content block file by link name (searches recursively in all type subfolders)
  async findContentBlockFileByLinkName(contentsRoot, linkName) {
    const root2 = this.fileManager.getVault().getAbstractFileByPath(contentsRoot);
    if (!(root2 instanceof import_obsidian8.TFolder))
      return null;
    const target = `${linkName}.md`;
    const stack = [root2];
    while (stack.length) {
      const folder = stack.pop();
      for (const child of folder.children) {
        if (child instanceof import_obsidian8.TFolder) {
          stack.push(child);
        } else if (child instanceof import_obsidian8.TFile && child.name === target) {
          return child.path;
        }
      }
    }
    return null;
  }
  // Find prose block by content when file name doesn't match (searches recursively in all type subfolders)
  async findContentBlockByContent(contentsFolderPath, content) {
    try {
      const folder = this.fileManager.getVault().getAbstractFileByPath(contentsFolderPath);
      if (!(folder instanceof import_obsidian8.TFolder)) {
        return null;
      }
      const normalizedContent = content.trim();
      const stack = [folder];
      while (stack.length) {
        const currentFolder = stack.pop();
        for (const child of currentFolder.children) {
          if (child instanceof import_obsidian8.TFolder) {
            stack.push(child);
          } else if (child instanceof import_obsidian8.TFile && child.extension === "md") {
            const contentBlock = await this.fileManager.readContentBlockFromFile(child.path);
            if (contentBlock && contentBlock.content.trim() === normalizedContent) {
              return contentBlock;
            }
          }
        }
      }
    } catch (err) {
      console.error("Error searching for prose block by content:", err);
    }
    return null;
  }
  // Find prose block by ID when we have remote ID but need local file (searches recursively in all type subfolders)
  async findContentBlockById(contentsFolderPath, id2) {
    try {
      const folder = this.fileManager.getVault().getAbstractFileByPath(contentsFolderPath);
      if (!(folder instanceof import_obsidian8.TFolder)) {
        return null;
      }
      const stack = [folder];
      while (stack.length) {
        const currentFolder = stack.pop();
        for (const child of currentFolder.children) {
          if (child instanceof import_obsidian8.TFolder) {
            stack.push(child);
          } else if (child instanceof import_obsidian8.TFile && child.extension === "md") {
            const contentBlock = await this.fileManager.readContentBlockFromFile(child.path);
            if (contentBlock && contentBlock.id === id2) {
              return contentBlock;
            }
          }
        }
      }
    } catch (err) {
      console.error("Error searching for prose block by ID:", err);
    }
    return null;
  }
  // Get the correct file path for a content block (always uses type subfolders)
  getContentBlockFilePath(storyFolderPath, contentBlock) {
    const fileName = this.fileManager.generateContentBlockFileName(contentBlock);
    const typeFolderPath = this.fileManager.getContentBlockFolderPath(storyFolderPath, contentBlock.type || "text");
    return `${typeFolderPath}/${fileName}`;
  }
  // Get content block file path from contents folder path (03-contents)
  async getContentBlockFilePathFromContents(contentsFolderPath, contentBlock) {
    const typeFolder = this.fileManager.getContentTypeFolder(contentBlock.type || "text");
    const typeFolderPath = `${contentsFolderPath}/${typeFolder}`;
    await this.fileManager.ensureFolderExists(typeFolderPath);
    const fileName = this.fileManager.generateContentBlockFileName(contentBlock);
    return `${typeFolderPath}/${fileName}`;
  }
  // Resolve conflict using modal or auto-resolve based on mode
  async resolveConflict(localContentBlock, remoteContentBlock) {
    if (this.settings.mode === "local") {
      return { resolution: "local" };
    }
    return new Promise((resolve) => {
      const modal = new ConflictModal(
        this.app,
        localContentBlock,
        remoteContentBlock,
        async (result) => {
          resolve(result);
        }
      );
      modal.open();
    });
  }
  // Update the Chapter section in chapter file (hierarchical structure)
  async updateChapterProseSectionHierarchical(originalContent, updatedSections, file, frontmatter) {
    const frontmatterMatch = originalContent.match(/^---\n([\s\S]*?)\n---/);
    const frontmatterText = frontmatterMatch ? frontmatterMatch[0] : "";
    const bodyStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
    const bodyContent = originalContent.substring(bodyStart).trim();
    const chapterNumber = frontmatter.number || "1";
    const chapterTitle = frontmatter.title || "Untitled";
    const chapterHeaderPattern = `##\\s+Chapter\\s+${chapterNumber}:\\s+[^\\n]+`;
    const chapterSectionMatch = bodyContent.match(new RegExp(`([\\s\\S]*?${chapterHeaderPattern}\\s*\\n+)([\\s\\S]*?)(?=\\n##\\s+Chapter\\s+\\d+:|$)`, "i"));
    if (!chapterSectionMatch) {
      const newChapterSection = `

## Chapter ${chapterNumber}: ${chapterTitle}

${updatedSections.join("\n\n")}

`;
      const updatedContent2 = `${frontmatterText}
${bodyContent}${newChapterSection}`;
      await this.fileManager.getVault().modify(file, updatedContent2);
      return;
    }
    const beforeChapter = chapterSectionMatch[1];
    const afterChapter = bodyContent.substring(chapterSectionMatch.index + chapterSectionMatch[0].length);
    const newChapterContent = updatedSections.join("\n\n");
    const updatedBody = `${beforeChapter}${newChapterContent}

${afterChapter}`;
    const updatedContent = `${frontmatterText}
${updatedBody}`;
    await this.fileManager.getVault().modify(file, updatedContent);
  }
  // Update the Prose section in chapter file
  async updateChapterProseSection(originalContent, updatedParagraphs, file) {
    const frontmatterMatch = originalContent.match(/^---\n([\s\S]*?)\n---/);
    const frontmatter = frontmatterMatch ? frontmatterMatch[0] : "";
    const bodyStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
    const bodyContent = originalContent.substring(bodyStart).trim();
    const proseSectionMatch = bodyContent.match(/([\s\S]*?##\s+Prose\s*\n\n)([\s\S]*?)(?=\n##|\n*$)/);
    if (!proseSectionMatch) {
      const newProseSection = `

## Prose

${updatedParagraphs.join("\n\n")}

`;
      const updatedContent2 = `${frontmatter}
${bodyContent}${newProseSection}`;
      await this.fileManager.getVault().modify(file, updatedContent2);
      return;
    }
    const beforeProse = proseSectionMatch[1];
    const newProseContent = updatedParagraphs.join("\n\n");
    const afterProse = bodyContent.substring(proseSectionMatch.index + proseSectionMatch[0].length);
    const updatedBody = `${beforeProse}${newProseContent}

${afterProse}`;
    const updatedContent = `${frontmatter}
${updatedBody}`;
    await this.fileManager.getVault().modify(file, updatedContent);
  }
  async writeChapterBundle(data) {
    const folderPath = this.fileManager.getStoryFolderPath(data.story.title);
    await this.ensureStoryFolders(folderPath);
    for (const contentBlock of data.contentBlocks) {
      await this.writeContentBlockToFolder(folderPath, data.story.title, contentBlock);
    }
    const chaptersFolderPath = `${folderPath}/00-chapters`;
    const chapterFileName = `Chapter-${data.chapter.number}.md`;
    const chapterFilePath = `${chaptersFolderPath}/${chapterFileName}`;
    await this.fileManager.writeChapterFile(
      { chapter: data.chapter, scenes: data.scenes },
      chapterFilePath,
      data.story.title,
      data.contentBlocks,
      data.contentBlockRefs,
      []
    );
    const { byScene, byBeat } = this.buildContentBlockAssociationMaps(
      data.contentBlocks,
      data.contentBlockRefs
    );
    await this.syncScenesToFilesystem(
      data.scenes,
      folderPath,
      data.story.title,
      byScene,
      byBeat
    );
  }
  async writeSceneBundle(data) {
    var _a, _b;
    await this.fileManager.ensureFolderExists(`${data.folderPath}/01-scenes`);
    await this.fileManager.ensureFolderExists(`${data.folderPath}/02-beats`);
    const sceneContentBlocks = (_a = data.sceneContentBlocks) != null ? _a : data.skipRemoteContentFetch ? [] : await this.apiClient.getContentBlocksByScene(data.scene.id);
    const sceneFileName = this.fileManager.generateSceneFileName(data.scene);
    const sceneFilePath = `${data.folderPath}/01-scenes/${sceneFileName}`;
    await this.fileManager.writeSceneFile(
      { scene: data.scene, beats: data.beats },
      sceneFilePath,
      data.storyTitle,
      sceneContentBlocks,
      []
    );
    for (const beat of data.beats) {
      const provided = (_b = data.beatContentBlockMap) == null ? void 0 : _b.get(beat.id);
      const beatContentBlocks = provided != null ? provided : data.skipRemoteContentFetch ? [] : await this.apiClient.getContentBlocksByBeat(beat.id);
      const beatFileName = this.fileManager.generateBeatFileName(beat);
      const beatFilePath = `${data.folderPath}/02-beats/${beatFileName}`;
      await this.fileManager.writeBeatFile(
        beat,
        beatFilePath,
        data.storyTitle,
        beatContentBlocks
      );
    }
  }
  buildContentBlockAssociationMaps(contentBlocks, contentBlockRefs) {
    const byScene = /* @__PURE__ */ new Map();
    const byBeat = /* @__PURE__ */ new Map();
    const blockById = new Map(contentBlocks.map((block) => [block.id, block]));
    for (const ref of contentBlockRefs) {
      const block = blockById.get(ref.content_block_id);
      if (!block) {
        continue;
      }
      if (ref.entity_type === "scene") {
        if (!byScene.has(ref.entity_id)) {
          byScene.set(ref.entity_id, []);
        }
        byScene.get(ref.entity_id).push(block);
      } else if (ref.entity_type === "beat") {
        if (!byBeat.has(ref.entity_id)) {
          byBeat.set(ref.entity_id, []);
        }
        byBeat.get(ref.entity_id).push(block);
      }
    }
    return { byScene, byBeat };
  }
  async pullSingleEntity(storyId, target) {
    switch (target.type) {
      case "chapter":
        await this.pullChapterEntity(storyId, target.id);
        break;
      case "scene":
        await this.pullSceneEntity(storyId, target.id);
        break;
      case "content":
        await this.pullContentBlockEntity(storyId, target.id);
        break;
      default:
        throw new Error(`Unsupported entity type: ${target.type}`);
    }
  }
  async pullChapterEntity(storyId, chapterId) {
    const story = await this.apiClient.getStory(storyId);
    const chapter = await this.apiClient.getChapter(chapterId);
    if (chapter.story_id !== storyId) {
      throw new Error("Chapter does not belong to the selected story");
    }
    const scenes = await this.apiClient.getScenes(chapterId);
    const scenesWithBeats = await Promise.all(
      scenes.map(async (scene) => {
        const beats = await this.apiClient.getBeats(scene.id);
        return { scene, beats };
      })
    );
    const contentBlocks = await this.apiClient.getContentBlocks(chapterId);
    const contentBlockRefs = [];
    for (const contentBlock of contentBlocks) {
      const refs = await this.apiClient.getContentAnchors(contentBlock.id);
      contentBlockRefs.push(...refs);
    }
    await this.writeChapterBundle({
      story,
      chapter,
      scenes: scenesWithBeats,
      contentBlocks,
      contentBlockRefs
    });
    new import_obsidian8.Notice(`Chapter "${chapter.title}" synced successfully`);
  }
  async pullSceneEntity(storyId, sceneId) {
    const scene = await this.apiClient.getScene(sceneId);
    if (scene.story_id !== storyId) {
      throw new Error("Scene does not belong to the selected story");
    }
    const story = await this.apiClient.getStory(storyId);
    const folderPath = this.fileManager.getStoryFolderPath(story.title);
    await this.ensureStoryFolders(folderPath);
    const beats = await this.apiClient.getBeats(scene.id);
    const sceneContentBlocks = await this.apiClient.getContentBlocksByScene(scene.id);
    const beatContentBlockMap = /* @__PURE__ */ new Map();
    for (const beat of beats) {
      const beatContentBlocks = await this.apiClient.getContentBlocksByBeat(beat.id);
      beatContentBlockMap.set(beat.id, beatContentBlocks);
    }
    await this.writeSceneBundle({
      storyTitle: story.title,
      folderPath,
      scene,
      beats,
      sceneContentBlocks,
      beatContentBlockMap
    });
    await this.syncSceneContentBlocks(scene, beats, folderPath, story.title);
    new import_obsidian8.Notice(`Scene "${scene.goal}" synced successfully`);
  }
  async pullContentBlockEntity(storyId, contentBlockId) {
    const story = await this.apiClient.getStory(storyId);
    const contentBlock = await this.apiClient.getContentBlock(contentBlockId);
    if (contentBlock.chapter_id) {
      const chapter = await this.apiClient.getChapter(contentBlock.chapter_id);
      if (chapter.story_id !== storyId) {
        throw new Error("Content block does not belong to the selected story");
      }
    }
    const folderPath = this.fileManager.getStoryFolderPath(story.title);
    await this.ensureContentFolders(folderPath);
    await this.writeContentBlockToFolder(folderPath, story.title, contentBlock);
    new import_obsidian8.Notice("Content block synced successfully");
  }
  async pushSingleEntity(folderPath, target, storyId, storyTitle) {
    let entityLabel;
    switch (target.type) {
      case "chapter":
        entityLabel = await this.pushChapterEntity(folderPath, target.id);
        break;
      case "scene":
        entityLabel = await this.pushSceneEntity(folderPath, storyId, target.id);
        break;
      case "content":
        entityLabel = await this.pushContentBlockEntity(folderPath, target.id, storyTitle);
        break;
      default:
        throw new Error(`Unsupported entity type: ${target.type}`);
    }
    new import_obsidian8.Notice(`${entityLabel} pushed successfully`);
    try {
      await this.pullSingleEntity(storyId, target);
    } catch (pullErr) {
      const pullErrorMessage = pullErr instanceof Error ? pullErr.message : "Failed to sync entity after push";
      new import_obsidian8.Notice(`Warning: ${pullErrorMessage}`, 5e3);
    }
  }
  async pushChapterEntity(folderPath, chapterId) {
    var _a, _b;
    const chapterFile = await this.findChapterFileById(folderPath, chapterId);
    if (!chapterFile) {
      throw new Error("Chapter file not found locally");
    }
    await this.pushChapterContentBlocks(chapterFile.path, folderPath);
    const label = ((_a = chapterFile.frontmatter) == null ? void 0 : _a.title) || (((_b = chapterFile.frontmatter) == null ? void 0 : _b.number) ? `Chapter ${chapterFile.frontmatter.number}` : "Chapter");
    return label;
  }
  async pushSceneEntity(folderPath, storyId, sceneId) {
    var _a;
    const sceneFile = await this.findSceneFileById(folderPath, sceneId);
    if (!sceneFile) {
      throw new Error("Scene file not found locally");
    }
    await this.pushSceneBeats(sceneFile.path, storyId);
    await this.pushSceneContentBlocks(sceneFile.path, folderPath);
    const label = ((_a = sceneFile.frontmatter) == null ? void 0 : _a.goal) ? `Scene: ${sceneFile.frontmatter.goal}` : "Scene";
    return label;
  }
  async pushContentBlockEntity(folderPath, contentBlockId, storyTitle) {
    var _a;
    const contentsFolderPath = `${folderPath}/03-contents`;
    await this.fileManager.ensureFolderExists(contentsFolderPath);
    const localContentBlock = await this.findContentBlockById(contentsFolderPath, contentBlockId);
    if (!localContentBlock) {
      throw new Error("Content block file not found locally");
    }
    const updatedBlock = await this.apiClient.updateContentBlock(contentBlockId, {
      content: localContentBlock.content,
      metadata: localContentBlock.metadata,
      type: localContentBlock.type,
      kind: localContentBlock.kind,
      order_num: (_a = localContentBlock.order_num) != null ? _a : void 0
    });
    const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, updatedBlock);
    await this.fileManager.writeContentBlockFile(updatedBlock, filePath, storyTitle);
    return "Content block";
  }
  async ensureStoryFolders(folderPath) {
    await this.fileManager.ensureFolderExists(folderPath);
    await this.ensureContentFolders(folderPath);
    await this.fileManager.ensureFolderExists(`${folderPath}/00-chapters`);
    await this.fileManager.ensureFolderExists(`${folderPath}/01-scenes`);
    await this.fileManager.ensureFolderExists(`${folderPath}/02-beats`);
  }
  async ensureContentFolders(folderPath) {
    const contentsFolderPath = `${folderPath}/03-contents`;
    await this.fileManager.ensureFolderExists(contentsFolderPath);
    for (const typeFolder of ["00-texts", "01-images", "02-videos", "03-audios", "04-embeds", "05-links"]) {
      await this.fileManager.ensureFolderExists(`${contentsFolderPath}/${typeFolder}`);
    }
  }
  async writeContentBlockToFolder(storyFolderPath, storyTitle, contentBlock) {
    const typeFolderPath = this.fileManager.getContentBlockFolderPath(
      storyFolderPath,
      contentBlock.type || "text"
    );
    await this.fileManager.ensureFolderExists(typeFolderPath);
    const contentBlockFileName = this.fileManager.generateContentBlockFileName(contentBlock);
    const contentBlockFilePath = `${typeFolderPath}/${contentBlockFileName}`;
    await this.fileManager.writeContentBlockFile(contentBlock, contentBlockFilePath, storyTitle);
  }
  async syncScenesToFilesystem(scenesWithBeats, folderPath, storyTitle, contentBlocksByScene, contentBlocksByBeat) {
    const skipRemoteFetch = Boolean(contentBlocksByScene || contentBlocksByBeat);
    for (const { scene, beats } of scenesWithBeats) {
      await this.writeSceneBundle({
        storyTitle,
        folderPath,
        scene,
        beats,
        sceneContentBlocks: contentBlocksByScene == null ? void 0 : contentBlocksByScene.get(scene.id),
        beatContentBlockMap: contentBlocksByBeat,
        skipRemoteContentFetch: skipRemoteFetch
      });
    }
  }
  async syncSceneContentBlocks(scene, beats, folderPath, storyTitle) {
    if (!scene.chapter_id) {
      return;
    }
    const contentBlocks = await this.apiClient.getContentBlocks(scene.chapter_id);
    for (const contentBlock of contentBlocks) {
      const refs = await this.apiClient.getContentAnchors(contentBlock.id);
      const hasSceneRef = refs.some(
        (ref) => ref.entity_type === "scene" && ref.entity_id === scene.id
      );
      const beatIds = beats.map((beat) => beat.id);
      const hasBeatRef = refs.some(
        (ref) => ref.entity_type === "beat" && beatIds.includes(ref.entity_id)
      );
      if (hasSceneRef || hasBeatRef) {
        await this.writeContentBlockToFolder(folderPath, storyTitle, contentBlock);
      }
    }
  }
  async findChapterFileById(folderPath, chapterId) {
    const chapterFiles = await this.fileManager.listChapterFiles(folderPath);
    for (const chapterFilePath of chapterFiles) {
      const file = this.fileManager.getVault().getAbstractFileByPath(chapterFilePath);
      if (!(file instanceof import_obsidian8.TFile)) {
        continue;
      }
      const content = await this.fileManager.getVault().read(file);
      const frontmatter = this.fileManager.parseFrontmatter(content);
      if (frontmatter.id === chapterId) {
        return { path: chapterFilePath, frontmatter };
      }
    }
    return null;
  }
  async findSceneFileById(folderPath, sceneId) {
    const sceneFiles = await this.fileManager.listStorySceneFiles(folderPath);
    for (const sceneFilePath of sceneFiles) {
      const file = this.fileManager.getVault().getAbstractFileByPath(sceneFilePath);
      if (!(file instanceof import_obsidian8.TFile)) {
        continue;
      }
      const content = await this.fileManager.getVault().read(file);
      const frontmatter = this.fileManager.parseFrontmatter(content);
      if (frontmatter.id === sceneId) {
        return { path: sceneFilePath, frontmatter };
      }
    }
    return null;
  }
};

// src/sync/autoSyncManager.ts
var import_obsidian9 = require("obsidian");
var IDLE_DELAY_MS = 6e4;
var AutoSyncManager = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.idleTimeoutId = null;
    this.activeFile = null;
    this.lastEditTs = 0;
    this.dirtyFiles = /* @__PURE__ */ new Set();
    this.pendingSyncs = /* @__PURE__ */ new Set();
    this.handleActiveLeafChange = (leaf) => {
      const previousFile = this.activeFile;
      const newFile = this.plugin.app.workspace.getActiveFile();
      if (previousFile && (!newFile || previousFile.path !== newFile.path) && this.dirtyFiles.has(previousFile.path)) {
        void this.triggerSyncForFile(previousFile, "blur");
      }
      this.activeFile = newFile;
      this.lastEditTs = Date.now();
      this.resetIdleTimer();
    };
    this.activeFile = this.plugin.app.workspace.getActiveFile();
    this.lastEditTs = Date.now();
    this.registerEvents();
    this.resetIdleTimer();
  }
  dispose() {
    if (this.leafChangeRef) {
      this.plugin.app.workspace.offref(this.leafChangeRef);
      this.leafChangeRef = void 0;
    }
    if (this.editorChangeRef) {
      this.plugin.app.workspace.offref(this.editorChangeRef);
      this.editorChangeRef = void 0;
    }
    if (this.idleTimeoutId !== null) {
      window.clearTimeout(this.idleTimeoutId);
      this.idleTimeoutId = null;
    }
    this.dirtyFiles.clear();
    this.pendingSyncs.clear();
  }
  registerEvents() {
    this.leafChangeRef = this.plugin.app.workspace.on(
      "active-leaf-change",
      this.handleActiveLeafChange
    );
    this.plugin.registerEvent(this.leafChangeRef);
    this.editorChangeRef = this.plugin.app.workspace.on("editor-change", () => {
      const file = this.plugin.app.workspace.getActiveFile();
      if (!file) {
        return;
      }
      this.activeFile = file;
      this.lastEditTs = Date.now();
      this.dirtyFiles.add(file.path);
      this.resetIdleTimer();
    });
    this.plugin.registerEvent(this.editorChangeRef);
  }
  resetIdleTimer() {
    if (this.idleTimeoutId !== null) {
      window.clearTimeout(this.idleTimeoutId);
    }
    if (!this.activeFile) {
      this.idleTimeoutId = null;
      return;
    }
    this.idleTimeoutId = window.setTimeout(() => {
      const file = this.activeFile;
      if (!file) {
        return;
      }
      const idleDuration = Date.now() - this.lastEditTs;
      if (idleDuration >= IDLE_DELAY_MS && this.dirtyFiles.has(file.path)) {
        void this.triggerSyncForFile(file, "idle");
      } else {
        this.resetIdleTimer();
      }
    }, IDLE_DELAY_MS);
  }
  async triggerSyncForFile(file, reason) {
    const path = file.path;
    if (this.pendingSyncs.has(path)) {
      return;
    }
    this.pendingSyncs.add(path);
    try {
      const target = await this.resolveTarget(file);
      if (!target) {
        return;
      }
      if (target.pushWholeStory) {
        await this.plugin.syncService.pushStory(target.folderPath);
      } else if (target.syncTarget) {
        await this.plugin.syncService.pushStory(target.folderPath, target.syncTarget);
      }
      this.dirtyFiles.delete(path);
      if (reason === "idle") {
        this.lastEditTs = Date.now();
        this.resetIdleTimer();
      }
    } catch (err) {
      console.error(`Auto push failed for ${file.path}`, err);
    } finally {
      this.pendingSyncs.delete(path);
    }
  }
  async resolveTarget(file) {
    const folderPath = this.findStoryFolderPath(file);
    if (!folderPath) {
      return null;
    }
    if (file.name === "story.md") {
      return { folderPath, pushWholeStory: true };
    }
    const content = await this.plugin.app.vault.read(file);
    const frontmatter = this.plugin.fileManager.parseFrontmatter(content);
    const entityId = frontmatter == null ? void 0 : frontmatter.id;
    if (!entityId) {
      return null;
    }
    const sceneId = frontmatter.scene_id;
    const chapterId = frontmatter.chapter_id;
    const isContentFile = file.path.includes("/03-contents/");
    const isChapterFile = file.path.includes("/00-chapters/");
    const isSceneFile = file.path.includes("/01-scenes/");
    if (frontmatter.story_id && frontmatter.number && isChapterFile) {
      return {
        folderPath,
        pushWholeStory: false,
        syncTarget: { type: "chapter", id: entityId }
      };
    }
    if (frontmatter.story_id && (isSceneFile || chapterId)) {
      return {
        folderPath,
        pushWholeStory: false,
        syncTarget: { type: "scene", id: entityId }
      };
    }
    if (sceneId) {
      return {
        folderPath,
        pushWholeStory: false,
        syncTarget: { type: "scene", id: sceneId }
      };
    }
    if (isContentFile) {
      return {
        folderPath,
        pushWholeStory: false,
        syncTarget: { type: "content", id: entityId }
      };
    }
    return null;
  }
  findStoryFolderPath(file) {
    let current = file.parent;
    while (current) {
      const storyFilePath = `${current.path}/story.md`;
      const maybeStoryFile = this.plugin.app.vault.getAbstractFileByPath(storyFilePath);
      if (maybeStoryFile instanceof import_obsidian9.TFile) {
        return current.path;
      }
      const parent = current.parent;
      if (parent instanceof import_obsidian9.TFolder) {
        current = parent;
      } else {
        current = null;
      }
    }
    return null;
  }
};

// src/views/StoryListView.ts
var import_obsidian16 = require("obsidian");

// src/views/modals/ChapterModal.ts
var import_obsidian10 = require("obsidian");
var ChapterModal = class extends import_obsidian10.Modal {
  constructor(app, onSubmit, existingChapters = [], chapter) {
    super(app);
    this.chapter = {
      title: "",
      status: "draft"
    };
    this.isEdit = false;
    this.existingChapters = [];
    this.onSubmit = onSubmit;
    this.existingChapters = existingChapters;
    if (chapter) {
      this.isEdit = true;
      this.chapter = {
        number: chapter.number,
        title: chapter.title,
        status: chapter.status
      };
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", {
      text: this.isEdit ? "Edit Chapter" : "Create Chapter"
    });
    if (this.isEdit) {
      new import_obsidian10.Setting(contentEl).setName("Chapter Number").setDesc("The chapter number").addText(
        (text) => {
          var _a;
          return text.setPlaceholder("1").setValue(((_a = this.chapter.number) == null ? void 0 : _a.toString()) || "1").onChange((value) => {
            const num = parseInt(value);
            if (!isNaN(num) && num > 0) {
              this.chapter.number = num;
            }
          });
        }
      );
    }
    new import_obsidian10.Setting(contentEl).setName("Title").setDesc("Chapter title").addText(
      (text) => text.setPlaceholder("Chapter Title").setValue(this.chapter.title || "").onChange((value) => {
        this.chapter.title = value;
      }).inputEl.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          this.submit();
        }
      })
    );
    new import_obsidian10.Setting(contentEl).setName("Status").setDesc("Chapter status").addDropdown(
      (dropdown) => dropdown.addOption("draft", "Draft").addOption("in_progress", "In Progress").addOption("completed", "Completed").setValue(this.chapter.status || "draft").onChange((value) => {
        this.chapter.status = value;
      })
    );
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const submitButton = buttonContainer.createEl("button", {
      text: this.isEdit ? "Update" : "Create",
      cls: "mod-cta"
    });
    submitButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
    const titleInput = contentEl.querySelector("input[placeholder='Chapter Title']");
    if (titleInput) {
      titleInput.focus();
    }
  }
  async submit() {
    var _a;
    if (!((_a = this.chapter.title) == null ? void 0 : _a.trim())) {
      new import_obsidian10.Notice("Please enter a chapter title", 3e3);
      return;
    }
    if (!this.isEdit) {
      const maxNumber = this.existingChapters.length > 0 ? Math.max(...this.existingChapters.map((c) => c.number)) : 0;
      this.chapter.number = maxNumber + 1;
    } else {
      if (!this.chapter.number || this.chapter.number < 1) {
        new import_obsidian10.Notice("Chapter number must be greater than 0", 3e3);
        return;
      }
    }
    try {
      await this.onSubmit(this.chapter);
      this.close();
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to save chapter";
      new import_obsidian10.Notice(`Error: ${errorMessage}`, 5e3);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/modals/SceneModal.ts
var import_obsidian11 = require("obsidian");
var SceneModal = class extends import_obsidian11.Modal {
  constructor(app, storyId, chapters, onSubmit, existingScenes = [], scene, defaultChapterId) {
    super(app);
    this.scene = {
      time_ref: "",
      goal: ""
    };
    this.isEdit = false;
    this.chapters = [];
    this.existingScenes = [];
    this.storyId = storyId;
    this.chapters = chapters;
    this.existingScenes = existingScenes;
    this.defaultChapterId = defaultChapterId;
    this.onSubmit = onSubmit;
    if (scene) {
      this.isEdit = true;
      this.scene = {
        story_id: scene.story_id,
        chapter_id: scene.chapter_id || null,
        order_num: scene.order_num,
        time_ref: scene.time_ref,
        goal: scene.goal,
        pov_character_id: scene.pov_character_id,
        location_id: scene.location_id
      };
    } else {
      this.scene.story_id = storyId;
      if (defaultChapterId !== void 0) {
        this.scene.chapter_id = defaultChapterId;
      }
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", {
      text: this.isEdit ? "Edit Scene" : "Create Scene"
    });
    new import_obsidian11.Setting(contentEl).setName("Chapter").setDesc("Select the chapter for this scene (optional)").addDropdown((dropdown) => {
      dropdown.addOption("", "No Chapter");
      for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
        dropdown.addOption(
          chapter.id,
          `Chapter ${chapter.number}: ${chapter.title}`
        );
      }
      dropdown.setValue(this.scene.chapter_id || "");
      dropdown.onChange((value) => {
        this.scene.chapter_id = value || null;
      });
    });
    if (this.isEdit) {
      new import_obsidian11.Setting(contentEl).setName("Order Number").setDesc("Scene order within chapter").addText(
        (text) => {
          var _a;
          return text.setPlaceholder("1").setValue(((_a = this.scene.order_num) == null ? void 0 : _a.toString()) || "1").onChange((value) => {
            const num = parseInt(value);
            if (!isNaN(num) && num > 0) {
              this.scene.order_num = num;
            }
          });
        }
      );
    }
    new import_obsidian11.Setting(contentEl).setName("Goal").setDesc("Scene goal or description").addTextArea(
      (text) => text.setPlaceholder("What happens in this scene?").setValue(this.scene.goal || "").onChange((value) => {
        this.scene.goal = value;
      })
    );
    new import_obsidian11.Setting(contentEl).setName("Time Reference").setDesc("When does this scene take place?").addText(
      (text) => text.setPlaceholder("Morning, Evening, etc.").setValue(this.scene.time_ref || "").onChange((value) => {
        this.scene.time_ref = value;
      })
    );
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const submitButton = buttonContainer.createEl("button", {
      text: this.isEdit ? "Update" : "Create",
      cls: "mod-cta"
    });
    submitButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
    const goalInput = contentEl.querySelector("textarea");
    if (goalInput) {
      goalInput.focus();
    }
  }
  async submit() {
    if (!this.isEdit) {
      const chapterId = this.scene.chapter_id || null;
      const scenesInChapter = this.existingScenes.filter(
        (s) => (s.chapter_id || null) === chapterId
      );
      const maxOrderNum = scenesInChapter.length > 0 ? Math.max(...scenesInChapter.map((s) => s.order_num)) : 0;
      this.scene.order_num = maxOrderNum + 1;
    } else {
      if (!this.scene.order_num || this.scene.order_num < 1) {
        new import_obsidian11.Notice("Order number must be greater than 0", 3e3);
        return;
      }
    }
    try {
      await this.onSubmit(this.scene);
      this.close();
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to save scene";
      new import_obsidian11.Notice(`Error: ${errorMessage}`, 5e3);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/modals/BeatModal.ts
var import_obsidian12 = require("obsidian");
var BeatModal = class extends import_obsidian12.Modal {
  constructor(app, storyId, scenes, onSubmit, existingBeats = [], beat, chapters = [], defaultSceneId) {
    super(app);
    this.beat = {
      type: "setup",
      intent: "",
      outcome: ""
    };
    this.isEdit = false;
    this.scenes = [];
    this.chapters = [];
    this.existingBeats = [];
    this.storyId = storyId;
    this.scenes = scenes;
    this.chapters = chapters;
    this.existingBeats = existingBeats;
    this.defaultSceneId = defaultSceneId;
    this.onSubmit = onSubmit;
    if (beat) {
      this.isEdit = true;
      this.beat = {
        scene_id: beat.scene_id,
        order_num: beat.order_num,
        type: beat.type,
        intent: beat.intent,
        outcome: beat.outcome
      };
    } else if (defaultSceneId) {
      this.beat.scene_id = defaultSceneId;
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", {
      text: this.isEdit ? "Edit Beat" : "Create Beat"
    });
    new import_obsidian12.Setting(contentEl).setName("Scene").setDesc("Select the scene for this beat").addDropdown((dropdown) => {
      const scenesByChapter = /* @__PURE__ */ new Map();
      for (const scene of this.scenes) {
        const chapterId = scene.chapter_id || null;
        if (!scenesByChapter.has(chapterId)) {
          scenesByChapter.set(chapterId, []);
        }
        scenesByChapter.get(chapterId).push(scene);
      }
      const getChapterLabel = (chapterId) => {
        if (!chapterId)
          return "No Chapter";
        const chapter = this.chapters.find((c) => c.id === chapterId);
        return chapter ? `Chapter ${chapter.number}: ${chapter.title}` : "No Chapter";
      };
      for (const [chapterId, chapterScenes] of scenesByChapter.entries()) {
        const label = getChapterLabel(chapterId);
        for (const scene of chapterScenes.sort((a, b) => a.order_num - b.order_num)) {
          dropdown.addOption(
            scene.id,
            `${label} > Scene ${scene.order_num}: ${scene.goal || "Untitled"}`
          );
        }
      }
      dropdown.setValue(this.beat.scene_id || "");
      dropdown.onChange((value) => {
        this.beat.scene_id = value;
      });
    });
    if (this.isEdit) {
      new import_obsidian12.Setting(contentEl).setName("Order Number").setDesc("Beat order within scene").addText(
        (text) => {
          var _a;
          return text.setPlaceholder("1").setValue(((_a = this.beat.order_num) == null ? void 0 : _a.toString()) || "1").onChange((value) => {
            const num = parseInt(value);
            if (!isNaN(num) && num > 0) {
              this.beat.order_num = num;
            }
          });
        }
      );
    }
    new import_obsidian12.Setting(contentEl).setName("Type").setDesc("Beat type").addDropdown(
      (dropdown) => dropdown.addOption("setup", "Setup").addOption("turn", "Turn").addOption("reveal", "Reveal").addOption("conflict", "Conflict").addOption("climax", "Climax").addOption("resolution", "Resolution").addOption("hook", "Hook").addOption("transition", "Transition").setValue(this.beat.type || "setup").onChange((value) => {
        this.beat.type = value;
      })
    );
    new import_obsidian12.Setting(contentEl).setName("Intent").setDesc("What is the intent of this beat?").addTextArea(
      (text) => text.setPlaceholder("What does the character want?").setValue(this.beat.intent || "").onChange((value) => {
        this.beat.intent = value;
      })
    );
    new import_obsidian12.Setting(contentEl).setName("Outcome").setDesc("What is the outcome of this beat?").addTextArea(
      (text) => text.setPlaceholder("What happens as a result?").setValue(this.beat.outcome || "").onChange((value) => {
        this.beat.outcome = value;
      })
    );
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const submitButton = buttonContainer.createEl("button", {
      text: this.isEdit ? "Update" : "Create",
      cls: "mod-cta"
    });
    submitButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
    const intentInput = contentEl.querySelector("textarea");
    if (intentInput) {
      intentInput.focus();
    }
  }
  async submit() {
    if (!this.beat.scene_id) {
      new import_obsidian12.Notice("Please select a scene", 3e3);
      return;
    }
    if (!this.beat.type) {
      new import_obsidian12.Notice("Please select a beat type", 3e3);
      return;
    }
    if (!this.isEdit) {
      const beatsInScene = this.existingBeats.filter((b) => b.scene_id === this.beat.scene_id);
      const maxOrderNum = beatsInScene.length > 0 ? Math.max(...beatsInScene.map((b) => b.order_num)) : 0;
      this.beat.order_num = maxOrderNum + 1;
    } else {
      if (!this.beat.order_num || this.beat.order_num < 1) {
        new import_obsidian12.Notice("Order number must be greater than 0", 3e3);
        return;
      }
    }
    try {
      await this.onSubmit(this.beat);
      this.close();
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to save beat";
      new import_obsidian12.Notice(`Error: ${errorMessage}`, 5e3);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/modals/ContentBlockModal.ts
var import_obsidian13 = require("obsidian");

// src/api/unsplash.ts
var UnsplashClient = class {
  constructor(accessKey, secretKey) {
    this.apiUrl = "https://api.unsplash.com";
    this.accessKey = accessKey || "YOUR_UNSPLASH_ACCESS_KEY";
    this.secretKey = secretKey || "";
  }
  async searchImages(query, page = 1, perPage = 20) {
    const url = `${this.apiUrl}/search/photos?query=${encodeURIComponent(query)}&page=${page}&per_page=${perPage}`;
    const headers = {
      "Accept-Version": "v1"
    };
    if (!this.accessKey || this.accessKey === "YOUR_UNSPLASH_ACCESS_KEY") {
      throw new Error("Unsplash access key is required. Please configure it in plugin settings.");
    }
    headers["Authorization"] = `Client-ID ${this.accessKey}`;
    const response = await fetch(url, { headers });
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Unsplash API error: ${response.status} ${response.statusText}. ${errorText}`);
    }
    return response.json();
  }
  getImageUrl(photo, size = "regular") {
    return photo.urls[size];
  }
  getAttributionUrl(photo) {
    return photo.links.html;
  }
  getAttributionText(photo) {
    return `Photo by ${photo.user.name} on Unsplash`;
  }
};

// src/views/modals/ContentBlockModal.ts
var ContentBlockModal = class extends import_obsidian13.Modal {
  constructor(app, onSubmit, contentBlock, plugin) {
    var _a, _b, _c, _d;
    super(app);
    this.contentBlock = {
      type: "text",
      kind: "final",
      content: "",
      metadata: {}
    };
    this.isEdit = false;
    this.unsplashResults = [];
    this.unsplashSearchQuery = "";
    this.unsplashSearching = false;
    this.selectedImageUrl = "";
    this.currentImageSourceTab = "internet link";
    this.onSubmit = onSubmit;
    this.plugin = plugin;
    const unsplashAccessKey = ((_b = (_a = this.plugin) == null ? void 0 : _a.settings) == null ? void 0 : _b.unsplashAccessKey) || "";
    const unsplashSecretKey = ((_d = (_c = this.plugin) == null ? void 0 : _c.settings) == null ? void 0 : _d.unsplashSecretKey) || "";
    this.unsplashClient = new UnsplashClient(unsplashAccessKey, unsplashSecretKey);
    if (contentBlock) {
      this.isEdit = true;
      this.contentBlock = {
        type: contentBlock.type,
        kind: contentBlock.kind || "final",
        content: contentBlock.content,
        metadata: contentBlock.metadata || {}
      };
      if (contentBlock.type === "image" && contentBlock.content) {
        this.selectedImageUrl = contentBlock.content;
      }
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", {
      text: this.isEdit ? "Edit Content Block" : "Create Content Block"
    });
    if (this.isEdit && !this.contentBlock.type) {
      new import_obsidian13.Setting(contentEl).setName("Type").setDesc("Select the content type").addDropdown(
        (dropdown) => dropdown.addOption("text", "Text").addOption("image", "Image").setValue(this.contentBlock.type || "text").onChange((value) => {
          this.contentBlock.type = value;
          this.renderContentFields();
        })
      );
    }
    this.renderContentFields();
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const submitButton = buttonContainer.createEl("button", {
      text: this.isEdit ? "Update" : "Create",
      cls: "mod-cta"
    });
    submitButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
  }
  renderContentFields() {
    var _a, _b, _c, _d, _e, _f, _g;
    const { contentEl } = this;
    const existingFields = contentEl.querySelectorAll(".content-block-field");
    existingFields.forEach((el) => el.remove());
    if (this.contentBlock.type === "text") {
      const textField = contentEl.createDiv({ cls: "content-block-field" });
      new import_obsidian13.Setting(textField).setName("Content").setDesc("Enter the text content").addTextArea(
        (text) => text.setPlaceholder("Enter text...").setValue(this.contentBlock.content || "").onChange((value) => {
          this.contentBlock.content = value;
          if (!this.contentBlock.metadata) {
            this.contentBlock.metadata = {};
          }
          this.contentBlock.metadata.word_count = value.trim().split(/\s+/).filter((w) => w.length > 0).length;
        })
      );
    } else if (this.contentBlock.type === "image") {
      const imageField = contentEl.createDiv({ cls: "content-block-field" });
      const sourceValue = ((_a = this.contentBlock.metadata) == null ? void 0 : _a.source) || "internet link";
      this.currentImageSourceTab = sourceValue;
      const tabsContainer = imageField.createDiv({ cls: "content-block-source-tabs" });
      const unsplashTab = tabsContainer.createEl("button", {
        text: "Unsplash",
        cls: `content-block-source-tab ${this.currentImageSourceTab === "unsplash" ? "is-active" : ""}`
      });
      const internetTab = tabsContainer.createEl("button", {
        text: "Internet Link",
        cls: `content-block-source-tab ${this.currentImageSourceTab === "internet link" ? "is-active" : ""}`
      });
      const localTab = tabsContainer.createEl("button", {
        text: "Local Upload",
        cls: `content-block-source-tab ${this.currentImageSourceTab === "local" ? "is-active" : ""}`
      });
      const tabContent = imageField.createDiv({ cls: "content-block-source-tab-content" });
      unsplashTab.onclick = () => {
        this.currentImageSourceTab = "unsplash";
        if (!this.contentBlock.metadata) {
          this.contentBlock.metadata = {};
        }
        this.contentBlock.metadata.source = "unsplash";
        this.renderContentFields();
      };
      internetTab.onclick = () => {
        this.currentImageSourceTab = "internet link";
        if (!this.contentBlock.metadata) {
          this.contentBlock.metadata = {};
        }
        this.contentBlock.metadata.source = "internet link";
        this.renderContentFields();
      };
      localTab.onclick = () => {
        this.currentImageSourceTab = "local";
        if (!this.contentBlock.metadata) {
          this.contentBlock.metadata = {};
        }
        this.contentBlock.metadata.source = "local";
        this.renderContentFields();
      };
      if (this.currentImageSourceTab === "unsplash") {
        const unsplashAccessKey = ((_c = (_b = this.plugin) == null ? void 0 : _b.settings) == null ? void 0 : _c.unsplashAccessKey) || "";
        if (unsplashAccessKey && unsplashAccessKey !== "YOUR_UNSPLASH_ACCESS_KEY") {
          const unsplashSetting = new import_obsidian13.Setting(tabContent);
          unsplashSetting.setName("Search Unsplash");
          unsplashSetting.setDesc("Search for free images");
          unsplashSetting.addButton((button) => {
            button.setButtonText("Search");
            button.onClick(() => {
              this.showUnsplashSearch();
            });
          });
        } else {
          const unsplashSetting = new import_obsidian13.Setting(tabContent);
          unsplashSetting.setName("Search Unsplash");
          unsplashSetting.setDesc("Configure Unsplash Access Key and Secret Key in plugin settings to enable image search");
          unsplashSetting.addButton((button) => {
            button.setButtonText("Search");
            button.setDisabled(true);
          });
        }
        if (this.selectedImageUrl) {
          new import_obsidian13.Setting(tabContent).setName("Selected Image URL").setDesc("Image URL from Unsplash").addText(
            (text) => text.setValue(this.selectedImageUrl).setDisabled(true)
          );
        }
      } else if (this.currentImageSourceTab === "internet link") {
        new import_obsidian13.Setting(tabContent).setName("Image URL").setDesc("Enter image URL").addText(
          (text) => text.setPlaceholder("https://example.com/image.jpg").setValue(this.selectedImageUrl).onChange((value) => {
            this.selectedImageUrl = value;
            this.contentBlock.content = value;
            if (!this.contentBlock.metadata) {
              this.contentBlock.metadata = {};
            }
            this.contentBlock.metadata.source = "internet link";
          })
        );
      } else if (this.currentImageSourceTab === "local") {
        new import_obsidian13.Setting(tabContent).setName("Upload from Computer").setDesc("Upload image from your computer (coming soon)").addButton((button) => {
          button.setButtonText("Choose File");
          button.setDisabled(true);
        });
      }
      const altTextValue = ((_d = this.contentBlock.metadata) == null ? void 0 : _d.alt_text) || "";
      const altTextSetting = new import_obsidian13.Setting(imageField);
      altTextSetting.setName("Alt Text");
      altTextSetting.setDesc("Alt text for accessibility");
      altTextSetting.addText(
        (text) => text.setPlaceholder("Describe the image for accessibility").setValue(altTextValue).onChange((value) => {
          if (!this.contentBlock.metadata) {
            this.contentBlock.metadata = {};
          }
          this.contentBlock.metadata.alt_text = value || void 0;
        })
      );
      const authorNameValue = ((_e = this.contentBlock.metadata) == null ? void 0 : _e.author_name) || "";
      new import_obsidian13.Setting(imageField).setName("Author Name").setDesc("Name of the image author/photographer").addText(
        (text) => text.setPlaceholder("Author name").setValue(authorNameValue).onChange((value) => {
          if (!this.contentBlock.metadata) {
            this.contentBlock.metadata = {};
          }
          this.contentBlock.metadata.author_name = value || void 0;
        })
      );
      const attributionValue = ((_f = this.contentBlock.metadata) == null ? void 0 : _f.attribution) || "";
      new import_obsidian13.Setting(imageField).setName("Attribution").setDesc("Attribution text (e.g., 'Photo by John Doe on Unsplash')").addText(
        (text) => text.setPlaceholder("Photo by Author Name on Source").setValue(attributionValue).onChange((value) => {
          if (!this.contentBlock.metadata) {
            this.contentBlock.metadata = {};
          }
          this.contentBlock.metadata.attribution = value || void 0;
        })
      );
      const attributionUrlValue = ((_g = this.contentBlock.metadata) == null ? void 0 : _g.attribution_url) || "";
      new import_obsidian13.Setting(imageField).setName("Attribution URL").setDesc("Link to the original image or author page").addText(
        (text) => text.setPlaceholder("https://example.com/photo").setValue(attributionUrlValue).onChange((value) => {
          if (!this.contentBlock.metadata) {
            this.contentBlock.metadata = {};
          }
          this.contentBlock.metadata.attribution_url = value || void 0;
        })
      );
    }
  }
  showUnsplashSearch() {
    const { contentEl } = this;
    const searchModal = new import_obsidian13.Modal(this.app);
    searchModal.titleEl.setText("Search Unsplash");
    const searchContent = searchModal.contentEl;
    const searchInput = searchContent.createEl("input", {
      type: "text",
      placeholder: "Search for images...",
      cls: "unsplash-search-input"
    });
    searchInput.value = this.unsplashSearchQuery;
    searchInput.style.width = "100%";
    searchInput.style.padding = "0.5rem";
    searchInput.style.marginBottom = "1rem";
    const searchButton = searchContent.createEl("button", {
      text: "Search",
      cls: "mod-cta"
    });
    searchButton.style.marginBottom = "1rem";
    const resultsContainer = searchContent.createDiv({ cls: "unsplash-results-grid" });
    const performSearch = async () => {
      const query = searchInput.value.trim();
      if (!query) {
        new import_obsidian13.Notice("Please enter a search query", 3e3);
        return;
      }
      this.unsplashSearching = true;
      searchButton.disabled = true;
      searchButton.setText("Searching...");
      resultsContainer.empty();
      resultsContainer.createEl("p", { text: "Searching..." });
      try {
        const response = await this.unsplashClient.searchImages(query, 1, 20);
        this.unsplashResults = response.results;
        resultsContainer.empty();
        if (this.unsplashResults.length === 0) {
          resultsContainer.createEl("p", { text: "No results found." });
        } else {
          for (const photo of this.unsplashResults) {
            const photoItem = resultsContainer.createDiv({ cls: "unsplash-photo-item" });
            const img = photoItem.createEl("img", {
              attr: {
                src: this.unsplashClient.getImageUrl(photo, "thumb"),
                alt: photo.alt_description || photo.description || "Unsplash photo"
              }
            });
            img.style.width = "100%";
            img.style.height = "150px";
            img.style.objectFit = "cover";
            img.style.borderRadius = "4px";
            img.style.cursor = "pointer";
            const photoInfo = photoItem.createDiv({ cls: "unsplash-photo-info" });
            photoInfo.createEl("p", {
              text: photo.alt_description || photo.description || "Untitled",
              cls: "unsplash-photo-title"
            });
            photoInfo.createEl("p", {
              text: this.unsplashClient.getAttributionText(photo),
              cls: "unsplash-photo-attribution"
            });
            photoItem.onclick = () => {
              const imageUrl = this.unsplashClient.getImageUrl(photo, "regular");
              this.selectedImageUrl = imageUrl;
              this.contentBlock.content = imageUrl;
              if (!this.contentBlock.metadata) {
                this.contentBlock.metadata = {};
              }
              const altText = photo.alt_description || photo.description || "";
              this.contentBlock.metadata.alt_text = altText;
              this.contentBlock.metadata.attribution = this.unsplashClient.getAttributionText(photo);
              this.contentBlock.metadata.attribution_url = this.unsplashClient.getAttributionUrl(photo);
              this.contentBlock.metadata.author_name = photo.user.name;
              this.contentBlock.metadata.source = "unsplash";
              searchModal.close();
              this.renderContentFields();
              new import_obsidian13.Notice("Image selected");
            };
          }
        }
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to search Unsplash";
        new import_obsidian13.Notice(`Error: ${errorMessage}`, 5e3);
        resultsContainer.empty();
        resultsContainer.createEl("p", {
          text: `Error: ${errorMessage}`,
          cls: "story-engine-error"
        });
      } finally {
        this.unsplashSearching = false;
        searchButton.disabled = false;
        searchButton.setText("Search");
      }
    };
    searchButton.onclick = performSearch;
    searchInput.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        performSearch();
      }
    });
    if (this.unsplashSearchQuery) {
      performSearch();
    }
    searchModal.open();
  }
  async submit() {
    var _a, _b;
    if (!this.contentBlock.type) {
      this.contentBlock.type = "text";
    }
    if (this.contentBlock.type === "text" && !((_a = this.contentBlock.content) == null ? void 0 : _a.trim())) {
      new import_obsidian13.Notice("Please enter text content", 3e3);
      return;
    }
    if (this.contentBlock.type === "image" && !((_b = this.contentBlock.content) == null ? void 0 : _b.trim())) {
      new import_obsidian13.Notice("Please enter an image URL or select an image", 3e3);
      return;
    }
    try {
      await this.onSubmit(this.contentBlock);
      this.close();
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to save content block";
      new import_obsidian13.Notice(`Error: ${errorMessage}`, 5e3);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/TimelineModal.ts
var import_obsidian14 = require("obsidian");

// node_modules/d3-array/src/ascending.js
function ascending(a, b) {
  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

// node_modules/d3-array/src/descending.js
function descending(a, b) {
  return a == null || b == null ? NaN : b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

// node_modules/d3-array/src/bisector.js
function bisector(f) {
  let compare1, compare2, delta;
  if (f.length !== 2) {
    compare1 = ascending;
    compare2 = (d, x) => ascending(f(d), x);
    delta = (d, x) => f(d) - x;
  } else {
    compare1 = f === ascending || f === descending ? f : zero;
    compare2 = f;
    delta = f;
  }
  function left2(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a[mid], x) < 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right2(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a[mid], x) <= 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center2(a, x, lo = 0, hi = a.length) {
    const i = left2(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }
  return { left: left2, center: center2, right: right2 };
}
function zero() {
  return 0;
}

// node_modules/d3-array/src/number.js
function number(x) {
  return x === null ? NaN : +x;
}

// node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector(number).center;
var bisect_default = bisectRight;

// node_modules/d3-array/src/extent.js
function extent(values, valueof) {
  let min2;
  let max2;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null) {
        if (min2 === void 0) {
          if (value >= value)
            min2 = max2 = value;
        } else {
          if (min2 > value)
            min2 = value;
          if (max2 < value)
            max2 = value;
        }
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null) {
        if (min2 === void 0) {
          if (value >= value)
            min2 = max2 = value;
        } else {
          if (min2 > value)
            min2 = value;
          if (max2 < value)
            max2 = value;
        }
      }
    }
  }
  return [min2, max2];
}

// node_modules/internmap/src/index.js
var InternMap = class extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (entries != null)
      for (const [key2, value] of entries)
        this.set(key2, value);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value) {
    return super.set(intern_set(this, key), value);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
};
function intern_get({ _intern, _key }, value) {
  const key = _key(value);
  return _intern.has(key) ? _intern.get(key) : value;
}
function intern_set({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key))
    return _intern.get(key);
  _intern.set(key, value);
  return value;
}
function intern_delete({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key)) {
    value = _intern.get(key);
    _intern.delete(key);
  }
  return value;
}
function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}

// node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
function tickSpec(start2, stop, count) {
  const step = (stop - start2) / Math.max(0, count), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start2 * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start2)
      ++i1;
    if (i2 / inc > stop)
      --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start2 / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start2)
      ++i1;
    if (i2 * inc > stop)
      --i2;
  }
  if (i2 < i1 && 0.5 <= count && count < 2)
    return tickSpec(start2, stop, count * 2);
  return [i1, i2, inc];
}
function ticks(start2, stop, count) {
  stop = +stop, start2 = +start2, count = +count;
  if (!(count > 0))
    return [];
  if (start2 === stop)
    return [start2];
  const reverse = stop < start2, [i1, i2, inc] = reverse ? tickSpec(stop, start2, count) : tickSpec(start2, stop, count);
  if (!(i2 >= i1))
    return [];
  const n = i2 - i1 + 1, ticks2 = new Array(n);
  if (reverse) {
    if (inc < 0)
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i2 - i) / -inc;
    else
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i2 - i) * inc;
  } else {
    if (inc < 0)
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i1 + i) / -inc;
    else
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i1 + i) * inc;
  }
  return ticks2;
}
function tickIncrement(start2, stop, count) {
  stop = +stop, start2 = +start2, count = +count;
  return tickSpec(start2, stop, count)[2];
}
function tickStep(start2, stop, count) {
  stop = +stop, start2 = +start2, count = +count;
  const reverse = stop < start2, inc = reverse ? tickIncrement(stop, start2, count) : tickIncrement(start2, stop, count);
  return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}

// node_modules/d3-axis/src/identity.js
function identity_default(x) {
  return x;
}

// node_modules/d3-axis/src/axis.js
var top = 1;
var right = 2;
var bottom = 3;
var left = 4;
var epsilon = 1e-6;
function translateX(x) {
  return "translate(" + x + ",0)";
}
function translateY(y) {
  return "translate(0," + y + ")";
}
function number2(scale) {
  return (d) => +scale(d);
}
function center(scale, offset) {
  offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;
  if (scale.round())
    offset = Math.round(offset);
  return (d) => +scale(d) + offset;
}
function entering() {
  return !this.__axis;
}
function axis(orient, scale) {
  var tickArguments = [], tickValues = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5, k = orient === top || orient === left ? -1 : 1, x = orient === left || orient === right ? "x" : "y", transform2 = orient === top || orient === bottom ? translateX : translateY;
  function axis2(context) {
    var values = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues, format2 = tickFormat2 == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity_default : tickFormat2, spacing = Math.max(tickSizeInner, 0) + tickPadding, range = scale.range(), range0 = +range[0] + offset, range1 = +range[range.length - 1] + offset, position = (scale.bandwidth ? center : number2)(scale.copy(), offset), selection2 = context.selection ? context.selection() : context, path = selection2.selectAll(".domain").data([null]), tick = selection2.selectAll(".tick").data(values, scale).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line = tick.select("line"), text = tick.select("text");
    path = path.merge(path.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
    tick = tick.merge(tickEnter);
    line = line.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x + "2", k * tickSizeInner));
    text = text.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x, k * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
    if (context !== selection2) {
      path = path.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text = text.transition(context);
      tickExit = tickExit.transition(context).attr("opacity", epsilon).attr("transform", function(d) {
        return isFinite(d = position(d)) ? transform2(d + offset) : this.getAttribute("transform");
      });
      tickEnter.attr("opacity", epsilon).attr("transform", function(d) {
        var p = this.parentNode.__axis;
        return transform2((p && isFinite(p = p(d)) ? p : position(d)) + offset);
      });
    }
    tickExit.remove();
    path.attr("d", orient === left || orient === right ? tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1);
    tick.attr("opacity", 1).attr("transform", function(d) {
      return transform2(position(d) + offset);
    });
    line.attr(x + "2", k * tickSizeInner);
    text.attr(x, k * spacing).text(format2);
    selection2.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
    selection2.each(function() {
      this.__axis = position;
    });
  }
  axis2.scale = function(_) {
    return arguments.length ? (scale = _, axis2) : scale;
  };
  axis2.ticks = function() {
    return tickArguments = Array.from(arguments), axis2;
  };
  axis2.tickArguments = function(_) {
    return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis2) : tickArguments.slice();
  };
  axis2.tickValues = function(_) {
    return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis2) : tickValues && tickValues.slice();
  };
  axis2.tickFormat = function(_) {
    return arguments.length ? (tickFormat2 = _, axis2) : tickFormat2;
  };
  axis2.tickSize = function(_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis2) : tickSizeInner;
  };
  axis2.tickSizeInner = function(_) {
    return arguments.length ? (tickSizeInner = +_, axis2) : tickSizeInner;
  };
  axis2.tickSizeOuter = function(_) {
    return arguments.length ? (tickSizeOuter = +_, axis2) : tickSizeOuter;
  };
  axis2.tickPadding = function(_) {
    return arguments.length ? (tickPadding = +_, axis2) : tickPadding;
  };
  axis2.offset = function(_) {
    return arguments.length ? (offset = +_, axis2) : offset;
  };
  return axis2;
}
function axisBottom(scale) {
  return axis(bottom, scale);
}
function axisLeft(scale) {
  return axis(left, scale);
}

// node_modules/d3-dispatch/src/dispatch.js
var noop = { value: () => {
} };
function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t))
      throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0)
      name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t))
      throw new Error("unknown type: " + t);
    return { type: t, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._, T = parseTypenames(typename + "", _), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n)
        if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name)))
          return t;
      return;
    }
    if (callback != null && typeof callback !== "function")
      throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type)
        _[t] = set(_[t], typename.name, callback);
      else if (callback == null)
        for (t in _)
          _[t] = set(_[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy2 = {}, _ = this._;
    for (var t in _)
      copy2[t] = _[t].slice();
    return new Dispatch(copy2);
  },
  call: function(type2, that) {
    if ((n = arguments.length - 2) > 0)
      for (var args = new Array(n), i = 0, n, t; i < n; ++i)
        args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (t = this._[type2], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  },
  apply: function(type2, that, args) {
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (var t = this._[type2], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  }
};
function get(type2, name) {
  for (var i = 0, n = type2.length, c; i < n; ++i) {
    if ((c = type2[i]).name === name) {
      return c.value;
    }
  }
}
function set(type2, name, callback) {
  for (var i = 0, n = type2.length; i < n; ++i) {
    if (type2[i].name === name) {
      type2[i] = noop, type2 = type2.slice(0, i).concat(type2.slice(i + 1));
      break;
    }
  }
  if (callback != null)
    type2.push({ name, value: callback });
  return type2;
}
var dispatch_default = dispatch;

// node_modules/d3-selection/src/namespaces.js
var xhtml = "http://www.w3.org/1999/xhtml";
var namespaces_default = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

// node_modules/d3-selection/src/namespace.js
function namespace_default(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns")
    name = name.slice(i + 1);
  return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name } : name;
}

// node_modules/d3-selection/src/creator.js
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator_default(name) {
  var fullname = namespace_default(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}

// node_modules/d3-selection/src/selector.js
function none() {
}
function selector_default(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

// node_modules/d3-selection/src/selection/select.js
function select_default(select) {
  if (typeof select !== "function")
    select = selector_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/array.js
function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}

// node_modules/d3-selection/src/selectorAll.js
function empty() {
  return [];
}
function selectorAll_default(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}

// node_modules/d3-selection/src/selection/selectAll.js
function arrayAll(select) {
  return function() {
    return array(select.apply(this, arguments));
  };
}
function selectAll_default(select) {
  if (typeof select === "function")
    select = arrayAll(select);
  else
    select = selectorAll_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }
  return new Selection(subgroups, parents);
}

// node_modules/d3-selection/src/matcher.js
function matcher_default(selector) {
  return function() {
    return this.matches(selector);
  };
}
function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}

// node_modules/d3-selection/src/selection/selectChild.js
var find = Array.prototype.find;
function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selectChild_default(match) {
  return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/d3-selection/src/selection/selectChildren.js
var filter = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}
function selectChildren_default(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/d3-selection/src/selection/filter.js
function filter_default(match) {
  if (typeof match !== "function")
    match = matcher_default(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/selection/sparse.js
function sparse_default(update) {
  return new Array(update.length);
}

// node_modules/d3-selection/src/selection/enter.js
function enter_default() {
  return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector) {
    return this._parent.querySelector(selector);
  },
  querySelectorAll: function(selector) {
    return this._parent.querySelectorAll(selector);
  }
};

// node_modules/d3-selection/src/constant.js
function constant_default(x) {
  return function() {
    return x;
  };
}

// node_modules/d3-selection/src/selection/data.js
function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0, node, groupLength = group.length, dataLength = data.length;
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}
function bindKey(parent, group, enter, update, exit, data, key) {
  var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
      exit[i] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function data_default(value, key) {
  if (!arguments.length)
    return Array.from(this, datum);
  var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
  if (typeof value !== "function")
    value = constant_default(value);
  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j], group = groups[j], groupLength = group.length, data = arraylike(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1)
          i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength)
          ;
        previous._next = next || null;
      }
    }
  }
  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}

// node_modules/d3-selection/src/selection/exit.js
function exit_default() {
  return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
}

// node_modules/d3-selection/src/selection/join.js
function join_default(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter)
      enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update)
      update = update.selection();
  }
  if (onexit == null)
    exit.remove();
  else
    onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}

// node_modules/d3-selection/src/selection/merge.js
function merge_default(context) {
  var selection2 = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection(merges, this._parents);
}

// node_modules/d3-selection/src/selection/order.js
function order_default() {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4)
          next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/sort.js
function sort_default(compare) {
  if (!compare)
    compare = ascending2;
  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }
  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection(sortgroups, this._parents).order();
}
function ascending2(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

// node_modules/d3-selection/src/selection/call.js
function call_default() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

// node_modules/d3-selection/src/selection/nodes.js
function nodes_default() {
  return Array.from(this);
}

// node_modules/d3-selection/src/selection/node.js
function node_default() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node)
        return node;
    }
  }
  return null;
}

// node_modules/d3-selection/src/selection/size.js
function size_default() {
  let size = 0;
  for (const node of this)
    ++size;
  return size;
}

// node_modules/d3-selection/src/selection/empty.js
function empty_default() {
  return !this.node();
}

// node_modules/d3-selection/src/selection/each.js
function each_default(callback) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i])
        callback.call(node, node.__data__, i, group);
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/attr.js
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.removeAttribute(name);
    else
      this.setAttribute(name, v);
  };
}
function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.removeAttributeNS(fullname.space, fullname.local);
    else
      this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
function attr_default(name, value) {
  var fullname = namespace_default(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
}

// node_modules/d3-selection/src/window.js
function window_default(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}

// node_modules/d3-selection/src/selection/style.js
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.style.removeProperty(name);
    else
      this.style.setProperty(name, v, priority);
  };
}
function style_default(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || window_default(node).getComputedStyle(node, null).getPropertyValue(name);
}

// node_modules/d3-selection/src/selection/property.js
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      delete this[name];
    else
      this[name] = v;
  };
}
function property_default(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}

// node_modules/d3-selection/src/selection/classed.js
function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n)
    list.add(names[i]);
}
function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n)
    list.remove(names[i]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function classed_default(name, value) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n)
      if (!list.contains(names[i]))
        return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}

// node_modules/d3-selection/src/selection/text.js
function textRemove() {
  this.textContent = "";
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}
function text_default(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
}

// node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}
function html_default(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}

// node_modules/d3-selection/src/selection/raise.js
function raise() {
  if (this.nextSibling)
    this.parentNode.appendChild(this);
}
function raise_default() {
  return this.each(raise);
}

// node_modules/d3-selection/src/selection/lower.js
function lower() {
  if (this.previousSibling)
    this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function lower_default() {
  return this.each(lower);
}

// node_modules/d3-selection/src/selection/append.js
function append_default(name) {
  var create2 = typeof name === "function" ? name : creator_default(name);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}

// node_modules/d3-selection/src/selection/insert.js
function constantNull() {
  return null;
}
function insert_default(name, before) {
  var create2 = typeof name === "function" ? name : creator_default(name), select = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

// node_modules/d3-selection/src/selection/remove.js
function remove() {
  var parent = this.parentNode;
  if (parent)
    parent.removeChild(this);
}
function remove_default() {
  return this.each(remove);
}

// node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function clone_default(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

// node_modules/d3-selection/src/selection/datum.js
function datum_default(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}

// node_modules/d3-selection/src/selection/on.js
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames2(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0)
      name = t.slice(i + 1), t = t.slice(0, i);
    return { type: t, name };
  });
}
function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on)
      return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i)
      on.length = i;
    else
      delete this.__on;
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on)
      for (var j = 0, m = on.length; j < m; ++j) {
        if ((o = on[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
          this.addEventListener(o.type, o.listener = listener, o.options = options);
          o.value = value;
          return;
        }
      }
    this.addEventListener(typename.type, listener, options);
    o = { type: typename.type, name: typename.name, value, listener, options };
    if (!on)
      this.__on = [o];
    else
      on.push(o);
  };
}
function on_default(typename, value, options) {
  var typenames = parseTypenames2(typename + ""), i, n = typenames.length, t;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on)
      for (var j = 0, m = on.length, o; j < m; ++j) {
        for (i = 0, o = on[j]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
    return;
  }
  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i)
    this.each(on(typenames[i], value, options));
  return this;
}

// node_modules/d3-selection/src/selection/dispatch.js
function dispatchEvent(node, type2, params) {
  var window2 = window_default(node), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type2, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params)
      event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;
    else
      event.initEvent(type2, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params);
  };
}
function dispatchFunction(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params.apply(this, arguments));
  };
}
function dispatch_default2(type2, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
}

// node_modules/d3-selection/src/selection/iterator.js
function* iterator_default() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i])
        yield node;
    }
  }
}

// node_modules/d3-selection/src/selection/index.js
var root = [null];
function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection() {
  return new Selection([[document.documentElement]], root);
}
function selection_selection() {
  return this;
}
Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: select_default,
  selectAll: selectAll_default,
  selectChild: selectChild_default,
  selectChildren: selectChildren_default,
  filter: filter_default,
  data: data_default,
  enter: enter_default,
  exit: exit_default,
  join: join_default,
  merge: merge_default,
  selection: selection_selection,
  order: order_default,
  sort: sort_default,
  call: call_default,
  nodes: nodes_default,
  node: node_default,
  size: size_default,
  empty: empty_default,
  each: each_default,
  attr: attr_default,
  style: style_default,
  property: property_default,
  classed: classed_default,
  text: text_default,
  html: html_default,
  raise: raise_default,
  lower: lower_default,
  append: append_default,
  insert: insert_default,
  remove: remove_default,
  clone: clone_default,
  datum: datum_default,
  on: on_default,
  dispatch: dispatch_default2,
  [Symbol.iterator]: iterator_default
};
var selection_default = selection;

// node_modules/d3-selection/src/select.js
function select_default2(selector) {
  return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
}

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m, l;
  format2 = (format2 + "").trim().toLowerCase();
  return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0)
    r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s, l, a) {
  if (a <= 0)
    h = s = l = NaN;
  else if (l <= 0 || l >= 1)
    h = s = NaN;
  else if (s <= 0)
    h = NaN;
  return new Hsl(h, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min2 = Math.min(r, g, b), max2 = Math.max(r, g, b), h = NaN, s = max2 - min2, l = (max2 + min2) / 2;
  if (s) {
    if (r === max2)
      h = (g - b) / s + (g < b) * 6;
    else if (g === max2)
      h = (b - r) / s + 2;
    else
      h = (r - g) / s + 4;
    s /= l < 0.5 ? max2 + min2 : 2 - max2 - min2;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

// node_modules/d3-interpolate/src/basis.js
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}
function basis_default(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default2 = (x) => () => x;

// node_modules/d3-interpolate/src/color.js
function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}
function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}
function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant_default2(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant_default2(isNaN(a) ? b : a);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y) {
  var color2 = gamma(y);
  function rgb2(start2, end) {
    var r = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
    return function(t) {
      start2.r = r(t);
      start2.g = g(t);
      start2.b = b(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
    for (i = 0; i < n; ++i) {
      color2 = rgb(colors[i]);
      r[i] = color2.r || 0;
      g[i] = color2.g || 0;
      b[i] = color2.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color2.opacity = 1;
    return function(t) {
      color2.r = r(t);
      color2.g = g(t);
      color2.b = b(t);
      return color2 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a, b) {
  if (!b)
    b = [];
  var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i)
      c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}
function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}

// node_modules/d3-interpolate/src/array.js
function genericArray(a, b) {
  var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
  for (i = 0; i < na; ++i)
    x[i] = value_default(a[i], b[i]);
  for (; i < nb; ++i)
    c[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i)
      c[i] = x[i](t);
    return c;
  };
}

// node_modules/d3-interpolate/src/date.js
function date_default(a, b) {
  var d = /* @__PURE__ */ new Date();
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}

// node_modules/d3-interpolate/src/number.js
function number_default(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}

// node_modules/d3-interpolate/src/object.js
function object_default(a, b) {
  var i = {}, c = {}, k;
  if (a === null || typeof a !== "object")
    a = {};
  if (b === null || typeof b !== "object")
    b = {};
  for (k in b) {
    if (k in a) {
      i[k] = value_default(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }
  return function(t) {
    for (k in i)
      c[k] = i[k](t);
    return c;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero2(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function string_default(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a = a + "", b = b + "";
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s[i])
        s[i] += bs;
      else
        s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i])
        s[i] += bm;
      else
        s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({ i, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i])
      s[i] += bs;
    else
      s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one(q[0].x) : zero2(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2)
      s[(o = q[i2]).i] = o.x(t);
    return s.join("");
  });
}

// node_modules/d3-interpolate/src/value.js
function value_default(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant_default2(b) : (t === "number" ? number_default : t === "string" ? (c = color(b)) ? (b = c, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a, b);
}

// node_modules/d3-interpolate/src/round.js
function round_default(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
}

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees = 180 / Math.PI;
var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b))
    a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d)
    c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d))
    c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c)
    a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? identity : decompose_default(m.a, m.b, m.c, m.d, m.e, m.f);
}
function parseSvg(value) {
  if (value == null)
    return identity;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate()))
    return identity;
  value = value.matrix;
  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180)
        b += 360;
      else if (b - a > 180)
        a += 360;
      q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number_default(a, b) });
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }
  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number_default(a, b) });
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a, b) {
    var s = [], q = [];
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n)
        s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t = new Timer();
  t.restart(callback, delay, time);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0)
      t._call.call(void 0, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time)
        time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}
function sleep(time) {
  if (frame)
    return;
  if (timeout)
    timeout = clearTimeout(timeout);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity)
      timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/d3-timer/src/timeout.js
function timeout_default(callback, delay, time) {
  var t = new Timer();
  delay = delay == null ? 0 : +delay;
  t.restart((elapsed) => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}

// node_modules/d3-transition/src/transition/schedule.js
var emptyOn = dispatch_default("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule_default(node, name, id2, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules)
    node.__transition = {};
  else if (id2 in schedules)
    return;
  create(node, id2, {
    name,
    index,
    // For context during callback.
    group,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init(node, id2) {
  var schedule = get2(node, id2);
  if (schedule.state > CREATED)
    throw new Error("too late; already scheduled");
  return schedule;
}
function set2(node, id2) {
  var schedule = get2(node, id2);
  if (schedule.state > STARTED)
    throw new Error("too late; already running");
  return schedule;
}
function get2(node, id2) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id2]))
    throw new Error("transition not found");
  return schedule;
}
function create(node, id2, self) {
  var schedules = node.__transition, tween;
  schedules[id2] = self;
  self.timer = timer(schedule, 0, self.time);
  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start2, self.delay, self.time);
    if (self.delay <= elapsed)
      start2(elapsed - self.delay);
  }
  function start2(elapsed) {
    var i, j, n, o;
    if (self.state !== SCHEDULED)
      return stop();
    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name)
        continue;
      if (o.state === STARTED)
        return timeout_default(start2);
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      } else if (+i < id2) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }
    timeout_default(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING)
      return;
    self.state = STARTED;
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }
  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1), i = -1, n = tween.length;
    while (++i < n) {
      tween[i].call(node, t);
    }
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }
  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id2];
    for (var i in schedules)
      return;
    delete node.__transition;
  }
}

// node_modules/d3-transition/src/interrupt.js
function interrupt_default(node, name) {
  var schedules = node.__transition, schedule, active, empty2 = true, i;
  if (!schedules)
    return;
  name = name == null ? null : name + "";
  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) {
      empty2 = false;
      continue;
    }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }
  if (empty2)
    delete node.__transition;
}

// node_modules/d3-transition/src/selection/interrupt.js
function interrupt_default2(name) {
  return this.each(function() {
    interrupt_default(this, name);
  });
}

// node_modules/d3-transition/src/transition/tween.js
function tweenRemove(id2, name) {
  var tween0, tween1;
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }
    schedule.tween = tween1;
  };
}
function tweenFunction(id2, name, value) {
  var tween0, tween1;
  if (typeof value !== "function")
    throw new Error();
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = { name, value }, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n)
        tween1.push(t);
    }
    schedule.tween = tween1;
  };
}
function tween_default(name, value) {
  var id2 = this._id;
  name += "";
  if (arguments.length < 2) {
    var tween = get2(this.node(), id2).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
}
function tweenValue(transition2, name, value) {
  var id2 = transition2._id;
  transition2.each(function() {
    var schedule = set2(this, id2);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });
  return function(node) {
    return get2(node, id2).value[name];
  };
}

// node_modules/d3-transition/src/transition/interpolate.js
function interpolate_default(a, b) {
  var c;
  return (typeof b === "number" ? number_default : b instanceof color ? rgb_default : (c = color(b)) ? (b = c, rgb_default) : string_default)(a, b);
}

// node_modules/d3-transition/src/transition/attr.js
function attrRemove2(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS2(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrConstantNS2(fullname, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attrFunctionNS2(fullname, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attr_default2(name, value) {
  var fullname = namespace_default(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i, value));
}

// node_modules/d3-transition/src/transition/attrTween.js
function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}
function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}
function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function attrTween_default(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  var fullname = namespace_default(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

// node_modules/d3-transition/src/transition/delay.js
function delayFunction(id2, value) {
  return function() {
    init(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init(this, id2).delay = value;
  };
}
function delay_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get2(this.node(), id2).delay;
}

// node_modules/d3-transition/src/transition/duration.js
function durationFunction(id2, value) {
  return function() {
    set2(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set2(this, id2).duration = value;
  };
}
function duration_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get2(this.node(), id2).duration;
}

// node_modules/d3-transition/src/transition/ease.js
function easeConstant(id2, value) {
  if (typeof value !== "function")
    throw new Error();
  return function() {
    set2(this, id2).ease = value;
  };
}
function ease_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get2(this.node(), id2).ease;
}

// node_modules/d3-transition/src/transition/easeVarying.js
function easeVarying(id2, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function")
      throw new Error();
    set2(this, id2).ease = v;
  };
}
function easeVarying_default(value) {
  if (typeof value !== "function")
    throw new Error();
  return this.each(easeVarying(this._id, value));
}

// node_modules/d3-transition/src/transition/filter.js
function filter_default2(match) {
  if (typeof match !== "function")
    match = matcher_default(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/merge.js
function merge_default2(transition2) {
  if (transition2._id !== this._id)
    throw new Error();
  for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/on.js
function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0)
      t = t.slice(0, i);
    return !t || t === "start";
  });
}
function onFunction(id2, name, listener) {
  var on0, on1, sit = start(name) ? init : set2;
  return function() {
    var schedule = sit(this, id2), on = schedule.on;
    if (on !== on0)
      (on1 = (on0 = on).copy()).on(name, listener);
    schedule.on = on1;
  };
}
function on_default2(name, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get2(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
}

// node_modules/d3-transition/src/transition/remove.js
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition)
      if (+i !== id2)
        return;
    if (parent)
      parent.removeChild(this);
  };
}
function remove_default2() {
  return this.on("end.remove", removeFunction(this._id));
}

// node_modules/d3-transition/src/transition/select.js
function select_default3(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function")
    select = selector_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule_default(subgroup[i], name, id2, i, subgroup, get2(node, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name, id2);
}

// node_modules/d3-transition/src/transition/selectAll.js
function selectAll_default2(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function")
    select = selectorAll_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children2 = select.call(node, node.__data__, i, group), child, inherit2 = get2(node, id2), k = 0, l = children2.length; k < l; ++k) {
          if (child = children2[k]) {
            schedule_default(child, name, id2, k, children2, inherit2);
          }
        }
        subgroups.push(children2);
        parents.push(node);
      }
    }
  }
  return new Transition(subgroups, parents, name, id2);
}

// node_modules/d3-transition/src/transition/selection.js
var Selection2 = selection_default.prototype.constructor;
function selection_default2() {
  return new Selection2(this._groups, this._parents);
}

// node_modules/d3-transition/src/transition/style.js
function styleNull(name, interpolate) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}
function styleRemove2(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function styleFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
    if (value1 == null)
      string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove2;
  return function() {
    var schedule = set2(this, id2), on = schedule.on, listener = schedule.value[key] == null ? remove2 || (remove2 = styleRemove2(name)) : void 0;
    if (on !== on0 || listener0 !== listener)
      (on1 = (on0 = on).copy()).on(event, listener0 = listener);
    schedule.on = on1;
  };
}
function style_default2(name, value, priority) {
  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate_default;
  return value == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove2(name)) : typeof value === "function" ? this.styleTween(name, styleFunction2(name, i, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant2(name, i, value), priority).on("end.style." + name, null);
}

// node_modules/d3-transition/src/transition/styleTween.js
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}
function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}
function styleTween_default(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}

// node_modules/d3-transition/src/transition/text.js
function textConstant2(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction2(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function text_default2(value) {
  return this.tween("text", typeof value === "function" ? textFunction2(tweenValue(this, "text", value)) : textConstant2(value == null ? "" : value + ""));
}

// node_modules/d3-transition/src/transition/textTween.js
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}
function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function textTween_default(value) {
  var key = "text";
  if (arguments.length < 1)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, textTween(value));
}

// node_modules/d3-transition/src/transition/transition.js
function transition_default() {
  var name = this._name, id0 = this._id, id1 = newId();
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit2 = get2(node, id0);
        schedule_default(node, name, id1, i, group, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
    }
  }
  return new Transition(groups, this._parents, name, id1);
}

// node_modules/d3-transition/src/transition/end.js
function end_default() {
  var on0, on1, that = this, id2 = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = { value: reject }, end = { value: function() {
      if (--size === 0)
        resolve();
    } };
    that.each(function() {
      var schedule = set2(this, id2), on = schedule.on;
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule.on = on1;
    });
    if (size === 0)
      resolve();
  });
}

// node_modules/d3-transition/src/transition/index.js
var id = 0;
function Transition(groups, parents, name, id2) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id2;
}
function transition(name) {
  return selection_default().transition(name);
}
function newId() {
  return ++id;
}
var selection_prototype = selection_default.prototype;
Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: select_default3,
  selectAll: selectAll_default2,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: filter_default2,
  merge: merge_default2,
  selection: selection_default2,
  transition: transition_default,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: on_default2,
  attr: attr_default2,
  attrTween: attrTween_default,
  style: style_default2,
  styleTween: styleTween_default,
  text: text_default2,
  textTween: textTween_default,
  remove: remove_default2,
  tween: tween_default,
  delay: delay_default,
  duration: duration_default,
  ease: ease_default,
  easeVarying: easeVarying_default,
  end: end_default,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};

// node_modules/d3-ease/src/cubic.js
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

// node_modules/d3-transition/src/selection/transition.js
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node, id2) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id2])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id2} not found`);
    }
  }
  return timing;
}
function transition_default2(name) {
  var id2, timing;
  if (name instanceof Transition) {
    id2 = name._id, name = name._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule_default(node, name, id2, i, group, timing || inherit(node, id2));
      }
    }
  }
  return new Transition(groups, this._parents, name, id2);
}

// node_modules/d3-transition/src/selection/index.js
selection_default.prototype.interrupt = interrupt_default2;
selection_default.prototype.transition = transition_default2;

// node_modules/d3-brush/src/brush.js
var { abs, max, min } = Math;
function number1(e) {
  return [+e[0], +e[1]];
}
function number22(e) {
  return [number1(e[0]), number1(e[1])];
}
var X = {
  name: "x",
  handles: ["w", "e"].map(type),
  input: function(x, e) {
    return x == null ? null : [[+x[0], e[0][1]], [+x[1], e[1][1]]];
  },
  output: function(xy) {
    return xy && [xy[0][0], xy[1][0]];
  }
};
var Y = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function(y, e) {
    return y == null ? null : [[e[0][0], +y[0]], [e[1][0], +y[1]]];
  },
  output: function(xy) {
    return xy && [xy[0][1], xy[1][1]];
  }
};
var XY = {
  name: "xy",
  handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
  input: function(xy) {
    return xy == null ? null : number22(xy);
  },
  output: function(xy) {
    return xy;
  }
};
function type(t) {
  return { type: t };
}

// node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x) {
  return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
}
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}

// node_modules/d3-format/src/exponent.js
function exponent_default(x) {
  return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
}

// node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value, width) {
    var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
    while (i > 0 && g > 0) {
      if (length + g + 1 > width)
        g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width)
        break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}

// node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s) {
  out:
    for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (!+s[i])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

// node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d)
    return x + "";
  var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0];
}

// node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d)
    return x + "";
  var coefficient = d[0], exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": (x, p) => (x * 100).toFixed(p),
  "b": (x) => Math.round(x).toString(2),
  "c": (x) => x + "",
  "d": formatDecimal_default,
  "e": (x, p) => x.toExponential(p),
  "f": (x, p) => x.toFixed(p),
  "g": (x, p) => x.toPrecision(p),
  "o": (x) => Math.round(x).toString(8),
  "p": (x, p) => formatRounded_default(x * 100, p),
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": (x) => Math.round(x).toString(16).toUpperCase(),
  "x": (x) => Math.round(x).toString(16)
};

// node_modules/d3-format/src/identity.js
function identity_default2(x) {
  return x;
}

// node_modules/d3-format/src/locale.js
var map = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale2) {
  var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity_default2 : formatGroup_default(map.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity_default2 : formatNumerals_default(map.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "\u2212" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero3 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type2 = specifier.type;
    if (type2 === "n")
      comma = true, type2 = "g";
    else if (!formatTypes_default[type2])
      precision === void 0 && (precision = 12), trim = true, type2 = "g";
    if (zero3 || fill === "0" && align === "=")
      zero3 = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
    var formatType = formatTypes_default[type2], maybeSuffix = /[defgprs%]/.test(type2);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
      if (type2 === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim)
          value = formatTrim_default(value);
        if (valueNegative && +value === 0 && sign !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type2 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero3)
        value = group(value, Infinity);
      var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
      if (comma && zero3)
        value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
    return function(value2) {
      return f(k * value2) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// node_modules/d3-format/src/defaultLocale.js
var locale;
var format;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = locale_default(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default(step) {
  return Math.max(0, -exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionRound.js
function precisionRound_default(step, max2) {
  step = Math.abs(step), max2 = Math.abs(max2) - step;
  return Math.max(0, exponent_default(max2) - exponent_default(step)) + 1;
}

// node_modules/d3-scale/src/init.js
function initRange(domain, range) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range).domain(domain);
      break;
  }
  return this;
}

// node_modules/d3-scale/src/ordinal.js
var implicit = Symbol("implicit");
function ordinal() {
  var index = new InternMap(), domain = [], range = [], unknown = implicit;
  function scale(d) {
    let i = index.get(d);
    if (i === void 0) {
      if (unknown !== implicit)
        return unknown;
      index.set(d, i = domain.push(d) - 1);
    }
    return range[i % range.length];
  }
  scale.domain = function(_) {
    if (!arguments.length)
      return domain.slice();
    domain = [], index = new InternMap();
    for (const value of _) {
      if (index.has(value))
        continue;
      index.set(value, domain.push(value) - 1);
    }
    return scale;
  };
  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), scale) : range.slice();
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.copy = function() {
    return ordinal(domain, range).unknown(unknown);
  };
  initRange.apply(scale, arguments);
  return scale;
}

// node_modules/d3-scale/src/constant.js
function constants(x) {
  return function() {
    return x;
  };
}

// node_modules/d3-scale/src/number.js
function number3(x) {
  return +x;
}

// node_modules/d3-scale/src/continuous.js
var unit = [0, 1];
function identity2(x) {
  return x;
}
function normalize(a, b) {
  return (b -= a = +a) ? function(x) {
    return (x - a) / b;
  } : constants(isNaN(b) ? NaN : 0.5);
}
function clamper(a, b) {
  var t;
  if (a > b)
    t = a, a = b, b = t;
  return function(x) {
    return Math.max(a, Math.min(b, x));
  };
}
function bimap(domain, range, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0)
    d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else
    d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x) {
    return r0(d0(x));
  };
}
function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1, d = new Array(j), r = new Array(j), i = -1;
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }
  return function(x) {
    var i2 = bisect_default(domain, x, 1, j) - 1;
    return r[i2](d[i2](x));
  };
}
function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer() {
  var domain = unit, range = unit, interpolate = value_default, transform2, untransform, unknown, clamp = identity2, piecewise, output, input;
  function rescale() {
    var n = Math.min(domain.length, range.length);
    if (clamp !== identity2)
      clamp = clamper(domain[0], domain[n - 1]);
    piecewise = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }
  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform2), range, interpolate)))(transform2(clamp(x)));
  }
  scale.invert = function(y) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform2), number_default)))(y)));
  };
  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, number3), rescale()) : domain.slice();
  };
  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };
  scale.rangeRound = function(_) {
    return range = Array.from(_), interpolate = round_default, rescale();
  };
  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? true : identity2, rescale()) : clamp !== identity2;
  };
  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function(t, u) {
    transform2 = t, untransform = u;
    return rescale();
  };
}
function continuous() {
  return transformer()(identity2, identity2);
}

// node_modules/d3-scale/src/tickFormat.js
function tickFormat(start2, stop, count, specifier) {
  var step = tickStep(start2, stop, count), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start2), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value)))
        specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start2), Math.abs(stop)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}

// node_modules/d3-scale/src/linear.js
function linearish(scale) {
  var domain = scale.domain;
  scale.ticks = function(count) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
  };
  scale.tickFormat = function(count, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };
  scale.nice = function(count) {
    if (count == null)
      count = 10;
    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start2 = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start2) {
      step = start2, start2 = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start2, stop, count);
      if (step === prestep) {
        d[i0] = start2;
        d[i1] = stop;
        return domain(d);
      } else if (step > 0) {
        start2 = Math.floor(start2 / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start2 = Math.ceil(start2 * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale;
  };
  return scale;
}
function linear2() {
  var scale = continuous();
  scale.copy = function() {
    return copy(scale, linear2());
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}

// node_modules/d3-scale-chromatic/src/colors.js
function colors_default(specifier) {
  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
  while (i < n)
    colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
  return colors;
}

// node_modules/d3-scale-chromatic/src/categorical/category10.js
var category10_default = colors_default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

// node_modules/d3-zoom/src/transform.js
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity3 = new Transform(1, 0, 0);
transform.prototype = Transform.prototype;
function transform(node) {
  while (!node.__zoom)
    if (!(node = node.parentNode))
      return identity3;
  return node.__zoom;
}

// src/views/TimelineModal.ts
var TimelineModal = class extends import_obsidian14.Modal {
  constructor(app, events, timeConfig) {
    super(app);
    this.events = events;
    this.timeConfig = timeConfig;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("story-engine-timeline-modal");
    contentEl.createEl("h2", { text: "World Timeline" });
    const chartContainer = contentEl.createDiv({ cls: "story-engine-timeline-chart" });
    this.renderTimeline(chartContainer);
  }
  renderTimeline(container) {
    if (this.events.length === 0) {
      container.createEl("p", { text: "No events with timeline data found." });
      return;
    }
    const width = 800;
    const height = 400;
    const margin = { top: 20, right: 30, bottom: 50, left: 60 };
    const svg = select_default2(container).append("svg").attr("width", width).attr("height", height);
    const eventsWithPosition = this.events.map((e, i) => {
      var _a, _b, _c;
      return {
        ...e,
        timeline_position: (_a = e.timeline_position) != null ? _a : i * 10,
        parent_id: (_b = e.parent_id) != null ? _b : null,
        is_epoch: (_c = e.is_epoch) != null ? _c : false
      };
    });
    const xExtent = extent(eventsWithPosition, (d) => d.timeline_position);
    const xScale = linear2().domain([xExtent[0] - 1, xExtent[1] + 1]).range([margin.left, width - margin.right]);
    const yScale = linear2().domain([0, 10]).range([height - margin.bottom, margin.top]);
    const colorScale = ordinal(category10_default);
    svg.append("g").attr("transform", `translate(0,${height - margin.bottom})`).call(axisBottom(xScale).tickFormat((d) => `Year ${d}`));
    svg.append("g").attr("transform", `translate(${margin.left},0)`).call(axisLeft(yScale).tickFormat((d) => `Imp ${d}`));
    const eventsWithParent = eventsWithPosition.filter((e) => e.parent_id);
    svg.selectAll("line.parent-link").data(eventsWithParent).join("line").attr("class", "parent-link").attr("x1", (d) => {
      const parent = eventsWithPosition.find((e) => e.id === d.parent_id);
      return parent ? xScale(parent.timeline_position) : 0;
    }).attr("y1", (d) => {
      const parent = eventsWithPosition.find((e) => e.id === d.parent_id);
      return parent ? yScale(parent.importance) : 0;
    }).attr("x2", (d) => xScale(d.timeline_position)).attr("y2", (d) => yScale(d.importance)).attr("stroke", "#999").attr("stroke-dasharray", "4,2").attr("stroke-width", 1);
    svg.selectAll("circle").data(eventsWithPosition).join("circle").attr("cx", (d) => xScale(d.timeline_position)).attr("cy", (d) => yScale(d.importance)).attr("r", (d) => d.is_epoch ? 10 : 6).attr("fill", (d) => colorScale(d.type || "default")).attr("stroke", (d) => d.is_epoch ? "gold" : "none").attr("stroke-width", 3).style("cursor", "pointer").on("click", (_event, d) => this.showEventDetails(d)).append("title").text((d) => `${d.name} (Year ${d.timeline_position})`);
    svg.selectAll("text.event-label").data(eventsWithPosition.filter((e) => e.importance >= 8)).join("text").attr("class", "event-label").attr("x", (d) => xScale(d.timeline_position)).attr("y", (d) => yScale(d.importance) - 12).attr("text-anchor", "middle").attr("font-size", "10px").text((d) => d.name.substring(0, 15) + (d.name.length > 15 ? "..." : ""));
  }
  showEventDetails(event) {
    var _a;
    new import_obsidian14.Notice(`Event: ${event.name}
Year: ${(_a = event.timeline_position) != null ? _a : "N/A"}
Importance: ${event.importance}`);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/CharacterDetailsView.ts
var import_obsidian15 = require("obsidian");
var CharacterDetailsView = class {
  constructor(plugin, character, headerEl, contentEl, onBack, onEditCharacter, world = null, characters = [], archetypes = [], traits = [], events = []) {
    // State
    this.characterTab = "overview";
    this.characterTraits = [];
    this.characterEvents = [];
    this.characterScenes = [];
    this.characterRelationships = [];
    this.plugin = plugin;
    this.character = character;
    this.world = world;
    this.characters = characters;
    this.archetypes = archetypes;
    this.traits = traits;
    this.events = events;
    this.headerEl = headerEl;
    this.contentEl = contentEl;
    this.onBack = onBack;
    this.onEditCharacter = onEditCharacter;
  }
  async render() {
    await this.loadCharacterData();
    this.renderHeader();
    this.renderTabs();
    this.renderTabContent();
  }
  async loadCharacterData() {
    try {
      this.characterTraits = await this.plugin.apiClient.getCharacterTraits(this.character.id);
      const eventCharacters = await this.plugin.apiClient.getCharacterEvents(this.character.id);
      this.characterEvents = await Promise.all(
        eventCharacters.map(async (ec) => {
          const event = await this.plugin.apiClient.getEvent(ec.event_id);
          return { event, role: ec.role || void 0 };
        })
      );
      this.characterRelationships = await this.plugin.apiClient.getCharacterRelationships(this.character.id);
      this.characterScenes = [];
      if (this.world) {
        const allStories = await this.plugin.apiClient.listStories();
        const worldStories = allStories.filter((s) => s.world_id === this.world.id);
        for (const story of worldStories) {
          const scenes = await this.plugin.apiClient.getScenesByStory(story.id);
          const povScenes = scenes.filter((s) => s.pov_character_id === this.character.id);
          for (const scene of povScenes) {
            this.characterScenes.push({ scene, story, type: "pov" });
          }
          for (const scene of scenes) {
            const refs = await this.plugin.apiClient.getSceneReferences(scene.id);
            const charRef = refs.find(
              (r) => r.entity_type === "character" && r.entity_id === this.character.id
            );
            if (charRef) {
              this.characterScenes.push({ scene, story, type: "coadjuvante" });
            }
          }
        }
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to load character data";
      new import_obsidian15.Notice(`Error: ${errorMessage}`, 5e3);
    }
  }
  renderHeader() {
    if (!this.headerEl)
      return;
    this.headerEl.empty();
    const headerLeft = this.headerEl.createDiv({ cls: "story-engine-header-left" });
    const backButton = headerLeft.createEl("button", {
      text: "\u2190 Back",
      cls: "story-engine-back-btn"
    });
    backButton.onclick = () => {
      this.onBack();
    };
    const titleDiv = headerLeft.createDiv({ cls: "story-engine-header-title" });
    titleDiv.createEl("h2", { text: this.character.name });
    if (this.character.archetype_id) {
      const archetype = this.archetypes.find((a) => a.id === this.character.archetype_id);
      if (archetype) {
        const archetypePill = titleDiv.createSpan({ cls: "story-engine-badge" });
        archetypePill.textContent = archetype.name;
      }
    }
    const uuidDiv = headerLeft.createDiv({ cls: "story-engine-uuid" });
    uuidDiv.createEl("span", { text: this.character.id });
    const copyIcon = uuidDiv.createEl("span", { cls: "story-engine-copy-icon" });
    (0, import_obsidian15.setIcon)(copyIcon, "copy");
    copyIcon.onclick = () => {
      navigator.clipboard.writeText(this.character.id);
      new import_obsidian15.Notice("UUID copied to clipboard");
    };
    const headerRight = this.headerEl.createDiv({ cls: "story-engine-header-right" });
    const menuButton = headerRight.createEl("button", { text: "Edit Character" });
    menuButton.onclick = () => {
      this.onEditCharacter(this.character);
    };
  }
  renderTabs() {
    if (!this.contentEl)
      return;
    const existingTabs = this.contentEl.querySelector(".story-engine-tabs");
    if (existingTabs) {
      existingTabs.remove();
    }
    const tabsContainer = this.contentEl.createDiv({ cls: "story-engine-tabs" });
    const tabs = [
      { key: "overview", label: "Overview" },
      { key: "traits", label: "Traits" },
      { key: "events", label: "Events" },
      { key: "scenes", label: "Scenes" },
      { key: "relationships", label: "Relationships" }
    ];
    for (const tab of tabs) {
      const tabEl = tabsContainer.createEl("button", {
        text: tab.label,
        cls: this.characterTab === tab.key ? "story-engine-tab-active" : "story-engine-tab"
      });
      tabEl.onclick = () => {
        this.characterTab = tab.key;
        this.renderTabContent();
      };
    }
  }
  renderTabContent() {
    if (!this.contentEl)
      return;
    const existingContainer = this.contentEl.querySelector(".story-engine-tab-content");
    if (existingContainer) {
      existingContainer.remove();
    }
    const contentContainer = this.contentEl.createDiv({ cls: "story-engine-tab-content" });
    switch (this.characterTab) {
      case "overview":
        this.renderOverviewTab(contentContainer);
        break;
      case "traits":
        this.renderTraitsTab(contentContainer);
        break;
      case "events":
        this.renderEventsTab(contentContainer);
        break;
      case "scenes":
        this.renderScenesTab(contentContainer);
        break;
      case "relationships":
        this.renderRelationshipsTab(contentContainer);
        break;
    }
  }
  renderOverviewTab(container) {
    const descSection = container.createDiv({ cls: "story-engine-section" });
    descSection.createEl("h3", { text: "Description" });
    const descTextarea = descSection.createEl("textarea", {
      cls: "story-engine-textarea",
      attr: { rows: "5" }
    });
    descTextarea.value = this.character.description || "";
    descTextarea.placeholder = "Enter character description...";
    const descActions = descSection.createDiv({ cls: "story-engine-actions" });
    const saveDescBtn = descActions.createEl("button", { text: "Save Description", cls: "mod-cta" });
    saveDescBtn.onclick = async () => {
      try {
        const updated = await this.plugin.apiClient.updateCharacter(this.character.id, {
          description: descTextarea.value
        });
        this.character = updated;
        new import_obsidian15.Notice("Description saved");
      } catch (err) {
        new import_obsidian15.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    const archetypeSection = container.createDiv({ cls: "story-engine-section" });
    archetypeSection.createEl("h3", { text: "Archetype" });
    const archetypeSelect = archetypeSection.createEl("select", { cls: "story-engine-select" });
    const noneOption = archetypeSelect.createEl("option", { text: "None", value: "" });
    if (!this.character.archetype_id) {
      noneOption.selected = true;
    }
    for (const archetype of this.archetypes) {
      const option = archetypeSelect.createEl("option", {
        text: archetype.name,
        value: archetype.id
      });
      if (this.character.archetype_id === archetype.id) {
        option.selected = true;
      }
    }
    const archetypeActions = archetypeSection.createDiv({ cls: "story-engine-actions" });
    const saveArchetypeBtn = archetypeActions.createEl("button", { text: "Save Archetype", cls: "mod-cta" });
    saveArchetypeBtn.onclick = async () => {
      try {
        const archetypeId = archetypeSelect.value || null;
        const updated = await this.plugin.apiClient.updateCharacter(this.character.id, {
          archetype_id: archetypeId
        });
        this.character = updated;
        await this.loadCharacterData();
        this.renderHeader();
        this.renderTabContent();
        new import_obsidian15.Notice("Archetype saved");
      } catch (err) {
        new import_obsidian15.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
  }
  renderTraitsTab(container) {
    const actionsBar = container.createDiv({ cls: "story-engine-actions-bar" });
    const addBtn = actionsBar.createEl("button", { text: "Add Trait", cls: "mod-cta" });
    addBtn.onclick = () => {
      this.showAddTraitModal();
    };
    if (this.characterTraits.length === 0) {
      container.createEl("p", { text: "No traits assigned. Add a trait to get started!" });
      return;
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const charTrait of this.characterTraits) {
      const item = list.createDiv({ cls: "story-engine-item" });
      const titleRow = item.createDiv({ cls: "story-engine-title" });
      titleRow.createEl("strong", { text: charTrait.trait_name });
      const categoryPill = titleRow.createSpan({ cls: "story-engine-badge" });
      categoryPill.textContent = charTrait.trait_category;
      const meta = item.createDiv({ cls: "story-engine-meta" });
      meta.createEl("span", { text: `Value: ${charTrait.value || "N/A"}` });
      if (charTrait.notes) {
        meta.createEl("span", { text: ` | Notes: ${charTrait.notes}` });
      }
      const actions = item.createDiv({ cls: "story-engine-item-actions" });
      actions.createEl("button", { text: "Edit" }).onclick = () => {
        this.showEditTraitModal(charTrait);
      };
      actions.createEl("button", { text: "Delete" }).onclick = async () => {
        if (confirm(`Remove trait "${charTrait.trait_name}"?`)) {
          try {
            await this.plugin.apiClient.removeCharacterTrait(this.character.id, charTrait.trait_id);
            await this.loadCharacterData();
            this.renderTabContent();
            new import_obsidian15.Notice("Trait removed");
          } catch (err) {
            new import_obsidian15.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
          }
        }
      };
    }
  }
  renderEventsTab(container) {
    const actionsBar = container.createDiv({ cls: "story-engine-actions-bar" });
    const addBtn = actionsBar.createEl("button", { text: "Add Event", cls: "mod-cta" });
    addBtn.onclick = () => {
      this.showAddEventModal();
    };
    if (this.characterEvents.length === 0) {
      container.createEl("p", { text: "No events assigned. Add an event to get started!" });
      return;
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const { event, role } of this.characterEvents) {
      const item = list.createDiv({ cls: "story-engine-item" });
      item.createDiv({ cls: "story-engine-title", text: event.name });
      const meta = item.createDiv({ cls: "story-engine-meta" });
      if (role) {
        meta.createEl("span", { text: `Role: ${role}` });
      }
      const actions = item.createDiv({ cls: "story-engine-item-actions" });
      actions.createEl("button", { text: "Edit Role" }).onclick = () => {
        this.showEditEventRoleModal(event, role);
      };
      actions.createEl("button", { text: "Remove" }).onclick = async () => {
        if (confirm(`Remove character from event "${event.name}"?`)) {
          try {
            await this.plugin.apiClient.removeEventCharacter(event.id, this.character.id);
            await this.loadCharacterData();
            this.renderTabContent();
            new import_obsidian15.Notice("Character removed from event");
          } catch (err) {
            new import_obsidian15.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
          }
        }
      };
    }
  }
  renderScenesTab(container) {
    if (this.characterScenes.length === 0) {
      container.createEl("p", { text: "No scenes found for this character." });
      return;
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const { scene, story, type: type2 } of this.characterScenes) {
      const item = list.createDiv({ cls: "story-engine-item" });
      const titleRow = item.createDiv({ cls: "story-engine-title" });
      titleRow.createEl("span", { text: scene.goal || "No goal" });
      const typePill = titleRow.createSpan({
        cls: type2 === "pov" ? "story-engine-badge story-engine-badge-green" : "story-engine-badge story-engine-badge-blue"
      });
      typePill.textContent = type2 === "pov" ? "POV" : "Coadjuvante";
      const meta = item.createDiv({ cls: "story-engine-meta" });
      meta.createEl("span", { text: `Story: ${story.title}` });
    }
  }
  renderRelationshipsTab(container) {
    const actionsBar = container.createDiv({ cls: "story-engine-actions-bar" });
    const addBtn = actionsBar.createEl("button", { text: "Add Relationship", cls: "mod-cta" });
    addBtn.onclick = () => {
      this.showAddRelationshipModal();
    };
    if (this.characterRelationships.length === 0) {
      container.createEl("p", { text: "No relationships defined. Add a relationship to get started!" });
      return;
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const rel of this.characterRelationships) {
      const otherCharId = rel.character1_id === this.character.id ? rel.character2_id : rel.character1_id;
      const otherChar = this.characters.find((c) => c.id === otherCharId);
      const otherCharName = otherChar ? otherChar.name : "Unknown";
      const item = list.createDiv({ cls: "story-engine-item" });
      const titleRow = item.createDiv({ cls: "story-engine-title" });
      titleRow.createEl("strong", { text: otherCharName });
      const typePill = titleRow.createSpan({ cls: "story-engine-badge" });
      typePill.textContent = rel.relationship_type;
      const directionIcon = titleRow.createSpan({ cls: "story-engine-direction" });
      directionIcon.textContent = rel.bidirectional ? "\u2194" : "\u2192";
      const meta = item.createDiv({ cls: "story-engine-meta" });
      if (rel.description) {
        meta.createEl("span", { text: rel.description });
      }
      const actions = item.createDiv({ cls: "story-engine-item-actions" });
      actions.createEl("button", { text: "Edit" }).onclick = () => {
        this.showEditRelationshipModal(rel);
      };
      actions.createEl("button", { text: "Delete" }).onclick = async () => {
        if (confirm(`Delete relationship with "${otherCharName}"?`)) {
          try {
            await this.plugin.apiClient.deleteCharacterRelationship(rel.id);
            await this.loadCharacterData();
            this.renderTabContent();
            new import_obsidian15.Notice("Relationship deleted");
          } catch (err) {
            new import_obsidian15.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
          }
        }
      };
    }
  }
  // Modal methods
  showAddTraitModal() {
    const modal = new import_obsidian15.Modal(this.plugin.app);
    modal.titleEl.textContent = "Add Trait";
    const content = modal.contentEl;
    content.createEl("p", { text: "Select a trait to add:" });
    const traitSelect = content.createEl("select", { cls: "story-engine-select" });
    const availableTraits = this.traits.filter(
      (t) => !this.characterTraits.some((ct) => ct.trait_id === t.id)
    );
    if (availableTraits.length === 0) {
      content.createEl("p", { text: "No available traits. Create a trait first!" });
      const buttonContainer2 = content.createDiv({ cls: "modal-button-container" });
      const closeBtn = buttonContainer2.createEl("button", { text: "Close" });
      closeBtn.onclick = () => modal.close();
      return;
    }
    for (const trait of availableTraits) {
      traitSelect.createEl("option", { text: `${trait.name} (${trait.category})`, value: trait.id });
    }
    const valueInput = content.createEl("input", {
      cls: "story-engine-input",
      attr: { type: "text", placeholder: "Value (optional)" }
    });
    const notesInput = content.createEl("textarea", {
      cls: "story-engine-textarea",
      attr: { rows: "3", placeholder: "Notes (optional)" }
    });
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Add", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      try {
        await this.plugin.apiClient.addCharacterTrait(
          this.character.id,
          traitSelect.value,
          valueInput.value || void 0,
          notesInput.value || void 0
        );
        await this.loadCharacterData();
        this.renderTabContent();
        modal.close();
        new import_obsidian15.Notice("Trait added");
      } catch (err) {
        new import_obsidian15.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => modal.close();
    modal.open();
  }
  showEditTraitModal(charTrait) {
    const modal = new import_obsidian15.Modal(this.plugin.app);
    modal.titleEl.textContent = "Edit Trait";
    const content = modal.contentEl;
    content.createEl("p", { text: `Editing: ${charTrait.trait_name}` });
    const valueInput = content.createEl("input", {
      cls: "story-engine-input",
      attr: { type: "text", placeholder: "Value" }
    });
    valueInput.value = charTrait.value || "";
    const notesInput = content.createEl("textarea", {
      cls: "story-engine-textarea",
      attr: { rows: "3", placeholder: "Notes" }
    });
    notesInput.value = charTrait.notes || "";
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      try {
        await this.plugin.apiClient.updateCharacterTrait(
          this.character.id,
          charTrait.trait_id,
          valueInput.value || void 0,
          notesInput.value || void 0
        );
        await this.loadCharacterData();
        this.renderTabContent();
        modal.close();
        new import_obsidian15.Notice("Trait updated");
      } catch (err) {
        new import_obsidian15.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => modal.close();
    modal.open();
  }
  showAddEventModal() {
    if (!this.world)
      return;
    const modal = new import_obsidian15.Modal(this.plugin.app);
    modal.titleEl.textContent = "Add Event";
    const content = modal.contentEl;
    content.createEl("p", { text: "Select an event:" });
    const eventSelect = content.createEl("select", { cls: "story-engine-select" });
    const availableEvents = this.events.filter(
      (e) => !this.characterEvents.some((ce) => ce.event.id === e.id)
    );
    if (availableEvents.length === 0) {
      content.createEl("p", { text: "No available events. Create an event first!" });
      const buttonContainer2 = content.createDiv({ cls: "modal-button-container" });
      const closeBtn = buttonContainer2.createEl("button", { text: "Close" });
      closeBtn.onclick = () => modal.close();
      return;
    }
    for (const event of availableEvents) {
      eventSelect.createEl("option", { text: event.name, value: event.id });
    }
    const roleInput = content.createEl("input", {
      cls: "story-engine-input",
      attr: { type: "text", placeholder: "Role (optional)" }
    });
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Add", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      try {
        await this.plugin.apiClient.addEventCharacter(
          eventSelect.value,
          this.character.id,
          roleInput.value || void 0
        );
        await this.loadCharacterData();
        this.renderTabContent();
        modal.close();
        new import_obsidian15.Notice("Character added to event");
      } catch (err) {
        new import_obsidian15.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => modal.close();
    modal.open();
  }
  showEditEventRoleModal(event, currentRole) {
    const modal = new import_obsidian15.Modal(this.plugin.app);
    modal.titleEl.textContent = "Edit Role";
    const content = modal.contentEl;
    content.createEl("p", { text: `Event: ${event.name}` });
    const roleInput = content.createEl("input", {
      cls: "story-engine-input",
      attr: { type: "text", placeholder: "Role" },
      value: currentRole || ""
    });
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      try {
        await this.plugin.apiClient.removeEventCharacter(event.id, this.character.id);
        await this.plugin.apiClient.addEventCharacter(
          event.id,
          this.character.id,
          roleInput.value || void 0
        );
        await this.loadCharacterData();
        this.renderTabContent();
        modal.close();
        new import_obsidian15.Notice("Role updated");
      } catch (err) {
        new import_obsidian15.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => modal.close();
    modal.open();
  }
  showAddRelationshipModal() {
    const modal = new import_obsidian15.Modal(this.plugin.app);
    modal.titleEl.textContent = "Add Relationship";
    const content = modal.contentEl;
    content.createEl("p", { text: "Select another character:" });
    const characterSelect = content.createEl("select", { cls: "story-engine-select" });
    const availableCharacters = this.characters.filter((c) => c.id !== this.character.id);
    if (availableCharacters.length === 0) {
      content.createEl("p", { text: "No other characters available." });
      const buttonContainer2 = content.createDiv({ cls: "modal-button-container" });
      const closeBtn = buttonContainer2.createEl("button", { text: "Close" });
      closeBtn.onclick = () => modal.close();
      return;
    }
    for (const char of availableCharacters) {
      characterSelect.createEl("option", { text: char.name, value: char.id });
    }
    const relationshipTypeSelect = content.createEl("select", { cls: "story-engine-select" });
    relationshipTypeSelect.createEl("option", { text: "Ally", value: "ally" });
    relationshipTypeSelect.createEl("option", { text: "Enemy", value: "enemy" });
    relationshipTypeSelect.createEl("option", { text: "Family", value: "family" });
    relationshipTypeSelect.createEl("option", { text: "Lover", value: "lover" });
    relationshipTypeSelect.createEl("option", { text: "Rival", value: "rival" });
    relationshipTypeSelect.createEl("option", { text: "Mentor", value: "mentor" });
    relationshipTypeSelect.createEl("option", { text: "Student", value: "student" });
    const descriptionInput = content.createEl("textarea", {
      cls: "story-engine-textarea",
      attr: { rows: "3", placeholder: "Description (optional)" }
    });
    const bidirectionalCheckbox = content.createEl("input", {
      attr: { type: "checkbox" }
    });
    bidirectionalCheckbox.checked = true;
    const bidirectionalLabel = content.createEl("label");
    bidirectionalLabel.appendChild(bidirectionalCheckbox);
    bidirectionalLabel.appendChild(document.createTextNode(" Bidirectional"));
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Add", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      try {
        await this.plugin.apiClient.createCharacterRelationship(this.character.id, {
          character1_id: this.character.id,
          character2_id: characterSelect.value,
          relationship_type: relationshipTypeSelect.value,
          description: descriptionInput.value || "",
          bidirectional: bidirectionalCheckbox.checked
        });
        await this.loadCharacterData();
        this.renderTabContent();
        modal.close();
        new import_obsidian15.Notice("Relationship added");
      } catch (err) {
        new import_obsidian15.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => modal.close();
    modal.open();
  }
  showEditRelationshipModal(rel) {
    const modal = new import_obsidian15.Modal(this.plugin.app);
    modal.titleEl.textContent = "Edit Relationship";
    const content = modal.contentEl;
    const relationshipTypeSelect = content.createEl("select", { cls: "story-engine-select" });
    relationshipTypeSelect.createEl("option", { text: "Ally", value: "ally" });
    relationshipTypeSelect.createEl("option", { text: "Enemy", value: "enemy" });
    relationshipTypeSelect.createEl("option", { text: "Family", value: "family" });
    relationshipTypeSelect.createEl("option", { text: "Lover", value: "lover" });
    relationshipTypeSelect.createEl("option", { text: "Rival", value: "rival" });
    relationshipTypeSelect.createEl("option", { text: "Mentor", value: "mentor" });
    relationshipTypeSelect.createEl("option", { text: "Student", value: "student" });
    relationshipTypeSelect.value = rel.relationship_type;
    const descriptionInput = content.createEl("textarea", {
      cls: "story-engine-textarea",
      attr: { rows: "3", placeholder: "Description" },
      text: rel.description || ""
    });
    const bidirectionalCheckbox = content.createEl("input", {
      attr: { type: "checkbox" }
    });
    bidirectionalCheckbox.checked = rel.bidirectional;
    const bidirectionalLabel = content.createEl("label");
    bidirectionalLabel.appendChild(bidirectionalCheckbox);
    bidirectionalLabel.appendChild(document.createTextNode(" Bidirectional"));
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      try {
        await this.plugin.apiClient.updateCharacterRelationship(rel.id, {
          relationship_type: relationshipTypeSelect.value,
          description: descriptionInput.value || "",
          bidirectional: bidirectionalCheckbox.checked
        });
        await this.loadCharacterData();
        this.renderTabContent();
        modal.close();
        new import_obsidian15.Notice("Relationship updated");
      } catch (err) {
        new import_obsidian15.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => modal.close();
    modal.open();
  }
  // Method to update character after edit
  updateCharacter(character) {
    this.character = character;
    this.renderHeader();
    this.renderTabContent();
  }
};

// src/views/StoryListView.ts
var STORY_LIST_VIEW_TYPE = "story-engine-list-view";
var StoryListView = class extends import_obsidian16.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.stories = [];
    this.worlds = [];
    this.rpgSystems = [];
    this.loading = true;
    this.error = null;
    this.currentStory = null;
    this.currentWorld = null;
    this.viewMode = "list";
    this.currentTab = "chapters";
    this.storyCharacters = [];
    this.worldTab = "characters";
    this.listTab = "stories";
    this.expandedWorldId = null;
    // Character Details View
    this.characterDetailsView = null;
    this.chapters = [];
    this.scenes = [];
    this.beats = [];
    this.contentBlocks = [];
    this.contentBlockRefs = [];
    this.loadingHierarchy = false;
    // World entities
    this.characters = [];
    this.locations = [];
    this.artifacts = [];
    this.events = [];
    this.traits = [];
    this.archetypes = [];
    this.factions = [];
    this.lores = [];
    this.loadingWorldData = false;
    this.plugin = plugin;
  }
  getViewType() {
    return STORY_LIST_VIEW_TYPE;
  }
  getDisplayText() {
    if (this.viewMode === "details" && this.currentStory) {
      return this.currentStory.title;
    }
    if (this.viewMode === "world-details" && this.currentWorld) {
      return this.currentWorld.name;
    }
    if (this.viewMode === "character-details" && this.characterDetailsView) {
      return this.characterDetailsView["character"].name;
    }
    return "Stories";
  }
  getIcon() {
    return "book-open";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("story-engine-view-container");
    await this.render(container);
    await this.loadStories();
  }
  async onClose() {
  }
  async render(container) {
    container.empty();
    this.headerEl = container.createDiv({ cls: "story-engine-view-header" });
    this.contentEl = container.createDiv({ cls: "story-engine-view-content" });
    if (this.viewMode === "details" && this.currentStory) {
      this.renderDetails();
    } else if (this.viewMode === "world-details" && this.currentWorld) {
      this.renderWorldDetails();
    } else if (this.viewMode === "character-details" && this.characterDetailsView) {
      this.characterDetailsView.render();
    } else {
      this.renderListHeader();
      this.renderListContent();
    }
  }
  renderListHeader() {
    if (!this.headerEl)
      return;
    this.headerEl.empty();
    this.headerEl.createEl("h2", { text: "Stories" });
    const tabsContainer = this.headerEl.createDiv({ cls: "story-engine-tabs" });
    const storiesTab = tabsContainer.createEl("button", {
      text: "Stories",
      cls: `story-engine-tab ${this.listTab === "stories" ? "is-active" : ""}`
    });
    storiesTab.onclick = () => {
      this.listTab = "stories";
      this.renderListHeader();
      this.renderListContent();
    };
    const worldsTab = tabsContainer.createEl("button", {
      text: "Worlds",
      cls: `story-engine-tab ${this.listTab === "worlds" ? "is-active" : ""}`
    });
    worldsTab.onclick = () => {
      this.listTab = "worlds";
      this.renderListHeader();
      this.renderListContent();
    };
    const rpgSystemsTab = tabsContainer.createEl("button", {
      text: "RPG Systems",
      cls: `story-engine-tab ${this.listTab === "rpg-systems" ? "is-active" : ""}`
    });
    rpgSystemsTab.onclick = () => {
      this.listTab = "rpg-systems";
      this.renderListHeader();
      this.renderListContent();
    };
    const settingsButton = tabsContainer.createEl("button", {
      cls: "story-engine-settings-btn story-engine-tab",
      attr: { "aria-label": "Open Settings" }
    });
    (0, import_obsidian16.setIcon)(settingsButton, "gear");
    settingsButton.onclick = () => {
      this.plugin.openSettings();
    };
  }
  renderListContent() {
    if (!this.contentEl)
      return;
    this.contentEl.empty();
    if (this.loading) {
      this.contentEl.createEl("p", { text: "Loading..." });
      return;
    }
    if (this.error) {
      this.contentEl.createEl("p", {
        text: `Error: ${this.error}`,
        cls: "story-engine-error"
      });
      this.renderActionsBar();
      return;
    }
    switch (this.listTab) {
      case "stories":
        this.renderStoriesTab();
        break;
      case "worlds":
        this.renderWorldsTab();
        break;
      case "rpg-systems":
        this.renderRPGSystemsTab();
        break;
    }
    this.renderActionsBar();
  }
  renderActionsBar() {
    if (!this.contentEl)
      return;
    const actionsBar = this.contentEl.createDiv({ cls: "story-engine-actions-bar" });
    const refreshButton = actionsBar.createEl("button", {
      text: "Refresh",
      cls: "story-engine-refresh-btn"
    });
    refreshButton.onclick = async () => {
      await this.loadStories();
    };
    const syncAllButton = actionsBar.createEl("button", {
      text: "Sync All",
      cls: "story-engine-sync-all-btn"
    });
    syncAllButton.onclick = async () => {
      if (!this.plugin.settings.tenantId) {
        new import_obsidian16.Notice("Please configure Tenant ID in settings", 5e3);
        return;
      }
      try {
        new import_obsidian16.Notice("Syncing all stories...");
        await this.plugin.syncService.pullAllStories();
        await this.loadStories();
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to sync stories";
        new import_obsidian16.Notice(`Error: ${errorMessage}`, 5e3);
      }
    };
    let createButtonText = "Create Story";
    let createButtonAction = () => {
      this.plugin.createStoryCommand();
    };
    if (this.listTab === "worlds") {
      createButtonText = "Create World";
      createButtonAction = async () => {
        new CreateWorldModal(this.app, async (name, description, genre) => {
          try {
            new import_obsidian16.Notice(`Creating world "${name}"...`);
            const newWorld = await this.plugin.apiClient.createWorld(name, description, genre);
            new import_obsidian16.Notice(`World "${name}" created successfully`);
            await this.loadStories();
          } catch (err) {
            const errorMessage = err instanceof Error ? err.message : "Failed to create world";
            new import_obsidian16.Notice(`Error: ${errorMessage}`, 5e3);
          }
        }).open();
      };
    } else if (this.listTab === "rpg-systems") {
      createButtonText = "Create RPG System";
      createButtonAction = () => {
        new import_obsidian16.Notice("Create RPG System - Coming soon", 3e3);
      };
    }
    const createButton = actionsBar.createEl("button", {
      text: createButtonText,
      cls: "mod-cta story-engine-create-btn"
    });
    createButton.onclick = createButtonAction;
  }
  renderDetailsHeader() {
    if (!this.headerEl || !this.currentStory)
      return;
    this.headerEl.empty();
    const headerLeft = this.headerEl.createDiv({ cls: "story-engine-header-left" });
    const backButton = headerLeft.createEl("button", {
      text: "\u2190 Back",
      cls: "story-engine-back-btn"
    });
    backButton.onclick = () => {
      this.showList();
    };
    const titleContainer = headerLeft.createDiv({ cls: "story-engine-title-container" });
    const titleRow = titleContainer.createDiv({ cls: "story-engine-title-row" });
    const titleH2 = titleRow.createEl("h2", {
      text: this.currentStory.title,
      cls: "story-engine-title-header"
    });
    const statusPill = titleRow.createSpan({
      cls: `story-engine-status-pill story-engine-status-${this.currentStory.status.toLowerCase().replace(/\s+/g, "-")}`
    });
    statusPill.textContent = this.currentStory.status;
    const versionSpan = titleRow.createSpan({ cls: "story-engine-version" });
    versionSpan.textContent = `v.${this.currentStory.version_number}`;
    const uuidRow = titleContainer.createDiv({ cls: "story-engine-uuid-row" });
    const uuidSpan = uuidRow.createSpan({ cls: "story-engine-uuid" });
    uuidSpan.textContent = this.currentStory.id;
    const copyUuidButton = uuidRow.createEl("button", {
      cls: "story-engine-copy-uuid-btn",
      attr: { "aria-label": "Copy UUID" }
    });
    (0, import_obsidian16.setIcon)(copyUuidButton, "copy");
    copyUuidButton.onclick = () => {
      this.copyStoryId();
    };
    const headerActions = this.headerEl.createDiv({ cls: "story-engine-header-actions" });
    if (this.currentStory.world_id) {
      const world = this.worlds.find((w) => w.id === this.currentStory.world_id);
      if (world) {
        const worldButton = headerActions.createEl("button", {
          cls: "story-engine-world-btn",
          attr: { "aria-label": `Go to World: ${world.name}` }
        });
        (0, import_obsidian16.setIcon)(worldButton, "globe");
        worldButton.createSpan({ text: "World" });
        worldButton.onclick = () => {
          this.showWorldDetails(world);
        };
      }
    }
    const contextButton = headerActions.createEl("button", {
      cls: "story-engine-context-btn",
      attr: { "aria-label": "Story Actions" }
    });
    (0, import_obsidian16.setIcon)(contextButton, "more-vertical");
    const dropdownMenu = headerActions.createDiv({ cls: "story-engine-dropdown-menu" });
    dropdownMenu.style.display = "none";
    const editOption = dropdownMenu.createEl("button", {
      cls: "story-engine-dropdown-item"
    });
    (0, import_obsidian16.setIcon)(editOption, "pencil");
    editOption.createSpan({ text: "Edit Story Name" });
    editOption.onclick = () => {
      dropdownMenu.style.display = "none";
      this.showEditStoryNameModal();
    };
    const cloneOption = dropdownMenu.createEl("button", {
      cls: "story-engine-dropdown-item"
    });
    (0, import_obsidian16.setIcon)(cloneOption, "copy");
    cloneOption.createSpan({ text: "Clone Story" });
    cloneOption.onclick = async () => {
      dropdownMenu.style.display = "none";
      await this.cloneStory();
    };
    const pullOption = dropdownMenu.createEl("button", {
      cls: "story-engine-dropdown-item"
    });
    (0, import_obsidian16.setIcon)(pullOption, "download");
    pullOption.createSpan({ text: "Pull from Service" });
    pullOption.onclick = async () => {
      dropdownMenu.style.display = "none";
      if (!this.currentStory)
        return;
      try {
        new import_obsidian16.Notice(`Pulling story "${this.currentStory.title}"...`);
        await this.plugin.syncService.pullStory(this.currentStory.id);
        await this.loadHierarchy();
        this.renderTabContent();
        new import_obsidian16.Notice(`Story pulled successfully!`);
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to pull story";
        new import_obsidian16.Notice(`Error: ${errorMessage}`, 5e3);
      }
    };
    const pushOption = dropdownMenu.createEl("button", {
      cls: "story-engine-dropdown-item"
    });
    (0, import_obsidian16.setIcon)(pushOption, "upload");
    pushOption.createSpan({ text: "Push to Service" });
    pushOption.onclick = async () => {
      dropdownMenu.style.display = "none";
      if (!this.currentStory)
        return;
      try {
        const folderPath = this.plugin.fileManager.getStoryFolderPath(this.currentStory.title);
        new import_obsidian16.Notice(`Pushing story "${this.currentStory.title}"...`);
        await this.plugin.syncService.pushStory(folderPath);
        new import_obsidian16.Notice(`Story pushed successfully!`);
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to push story";
        new import_obsidian16.Notice(`Error: ${errorMessage}`, 5e3);
      }
    };
    contextButton.onclick = (e) => {
      e.stopPropagation();
      const isVisible = dropdownMenu.style.display !== "none";
      dropdownMenu.style.display = isVisible ? "none" : "block";
    };
    document.addEventListener("click", () => {
      dropdownMenu.style.display = "none";
    }, { once: true });
  }
  renderStoriesTab() {
    if (this.stories.length === 0) {
      this.contentEl.createEl("p", { text: "No stories found." });
      return;
    }
    const storiesList = this.contentEl.createDiv({ cls: "story-engine-list" });
    for (const story of this.stories) {
      this.renderStoryItem(storiesList, story);
    }
  }
  renderWorldsTab() {
    if (this.worlds.length === 0) {
      this.contentEl.createEl("p", { text: "No worlds found." });
      return;
    }
    const storiesByWorld = /* @__PURE__ */ new Map();
    for (const story of this.stories) {
      const worldId = story.world_id || null;
      if (!storiesByWorld.has(worldId)) {
        storiesByWorld.set(worldId, []);
      }
      storiesByWorld.get(worldId).push(story);
    }
    const worldsList = this.contentEl.createDiv({ cls: "story-engine-list" });
    for (const world of this.worlds) {
      const worldStories = storiesByWorld.get(world.id) || [];
      const worldItem = worldsList.createDiv({ cls: "story-engine-world-item" });
      const worldHeader = worldItem.createDiv({ cls: "story-engine-world-item-header" });
      const worldTitle = worldHeader.createDiv({ cls: "story-engine-world-title" });
      worldTitle.createEl("h3", { text: world.name });
      if (world.description) {
        worldTitle.createEl("p", {
          text: world.description,
          cls: "story-engine-world-description"
        });
      }
      worldTitle.style.cursor = "pointer";
      worldTitle.onclick = () => {
        this.showWorldDetails(world);
      };
      const accordionButton = worldHeader.createEl("button", {
        text: worldStories.length > 0 ? `${worldStories.length} story${worldStories.length !== 1 ? "s" : ""}` : "No stories",
        cls: `story-engine-accordion-btn ${this.expandedWorldId === world.id ? "is-expanded" : ""}`
      });
      accordionButton.onclick = (e) => {
        e.stopPropagation();
        if (this.expandedWorldId === world.id) {
          this.expandedWorldId = null;
        } else {
          this.expandedWorldId = world.id;
        }
        this.renderListContent();
      };
      if (this.expandedWorldId === world.id && worldStories.length > 0) {
        const storiesContent = worldItem.createDiv({ cls: "story-engine-world-stories-content" });
        for (const story of worldStories) {
          this.renderStoryItem(storiesContent, story);
        }
      }
    }
    const storiesWithoutWorld = storiesByWorld.get(null) || [];
    if (storiesWithoutWorld.length > 0) {
      const noWorldItem = worldsList.createDiv({ cls: "story-engine-world-item" });
      const noWorldHeader = noWorldItem.createDiv({ cls: "story-engine-world-item-header" });
      noWorldHeader.createEl("h3", { text: "No World" });
      const accordionButton = noWorldHeader.createEl("button", {
        text: `${storiesWithoutWorld.length} story${storiesWithoutWorld.length !== 1 ? "s" : ""}`,
        cls: `story-engine-accordion-btn ${this.expandedWorldId === "no-world" ? "is-expanded" : ""}`
      });
      accordionButton.onclick = () => {
        if (this.expandedWorldId === "no-world") {
          this.expandedWorldId = null;
        } else {
          this.expandedWorldId = "no-world";
        }
        this.renderListContent();
      };
      if (this.expandedWorldId === "no-world") {
        const storiesContent = noWorldItem.createDiv({ cls: "story-engine-world-stories-content" });
        for (const story of storiesWithoutWorld) {
          this.renderStoryItem(storiesContent, story);
        }
      }
    }
  }
  renderRPGSystemsTab() {
    if (this.rpgSystems.length === 0) {
      if (this.plugin.settings.mode === "local") {
        this.contentEl.createEl("p", { text: "RPG systems are not available in local mode." });
      } else {
        this.contentEl.createEl("p", { text: "No RPG systems found." });
      }
      return;
    }
    const rpgSystemsList = this.contentEl.createDiv({ cls: "story-engine-list" });
    for (const rpgSystem of this.rpgSystems) {
      const rpgSystemItem = rpgSystemsList.createDiv({
        cls: "story-engine-item"
      });
      const title = rpgSystemItem.createDiv({
        cls: "story-engine-title",
        text: rpgSystem.name
      });
      const meta = rpgSystemItem.createDiv({
        cls: "story-engine-meta"
      });
      if (rpgSystem.description) {
        meta.createEl("span", {
          text: rpgSystem.description
        });
      }
      if (rpgSystem.is_builtin) {
        meta.createEl("span", {
          text: "Built-in",
          cls: "story-engine-badge"
        });
      }
    }
  }
  renderStoryItem(container, story) {
    const storyItem = container.createDiv({
      cls: "story-engine-item"
    });
    const title = storyItem.createDiv({
      cls: "story-engine-title",
      text: story.title
    });
    const meta = storyItem.createDiv({
      cls: "story-engine-meta"
    });
    meta.createEl("span", {
      text: `Version ${story.version_number}`
    });
    meta.createEl("span", {
      text: `Status: ${story.status}`
    });
    if (story.world_id) {
      const world = this.worlds.find((w) => w.id === story.world_id);
      if (world) {
        meta.createEl("span", {
          text: `World: ${world.name}`
        });
      }
    }
    storyItem.onclick = async () => {
      await this.showStoryDetails(story);
    };
  }
  async loadStories() {
    this.loading = true;
    this.error = null;
    try {
      if (this.plugin.settings.mode === "remote" && !this.plugin.settings.tenantId) {
        this.error = "Tenant ID not configured";
        this.loading = false;
        this.renderListContent();
        return;
      }
      this.worlds = await this.plugin.apiClient.getWorlds();
      this.stories = await this.plugin.apiClient.listStories();
      try {
        this.rpgSystems = await this.plugin.apiClient.getRPGSystems();
      } catch (rpgErr) {
        console.warn("RPG systems not available:", rpgErr);
        this.rpgSystems = [];
      }
    } catch (err) {
      this.error = err instanceof Error ? err.message : "Failed to load stories";
      console.error("Error loading stories:", err);
    } finally {
      this.loading = false;
      this.renderListContent();
    }
  }
  // Method to refresh the view
  async refresh() {
    await this.loadStories();
  }
  async showStoryDetails(story) {
    this.currentStory = story;
    this.viewMode = "details";
    this.currentTab = "chapters";
    await this.loadHierarchy();
    this.renderDetails();
  }
  async loadHierarchy() {
    if (!this.currentStory)
      return;
    this.loadingHierarchy = true;
    try {
      this.chapters = await this.plugin.apiClient.getChapters(this.currentStory.id);
      this.scenes = await this.plugin.apiClient.getScenesByStory(this.currentStory.id);
      this.beats = await this.plugin.apiClient.getBeatsByStory(this.currentStory.id);
      const contentBlocksMap = /* @__PURE__ */ new Map();
      this.contentBlockRefs = [];
      for (const chapter of this.chapters) {
        const chapterBlocks = await this.plugin.apiClient.getContentBlocks(chapter.id);
        for (const block of chapterBlocks) {
          contentBlocksMap.set(block.id, block);
        }
      }
      for (const scene of this.scenes) {
        const sceneBlocks = await this.plugin.apiClient.getContentBlocksByScene(scene.id);
        for (const block of sceneBlocks) {
          contentBlocksMap.set(block.id, block);
        }
      }
      for (const beat of this.beats) {
        const beatBlocks = await this.plugin.apiClient.getContentBlocksByBeat(beat.id);
        for (const block of beatBlocks) {
          contentBlocksMap.set(block.id, block);
        }
      }
      this.contentBlocks = Array.from(contentBlocksMap.values());
      for (const block of this.contentBlocks) {
        const refs = await this.plugin.apiClient.getContentAnchors(block.id);
        this.contentBlockRefs.push(...refs);
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to load hierarchy";
      new import_obsidian16.Notice(`Error: ${errorMessage}`, 5e3);
    } finally {
      this.loadingHierarchy = false;
    }
  }
  showList() {
    this.currentStory = null;
    this.viewMode = "list";
    this.renderListHeader();
    this.renderListContent();
  }
  renderDetails() {
    if (!this.contentEl || !this.currentStory)
      return;
    this.renderDetailsHeader();
    this.contentEl.empty();
    this.renderTabs();
    this.renderTabContent();
  }
  renderTabs() {
    if (!this.contentEl)
      return;
    const existingTabs = this.contentEl.querySelector(".story-engine-tabs");
    if (existingTabs) {
      existingTabs.remove();
    }
    const tabsContainer = this.contentEl.createDiv({ cls: "story-engine-tabs" });
    const chaptersTab = tabsContainer.createEl("button", {
      text: "Chapters",
      cls: `story-engine-tab ${this.currentTab === "chapters" ? "is-active" : ""}`
    });
    chaptersTab.onclick = () => {
      this.currentTab = "chapters";
      this.renderTabs();
      this.renderTabContent();
    };
    const scenesTab = tabsContainer.createEl("button", {
      text: "Scenes",
      cls: `story-engine-tab ${this.currentTab === "scenes" ? "is-active" : ""}`
    });
    scenesTab.onclick = () => {
      this.currentTab = "scenes";
      this.renderTabs();
      this.renderTabContent();
    };
    const beatsTab = tabsContainer.createEl("button", {
      text: "Beats",
      cls: `story-engine-tab ${this.currentTab === "beats" ? "is-active" : ""}`
    });
    beatsTab.onclick = () => {
      this.currentTab = "beats";
      this.renderTabs();
      this.renderTabContent();
    };
    const contentsTab = tabsContainer.createEl("button", {
      text: "Contents",
      cls: `story-engine-tab ${this.currentTab === "contents" ? "is-active" : ""}`
    });
    contentsTab.onclick = () => {
      this.currentTab = "contents";
      this.renderTabs();
      this.renderTabContent();
    };
    const charactersTab = tabsContainer.createEl("button", {
      text: "Characters",
      cls: `story-engine-tab ${this.currentTab === "characters" ? "is-active" : ""}`
    });
    charactersTab.onclick = async () => {
      this.currentTab = "characters";
      this.renderTabs();
      await this.loadStoryCharacters();
      this.renderTabContent();
    };
  }
  renderTabContent() {
    if (!this.contentEl)
      return;
    const existingContent = this.contentEl.querySelector(".story-engine-tab-content");
    if (existingContent) {
      existingContent.remove();
    }
    const tabContent = this.contentEl.createDiv({ cls: "story-engine-tab-content" });
    if (this.loadingHierarchy) {
      tabContent.createEl("p", { text: "Loading..." });
      return;
    }
    switch (this.currentTab) {
      case "chapters":
        this.renderChaptersTab(tabContent);
        break;
      case "scenes":
        this.renderScenesTab(tabContent);
        break;
      case "beats":
        this.renderBeatsTab(tabContent);
        break;
      case "contents":
        this.renderContentsTab(tabContent);
        break;
      case "characters":
        this.renderStoryCharactersTab(tabContent);
        break;
    }
  }
  renderChaptersTab(container) {
    container.empty();
    const list = container.createDiv({ cls: "story-engine-list" });
    if (this.chapters.length === 0) {
      list.createEl("p", { text: "No chapters found." });
    } else {
      for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
        const item = list.createDiv({ cls: "story-engine-item" });
        item.createDiv({
          cls: "story-engine-title",
          text: `Chapter ${chapter.number}: ${chapter.title}`
        });
        const meta = item.createDiv({ cls: "story-engine-meta" });
        meta.createEl("span", { text: `Status: ${chapter.status}` });
        const actions = item.createDiv({ cls: "story-engine-item-actions" });
        actions.createEl("button", { text: "Edit" }).onclick = () => {
          new ChapterModal(this.app, async (updatedChapter) => {
            try {
              await this.plugin.apiClient.updateChapter(chapter.id, updatedChapter);
              await this.loadHierarchy();
              this.renderTabContent();
              new import_obsidian16.Notice("Chapter updated successfully");
            } catch (err) {
              throw err;
            }
          }, this.chapters, chapter).open();
        };
        if (chapter.number > 1) {
          actions.createEl("button", { text: "Up" }).onclick = () => {
            this.moveChapterUp(chapter);
          };
        }
        if (chapter.number < this.chapters.length) {
          actions.createEl("button", { text: "Down" }).onclick = () => {
            this.moveChapterDown(chapter);
          };
        }
        if (this.currentTab === "contents") {
          actions.createEl("button", { text: "+ Content" }).onclick = () => {
            this.createContentForEntity("chapter", chapter.id, chapter.id);
          };
        }
        actions.createEl("button", { text: "Delete" }).onclick = async () => {
          if (confirm("Delete this chapter?")) {
            try {
              await this.plugin.apiClient.deleteChapter(chapter.id);
              await this.loadHierarchy();
              this.renderTabContent();
              new import_obsidian16.Notice("Chapter deleted");
            } catch (err) {
              new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
            }
          }
        };
      }
    }
    const footer = container.createDiv({ cls: "story-engine-list-footer" });
    const createButton = footer.createEl("button", {
      text: "Create Chapter",
      cls: "mod-cta"
    });
    createButton.onclick = () => {
      if (!this.currentStory)
        return;
      new ChapterModal(this.app, async (chapter) => {
        try {
          await this.plugin.apiClient.createChapter(this.currentStory.id, chapter);
          await this.loadHierarchy();
          this.renderTabContent();
          new import_obsidian16.Notice("Chapter created successfully");
        } catch (err) {
          throw err;
        }
      }, this.chapters).open();
    };
  }
  renderScenesTab(container) {
    container.empty();
    const scenesByChapter = /* @__PURE__ */ new Map();
    for (const scene of this.scenes) {
      const chapterId = scene.chapter_id || null;
      if (!scenesByChapter.has(chapterId)) {
        scenesByChapter.set(chapterId, []);
      }
      scenesByChapter.get(chapterId).push(scene);
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
      const chapterScenes = scenesByChapter.get(chapter.id) || [];
      const group = list.createDiv({ cls: "story-engine-group" });
      const groupHeader = group.createDiv({ cls: "story-engine-group-header" });
      groupHeader.createEl("h3", { text: `Chapter ${chapter.number}: ${chapter.title}` });
      const groupItems = group.createDiv({ cls: "story-engine-group-items" });
      if (chapterScenes.length === 0) {
        groupItems.createEl("p", { text: "No scenes in this chapter." });
      } else {
        for (const scene of chapterScenes.sort((a, b) => a.order_num - b.order_num)) {
          this.renderSceneItem(groupItems, scene);
        }
      }
      const groupFooter = group.createDiv({ cls: "story-engine-group-footer" });
      const addButton = groupFooter.createEl("button", {
        text: "+ Add Scene",
        cls: "story-engine-add-btn"
      });
      addButton.onclick = () => {
        if (!this.currentStory)
          return;
        new SceneModal(this.app, this.currentStory.id, this.chapters, async (scene) => {
          try {
            scene.chapter_id = chapter.id;
            await this.plugin.apiClient.createScene(scene);
            await this.loadHierarchy();
            this.renderTabContent();
            new import_obsidian16.Notice("Scene created successfully");
          } catch (err) {
            throw err;
          }
        }, this.scenes, void 0, chapter.id).open();
      };
    }
    const orphanScenes = scenesByChapter.get(null) || [];
    if (orphanScenes.length > 0 || scenesByChapter.size === 0) {
      const group = list.createDiv({ cls: "story-engine-group" });
      const groupHeader = group.createDiv({ cls: "story-engine-group-header" });
      groupHeader.createEl("h3", { text: "Without Chapter" });
      const groupItems = group.createDiv({ cls: "story-engine-group-items" });
      for (const scene of orphanScenes.sort((a, b) => a.order_num - b.order_num)) {
        this.renderSceneItem(groupItems, scene);
      }
      const groupFooter = group.createDiv({ cls: "story-engine-group-footer" });
      const addButton = groupFooter.createEl("button", {
        text: "+ Add Scene",
        cls: "story-engine-add-btn"
      });
      addButton.onclick = () => {
        if (!this.currentStory)
          return;
        new SceneModal(this.app, this.currentStory.id, this.chapters, async (scene) => {
          try {
            scene.chapter_id = null;
            await this.plugin.apiClient.createScene(scene);
            await this.loadHierarchy();
            this.renderTabContent();
            new import_obsidian16.Notice("Scene created successfully");
          } catch (err) {
            throw err;
          }
        }, this.scenes, void 0, null).open();
      };
    }
  }
  renderSceneItem(container, scene) {
    const item = container.createDiv({ cls: "story-engine-item" });
    item.createDiv({
      cls: "story-engine-title",
      text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`
    });
    const meta = item.createDiv({ cls: "story-engine-meta" });
    if (scene.time_ref) {
      meta.createEl("span", { text: `Time: ${scene.time_ref}` });
    }
    const actions = item.createDiv({ cls: "story-engine-item-actions" });
    actions.createEl("button", { text: "Edit" }).onclick = () => {
      if (!this.currentStory)
        return;
      new SceneModal(this.app, this.currentStory.id, this.chapters, async (updatedScene) => {
        try {
          await this.plugin.apiClient.updateScene(scene.id, updatedScene);
          await this.loadHierarchy();
          this.renderTabContent();
          new import_obsidian16.Notice("Scene updated successfully");
        } catch (err) {
          throw err;
        }
      }, this.scenes, scene).open();
    };
    const siblingScenes = this.scenes.filter((s) => s.chapter_id === scene.chapter_id).sort((a, b) => a.order_num - b.order_num);
    const minOrderNum = siblingScenes.length > 0 ? Math.min(...siblingScenes.map((s) => s.order_num)) : scene.order_num;
    const maxOrderNum = siblingScenes.length > 0 ? Math.max(...siblingScenes.map((s) => s.order_num)) : scene.order_num;
    if (scene.order_num > minOrderNum) {
      actions.createEl("button", { text: "Up" }).onclick = () => {
        this.moveSceneUp(scene);
      };
    }
    if (scene.order_num < maxOrderNum) {
      actions.createEl("button", { text: "Down" }).onclick = () => {
        this.moveSceneDown(scene);
      };
    }
    actions.createEl("button", { text: "Relinkar" }).onclick = async () => {
      await this.showMoveSceneModal(scene);
    };
    if (this.currentTab === "contents") {
      const chapterId = scene.chapter_id || (this.chapters.length > 0 ? this.chapters[0].id : "");
      if (chapterId) {
        actions.createEl("button", { text: "+ Content" }).onclick = () => {
          this.createContentForEntity("scene", scene.id, chapterId);
        };
      }
    }
    actions.createEl("button", { text: "Delete" }).onclick = async () => {
      if (confirm("Delete this scene?")) {
        try {
          await this.plugin.apiClient.deleteScene(scene.id);
          await this.loadHierarchy();
          this.renderTabContent();
          new import_obsidian16.Notice("Scene deleted");
        } catch (err) {
          new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
        }
      }
    };
  }
  renderBeatsTab(container) {
    container.empty();
    const beatsByScene = /* @__PURE__ */ new Map();
    for (const beat of this.beats) {
      if (!beatsByScene.has(beat.scene_id)) {
        beatsByScene.set(beat.scene_id, []);
      }
      beatsByScene.get(beat.scene_id).push(beat);
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
      const chapterScenes = this.scenes.filter((s) => s.chapter_id === chapter.id).sort((a, b) => a.order_num - b.order_num);
      if (chapterScenes.length > 0) {
        const chapterGroup = list.createDiv({ cls: "story-engine-chapter-group" });
        const chapterHeader = chapterGroup.createDiv({ cls: "story-engine-chapter-group-header" });
        chapterHeader.createEl("h2", {
          text: `Chapter ${chapter.number}: ${chapter.title}`
        });
        const chapterContent = chapterGroup.createDiv({ cls: "story-engine-chapter-group-content" });
        for (const scene of chapterScenes) {
          const sceneBeats = beatsByScene.get(scene.id) || [];
          const sceneGroup = chapterContent.createDiv({ cls: "story-engine-group" });
          const sceneHeader = sceneGroup.createDiv({ cls: "story-engine-group-header" });
          sceneHeader.createEl("h3", {
            text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`
          });
          const sceneItems = sceneGroup.createDiv({ cls: "story-engine-group-items" });
          if (sceneBeats.length === 0) {
            sceneItems.createEl("p", { text: "No beats in this scene." });
          } else {
            for (const beat of sceneBeats.sort((a, b) => a.order_num - b.order_num)) {
              this.renderBeatItem(sceneItems, beat);
            }
          }
          const sceneFooter = sceneGroup.createDiv({ cls: "story-engine-group-footer" });
          const addButton = sceneFooter.createEl("button", {
            text: "+ Add Beat",
            cls: "story-engine-add-btn"
          });
          addButton.onclick = () => {
            if (!this.currentStory)
              return;
            new BeatModal(this.app, this.currentStory.id, this.scenes, async (beat) => {
              try {
                beat.scene_id = scene.id;
                await this.plugin.apiClient.createBeat(beat);
                await this.loadHierarchy();
                this.renderTabContent();
                new import_obsidian16.Notice("Beat created successfully");
              } catch (err) {
                throw err;
              }
            }, this.beats, void 0, this.chapters, scene.id).open();
          };
        }
      }
    }
    const orphanBeats = this.beats.filter((b) => {
      const scene = this.scenes.find((s) => s.id === b.scene_id);
      return !scene || !scene.chapter_id;
    });
    if (this.chapters.length === 0 || orphanBeats.length > 0 || this.scenes.some((s) => !s.chapter_id)) {
      const orphanGroup = list.createDiv({ cls: "story-engine-chapter-group" });
      const orphanHeader = orphanGroup.createDiv({ cls: "story-engine-chapter-group-header" });
      orphanHeader.createEl("h2", { text: "Without Chapter" });
      const orphanContent = orphanGroup.createDiv({ cls: "story-engine-chapter-group-content" });
      const orphanScenes = this.scenes.filter((s) => !s.chapter_id).sort((a, b) => a.order_num - b.order_num);
      for (const scene of orphanScenes) {
        const sceneBeats = beatsByScene.get(scene.id) || [];
        const sceneGroup = orphanContent.createDiv({ cls: "story-engine-group" });
        const sceneHeader = sceneGroup.createDiv({ cls: "story-engine-group-header" });
        sceneHeader.createEl("h3", {
          text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`
        });
        const sceneItems = sceneGroup.createDiv({ cls: "story-engine-group-items" });
        if (sceneBeats.length === 0) {
          sceneItems.createEl("p", { text: "No beats in this scene." });
        } else {
          for (const beat of sceneBeats.sort((a, b) => a.order_num - b.order_num)) {
            this.renderBeatItem(sceneItems, beat);
          }
        }
        const sceneFooter = sceneGroup.createDiv({ cls: "story-engine-group-footer" });
        const addButton = sceneFooter.createEl("button", {
          text: "+ Add Beat",
          cls: "story-engine-add-btn"
        });
        addButton.onclick = () => {
          if (!this.currentStory)
            return;
          new BeatModal(this.app, this.currentStory.id, this.scenes, async (beat) => {
            try {
              beat.scene_id = scene.id;
              await this.plugin.apiClient.createBeat(beat);
              await this.loadHierarchy();
              this.renderTabContent();
              new import_obsidian16.Notice("Beat created successfully");
            } catch (err) {
              throw err;
            }
          }, this.beats, void 0, this.chapters, scene.id).open();
        };
      }
      const beatsWithoutScene = orphanBeats.filter((b) => {
        const scene = this.scenes.find((s) => s.id === b.scene_id);
        return !scene;
      });
      if (beatsWithoutScene.length > 0 || orphanScenes.length === 0 && this.beats.length > 0 && this.scenes.length === 0) {
        const sceneGroup = orphanContent.createDiv({ cls: "story-engine-group" });
        const sceneHeader = sceneGroup.createDiv({ cls: "story-engine-group-header" });
        sceneHeader.createEl("h3", { text: "Without Scene" });
        const sceneItems = sceneGroup.createDiv({ cls: "story-engine-group-items" });
        if (beatsWithoutScene.length > 0) {
          for (const beat of beatsWithoutScene.sort((a, b) => a.order_num - b.order_num)) {
            this.renderBeatItem(sceneItems, beat);
          }
        } else {
          sceneItems.createEl("p", { text: "No beats without scene." });
        }
      }
    }
  }
  renderBeatItem(container, beat) {
    const item = container.createDiv({ cls: "story-engine-item" });
    item.createDiv({
      cls: "story-engine-title",
      text: `Beat ${beat.order_num}: ${beat.type}`
    });
    const meta = item.createDiv({ cls: "story-engine-meta" });
    if (beat.intent) {
      meta.createEl("span", { text: `Intent: ${beat.intent}` });
    }
    if (beat.outcome) {
      meta.createEl("span", { text: `Outcome: ${beat.outcome}` });
    }
    const actions = item.createDiv({ cls: "story-engine-item-actions" });
    actions.createEl("button", { text: "Edit" }).onclick = () => {
      if (!this.currentStory)
        return;
      new BeatModal(this.app, this.currentStory.id, this.scenes, async (updatedBeat) => {
        try {
          await this.plugin.apiClient.updateBeat(beat.id, updatedBeat);
          await this.loadHierarchy();
          this.renderTabContent();
          new import_obsidian16.Notice("Beat updated successfully");
        } catch (err) {
          throw err;
        }
      }, this.beats, beat, this.chapters).open();
    };
    const siblingBeats = this.beats.filter((b) => b.scene_id === beat.scene_id).sort((a, b) => a.order_num - b.order_num);
    const minOrderNum = siblingBeats.length > 0 ? Math.min(...siblingBeats.map((b) => b.order_num)) : beat.order_num;
    const maxOrderNum = siblingBeats.length > 0 ? Math.max(...siblingBeats.map((b) => b.order_num)) : beat.order_num;
    if (beat.order_num > minOrderNum) {
      actions.createEl("button", { text: "Up" }).onclick = () => {
        this.moveBeatUp(beat);
      };
    }
    if (beat.order_num < maxOrderNum) {
      actions.createEl("button", { text: "Down" }).onclick = () => {
        this.moveBeatDown(beat);
      };
    }
    actions.createEl("button", { text: "Relinkar" }).onclick = async () => {
      await this.showMoveBeatModal(beat);
    };
    if (this.currentTab === "contents") {
      const scene = this.scenes.find((s) => s.id === beat.scene_id);
      const chapterId = (scene == null ? void 0 : scene.chapter_id) || (this.chapters.length > 0 ? this.chapters[0].id : "");
      if (chapterId) {
        actions.createEl("button", { text: "+ Content" }).onclick = () => {
          this.createContentForEntity("beat", beat.id, chapterId);
        };
      }
    }
    actions.createEl("button", { text: "Delete" }).onclick = async () => {
      if (confirm("Delete this beat?")) {
        try {
          await this.plugin.apiClient.deleteBeat(beat.id);
          await this.loadHierarchy();
          this.renderTabContent();
          new import_obsidian16.Notice("Beat deleted");
        } catch (err) {
          new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
        }
      }
    };
  }
  showEditStoryNameModal() {
    if (!this.currentStory)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Edit Story Name");
    const content = modal.contentEl;
    let title = this.currentStory.title;
    content.createEl("label", { text: "Story Name *" });
    const titleInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: title });
    titleInput.oninput = () => {
      title = titleInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      if (!title.trim()) {
        new import_obsidian16.Notice("Story name is required", 3e3);
        return;
      }
      try {
        const updatedStory = await this.plugin.apiClient.updateStory(this.currentStory.id, title.trim());
        this.currentStory = updatedStory;
        await this.loadStories();
        this.renderDetailsHeader();
        modal.close();
        new import_obsidian16.Notice("Story name updated");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
    titleInput.focus();
    titleInput.select();
  }
  async cloneStory() {
    var _a;
    if (!this.currentStory)
      return;
    const cloneButton = (_a = this.headerEl) == null ? void 0 : _a.querySelector(".story-engine-clone-btn");
    if (cloneButton) {
      cloneButton.disabled = true;
      cloneButton.setText("Cloning...");
    }
    try {
      if (!this.plugin.settings.tenantId) {
        throw new Error("Tenant ID not configured");
      }
      const clonedStory = await this.plugin.apiClient.cloneStory(
        this.currentStory.id
      );
      new import_obsidian16.Notice(`Story "${clonedStory.title}" cloned successfully!`);
      await this.loadStories();
      await this.showStoryDetails(clonedStory);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Clone failed";
      new import_obsidian16.Notice(`Error: ${errorMessage}`, 5e3);
      if (cloneButton) {
        cloneButton.setText("Clone Story");
        cloneButton.disabled = false;
      }
    }
  }
  showEditWorldModal() {
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Edit World");
    const content = modal.contentEl;
    let name = this.currentWorld.name;
    let description = this.currentWorld.description;
    let genre = this.currentWorld.genre;
    content.createEl("label", { text: "World Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: name });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Genre *" });
    const genreInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: genre });
    genreInput.oninput = () => {
      genre = genreInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.value = description;
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("World name is required", 3e3);
        return;
      }
      if (!genre.trim()) {
        new import_obsidian16.Notice("Genre is required", 3e3);
        return;
      }
      try {
        const updatedWorld = await this.plugin.apiClient.updateWorld(
          this.currentWorld.id,
          name.trim(),
          description.trim(),
          genre.trim()
        );
        this.currentWorld = updatedWorld;
        await this.loadStories();
        this.renderWorldDetails();
        modal.close();
        new import_obsidian16.Notice("World updated");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
    nameInput.focus();
    nameInput.select();
  }
  copyStoryId() {
    if (!this.currentStory)
      return;
    navigator.clipboard.writeText(this.currentStory.id).then(() => {
      new import_obsidian16.Notice("UUID copied to clipboard");
    }).catch(() => {
      const textarea = document.createElement("textarea");
      textarea.value = this.currentStory.id;
      textarea.style.position = "fixed";
      textarea.style.opacity = "0";
      textarea.style.left = "-9999px";
      document.body.appendChild(textarea);
      textarea.select();
      try {
        document.execCommand("copy");
        new import_obsidian16.Notice("UUID copied to clipboard");
      } catch (err) {
        new import_obsidian16.Notice("Failed to copy UUID", 3e3);
      }
      document.body.removeChild(textarea);
    });
  }
  async moveChapterUp(chapter) {
    const sortedChapters = [...this.chapters].sort((a, b) => a.number - b.number);
    const currentIndex = sortedChapters.findIndex((c) => c.id === chapter.id);
    if (currentIndex <= 0)
      return;
    const previousChapter = sortedChapters[currentIndex - 1];
    const tempNumber = chapter.number;
    try {
      await this.plugin.apiClient.updateChapter(chapter.id, { number: previousChapter.number });
      await this.plugin.apiClient.updateChapter(previousChapter.id, { number: tempNumber });
      await this.loadHierarchy();
      this.renderTabContent();
      new import_obsidian16.Notice("Chapter moved up");
    } catch (err) {
      new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
    }
  }
  async moveChapterDown(chapter) {
    const sortedChapters = [...this.chapters].sort((a, b) => a.number - b.number);
    const currentIndex = sortedChapters.findIndex((c) => c.id === chapter.id);
    if (currentIndex < 0 || currentIndex >= sortedChapters.length - 1)
      return;
    const nextChapter = sortedChapters[currentIndex + 1];
    const tempNumber = chapter.number;
    try {
      await this.plugin.apiClient.updateChapter(chapter.id, { number: nextChapter.number });
      await this.plugin.apiClient.updateChapter(nextChapter.id, { number: tempNumber });
      await this.loadHierarchy();
      this.renderTabContent();
      new import_obsidian16.Notice("Chapter moved down");
    } catch (err) {
      new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
    }
  }
  async moveSceneUp(scene) {
    const siblingScenes = this.scenes.filter((s) => s.chapter_id === scene.chapter_id).sort((a, b) => a.order_num - b.order_num);
    const currentIndex = siblingScenes.findIndex((s) => s.id === scene.id);
    if (currentIndex <= 0)
      return;
    const previousScene = siblingScenes[currentIndex - 1];
    const tempOrderNum = scene.order_num;
    try {
      await this.plugin.apiClient.updateScene(scene.id, { order_num: previousScene.order_num });
      await this.plugin.apiClient.updateScene(previousScene.id, { order_num: tempOrderNum });
      await this.loadHierarchy();
      this.renderTabContent();
      new import_obsidian16.Notice("Scene moved up");
    } catch (err) {
      new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
    }
  }
  async moveSceneDown(scene) {
    const siblingScenes = this.scenes.filter((s) => s.chapter_id === scene.chapter_id).sort((a, b) => a.order_num - b.order_num);
    const currentIndex = siblingScenes.findIndex((s) => s.id === scene.id);
    if (currentIndex < 0 || currentIndex >= siblingScenes.length - 1)
      return;
    const nextScene = siblingScenes[currentIndex + 1];
    const tempOrderNum = scene.order_num;
    try {
      await this.plugin.apiClient.updateScene(scene.id, { order_num: nextScene.order_num });
      await this.plugin.apiClient.updateScene(nextScene.id, { order_num: tempOrderNum });
      await this.loadHierarchy();
      this.renderTabContent();
      new import_obsidian16.Notice("Scene moved down");
    } catch (err) {
      new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
    }
  }
  async moveBeatUp(beat) {
    const siblingBeats = this.beats.filter((b) => b.scene_id === beat.scene_id).sort((a, b) => a.order_num - b.order_num);
    const currentIndex = siblingBeats.findIndex((b) => b.id === beat.id);
    if (currentIndex <= 0)
      return;
    const previousBeat = siblingBeats[currentIndex - 1];
    const tempOrderNum = beat.order_num;
    try {
      await this.plugin.apiClient.updateBeat(beat.id, { order_num: previousBeat.order_num });
      await this.plugin.apiClient.updateBeat(previousBeat.id, { order_num: tempOrderNum });
      await this.loadHierarchy();
      this.renderTabContent();
      new import_obsidian16.Notice("Beat moved up");
    } catch (err) {
      new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
    }
  }
  async moveBeatDown(beat) {
    const siblingBeats = this.beats.filter((b) => b.scene_id === beat.scene_id).sort((a, b) => a.order_num - b.order_num);
    const currentIndex = siblingBeats.findIndex((b) => b.id === beat.id);
    if (currentIndex < 0 || currentIndex >= siblingBeats.length - 1)
      return;
    const nextBeat = siblingBeats[currentIndex + 1];
    const tempOrderNum = beat.order_num;
    try {
      await this.plugin.apiClient.updateBeat(beat.id, { order_num: nextBeat.order_num });
      await this.plugin.apiClient.updateBeat(nextBeat.id, { order_num: tempOrderNum });
      await this.loadHierarchy();
      this.renderTabContent();
      new import_obsidian16.Notice("Beat moved down");
    } catch (err) {
      new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
    }
  }
  async showMoveSceneModal(scene) {
    if (!this.currentStory)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Move Scene");
    const content = modal.contentEl;
    content.createEl("p", { text: `Move scene "${scene.goal || `Scene ${scene.order_num}`}" to:` });
    const select = content.createEl("select", { cls: "story-engine-move-select" });
    const noChapterOption = select.createEl("option", { text: "No Chapter", value: "" });
    for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
      const option = select.createEl("option", {
        text: `Chapter ${chapter.number}: ${chapter.title}`,
        value: chapter.id
      });
      if (scene.chapter_id === chapter.id) {
        option.selected = true;
      }
    }
    if (!scene.chapter_id) {
      noChapterOption.selected = true;
    }
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const moveButton = buttonContainer.createEl("button", {
      text: "Move",
      cls: "mod-cta"
    });
    moveButton.onclick = async () => {
      const selectedChapterId = select.value || null;
      try {
        await this.plugin.apiClient.moveScene(scene.id, selectedChapterId);
        await this.loadHierarchy();
        this.renderTabContent();
        modal.close();
        new import_obsidian16.Notice("Scene moved successfully");
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to move scene";
        new import_obsidian16.Notice(`Error: ${errorMessage}`, 5e3);
      }
    };
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.onclick = () => modal.close();
    modal.open();
  }
  async showMoveBeatModal(beat) {
    if (!this.currentStory)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Move Beat");
    const content = modal.contentEl;
    content.createEl("p", { text: `Move beat "${beat.type}" to:` });
    const select = content.createEl("select", { cls: "story-engine-move-select" });
    for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
      const chapterScenes = this.scenes.filter((s) => s.chapter_id === chapter.id).sort((a, b) => a.order_num - b.order_num);
      if (chapterScenes.length > 0) {
        const optgroup = select.createEl("optgroup");
        optgroup.label = `Chapter ${chapter.number}: ${chapter.title}`;
        for (const scene of chapterScenes) {
          const option = optgroup.createEl("option", {
            text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`,
            value: scene.id
          });
          if (beat.scene_id === scene.id) {
            option.selected = true;
          }
        }
      }
    }
    const orphanScenes = this.scenes.filter((s) => !s.chapter_id);
    if (orphanScenes.length > 0) {
      const optgroup = select.createEl("optgroup");
      optgroup.label = "No Chapter";
      for (const scene of orphanScenes.sort((a, b) => a.order_num - b.order_num)) {
        const option = optgroup.createEl("option", {
          text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`,
          value: scene.id
        });
        if (beat.scene_id === scene.id) {
          option.selected = true;
        }
      }
    }
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const moveButton = buttonContainer.createEl("button", {
      text: "Move",
      cls: "mod-cta"
    });
    moveButton.onclick = async () => {
      const selectedSceneId = select.value;
      if (!selectedSceneId) {
        new import_obsidian16.Notice("Please select a scene", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.moveBeat(beat.id, selectedSceneId);
        await this.loadHierarchy();
        this.renderTabContent();
        modal.close();
        new import_obsidian16.Notice("Beat moved successfully");
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to move beat";
        new import_obsidian16.Notice(`Error: ${errorMessage}`, 5e3);
      }
    };
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.onclick = () => modal.close();
    modal.open();
  }
  renderContentsTab(container) {
    container.empty();
    const contentsByChapter = /* @__PURE__ */ new Map();
    const contentsByScene = /* @__PURE__ */ new Map();
    const contentsByBeat = /* @__PURE__ */ new Map();
    const orphanContents = [];
    for (const block of this.contentBlocks) {
      const refs = this.contentBlockRefs.filter((r) => r.content_block_id === block.id);
      if (refs.length === 0) {
        orphanContents.push(block);
        continue;
      }
      for (const ref of refs) {
        if (ref.entity_type === "chapter") {
          if (!contentsByChapter.has(ref.entity_id)) {
            contentsByChapter.set(ref.entity_id, []);
          }
          contentsByChapter.get(ref.entity_id).push(block);
        } else if (ref.entity_type === "scene") {
          if (!contentsByScene.has(ref.entity_id)) {
            contentsByScene.set(ref.entity_id, []);
          }
          contentsByScene.get(ref.entity_id).push(block);
        } else if (ref.entity_type === "beat") {
          if (!contentsByBeat.has(ref.entity_id)) {
            contentsByBeat.set(ref.entity_id, []);
          }
          contentsByBeat.get(ref.entity_id).push(block);
        }
      }
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
      const chapterContents = contentsByChapter.get(chapter.id) || [];
      const chapterScenes = this.scenes.filter((s) => s.chapter_id === chapter.id).sort((a, b) => a.order_num - b.order_num);
      if (chapterContents.length > 0 || chapterScenes.length > 0 || chapterScenes.some((s) => {
        const sceneContents = contentsByScene.get(s.id) || [];
        const sceneBeats = this.beats.filter((b) => b.scene_id === s.id);
        const beatContents = sceneBeats.flatMap((b) => contentsByBeat.get(b.id) || []);
        return sceneContents.length > 0 || beatContents.length > 0;
      })) {
        const chapterGroup = list.createDiv({ cls: "story-engine-chapter-group" });
        const chapterHeader = chapterGroup.createDiv({ cls: "story-engine-chapter-group-header story-engine-hoverable-header" });
        chapterHeader.createEl("h2", {
          text: `Chapter ${chapter.number}: ${chapter.title}`
        });
        const chapterHeaderActions = chapterHeader.createDiv({ cls: "story-engine-hover-header-actions" });
        const textBtn = chapterHeaderActions.createEl("button", {
          cls: "story-engine-add-content-btn story-engine-add-text-btn",
          attr: { "aria-label": "Add text content" }
        });
        textBtn.innerHTML = '<span class="story-engine-icon">\u{1F4DD}</span>';
        textBtn.onclick = () => {
          this.createContentForEntity("chapter", chapter.id, chapter.id, "text");
        };
        const imageBtn = chapterHeaderActions.createEl("button", {
          cls: "story-engine-add-content-btn story-engine-add-image-btn",
          attr: { "aria-label": "Add image content" }
        });
        imageBtn.innerHTML = '<span class="story-engine-icon">\u{1F5BC}\uFE0F</span>';
        imageBtn.onclick = () => {
          this.createContentForEntity("chapter", chapter.id, chapter.id, "image");
        };
        const chapterContent = chapterGroup.createDiv({ cls: "story-engine-chapter-group-content" });
        const chapterContentsGroup = chapterContent.createDiv({ cls: "story-engine-group" });
        const chapterContentsHeader = chapterContentsGroup.createDiv({ cls: "story-engine-group-header" });
        chapterContentsHeader.createEl("h3", { text: "Chapter Contents" });
        const chapterContentsItems = chapterContentsGroup.createDiv({ cls: "story-engine-group-items" });
        if (chapterContents.length > 0) {
          for (const block of chapterContents) {
            this.renderContentItem(chapterContentsItems, block, "chapter", chapter.id);
          }
        } else {
          chapterContentsItems.createEl("p", { text: "No content in this chapter.", cls: "story-engine-empty-content" });
        }
        for (const scene of chapterScenes) {
          const sceneContents = contentsByScene.get(scene.id) || [];
          const sceneBeats = this.beats.filter((b) => b.scene_id === scene.id).sort((a, b) => a.order_num - b.order_num);
          const beatContents = sceneBeats.flatMap((b) => contentsByBeat.get(b.id) || []);
          const sceneGroup = chapterContent.createDiv({ cls: "story-engine-group" });
          const sceneHeader = sceneGroup.createDiv({ cls: "story-engine-group-header story-engine-hoverable-header" });
          sceneHeader.createEl("h3", {
            text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`
          });
          const sceneHeaderActions = sceneHeader.createDiv({ cls: "story-engine-hover-header-actions" });
          const chapterId = scene.chapter_id || (this.chapters.length > 0 ? this.chapters[0].id : "");
          if (chapterId) {
            const textBtn2 = sceneHeaderActions.createEl("button", {
              cls: "story-engine-add-content-btn story-engine-add-text-btn",
              attr: { "aria-label": "Add text content" }
            });
            textBtn2.innerHTML = '<span class="story-engine-icon">\u{1F4DD}</span>';
            textBtn2.onclick = () => {
              this.createContentForEntity("scene", scene.id, chapterId, "text");
            };
            const imageBtn2 = sceneHeaderActions.createEl("button", {
              cls: "story-engine-add-content-btn story-engine-add-image-btn",
              attr: { "aria-label": "Add image content" }
            });
            imageBtn2.innerHTML = '<span class="story-engine-icon">\u{1F5BC}\uFE0F</span>';
            imageBtn2.onclick = () => {
              this.createContentForEntity("scene", scene.id, chapterId, "image");
            };
          }
          const sceneItems = sceneGroup.createDiv({ cls: "story-engine-group-items" });
          if (sceneContents.length > 0) {
            for (const block of sceneContents) {
              this.renderContentItem(sceneItems, block, "scene", scene.id);
            }
          } else {
            sceneItems.createEl("p", { text: "No content in this scene.", cls: "story-engine-empty-content" });
          }
          for (const beat of sceneBeats) {
            const beatContents2 = contentsByBeat.get(beat.id) || [];
            const beatSubGroup = sceneItems.createDiv({ cls: "story-engine-beat-subgroup" });
            const beatSubGroupTitle = beatSubGroup.createDiv({ cls: "story-engine-beat-subgroup-title-container story-engine-hoverable-header" });
            beatSubGroupTitle.createEl("h4", {
              text: `Beat ${beat.order_num}: ${beat.type}`,
              cls: "story-engine-beat-subgroup-title"
            });
            const beatHeaderActions = beatSubGroupTitle.createDiv({ cls: "story-engine-hover-header-actions" });
            const beatChapterId = scene.chapter_id || (this.chapters.length > 0 ? this.chapters[0].id : "");
            if (beatChapterId) {
              const textBtn2 = beatHeaderActions.createEl("button", {
                cls: "story-engine-add-content-btn story-engine-add-text-btn",
                attr: { "aria-label": "Add text content" }
              });
              textBtn2.innerHTML = '<span class="story-engine-icon">\u{1F4DD}</span>';
              textBtn2.onclick = () => {
                this.createContentForEntity("beat", beat.id, beatChapterId, "text");
              };
              const imageBtn2 = beatHeaderActions.createEl("button", {
                cls: "story-engine-add-content-btn story-engine-add-image-btn",
                attr: { "aria-label": "Add image content" }
              });
              imageBtn2.innerHTML = '<span class="story-engine-icon">\u{1F5BC}\uFE0F</span>';
              imageBtn2.onclick = () => {
                this.createContentForEntity("beat", beat.id, beatChapterId, "image");
              };
            }
            if (beatContents2.length > 0) {
              for (const block of beatContents2) {
                this.renderContentItem(beatSubGroup, block, "beat", beat.id);
              }
            } else {
              beatSubGroup.createEl("p", { text: "No content in this beat.", cls: "story-engine-empty-beat-content" });
            }
          }
        }
      }
    }
    if (this.chapters.length === 0 || orphanContents.length > 0 || this.scenes.some((s) => !s.chapter_id)) {
      const orphanGroup = list.createDiv({ cls: "story-engine-chapter-group" });
      const orphanHeader = orphanGroup.createDiv({ cls: "story-engine-chapter-group-header" });
      orphanHeader.createEl("h2", { text: "Without Chapter" });
      const orphanContent = orphanGroup.createDiv({ cls: "story-engine-chapter-group-content" });
      const orphanScenes = this.scenes.filter((s) => !s.chapter_id).sort((a, b) => a.order_num - b.order_num);
      for (const scene of orphanScenes) {
        const sceneContents = contentsByScene.get(scene.id) || [];
        const sceneBeats = this.beats.filter((b) => b.scene_id === scene.id).sort((a, b) => a.order_num - b.order_num);
        const beatContents = sceneBeats.flatMap((b) => contentsByBeat.get(b.id) || []);
        const sceneGroup = orphanContent.createDiv({ cls: "story-engine-group" });
        const sceneHeader = sceneGroup.createDiv({ cls: "story-engine-group-header story-engine-hoverable-header" });
        sceneHeader.createEl("h3", {
          text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`
        });
        const sceneHeaderActions = sceneHeader.createDiv({ cls: "story-engine-header-actions" });
        const chapterId = this.chapters.length > 0 ? this.chapters[0].id : "";
        if (chapterId) {
          sceneHeaderActions.createEl("button", {
            text: "+ Content",
            cls: "story-engine-add-content-btn"
          }).onclick = () => {
            this.createContentForEntity("scene", scene.id, chapterId);
          };
        }
        const sceneItems = sceneGroup.createDiv({ cls: "story-engine-group-items" });
        if (sceneContents.length > 0) {
          for (const block of sceneContents) {
            this.renderContentItem(sceneItems, block, "scene", scene.id);
          }
        } else {
          sceneItems.createEl("p", { text: "No content in this scene." });
        }
        for (const beat of sceneBeats) {
          const beatContents2 = contentsByBeat.get(beat.id) || [];
          const beatSubGroup = sceneItems.createDiv({ cls: "story-engine-beat-subgroup" });
          const beatSubGroupTitle = beatSubGroup.createDiv({ cls: "story-engine-beat-subgroup-title-container story-engine-hoverable-header" });
          beatSubGroupTitle.createEl("h4", {
            text: `Beat ${beat.order_num}: ${beat.type}`,
            cls: "story-engine-beat-subgroup-title"
          });
          const beatHeaderActions = beatSubGroupTitle.createDiv({ cls: "story-engine-hover-header-actions" });
          const beatChapterId = this.chapters.length > 0 ? this.chapters[0].id : "";
          if (beatChapterId) {
            beatHeaderActions.createEl("button", {
              text: "+ Content",
              cls: "story-engine-add-content-btn"
            }).onclick = () => {
              this.createContentForEntity("beat", beat.id, beatChapterId);
            };
          }
          if (beatContents2.length > 0) {
            for (const block of beatContents2) {
              this.renderContentItem(beatSubGroup, block, "beat", beat.id);
            }
          } else {
            beatSubGroup.createEl("p", { text: "No content in this beat.", cls: "story-engine-empty-beat-content" });
          }
        }
      }
      if (orphanContents.length > 0) {
        const orphanContentsGroup = orphanContent.createDiv({ cls: "story-engine-group" });
        const orphanContentsHeader = orphanContentsGroup.createDiv({ cls: "story-engine-group-header" });
        orphanContentsHeader.createEl("h3", { text: "Without Reference" });
        const orphanContentsItems = orphanContentsGroup.createDiv({ cls: "story-engine-group-items" });
        for (const block of orphanContents) {
          this.renderContentItem(orphanContentsItems, block, null, null);
        }
      }
    }
  }
  async loadStoryCharacters() {
    if (!this.currentStory || !this.currentStory.world_id) {
      this.storyCharacters = [];
      return;
    }
    try {
      this.storyCharacters = await this.plugin.apiClient.getCharacters(this.currentStory.world_id);
    } catch (err) {
      console.error("Error loading story characters:", err);
      this.storyCharacters = [];
      new import_obsidian16.Notice(`Error loading characters: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
    }
  }
  renderStoryCharactersTab(container) {
    var _a;
    container.empty();
    if (!((_a = this.currentStory) == null ? void 0 : _a.world_id)) {
      const noWorldMsg = container.createDiv({ cls: "story-engine-empty-state" });
      noWorldMsg.createEl("p", { text: "This story is not linked to a world." });
      noWorldMsg.createEl("p", { text: "Link this story to a world to see its characters.", cls: "story-engine-hint" });
      return;
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    if (this.storyCharacters.length === 0) {
      list.createEl("p", { text: "No characters found in this story's world." });
    } else {
      for (const character of this.storyCharacters.sort((a, b) => a.name.localeCompare(b.name))) {
        const item = list.createDiv({ cls: "story-engine-item" });
        const titleDiv = item.createDiv({ cls: "story-engine-title", text: character.name });
        titleDiv.style.cursor = "pointer";
        titleDiv.onclick = () => {
          this.showCharacterDetails(character);
        };
        const meta = item.createDiv({ cls: "story-engine-meta" });
        if (character.description) {
          meta.createEl("span", {
            text: character.description.substring(0, 80) + (character.description.length > 80 ? "..." : "")
          });
        }
        const actions = item.createDiv({ cls: "story-engine-item-actions" });
        const viewBtn = actions.createEl("button", { text: "View" });
        viewBtn.onclick = () => {
          this.showCharacterDetails(character);
        };
      }
    }
    const footer = container.createDiv({ cls: "story-engine-list-footer" });
    const createButton = footer.createEl("button", {
      text: "Create Character",
      cls: "mod-cta"
    });
    createButton.onclick = () => {
      this.showCreateCharacterModalForStory();
    };
  }
  showCreateCharacterModalForStory() {
    var _a;
    if (!((_a = this.currentStory) == null ? void 0 : _a.world_id)) {
      new import_obsidian16.Notice("This story is not linked to a world");
      return;
    }
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Create Character");
    const content = modal.contentEl;
    let name = "";
    let description = "";
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input" });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Create", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.createCharacter(this.currentStory.world_id, {
          name: name.trim(),
          description: description.trim()
        });
        await this.loadStoryCharacters();
        this.renderTabContent();
        modal.close();
        new import_obsidian16.Notice("Character created");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
    nameInput.focus();
  }
  renderContentItem(container, contentBlock, entityType, entityId) {
    var _a, _b;
    const item = container.createDiv({ cls: "story-engine-item story-engine-content-item" });
    const itemContent = item.createDiv({ cls: "story-engine-content-item-content" });
    const iconContainer = itemContent.createDiv({ cls: "story-engine-content-icon" });
    const iconMap = {
      text: "file-text",
      image: "image",
      video: "video",
      audio: "music",
      embed: "code",
      link: "external-link"
    };
    const iconName = iconMap[contentBlock.type] || "file";
    (0, import_obsidian16.setIcon)(iconContainer, iconName);
    const preview = itemContent.createDiv({ cls: "story-engine-content-preview" });
    if (contentBlock.type === "text") {
      const textPreview = contentBlock.content || "";
      const truncated = textPreview.length > 100 ? textPreview.substring(0, 100) + "..." : textPreview;
      preview.createEl("span", { text: truncated });
    } else if (contentBlock.type === "image") {
      const imgContainer = preview.createDiv({ cls: "story-engine-image-container" });
      const img = imgContainer.createEl("img", {
        attr: { src: contentBlock.content || "", alt: ((_a = contentBlock.metadata) == null ? void 0 : _a.alt_text) || "" },
        cls: "story-engine-content-thumbnail"
      });
      img.style.maxWidth = "100px";
      img.style.maxHeight = "60px";
      img.style.objectFit = "cover";
      img.style.borderRadius = "4px";
      if ((_b = contentBlock.metadata) == null ? void 0 : _b.attribution) {
        const attribution = imgContainer.createDiv({ cls: "story-engine-unsplash-attribution" });
        attribution.createEl("span", {
          text: contentBlock.metadata.attribution,
          cls: "story-engine-attribution-text"
        });
      }
    } else {
      preview.createEl("span", { text: contentBlock.content || "" });
    }
    const actions = item.createDiv({ cls: "story-engine-item-actions" });
    actions.createEl("button", { text: "Edit" }).onclick = () => {
      new ContentBlockModal(this.app, async (updatedContentBlock) => {
        try {
          await this.plugin.apiClient.updateContentBlock(contentBlock.id, updatedContentBlock);
          await this.loadHierarchy();
          this.renderTabContent();
          new import_obsidian16.Notice("Content block updated successfully");
        } catch (err) {
          throw err;
        }
      }, contentBlock, this.plugin).open();
    };
    actions.createEl("button", { text: "Move" }).onclick = async () => {
      await this.showMoveContentModal(contentBlock, entityType, entityId, "move");
    };
    actions.createEl("button", { text: "Link" }).onclick = async () => {
      await this.showMoveContentModal(contentBlock, entityType, entityId, "link");
    };
    actions.createEl("button", { text: "Delete" }).onclick = async () => {
      if (confirm("Delete this content block?")) {
        try {
          await this.plugin.apiClient.deleteContentBlock(contentBlock.id);
          await this.loadHierarchy();
          this.renderTabContent();
          new import_obsidian16.Notice("Content block deleted");
        } catch (err) {
          new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
        }
      }
    };
  }
  async showMoveContentModal(contentBlock, currentEntityType, currentEntityId, mode) {
    if (!this.currentStory)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText(mode === "move" ? "Move Content Block" : "Link Content Block");
    const content = modal.contentEl;
    content.createEl("p", {
      text: mode === "move" ? `Move content block to:` : `Link content block to (will appear in both places):`
    });
    const select = content.createEl("select", { cls: "story-engine-move-select" });
    const noRefOption = select.createEl("option", { text: "No Reference", value: "" });
    for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
      const option = select.createEl("option", {
        text: `Chapter ${chapter.number}: ${chapter.title}`,
        value: `chapter:${chapter.id}`
      });
      if (currentEntityType === "chapter" && currentEntityId === chapter.id) {
        option.selected = true;
      }
    }
    for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
      const chapterScenes = this.scenes.filter((s) => s.chapter_id === chapter.id).sort((a, b) => a.order_num - b.order_num);
      if (chapterScenes.length > 0) {
        const optgroup = select.createEl("optgroup");
        optgroup.label = `Chapter ${chapter.number}: ${chapter.title} - Scenes`;
        for (const scene of chapterScenes) {
          const option = optgroup.createEl("option", {
            text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`,
            value: `scene:${scene.id}`
          });
          if (currentEntityType === "scene" && currentEntityId === scene.id) {
            option.selected = true;
          }
        }
      }
    }
    const orphanScenes = this.scenes.filter((s) => !s.chapter_id);
    if (orphanScenes.length > 0) {
      const optgroup = select.createEl("optgroup");
      optgroup.label = "No Chapter - Scenes";
      for (const scene of orphanScenes.sort((a, b) => a.order_num - b.order_num)) {
        const option = optgroup.createEl("option", {
          text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`,
          value: `scene:${scene.id}`
        });
        if (currentEntityType === "scene" && currentEntityId === scene.id) {
          option.selected = true;
        }
      }
    }
    for (const scene of this.scenes.sort((a, b) => a.order_num - b.order_num)) {
      const sceneBeats = this.beats.filter((b) => b.scene_id === scene.id).sort((a, b) => a.order_num - b.order_num);
      if (sceneBeats.length > 0) {
        const chapter = this.chapters.find((c) => c.id === scene.chapter_id);
        const chapterLabel = chapter ? `Chapter ${chapter.number}` : "No Chapter";
        const optgroup = select.createEl("optgroup");
        optgroup.label = `${chapterLabel} > Scene ${scene.order_num} - Beats`;
        for (const beat of sceneBeats) {
          const option = optgroup.createEl("option", {
            text: `Beat ${beat.order_num}: ${beat.type}`,
            value: `beat:${beat.id}`
          });
          if (currentEntityType === "beat" && currentEntityId === beat.id) {
            option.selected = true;
          }
        }
      }
    }
    if (!currentEntityType) {
      noRefOption.selected = true;
    }
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const actionButton = buttonContainer.createEl("button", {
      text: mode === "move" ? "Move" : "Link",
      cls: "mod-cta"
    });
    actionButton.onclick = async () => {
      const selectedValue = select.value;
      try {
        if (mode === "move" && currentEntityType && currentEntityId) {
          const currentRef = this.contentBlockRefs.find(
            (r) => r.content_block_id === contentBlock.id && r.entity_type === currentEntityType && r.entity_id === currentEntityId
          );
          if (currentRef) {
            await this.plugin.apiClient.deleteContentAnchor(currentRef.id);
          }
        }
        if (selectedValue) {
          const [entityType, entityId] = selectedValue.split(":");
          await this.plugin.apiClient.createContentAnchor(contentBlock.id, entityType, entityId);
        }
        await this.loadHierarchy();
        this.renderTabContent();
        modal.close();
        new import_obsidian16.Notice(mode === "move" ? "Content block moved successfully" : "Content block linked successfully");
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : `Failed to ${mode} content block`;
        new import_obsidian16.Notice(`Error: ${errorMessage}`, 5e3);
      }
    };
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.onclick = () => modal.close();
    modal.open();
  }
  async createContentForEntity(entityType, entityId, chapterId, contentType = "text") {
    if (!this.currentStory)
      return;
    if (!chapterId) {
      if (this.chapters.length === 0) {
        new import_obsidian16.Notice("No chapter available. Please create a chapter first.", 5e3);
        return;
      }
      chapterId = this.chapters[0].id;
    }
    const chapterBlocks = this.contentBlocks.filter((cb) => {
      const refs = this.contentBlockRefs.filter((r) => r.content_block_id === cb.id && r.entity_type === "chapter" && r.entity_id === chapterId);
      return refs.length > 0 || cb.chapter_id === chapterId;
    });
    const maxOrderNum = chapterBlocks.length > 0 ? Math.max(...chapterBlocks.map((cb) => cb.order_num || 0)) : 0;
    const nextOrderNum = maxOrderNum + 1;
    const initialContentBlock = {
      type: contentType,
      kind: "final",
      content: "",
      metadata: {}
    };
    new ContentBlockModal(this.app, async (contentBlock) => {
      try {
        contentBlock.order_num = nextOrderNum;
        const created = await this.plugin.apiClient.createContentBlock(chapterId, contentBlock);
        await this.plugin.apiClient.createContentAnchor(created.id, entityType, entityId);
        await this.loadHierarchy();
        this.renderTabContent();
        new import_obsidian16.Notice("Content block created successfully");
      } catch (err) {
        throw err;
      }
    }, initialContentBlock, this.plugin).open();
  }
  // ==================== World View Methods ====================
  async showWorldDetails(world) {
    this.currentWorld = world;
    this.viewMode = "world-details";
    this.worldTab = "characters";
    await this.loadWorldData();
    this.renderWorldDetails();
  }
  async loadWorldData() {
    if (!this.currentWorld)
      return;
    this.loadingWorldData = true;
    try {
      this.characters = await this.plugin.apiClient.getCharacters(this.currentWorld.id);
      this.locations = await this.plugin.apiClient.getLocations(this.currentWorld.id);
      this.artifacts = await this.plugin.apiClient.getArtifacts(this.currentWorld.id);
      this.events = await this.plugin.apiClient.getEvents(this.currentWorld.id);
      try {
        this.traits = await this.plugin.apiClient.getTraits();
      } catch (err) {
        console.warn("Traits not available:", err);
        this.traits = [];
      }
      try {
        this.archetypes = await this.plugin.apiClient.getArchetypes();
      } catch (err) {
        console.warn("Archetypes not available:", err);
        this.archetypes = [];
      }
      try {
        this.factions = await this.plugin.apiClient.getFactions(this.currentWorld.id);
      } catch (err) {
        console.warn("Factions not available:", err);
        this.factions = [];
      }
      try {
        this.lores = await this.plugin.apiClient.getLores(this.currentWorld.id);
      } catch (err) {
        console.warn("Lores not available:", err);
        this.lores = [];
      }
      try {
        this.currentWorld = await this.plugin.apiClient.getWorld(this.currentWorld.id);
      } catch (err) {
        console.warn("Failed to reload world:", err);
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to load world data";
      new import_obsidian16.Notice(`Error: ${errorMessage}`, 5e3);
    } finally {
      this.loadingWorldData = false;
    }
  }
  renderWorldDetails() {
    if (!this.contentEl || !this.currentWorld)
      return;
    this.renderWorldDetailsHeader();
    this.contentEl.empty();
    this.renderWorldTabs();
    this.renderWorldTabContent();
  }
  renderWorldDetailsHeader() {
    if (!this.headerEl || !this.currentWorld)
      return;
    this.headerEl.empty();
    const headerLeft = this.headerEl.createDiv({ cls: "story-engine-header-left" });
    const backButton = headerLeft.createEl("button", {
      text: "\u2190 Back",
      cls: "story-engine-back-btn"
    });
    backButton.onclick = () => {
      this.currentWorld = null;
      this.viewMode = "list";
      this.listTab = "worlds";
      this.renderListHeader();
      this.renderListContent();
    };
    const titleContainer = headerLeft.createDiv({ cls: "story-engine-title-container" });
    const titleRow = titleContainer.createDiv({ cls: "story-engine-title-row" });
    titleRow.createEl("h2", {
      text: this.currentWorld.name,
      cls: "story-engine-title-header"
    });
    if (this.currentWorld.genre) {
      const genrePill = titleRow.createSpan({
        cls: "story-engine-status-pill story-engine-status-draft"
      });
      genrePill.textContent = this.currentWorld.genre;
    }
    const uuidRow = titleContainer.createDiv({ cls: "story-engine-uuid-row" });
    const uuidSpan = uuidRow.createSpan({ cls: "story-engine-uuid" });
    uuidSpan.textContent = this.currentWorld.id;
    const copyUuidButton = uuidRow.createEl("button", {
      cls: "story-engine-copy-uuid-btn",
      attr: { "aria-label": "Copy UUID" }
    });
    (0, import_obsidian16.setIcon)(copyUuidButton, "copy");
    copyUuidButton.onclick = () => {
      if (!this.currentWorld)
        return;
      navigator.clipboard.writeText(this.currentWorld.id).then(() => {
        new import_obsidian16.Notice("UUID copied to clipboard");
      }).catch(() => {
        new import_obsidian16.Notice("Failed to copy UUID", 3e3);
      });
    };
    if (this.currentWorld.description) {
      const descRow = titleContainer.createDiv({ cls: "story-engine-world-desc" });
      descRow.textContent = this.currentWorld.description;
    }
    const headerActions = this.headerEl.createDiv({ cls: "story-engine-header-actions" });
    const contextButton = headerActions.createEl("button", {
      cls: "story-engine-context-btn",
      attr: { "aria-label": "World Actions" }
    });
    (0, import_obsidian16.setIcon)(contextButton, "more-vertical");
    const dropdownMenu = headerActions.createDiv({ cls: "story-engine-dropdown-menu" });
    dropdownMenu.style.display = "none";
    const editOption = dropdownMenu.createEl("button", {
      cls: "story-engine-dropdown-item"
    });
    (0, import_obsidian16.setIcon)(editOption, "pencil");
    editOption.createSpan({ text: "Edit World" });
    editOption.onclick = () => {
      dropdownMenu.style.display = "none";
      this.showEditWorldModal();
    };
    contextButton.onclick = (e) => {
      e.stopPropagation();
      const isVisible = dropdownMenu.style.display !== "none";
      dropdownMenu.style.display = isVisible ? "none" : "block";
    };
    document.addEventListener("click", () => {
      dropdownMenu.style.display = "none";
    }, { once: true });
  }
  renderWorldTabs() {
    if (!this.contentEl)
      return;
    const existingTabs = this.contentEl.querySelector(".story-engine-tabs-container");
    if (existingTabs) {
      existingTabs.remove();
    }
    const tabsWrapper = this.contentEl.createDiv({ cls: "story-engine-tabs-container" });
    const entityTabsContainer = tabsWrapper.createDiv({ cls: "story-engine-tabs" });
    const entityTabs = [
      { key: "characters", label: "Characters" },
      { key: "locations", label: "Locations" },
      { key: "factions", label: "Factions" },
      { key: "artifacts", label: "Artifacts" }
    ];
    for (const tab of entityTabs) {
      const tabButton = entityTabsContainer.createEl("button", {
        text: tab.label,
        cls: `story-engine-tab ${this.worldTab === tab.key ? "is-active" : ""}`
      });
      tabButton.onclick = () => {
        this.worldTab = tab.key;
        this.renderWorldTabs();
        this.renderWorldTabContent();
      };
    }
    const metaTabsContainer = tabsWrapper.createDiv({ cls: "story-engine-tabs" });
    const metaTabs = [
      { key: "traits", label: "Traits" },
      { key: "archetypes", label: "Archetypes" },
      { key: "events", label: "Events" },
      { key: "lore", label: "Lore" }
    ];
    for (const tab of metaTabs) {
      const tabButton = metaTabsContainer.createEl("button", {
        text: tab.label,
        cls: `story-engine-tab ${this.worldTab === tab.key ? "is-active" : ""}`
      });
      tabButton.onclick = () => {
        this.worldTab = tab.key;
        this.renderWorldTabs();
        this.renderWorldTabContent();
      };
    }
  }
  renderWorldTabContent() {
    if (!this.contentEl)
      return;
    const existingContent = this.contentEl.querySelector(".story-engine-tab-content");
    if (existingContent) {
      existingContent.remove();
    }
    const contentContainer = this.contentEl.createDiv({ cls: "story-engine-tab-content" });
    if (this.loadingWorldData) {
      contentContainer.createEl("p", { text: "Loading..." });
      return;
    }
    switch (this.worldTab) {
      case "characters":
        this.renderCharactersTab(contentContainer);
        break;
      case "traits":
        this.renderTraitsTab(contentContainer);
        break;
      case "archetypes":
        this.renderArchetypesTab(contentContainer);
        break;
      case "events":
        this.renderEventsTab(contentContainer);
        break;
      case "lore":
        this.renderLoreTab(contentContainer);
        break;
      case "locations":
        this.renderLocationsTab(contentContainer);
        break;
      case "factions":
        this.renderFactionsTab(contentContainer);
        break;
      case "artifacts":
        this.renderArtifactsTab(contentContainer);
        break;
    }
    this.renderWorldActionsBar(contentContainer);
  }
  renderWorldActionsBar(container) {
    const actionsBar = container.createDiv({ cls: "story-engine-actions-bar" });
    let createButtonText = "Create Character";
    let createButtonAction = () => {
      this.showCreateCharacterModal();
    };
    switch (this.worldTab) {
      case "traits":
        createButtonText = "Create Trait";
        createButtonAction = () => this.showCreateTraitModal();
        break;
      case "archetypes":
        createButtonText = "Create Archetype";
        createButtonAction = () => this.showCreateArchetypeModal();
        break;
      case "events":
        createButtonText = "Create Event";
        createButtonAction = () => this.showCreateEventModal();
        break;
      case "lore":
        createButtonText = "Create Lore";
        createButtonAction = () => this.showCreateLoreModal();
        break;
      case "locations":
        createButtonText = "Create Location";
        createButtonAction = () => this.showCreateLocationModal();
        break;
      case "factions":
        createButtonText = "Create Faction";
        createButtonAction = () => this.showCreateFactionModal();
        break;
      case "artifacts":
        createButtonText = "Create Artifact";
        createButtonAction = () => this.showCreateArtifactModal();
        break;
    }
    const createButton = actionsBar.createEl("button", {
      text: createButtonText,
      cls: "mod-cta story-engine-create-btn"
    });
    createButton.onclick = createButtonAction;
  }
  renderCharactersTab(container) {
    if (this.characters.length === 0) {
      container.createEl("p", { text: "No characters found. Create your first character!" });
      return;
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const character of this.characters) {
      const item = list.createDiv({ cls: "story-engine-item" });
      const titleDiv = item.createDiv({ cls: "story-engine-title", text: character.name });
      titleDiv.style.cursor = "pointer";
      titleDiv.onclick = () => {
        this.showCharacterDetails(character);
      };
      const meta = item.createDiv({ cls: "story-engine-meta" });
      if (character.description) {
        meta.createEl("span", { text: character.description.substring(0, 50) + (character.description.length > 50 ? "..." : "") });
      }
      const actions = item.createDiv({ cls: "story-engine-item-actions" });
      const relBtn = actions.createEl("button");
      (0, import_obsidian16.setIcon)(relBtn, "users");
      relBtn.title = "Add Relationship";
      relBtn.onclick = () => this.showAddCharacterRelationshipModal(character);
      actions.createEl("button", { text: "Edit" }).onclick = () => {
        this.showEditCharacterModal(character);
      };
      actions.createEl("button", { text: "Delete" }).onclick = async () => {
        if (confirm(`Delete character "${character.name}"?`)) {
          try {
            await this.plugin.apiClient.deleteCharacter(character.id);
            await this.loadWorldData();
            this.renderWorldTabContent();
            new import_obsidian16.Notice("Character deleted");
          } catch (err) {
            new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
          }
        }
      };
    }
  }
  renderLocationsTab(container) {
    if (this.locations.length === 0) {
      container.createEl("p", { text: "No locations found. Create your first location!" });
      return;
    }
    const rootLocations = this.locations.filter((l) => !l.parent_id);
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const location of rootLocations.sort((a, b) => a.name.localeCompare(b.name))) {
      this.renderLocationItem(list, location, 0);
    }
  }
  renderLocationItem(container, location, level) {
    const item = container.createDiv({ cls: "story-engine-item" });
    item.style.marginLeft = `${level * 1}rem`;
    const titleRow = item.createDiv({ cls: "story-engine-title" });
    titleRow.textContent = location.name;
    if (location.type) {
      const typeBadge = titleRow.createSpan({ cls: "story-engine-badge" });
      typeBadge.textContent = location.type;
    }
    const meta = item.createDiv({ cls: "story-engine-meta" });
    if (location.description) {
      meta.createEl("span", { text: location.description.substring(0, 50) + (location.description.length > 50 ? "..." : "") });
    }
    const actions = item.createDiv({ cls: "story-engine-item-actions" });
    actions.createEl("button", { text: "Edit" }).onclick = () => {
      this.showEditLocationModal(location);
    };
    actions.createEl("button", { text: "Delete" }).onclick = async () => {
      if (confirm(`Delete location "${location.name}"?`)) {
        try {
          await this.plugin.apiClient.deleteLocation(location.id);
          await this.loadWorldData();
          this.renderWorldTabContent();
          new import_obsidian16.Notice("Location deleted");
        } catch (err) {
          new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
        }
      }
    };
    const children2 = this.locations.filter((l) => l.parent_id === location.id);
    for (const child of children2.sort((a, b) => a.name.localeCompare(b.name))) {
      this.renderLocationItem(container, child, level + 1);
    }
  }
  renderArtifactsTab(container) {
    if (this.artifacts.length === 0) {
      container.createEl("p", { text: "No artifacts found. Create your first artifact!" });
      return;
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const artifact of this.artifacts) {
      const item = list.createDiv({ cls: "story-engine-item" });
      const titleRow = item.createDiv({ cls: "story-engine-title" });
      titleRow.textContent = artifact.name;
      if (artifact.rarity) {
        const rarityBadge = titleRow.createSpan({ cls: `story-engine-badge story-engine-rarity-${artifact.rarity.toLowerCase()}` });
        rarityBadge.textContent = artifact.rarity;
      }
      const meta = item.createDiv({ cls: "story-engine-meta" });
      if (artifact.description) {
        meta.createEl("span", { text: artifact.description.substring(0, 50) + (artifact.description.length > 50 ? "..." : "") });
      }
      const actions = item.createDiv({ cls: "story-engine-item-actions" });
      actions.createEl("button", { text: "Edit" }).onclick = () => {
        this.showEditArtifactModal(artifact);
      };
      actions.createEl("button", { text: "Delete" }).onclick = async () => {
        if (confirm(`Delete artifact "${artifact.name}"?`)) {
          try {
            await this.plugin.apiClient.deleteArtifact(artifact.id);
            await this.loadWorldData();
            this.renderWorldTabContent();
            new import_obsidian16.Notice("Artifact deleted");
          } catch (err) {
            new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
          }
        }
      };
    }
  }
  renderEventsTab(container) {
    var _a;
    const timeConfigSection = container.createDiv({ cls: "story-engine-time-config-section" });
    if ((_a = this.currentWorld) == null ? void 0 : _a.time_config) {
      this.renderTimeConfigDisplay(timeConfigSection, this.currentWorld.time_config);
      const editBtn = timeConfigSection.createEl("button", {
        text: "Edit Time Config",
        cls: "story-engine-btn-secondary"
      });
      editBtn.onclick = () => this.showTimeConfigModal(this.currentWorld.time_config);
    } else {
      const addBtn = timeConfigSection.createEl("button", {
        text: "Add Time Configuration",
        cls: "story-engine-btn-primary"
      });
      addBtn.onclick = () => this.showTimeConfigModal(null);
    }
    const timelineSection = container.createDiv({ cls: "story-engine-timeline-section" });
    const timelineBtn = timelineSection.createEl("button", {
      text: "View Timeline",
      cls: "story-engine-btn-secondary"
    });
    timelineBtn.onclick = () => this.showTimelineModal();
    const epochSection = container.createDiv({ cls: "story-engine-epoch-section" });
    epochSection.createEl("h4", { text: "\u23F0 Epoch Event (Year Zero)", cls: "story-engine-section-title" });
    const epochEvent = this.events.find((e) => e.is_epoch && e.timeline_position === 0);
    if (epochEvent) {
      const epochItem = epochSection.createDiv({ cls: "story-engine-item story-engine-epoch-item" });
      const epochTitle = epochItem.createDiv({ cls: "story-engine-title" });
      epochTitle.createSpan({ text: epochEvent.name });
      epochTitle.createSpan({ cls: "story-engine-badge story-engine-badge-epoch", text: "EPOCH" });
      const epochMeta = epochItem.createDiv({ cls: "story-engine-meta" });
      epochMeta.createEl("span", { text: "Position: 0 (Year Zero)" });
      if (epochEvent.description) {
        epochMeta.createEl("span", { text: epochEvent.description.substring(0, 80) + (epochEvent.description.length > 80 ? "..." : "") });
      }
      const epochActions = epochItem.createDiv({ cls: "story-engine-item-actions" });
      epochActions.createEl("button", { text: "Edit Epoch" }).onclick = () => {
        this.showEditEventModal(epochEvent);
      };
    } else {
      const createEpochBtn = epochSection.createEl("button", {
        text: "\u{1F31F} Create Epoch Event (Year Zero)",
        cls: "mod-cta story-engine-create-epoch-btn"
      });
      createEpochBtn.onclick = () => this.showCreateEpochEventModal();
      epochSection.createEl("p", {
        text: "The Epoch Event marks Year Zero - all other events are dated relative to this point.",
        cls: "story-engine-hint"
      });
    }
    const eventsSection = container.createDiv({ cls: "story-engine-events-list-section" });
    eventsSection.createEl("h4", { text: "\u{1F4DC} Events", cls: "story-engine-section-title" });
    const regularEvents = this.events.filter((e) => !(e.is_epoch && e.timeline_position === 0));
    if (regularEvents.length === 0) {
      eventsSection.createEl("p", { text: "No events yet. Create your first event!", cls: "story-engine-empty-hint" });
      return;
    }
    const list = eventsSection.createDiv({ cls: "story-engine-list" });
    const sortedEvents = regularEvents.sort((a, b) => {
      var _a2, _b;
      const posA = (_a2 = a.timeline_position) != null ? _a2 : Number.MAX_SAFE_INTEGER;
      const posB = (_b = b.timeline_position) != null ? _b : Number.MAX_SAFE_INTEGER;
      if (posA !== posB)
        return posA - posB;
      return b.importance - a.importance;
    });
    for (const event of sortedEvents) {
      const item = list.createDiv({ cls: "story-engine-item" });
      const titleRow = item.createDiv({ cls: "story-engine-title" });
      titleRow.createSpan({ text: event.name });
      const importanceBadge = titleRow.createSpan({ cls: "story-engine-badge" });
      importanceBadge.textContent = `\u2605${event.importance}`;
      if (event.type) {
        titleRow.createSpan({ cls: "story-engine-badge", text: event.type });
      }
      if (event.is_epoch) {
        titleRow.createSpan({ cls: "story-engine-badge story-engine-badge-epoch", text: "EPOCH" });
      }
      const meta = item.createDiv({ cls: "story-engine-meta" });
      if (event.timeline_position !== void 0 && event.timeline_position !== null) {
        const posText = event.timeline_position >= 0 ? `Year ${event.timeline_position}` : `${Math.abs(event.timeline_position)} years before Year Zero`;
        meta.createEl("span", { text: `\u{1F4C5} ${posText}`, cls: "story-engine-event-position" });
      }
      if (event.parent_id) {
        const parentEvent = this.events.find((e) => e.id === event.parent_id);
        if (parentEvent) {
          meta.createEl("span", { text: `\u21B3 Related to: ${parentEvent.name}`, cls: "story-engine-event-parent" });
        }
      }
      if (event.description) {
        meta.createEl("span", {
          text: event.description.substring(0, 60) + (event.description.length > 60 ? "..." : ""),
          cls: "story-engine-event-description"
        });
      }
      const actions = item.createDiv({ cls: "story-engine-item-actions" });
      const linkBtn = actions.createEl("button");
      (0, import_obsidian16.setIcon)(linkBtn, "link");
      linkBtn.title = "Link to Entity";
      linkBtn.onclick = () => this.showLinkEventToEntityModal(event);
      const eventLinkBtn = actions.createEl("button");
      (0, import_obsidian16.setIcon)(eventLinkBtn, "git-branch");
      eventLinkBtn.title = "Set Parent Event";
      eventLinkBtn.onclick = () => this.showSetEventParentModal(event);
      actions.createEl("button", { text: "Edit" }).onclick = () => {
        this.showEditEventModal(event);
      };
      actions.createEl("button", { text: "Delete" }).onclick = async () => {
        if (confirm(`Delete event "${event.name}"?`)) {
          try {
            await this.plugin.apiClient.deleteEvent(event.id);
            await this.loadWorldData();
            this.renderWorldTabContent();
            new import_obsidian16.Notice("Event deleted");
          } catch (err) {
            new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
          }
        }
      };
    }
  }
  showCreateEpochEventModal() {
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Create Epoch Event (Year Zero)");
    const content = modal.contentEl;
    let name = "";
    let description = "";
    content.createEl("p", {
      text: "The Epoch Event defines Year Zero in your world's timeline. All other events will be dated relative to this moment.",
      cls: "story-engine-modal-hint"
    });
    content.createEl("label", { text: "Event Name *" });
    const nameInput = content.createEl("input", {
      type: "text",
      cls: "story-engine-input",
      placeholder: "e.g., The Great Cataclysm, The Founding, Year of the Dragon"
    });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", {
      cls: "story-engine-textarea",
      placeholder: "Describe what happened at this pivotal moment..."
    });
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Create Epoch", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required");
        return;
      }
      try {
        await this.plugin.apiClient.createEvent(this.currentWorld.id, {
          name: name.trim(),
          description: description.trim() || void 0,
          timeline_position: 0,
          is_epoch: true,
          importance: 10,
          // Max importance for epoch
          type: "Epoch"
        });
        modal.close();
        await this.loadWorldData();
        this.renderWorldTabContent();
        new import_obsidian16.Notice("Epoch event created!");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => modal.close();
    modal.open();
  }
  renderTraitsTab(container) {
    if (this.traits.length === 0) {
      container.createEl("p", { text: "No traits found. Create your first trait!" });
      return;
    }
    const traitsByCategory = /* @__PURE__ */ new Map();
    for (const trait of this.traits) {
      const category = trait.category || "Uncategorized";
      if (!traitsByCategory.has(category)) {
        traitsByCategory.set(category, []);
      }
      traitsByCategory.get(category).push(trait);
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const [category, categoryTraits] of traitsByCategory.entries()) {
      const group = list.createDiv({ cls: "story-engine-group" });
      const groupHeader = group.createDiv({ cls: "story-engine-group-header" });
      groupHeader.createEl("h3", { text: category });
      const groupItems = group.createDiv({ cls: "story-engine-group-items" });
      for (const trait of categoryTraits.sort((a, b) => a.name.localeCompare(b.name))) {
        const item = groupItems.createDiv({ cls: "story-engine-item" });
        item.createDiv({ cls: "story-engine-title", text: trait.name });
        const meta = item.createDiv({ cls: "story-engine-meta" });
        if (trait.description) {
          meta.createEl("span", { text: trait.description.substring(0, 50) + (trait.description.length > 50 ? "..." : "") });
        }
        const actions = item.createDiv({ cls: "story-engine-item-actions" });
        actions.createEl("button", { text: "Edit" }).onclick = () => {
          this.showEditTraitModal(trait);
        };
        actions.createEl("button", { text: "Delete" }).onclick = async () => {
          if (confirm(`Delete trait "${trait.name}"?`)) {
            try {
              await this.plugin.apiClient.deleteTrait(trait.id);
              await this.loadWorldData();
              this.renderWorldTabContent();
              new import_obsidian16.Notice("Trait deleted");
            } catch (err) {
              new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
            }
          }
        };
      }
    }
  }
  renderArchetypesTab(container) {
    if (this.archetypes.length === 0) {
      container.createEl("p", { text: "No archetypes found. Create your first archetype!" });
      return;
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const archetype of this.archetypes.sort((a, b) => a.name.localeCompare(b.name))) {
      const item = list.createDiv({ cls: "story-engine-item" });
      item.createDiv({ cls: "story-engine-title", text: archetype.name });
      const meta = item.createDiv({ cls: "story-engine-meta" });
      if (archetype.description) {
        meta.createEl("span", { text: archetype.description.substring(0, 50) + (archetype.description.length > 50 ? "..." : "") });
      }
      const actions = item.createDiv({ cls: "story-engine-item-actions" });
      actions.createEl("button", { text: "View Traits" }).onclick = async () => {
        try {
          const traits = await this.plugin.apiClient.getArchetypeTraits(archetype.id);
          this.showArchetypeTraitsModal(archetype, traits);
        } catch (err) {
          new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
        }
      };
      actions.createEl("button", { text: "Edit" }).onclick = () => {
        this.showEditArchetypeModal(archetype);
      };
      actions.createEl("button", { text: "Delete" }).onclick = async () => {
        if (confirm(`Delete archetype "${archetype.name}"?`)) {
          try {
            await this.plugin.apiClient.deleteArchetype(archetype.id);
            await this.loadWorldData();
            this.renderWorldTabContent();
            new import_obsidian16.Notice("Archetype deleted");
          } catch (err) {
            new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
          }
        }
      };
    }
  }
  renderLoreTab(container) {
    if (this.lores.length === 0) {
      container.createEl("p", { text: "No lore found. Create your first lore!" });
      return;
    }
    const rootLores = this.lores.filter((l) => !l.parent_id);
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const lore of rootLores.sort((a, b) => a.name.localeCompare(b.name))) {
      this.renderLoreItem(list, lore, 0);
    }
  }
  renderLoreItem(container, lore, level) {
    const item = container.createDiv({ cls: "story-engine-item" });
    item.style.marginLeft = `${level * 1}rem`;
    const titleRow = item.createDiv({ cls: "story-engine-title" });
    titleRow.textContent = lore.name;
    if (lore.category) {
      const categoryBadge = titleRow.createSpan({ cls: "story-engine-badge" });
      categoryBadge.textContent = lore.category;
    }
    const meta = item.createDiv({ cls: "story-engine-meta" });
    if (lore.description) {
      meta.createEl("span", { text: lore.description.substring(0, 50) + (lore.description.length > 50 ? "..." : "") });
    }
    const actions = item.createDiv({ cls: "story-engine-item-actions" });
    const linkBtn = actions.createEl("button");
    (0, import_obsidian16.setIcon)(linkBtn, "link");
    linkBtn.title = "Link to Entity";
    linkBtn.onclick = () => this.showAddLoreReferenceModal(lore);
    const subBtn = actions.createEl("button");
    (0, import_obsidian16.setIcon)(subBtn, "folder-plus");
    subBtn.title = "Create Sub-Lore";
    subBtn.onclick = () => this.showCreateLoreModal(lore.id);
    actions.createEl("button", { text: "Edit" }).onclick = () => {
      this.showEditLoreModal(lore);
    };
    actions.createEl("button", { text: "Delete" }).onclick = async () => {
      if (confirm(`Delete lore "${lore.name}"?`)) {
        try {
          await this.plugin.apiClient.deleteLore(lore.id);
          await this.loadWorldData();
          this.renderWorldTabContent();
          new import_obsidian16.Notice("Lore deleted");
        } catch (err) {
          new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
        }
      }
    };
    const children2 = this.lores.filter((l) => l.parent_id === lore.id);
    for (const child of children2.sort((a, b) => a.name.localeCompare(b.name))) {
      this.renderLoreItem(container, child, level + 1);
    }
  }
  renderFactionsTab(container) {
    if (this.factions.length === 0) {
      container.createEl("p", { text: "No factions found. Create your first faction!" });
      return;
    }
    const rootFactions = this.factions.filter((f) => !f.parent_id);
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const faction of rootFactions.sort((a, b) => a.name.localeCompare(b.name))) {
      this.renderFactionItem(list, faction, 0);
    }
  }
  renderFactionItem(container, faction, level) {
    const item = container.createDiv({ cls: "story-engine-item" });
    item.style.marginLeft = `${level * 1}rem`;
    const titleRow = item.createDiv({ cls: "story-engine-title" });
    titleRow.textContent = faction.name;
    if (faction.type) {
      const typeBadge = titleRow.createSpan({ cls: "story-engine-badge" });
      typeBadge.textContent = faction.type;
    }
    const meta = item.createDiv({ cls: "story-engine-meta" });
    if (faction.description) {
      meta.createEl("span", { text: faction.description.substring(0, 50) + (faction.description.length > 50 ? "..." : "") });
    }
    const actions = item.createDiv({ cls: "story-engine-item-actions" });
    const linkBtn = actions.createEl("button");
    (0, import_obsidian16.setIcon)(linkBtn, "link");
    linkBtn.title = "Link to Entity";
    linkBtn.onclick = () => this.showAddFactionReferenceModal(faction);
    const subBtn = actions.createEl("button");
    (0, import_obsidian16.setIcon)(subBtn, "folder-plus");
    subBtn.title = "Create Sub-Faction";
    subBtn.onclick = () => this.showCreateFactionModal(faction.id);
    actions.createEl("button", { text: "View Details" }).onclick = () => {
      this.showFactionDetailsModal(faction);
    };
    actions.createEl("button", { text: "Edit" }).onclick = () => {
      this.showEditFactionModal(faction);
    };
    actions.createEl("button", { text: "Delete" }).onclick = async () => {
      if (confirm(`Delete faction "${faction.name}"?`)) {
        try {
          await this.plugin.apiClient.deleteFaction(faction.id);
          await this.loadWorldData();
          this.renderWorldTabContent();
          new import_obsidian16.Notice("Faction deleted");
        } catch (err) {
          new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
        }
      }
    };
    const children2 = this.factions.filter((f) => f.parent_id === faction.id);
    for (const child of children2.sort((a, b) => a.name.localeCompare(b.name))) {
      this.renderFactionItem(container, child, level + 1);
    }
  }
  // Modal methods for World entities
  showCreateCharacterModal() {
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Create Character");
    const content = modal.contentEl;
    let name = "";
    let description = "";
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input" });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Create", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.createCharacter(this.currentWorld.id, { name: name.trim(), description: description.trim() });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Character created");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
    nameInput.focus();
  }
  showEditCharacterModal(character) {
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Edit Character");
    const content = modal.contentEl;
    let name = character.name;
    let description = character.description;
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: name });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.value = description;
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        const updated = await this.plugin.apiClient.updateCharacter(character.id, { name: name.trim(), description: description.trim() });
        if (this.viewMode === "character-details" && this.characterDetailsView && this.characterDetailsView["character"].id === character.id) {
          this.characterDetailsView.updateCharacter(updated);
        } else {
          await this.loadWorldData();
          this.renderWorldTabContent();
        }
        modal.close();
        new import_obsidian16.Notice("Character updated");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  showCreateLocationModal() {
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Create Location");
    const content = modal.contentEl;
    let name = "";
    let type2 = "";
    let description = "";
    let parentId = null;
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input" });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Type" });
    const typeInput = content.createEl("input", { type: "text", cls: "story-engine-input", placeholder: "e.g., City, Forest, Building" });
    typeInput.oninput = () => {
      type2 = typeInput.value;
    };
    content.createEl("label", { text: "Parent Location" });
    const parentSelect = content.createEl("select", { cls: "story-engine-select" });
    parentSelect.createEl("option", { value: "", text: "None (Root Location)" });
    for (const loc of this.locations.sort((a, b) => a.name.localeCompare(b.name))) {
      parentSelect.createEl("option", { value: loc.id, text: loc.name });
    }
    parentSelect.onchange = () => {
      parentId = parentSelect.value || null;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Create", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.createLocation(this.currentWorld.id, {
          name: name.trim(),
          type: type2.trim(),
          description: description.trim(),
          parent_id: parentId
        });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Location created");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
    nameInput.focus();
  }
  showEditLocationModal(location) {
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Edit Location");
    const content = modal.contentEl;
    let name = location.name;
    let type2 = location.type;
    let description = location.description;
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: name });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Type" });
    const typeInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: type2 });
    typeInput.oninput = () => {
      type2 = typeInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.value = description;
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.updateLocation(location.id, { name: name.trim(), type: type2.trim(), description: description.trim() });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Location updated");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  showCreateArtifactModal() {
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Create Artifact");
    const content = modal.contentEl;
    let name = "";
    let description = "";
    let rarity = "";
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input" });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Rarity" });
    const raritySelect = content.createEl("select", { cls: "story-engine-select" });
    raritySelect.createEl("option", { value: "", text: "Select Rarity" });
    ["Common", "Uncommon", "Rare", "Epic", "Legendary", "Unique"].forEach((r) => {
      raritySelect.createEl("option", { value: r.toLowerCase(), text: r });
    });
    raritySelect.onchange = () => {
      rarity = raritySelect.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Create", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.createArtifact(this.currentWorld.id, {
          name: name.trim(),
          description: description.trim(),
          rarity
        });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Artifact created");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
    nameInput.focus();
  }
  showEditArtifactModal(artifact) {
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Edit Artifact");
    const content = modal.contentEl;
    let name = artifact.name;
    let description = artifact.description;
    let rarity = artifact.rarity;
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: name });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Rarity" });
    const raritySelect = content.createEl("select", { cls: "story-engine-select" });
    raritySelect.createEl("option", { value: "", text: "Select Rarity" });
    ["Common", "Uncommon", "Rare", "Epic", "Legendary", "Unique"].forEach((r) => {
      const opt = raritySelect.createEl("option", { value: r.toLowerCase(), text: r });
      if (rarity.toLowerCase() === r.toLowerCase())
        opt.selected = true;
    });
    raritySelect.onchange = () => {
      rarity = raritySelect.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.value = description;
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.updateArtifact(artifact.id, { name: name.trim(), description: description.trim(), rarity });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Artifact updated");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  showCreateEventModal() {
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Create Event");
    const content = modal.contentEl;
    let name = "";
    let type2 = "";
    let description = "";
    let importance = 5;
    let timelinePosition = void 0;
    content.createEl("h4", { text: "Basic Info", cls: "story-engine-modal-section" });
    content.createEl("label", { text: "Event Name *" });
    const nameInput = content.createEl("input", {
      type: "text",
      cls: "story-engine-input",
      placeholder: "e.g., The Battle of Crimson Fields"
    });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Event Type" });
    const typeSelect = content.createEl("select", { cls: "story-engine-select" });
    typeSelect.createEl("option", { value: "", text: "Select type..." });
    ["Battle", "Treaty", "Discovery", "Birth", "Death", "Coronation", "Disaster", "Migration", "Founding", "Other"].forEach((t) => {
      typeSelect.createEl("option", { value: t, text: t });
    });
    typeSelect.onchange = () => {
      type2 = typeSelect.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", {
      cls: "story-engine-textarea",
      placeholder: "What happened during this event?"
    });
    descInput.oninput = () => {
      description = descInput.value;
    };
    content.createEl("h4", { text: "\u{1F4C5} Timeline Position", cls: "story-engine-modal-section" });
    content.createEl("label", { text: "Year (relative to Epoch/Year Zero)" });
    content.createEl("p", {
      text: "Use positive numbers for years after Year Zero, negative for years before.",
      cls: "story-engine-hint"
    });
    const timelinePosInput = content.createEl("input", {
      type: "number",
      cls: "story-engine-input",
      placeholder: "e.g., 100 (Year 100) or -50 (50 years before Year Zero)"
    });
    timelinePosInput.oninput = () => {
      const val = timelinePosInput.value;
      timelinePosition = val ? parseInt(val) : void 0;
    };
    content.createEl("h4", { text: "\u2B50 Importance", cls: "story-engine-modal-section" });
    content.createEl("label", { text: "Importance Level (1-10)" });
    const importanceInput = content.createEl("input", {
      type: "range",
      cls: "story-engine-range",
      value: "5",
      attr: { min: "1", max: "10" }
    });
    const importanceValue = content.createEl("span", { text: " 5", cls: "story-engine-range-value" });
    importanceInput.oninput = () => {
      importance = parseInt(importanceInput.value) || 5;
      importanceValue.textContent = ` ${importance}`;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Create Event", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.createEvent(this.currentWorld.id, {
          name: name.trim(),
          type: type2.trim() || void 0,
          description: description.trim() || void 0,
          importance: Math.max(1, Math.min(10, importance)),
          timeline_position: timelinePosition
        });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Event created");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
    nameInput.focus();
  }
  showEditEventModal(event) {
    var _a, _b;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Edit Event");
    const content = modal.contentEl;
    let name = event.name;
    let type2 = event.type || "";
    let description = event.description || "";
    let importance = event.importance;
    let timelinePosition = (_a = event.timeline_position) != null ? _a : void 0;
    content.createEl("h4", { text: "Basic Info", cls: "story-engine-modal-section" });
    content.createEl("label", { text: "Event Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: name });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Event Type" });
    const typeSelect = content.createEl("select", { cls: "story-engine-select" });
    typeSelect.createEl("option", { value: "", text: "Select type..." });
    ["Battle", "Treaty", "Discovery", "Birth", "Death", "Coronation", "Disaster", "Migration", "Founding", "Epoch", "Other"].forEach((t) => {
      const opt = typeSelect.createEl("option", { value: t, text: t });
      if (type2.toLowerCase() === t.toLowerCase())
        opt.selected = true;
    });
    typeSelect.onchange = () => {
      type2 = typeSelect.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.value = description;
    descInput.oninput = () => {
      description = descInput.value;
    };
    content.createEl("h4", { text: "\u{1F4C5} Timeline Position", cls: "story-engine-modal-section" });
    content.createEl("label", { text: "Year (relative to Epoch/Year Zero)" });
    content.createEl("p", {
      text: "Use positive numbers for years after Year Zero, negative for years before.",
      cls: "story-engine-hint"
    });
    const timelinePosInput = content.createEl("input", {
      type: "number",
      cls: "story-engine-input",
      value: (_b = timelinePosition == null ? void 0 : timelinePosition.toString()) != null ? _b : ""
    });
    timelinePosInput.placeholder = "e.g., 100 or -50";
    timelinePosInput.oninput = () => {
      const val = timelinePosInput.value;
      timelinePosition = val ? parseInt(val) : void 0;
    };
    content.createEl("h4", { text: "\u2B50 Importance", cls: "story-engine-modal-section" });
    content.createEl("label", { text: "Importance Level (1-10)" });
    const importanceInput = content.createEl("input", {
      type: "range",
      cls: "story-engine-range",
      value: importance.toString(),
      attr: { min: "1", max: "10" }
    });
    const importanceValue = content.createEl("span", { text: ` ${importance}`, cls: "story-engine-range-value" });
    importanceInput.oninput = () => {
      importance = parseInt(importanceInput.value) || 5;
      importanceValue.textContent = ` ${importance}`;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.updateEvent(event.id, {
          name: name.trim(),
          type: type2.trim() || void 0,
          description: description.trim() || void 0,
          importance: Math.max(1, Math.min(10, importance)),
          timeline_position: timelinePosition
        });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Event updated");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  showCreateTraitModal() {
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Create Trait");
    const content = modal.contentEl;
    let name = "";
    let category = "";
    let description = "";
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input" });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Category" });
    const categoryInput = content.createEl("input", { type: "text", cls: "story-engine-input", placeholder: "e.g., Personality, Physical, Background" });
    categoryInput.oninput = () => {
      category = categoryInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Create", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.createTrait({
          name: name.trim(),
          category: category.trim(),
          description: description.trim()
        });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Trait created");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
    nameInput.focus();
  }
  showEditTraitModal(trait) {
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Edit Trait");
    const content = modal.contentEl;
    let name = trait.name;
    let category = trait.category;
    let description = trait.description;
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: name });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Category" });
    const categoryInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: category });
    categoryInput.oninput = () => {
      category = categoryInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.value = description;
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.updateTrait(trait.id, { name: name.trim(), category: category.trim(), description: description.trim() });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Trait updated");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  renderTimeConfigDisplay(container, config) {
    var _a;
    container.createEl("h4", { text: "Time Configuration" });
    const grid = container.createDiv({ cls: "story-engine-time-config-grid" });
    grid.createDiv().setText(`Base Unit: ${config.base_unit}`);
    grid.createDiv().setText(`Hours/Day: ${config.hours_per_day}`);
    grid.createDiv().setText(`Days/Week: ${config.days_per_week}`);
    grid.createDiv().setText(`Days/Year: ${config.days_per_year}`);
    grid.createDiv().setText(`Months/Year: ${config.months_per_year}`);
    if (config.era_name) {
      grid.createDiv().setText(`Era: ${config.era_name}`);
    }
    if ((_a = config.month_names) == null ? void 0 : _a.length) {
      grid.createDiv().setText(`Months: ${config.month_names.join(", ")}`);
    }
    if (config.year_zero !== void 0) {
      grid.createDiv().setText(`Year Zero: ${config.year_zero}`);
    }
  }
  showTimeConfigModal(existingConfig) {
    var _a;
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText(existingConfig ? "Edit Time Configuration" : "Create Time Configuration");
    const content = modal.contentEl;
    let baseUnit = (existingConfig == null ? void 0 : existingConfig.base_unit) || "year";
    let hoursPerDay = (existingConfig == null ? void 0 : existingConfig.hours_per_day) || 24;
    let daysPerWeek = (existingConfig == null ? void 0 : existingConfig.days_per_week) || 7;
    let daysPerYear = (existingConfig == null ? void 0 : existingConfig.days_per_year) || 365;
    let monthsPerYear = (existingConfig == null ? void 0 : existingConfig.months_per_year) || 12;
    let eraName = (existingConfig == null ? void 0 : existingConfig.era_name) || "";
    let yearZero = ((_a = existingConfig == null ? void 0 : existingConfig.year_zero) == null ? void 0 : _a.toString()) || "";
    content.createEl("label", { text: "Base Unit *" });
    const baseUnitSelect = content.createEl("select", { cls: "story-engine-select" });
    ["year", "day", "hour", "custom"].forEach((unit2) => {
      const opt = baseUnitSelect.createEl("option", { value: unit2, text: unit2 });
      if (baseUnit === unit2)
        opt.selected = true;
    });
    baseUnitSelect.onchange = () => {
      baseUnit = baseUnitSelect.value;
    };
    content.createEl("label", { text: "Hours per Day" });
    const hoursPerDayInput = content.createEl("input", {
      type: "number",
      cls: "story-engine-input",
      value: hoursPerDay.toString()
    });
    hoursPerDayInput.oninput = () => {
      hoursPerDay = parseFloat(hoursPerDayInput.value) || 24;
    };
    content.createEl("label", { text: "Days per Week" });
    const daysPerWeekInput = content.createEl("input", {
      type: "number",
      cls: "story-engine-input",
      value: daysPerWeek.toString()
    });
    daysPerWeekInput.oninput = () => {
      daysPerWeek = parseInt(daysPerWeekInput.value) || 7;
    };
    content.createEl("label", { text: "Days per Year" });
    const daysPerYearInput = content.createEl("input", {
      type: "number",
      cls: "story-engine-input",
      value: daysPerYear.toString()
    });
    daysPerYearInput.oninput = () => {
      daysPerYear = parseInt(daysPerYearInput.value) || 365;
    };
    content.createEl("label", { text: "Months per Year" });
    const monthsPerYearInput = content.createEl("input", {
      type: "number",
      cls: "story-engine-input",
      value: monthsPerYear.toString()
    });
    monthsPerYearInput.oninput = () => {
      monthsPerYear = parseInt(monthsPerYearInput.value) || 12;
    };
    content.createEl("label", { text: "Era Name (optional)" });
    const eraNameInput = content.createEl("input", {
      type: "text",
      cls: "story-engine-input",
      value: eraName
    });
    eraNameInput.oninput = () => {
      eraName = eraNameInput.value;
    };
    content.createEl("label", { text: "Year Zero (optional)" });
    const yearZeroInput = content.createEl("input", {
      type: "number",
      cls: "story-engine-input",
      value: yearZero
    });
    yearZeroInput.oninput = () => {
      yearZero = yearZeroInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      try {
        const timeConfig = {
          base_unit: baseUnit,
          hours_per_day: hoursPerDay,
          days_per_week: daysPerWeek,
          days_per_year: daysPerYear,
          months_per_year: monthsPerYear,
          era_name: eraName.trim() || void 0,
          year_zero: yearZero ? parseInt(yearZero) : void 0
        };
        await this.plugin.apiClient.updateWorldTimeConfig(this.currentWorld.id, timeConfig);
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Time configuration saved");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  async showTimelineModal() {
    if (!this.currentWorld)
      return;
    try {
      const events = await this.plugin.apiClient.getTimeline(this.currentWorld.id);
      const modal = new TimelineModal(this.app, events, this.currentWorld.time_config || null);
      modal.open();
    } catch (err) {
      new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed to load timeline"}`, 5e3);
    }
  }
  // Placeholder methods for modals that will be implemented later
  showArchetypeTraitsModal(archetype, traits) {
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText(`Traits for ${archetype.name}`);
    const content = modal.contentEl;
    if (traits.length === 0) {
      content.createEl("p", { text: "No traits assigned to this archetype." });
    } else {
      const list = content.createDiv({ cls: "story-engine-list" });
      for (const trait of traits) {
        const item = list.createDiv({ cls: "story-engine-item" });
        item.createDiv({ cls: "story-engine-title", text: trait.trait_name || "Unknown" });
      }
    }
    modal.open();
  }
  showCreateArchetypeModal() {
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Create Archetype");
    const content = modal.contentEl;
    let name = "";
    let description = "";
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input" });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Create", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.createArchetype({ name: name.trim(), description: description.trim() });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Archetype created");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
    nameInput.focus();
  }
  showEditArchetypeModal(archetype) {
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Edit Archetype");
    const content = modal.contentEl;
    let name = archetype.name;
    let description = archetype.description;
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: name });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.value = description;
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.updateArchetype(archetype.id, { name: name.trim(), description: description.trim() });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Archetype updated");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  showLoreDetailsModal(lore) {
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText(lore.name);
    const content = modal.contentEl;
    content.createEl("h4", { text: "Description" });
    content.createEl("p", { text: lore.description || "No description" });
    if (lore.rules) {
      content.createEl("h4", { text: "Rules" });
      content.createEl("p", { text: lore.rules });
    }
    if (lore.limitations) {
      content.createEl("h4", { text: "Limitations" });
      content.createEl("p", { text: lore.limitations });
    }
    if (lore.requirements) {
      content.createEl("h4", { text: "Requirements" });
      content.createEl("p", { text: lore.requirements });
    }
    modal.open();
  }
  showCreateLoreModal(parentId) {
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Create Lore");
    const content = modal.contentEl;
    let name = "";
    let category = "";
    let description = "";
    let rules = "";
    let limitations = "";
    let requirements = "";
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input" });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Category" });
    const categoryInput = content.createEl("input", { type: "text", cls: "story-engine-input" });
    categoryInput.oninput = () => {
      category = categoryInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.oninput = () => {
      description = descInput.value;
    };
    content.createEl("label", { text: "Rules" });
    const rulesInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    rulesInput.oninput = () => {
      rules = rulesInput.value;
    };
    content.createEl("label", { text: "Limitations" });
    const limitationsInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    limitationsInput.oninput = () => {
      limitations = limitationsInput.value;
    };
    content.createEl("label", { text: "Requirements" });
    const requirementsInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    requirementsInput.oninput = () => {
      requirements = requirementsInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Create", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.createLore(this.currentWorld.id, {
          name: name.trim(),
          category: category.trim() || void 0,
          description: description.trim(),
          rules: rules.trim(),
          limitations: limitations.trim(),
          requirements: requirements.trim(),
          parent_id: parentId || void 0
        });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Lore created");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
    nameInput.focus();
  }
  showEditLoreModal(lore) {
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Edit Lore");
    const content = modal.contentEl;
    let name = lore.name;
    let category = lore.category || "";
    let description = lore.description;
    let rules = lore.rules;
    let limitations = lore.limitations;
    let requirements = lore.requirements;
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: name });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Category" });
    const categoryInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: category });
    categoryInput.oninput = () => {
      category = categoryInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.value = description;
    descInput.oninput = () => {
      description = descInput.value;
    };
    content.createEl("label", { text: "Rules" });
    const rulesInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    rulesInput.value = rules;
    rulesInput.oninput = () => {
      rules = rulesInput.value;
    };
    content.createEl("label", { text: "Limitations" });
    const limitationsInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    limitationsInput.value = limitations;
    limitationsInput.oninput = () => {
      limitations = limitationsInput.value;
    };
    content.createEl("label", { text: "Requirements" });
    const requirementsInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    requirementsInput.value = requirements;
    requirementsInput.oninput = () => {
      requirements = requirementsInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.updateLore(lore.id, {
          name: name.trim(),
          category: category.trim() || void 0,
          description: description.trim(),
          rules: rules.trim(),
          limitations: limitations.trim(),
          requirements: requirements.trim()
        });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Lore updated");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  showFactionDetailsModal(faction) {
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText(faction.name);
    const content = modal.contentEl;
    content.createEl("h4", { text: "Description" });
    content.createEl("p", { text: faction.description || "No description" });
    if (faction.beliefs) {
      content.createEl("h4", { text: "Beliefs" });
      content.createEl("p", { text: faction.beliefs });
    }
    if (faction.structure) {
      content.createEl("h4", { text: "Structure" });
      content.createEl("p", { text: faction.structure });
    }
    if (faction.symbols) {
      content.createEl("h4", { text: "Symbols" });
      content.createEl("p", { text: faction.symbols });
    }
    modal.open();
  }
  showCreateFactionModal(parentId) {
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Create Faction");
    const content = modal.contentEl;
    let name = "";
    let type2 = "";
    let description = "";
    let beliefs = "";
    let structure = "";
    let symbols = "";
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input" });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Type" });
    const typeInput = content.createEl("input", { type: "text", cls: "story-engine-input" });
    typeInput.oninput = () => {
      type2 = typeInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.oninput = () => {
      description = descInput.value;
    };
    content.createEl("label", { text: "Beliefs" });
    const beliefsInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    beliefsInput.oninput = () => {
      beliefs = beliefsInput.value;
    };
    content.createEl("label", { text: "Structure" });
    const structureInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    structureInput.oninput = () => {
      structure = structureInput.value;
    };
    content.createEl("label", { text: "Symbols" });
    const symbolsInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    symbolsInput.oninput = () => {
      symbols = symbolsInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Create", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.createFaction(this.currentWorld.id, {
          name: name.trim(),
          type: type2.trim() || void 0,
          description: description.trim(),
          beliefs: beliefs.trim(),
          structure: structure.trim(),
          symbols: symbols.trim(),
          parent_id: parentId || void 0
        });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Faction created");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
    nameInput.focus();
  }
  showEditFactionModal(faction) {
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Edit Faction");
    const content = modal.contentEl;
    let name = faction.name;
    let type2 = faction.type || "";
    let description = faction.description;
    let beliefs = faction.beliefs;
    let structure = faction.structure;
    let symbols = faction.symbols;
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: name });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Type" });
    const typeInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: type2 });
    typeInput.oninput = () => {
      type2 = typeInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.value = description;
    descInput.oninput = () => {
      description = descInput.value;
    };
    content.createEl("label", { text: "Beliefs" });
    const beliefsInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    beliefsInput.value = beliefs;
    beliefsInput.oninput = () => {
      beliefs = beliefsInput.value;
    };
    content.createEl("label", { text: "Structure" });
    const structureInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    structureInput.value = structure;
    structureInput.oninput = () => {
      structure = structureInput.value;
    };
    content.createEl("label", { text: "Symbols" });
    const symbolsInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    symbolsInput.value = symbols;
    symbolsInput.oninput = () => {
      symbols = symbolsInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.updateFaction(faction.id, {
          name: name.trim(),
          type: type2.trim() || void 0,
          description: description.trim(),
          beliefs: beliefs.trim(),
          structure: structure.trim(),
          symbols: symbols.trim()
        });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Faction updated");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  // ==================== Relationship Modals ====================
  showAddCharacterRelationshipModal(character) {
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Add Character Relationship");
    const content = modal.contentEl;
    let otherCharacterId = "";
    let relationshipType = "ally";
    let description = "";
    let bidirectional = true;
    content.createEl("label", { text: "Other Character *" });
    const characterSelect = content.createEl("select", { cls: "story-engine-select" });
    characterSelect.createEl("option", { value: "", text: "Select a character..." });
    for (const char of this.characters.filter((c) => c.id !== character.id).sort((a, b) => a.name.localeCompare(b.name))) {
      characterSelect.createEl("option", { value: char.id, text: char.name });
    }
    characterSelect.onchange = () => {
      otherCharacterId = characterSelect.value;
    };
    content.createEl("label", { text: "Relationship Type *" });
    const typeSelect = content.createEl("select", { cls: "story-engine-select" });
    const relationshipTypes = ["ally", "enemy", "family", "lover", "rival", "mentor", "student"];
    for (const type2 of relationshipTypes) {
      typeSelect.createEl("option", { value: type2, text: type2.charAt(0).toUpperCase() + type2.slice(1) });
    }
    typeSelect.onchange = () => {
      relationshipType = typeSelect.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.oninput = () => {
      description = descInput.value;
    };
    content.createEl("label", { text: "Bidirectional" });
    const bidirectionalCheckbox = content.createEl("input", { type: "checkbox" });
    bidirectionalCheckbox.checked = true;
    bidirectionalCheckbox.onchange = () => {
      bidirectional = bidirectionalCheckbox.checked;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Create", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!otherCharacterId) {
        new import_obsidian16.Notice("Please select a character", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.createCharacterRelationship(character.id, {
          character2_id: otherCharacterId,
          relationship_type: relationshipType,
          description: description.trim(),
          bidirectional
        });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Relationship created");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  showLinkEventToEntityModal(event) {
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText(`Link Event: ${event.name}`);
    const content = modal.contentEl;
    let entityType = "character";
    let entityId = "";
    let relationshipType = "";
    let notes = "";
    content.createEl("label", { text: "Entity Type *" });
    const typeSelect = content.createEl("select", { cls: "story-engine-select" });
    typeSelect.createEl("option", { value: "character", text: "\u{1F464} Character" });
    typeSelect.createEl("option", { value: "location", text: "\u{1F4CD} Location" });
    typeSelect.createEl("option", { value: "faction", text: "\u{1F3F4} Faction" });
    typeSelect.createEl("option", { value: "artifact", text: "\u2694\uFE0F Artifact" });
    typeSelect.createEl("option", { value: "lore", text: "\u{1F4DC} Lore" });
    content.createEl("label", { text: "Entity *" });
    const entitySelect = content.createEl("select", { cls: "story-engine-select" });
    const populateEntitySelect = () => {
      entitySelect.empty();
      entitySelect.createEl("option", { value: "", text: `Select a ${entityType}...` });
      entityId = "";
      if (entityType === "character") {
        for (const char of this.characters.sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: char.id, text: char.name });
        }
      } else if (entityType === "location") {
        for (const loc of this.locations.sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: loc.id, text: loc.name });
        }
      } else if (entityType === "faction") {
        for (const faction of this.factions.sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: faction.id, text: faction.name });
        }
      } else if (entityType === "artifact") {
        for (const art of this.artifacts.sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: art.id, text: art.name });
        }
      } else if (entityType === "lore") {
        for (const lore of this.lores.sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: lore.id, text: lore.name });
        }
      }
    };
    populateEntitySelect();
    typeSelect.onchange = () => {
      entityType = typeSelect.value;
      populateEntitySelect();
    };
    entitySelect.onchange = () => {
      entityId = entitySelect.value;
    };
    content.createEl("label", { text: "Relationship Type" });
    const relTypeSelect = content.createEl("select", { cls: "story-engine-select" });
    relTypeSelect.createEl("option", { value: "", text: "Select relationship..." });
    ["involved", "caused", "affected", "witnessed", "created", "destroyed", "participated", "led", "opposed"].forEach((rel) => {
      relTypeSelect.createEl("option", { value: rel, text: rel.charAt(0).toUpperCase() + rel.slice(1) });
    });
    relTypeSelect.onchange = () => {
      relationshipType = relTypeSelect.value;
    };
    content.createEl("label", { text: "Notes" });
    const notesInput = content.createEl("textarea", {
      cls: "story-engine-textarea",
      placeholder: "Additional details about this relationship..."
    });
    notesInput.oninput = () => {
      notes = notesInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Link Entity", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!entityId) {
        new import_obsidian16.Notice(`Please select a ${entityType}`, 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.addEventReference(event.id, entityType, entityId, relationshipType.trim() || void 0, notes.trim() || void 0);
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Entity linked to event");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  showSetEventParentModal(event) {
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Set Parent Event (Cause)");
    const content = modal.contentEl;
    let parentId = event.parent_id || null;
    content.createEl("p", {
      text: "Link this event to its cause or parent event in the timeline hierarchy.",
      cls: "story-engine-hint"
    });
    content.createEl("label", { text: "Parent Event (Cause)" });
    const parentSelect = content.createEl("select", { cls: "story-engine-select" });
    parentSelect.createEl("option", { value: "", text: "None (Root Event)" });
    const sortedEvents = this.events.filter((e) => e.id !== event.id).sort((a, b) => {
      var _a, _b;
      const posA = (_a = a.timeline_position) != null ? _a : Number.MAX_SAFE_INTEGER;
      const posB = (_b = b.timeline_position) != null ? _b : Number.MAX_SAFE_INTEGER;
      if (posA !== posB)
        return posA - posB;
      return a.name.localeCompare(b.name);
    });
    for (const evt of sortedEvents) {
      const posLabel = evt.timeline_position !== void 0 ? ` (Year ${evt.timeline_position})` : "";
      const opt = parentSelect.createEl("option", { value: evt.id, text: `${evt.name}${posLabel}` });
      if (event.parent_id === evt.id) {
        opt.selected = true;
      }
    }
    parentSelect.onchange = () => {
      parentId = parentSelect.value || null;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      try {
        await this.plugin.apiClient.moveEvent(event.id, parentId);
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Event parent updated");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  showAddFactionReferenceModal(faction) {
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Link Faction to Entity");
    const content = modal.contentEl;
    let entityType = "character";
    let entityId = "";
    let role = "";
    let notes = "";
    content.createEl("label", { text: "Entity Type *" });
    const typeSelect = content.createEl("select", { cls: "story-engine-select" });
    typeSelect.createEl("option", { value: "character", text: "Character" });
    typeSelect.createEl("option", { value: "location", text: "Location" });
    typeSelect.createEl("option", { value: "artifact", text: "Artifact" });
    typeSelect.createEl("option", { value: "event", text: "Event" });
    typeSelect.createEl("option", { value: "faction", text: "Faction" });
    typeSelect.onchange = () => {
      entityType = typeSelect.value;
      entitySelect.empty();
      entitySelect.createEl("option", { value: "", text: `Select a ${entityType}...` });
      loadEntitiesForType(entityType);
    };
    content.createEl("label", { text: "Entity *" });
    const entitySelect = content.createEl("select", { cls: "story-engine-select" });
    entitySelect.createEl("option", { value: "", text: "Select an entity..." });
    const loadEntitiesForType = (type2) => {
      if (type2 === "character") {
        for (const char of this.characters.sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: char.id, text: char.name });
        }
      } else if (type2 === "location") {
        for (const loc of this.locations.sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: loc.id, text: loc.name });
        }
      } else if (type2 === "artifact") {
        for (const art of this.artifacts.sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: art.id, text: art.name });
        }
      } else if (type2 === "event") {
        for (const evt of this.events.sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: evt.id, text: evt.name });
        }
      } else if (type2 === "faction") {
        for (const fac of this.factions.filter((f) => f.id !== faction.id).sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: fac.id, text: fac.name });
        }
      }
    };
    loadEntitiesForType(entityType);
    entitySelect.onchange = () => {
      entityId = entitySelect.value;
    };
    content.createEl("label", { text: "Role" });
    const roleInput = content.createEl("input", { type: "text", cls: "story-engine-input", placeholder: "e.g., leader, member, ally, rival" });
    roleInput.oninput = () => {
      role = roleInput.value;
    };
    content.createEl("label", { text: "Notes" });
    const notesInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    notesInput.oninput = () => {
      notes = notesInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Create", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!entityId) {
        new import_obsidian16.Notice("Please select an entity", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.addFactionReference(faction.id, entityType, entityId, role.trim() || void 0, notes.trim() || void 0);
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Reference created");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  showAddLoreReferenceModal(lore) {
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Link Lore to Entity");
    const content = modal.contentEl;
    let entityType = "character";
    let entityId = "";
    let relationshipType = "";
    let notes = "";
    content.createEl("label", { text: "Entity Type *" });
    const typeSelect = content.createEl("select", { cls: "story-engine-select" });
    typeSelect.createEl("option", { value: "character", text: "Character" });
    typeSelect.createEl("option", { value: "location", text: "Location" });
    typeSelect.createEl("option", { value: "artifact", text: "Artifact" });
    typeSelect.createEl("option", { value: "event", text: "Event" });
    typeSelect.createEl("option", { value: "faction", text: "Faction" });
    typeSelect.createEl("option", { value: "lore", text: "Lore" });
    typeSelect.onchange = () => {
      entityType = typeSelect.value;
      entitySelect.empty();
      entitySelect.createEl("option", { value: "", text: `Select a ${entityType}...` });
      loadEntitiesForType(entityType);
    };
    content.createEl("label", { text: "Entity *" });
    const entitySelect = content.createEl("select", { cls: "story-engine-select" });
    entitySelect.createEl("option", { value: "", text: "Select an entity..." });
    const loadEntitiesForType = (type2) => {
      if (type2 === "character") {
        for (const char of this.characters.sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: char.id, text: char.name });
        }
      } else if (type2 === "location") {
        for (const loc of this.locations.sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: loc.id, text: loc.name });
        }
      } else if (type2 === "artifact") {
        for (const art of this.artifacts.sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: art.id, text: art.name });
        }
      } else if (type2 === "event") {
        for (const evt of this.events.sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: evt.id, text: evt.name });
        }
      } else if (type2 === "faction") {
        for (const fac of this.factions.sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: fac.id, text: fac.name });
        }
      } else if (type2 === "lore") {
        for (const l of this.lores.filter((l2) => l2.id !== lore.id).sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: l.id, text: l.name });
        }
      }
    };
    loadEntitiesForType(entityType);
    entitySelect.onchange = () => {
      entityId = entitySelect.value;
    };
    content.createEl("label", { text: "Relationship Type" });
    const relTypeInput = content.createEl("input", { type: "text", cls: "story-engine-input", placeholder: "e.g., practitioner, origin, forbidden" });
    relTypeInput.oninput = () => {
      relationshipType = relTypeInput.value;
    };
    content.createEl("label", { text: "Notes" });
    const notesInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    notesInput.oninput = () => {
      notes = notesInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Create", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!entityId) {
        new import_obsidian16.Notice("Please select an entity", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.addLoreReference(lore.id, entityType, entityId, relationshipType.trim() || void 0, notes.trim() || void 0);
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Reference created");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  // ==================== Character Details View Methods ====================
  async showCharacterDetails(character) {
    this.viewMode = "character-details";
    const world = character.world_id ? await this.plugin.apiClient.getWorld(character.world_id).catch(() => null) : null;
    const characters = world ? await this.plugin.apiClient.getCharacters(world.id).catch(() => []) : [];
    let traits = this.traits;
    let archetypes = this.archetypes;
    let events = world ? this.events : [];
    if (!traits || traits.length === 0) {
      try {
        traits = await this.plugin.apiClient.getTraits();
        this.traits = traits;
      } catch (err) {
        console.warn("Failed to load traits:", err);
        traits = [];
      }
    }
    if (!archetypes || archetypes.length === 0) {
      try {
        archetypes = await this.plugin.apiClient.getArchetypes();
        this.archetypes = archetypes;
      } catch (err) {
        console.warn("Failed to load archetypes:", err);
        archetypes = [];
      }
    }
    if (world && (!events || events.length === 0)) {
      try {
        events = await this.plugin.apiClient.getEvents(world.id);
        this.events = events;
      } catch (err) {
        console.warn("Failed to load events:", err);
        events = [];
      }
    }
    this.characterDetailsView = new CharacterDetailsView(
      this.plugin,
      character,
      this.headerEl,
      this.contentEl,
      () => {
        this.characterDetailsView = null;
        if (this.currentWorld) {
          this.viewMode = "world-details";
          this.renderWorldDetails();
        } else if (this.currentStory) {
          this.viewMode = "details";
          this.renderDetails();
        } else {
          this.viewMode = "list";
          this.renderListHeader();
          this.renderListContent();
        }
      },
      (character2) => {
        this.showEditCharacterModal(character2);
      },
      world,
      characters,
      archetypes,
      traits,
      events
    );
    await this.characterDetailsView.render();
  }
};

// src/views/StoryEngineExtractView.ts
var import_obsidian17 = require("obsidian");
var STORY_ENGINE_EXTRACT_VIEW_TYPE = "story-engine-extract-view";
var StoryEngineExtractView = class extends import_obsidian17.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.result = null;
    this.logs = [];
    this.status = "idle";
    this.activeTab = "progress";
    this.expandedLogs = /* @__PURE__ */ new Set();
    this.expandedRelationIndex = null;
    this.pendingRelationScrollIndex = null;
    this.pendingTabScroll = false;
    this.plugin = plugin;
    this.logs = plugin.extractLogs;
    this.status = plugin.extractStatus;
  }
  getViewType() {
    return STORY_ENGINE_EXTRACT_VIEW_TYPE;
  }
  getDisplayText() {
    return "Extract";
  }
  getIcon() {
    return "search";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("story-engine-extract-container");
    this.contentRoot = container;
    this.setResult(this.plugin.extractResult);
    this.setLogs(this.plugin.extractLogs, this.plugin.extractStatus);
  }
  setResult(result) {
    this.result = result;
    this.render();
  }
  setLogs(logs, status) {
    this.logs = logs;
    this.status = status;
    this.render();
  }
  render() {
    if (!this.contentRoot)
      return;
    this.contentRoot.empty();
    const header = this.contentRoot.createDiv({
      cls: "story-engine-extract-header"
    });
    header.createEl("h2", { text: "Extract" });
    const headerMeta = header.createDiv({
      cls: "story-engine-extract-meta"
    });
    headerMeta.createEl("div", {
      text: `Status: ${this.status}`
    });
    if (this.result) {
      const foundCount = this.result.entities.filter((entity) => entity.found).length;
      headerMeta.createEl("div", {
        text: `Entities: ${this.result.entities.length}`
      });
      headerMeta.createEl("div", {
        text: `Relations: ${this.result.relations.length}`
      });
      headerMeta.createEl("div", {
        text: `Found: ${foundCount}`
      });
      headerMeta.createEl("div", {
        text: `Text length: ${this.result.text.length}`
      });
    }
    const headerActions = header.createDiv({
      cls: "story-engine-extract-header-actions"
    });
    const backButton = headerActions.createEl("button", {
      text: "Back to Stories",
      cls: "story-engine-extract-back"
    });
    backButton.onclick = () => {
      this.plugin.activateView();
    };
    if (this.status === "running") {
      const cancelButton = headerActions.createEl("button", {
        text: "Cancel",
        cls: "story-engine-extract-cancel"
      });
      cancelButton.onclick = () => {
        this.plugin.cancelExtractStream();
      };
    }
    if (!this.result) {
      this.renderLogs();
      this.contentRoot.createEl("p", {
        text: "No extraction results yet.",
        cls: "story-engine-extract-empty"
      });
      return;
    }
    const queryBlock = this.contentRoot.createDiv({
      cls: "story-engine-extract-query"
    });
    queryBlock.createEl("div", {
      text: "Text",
      cls: "story-engine-extract-label"
    });
    queryBlock.createEl("div", {
      text: this.result.text,
      cls: "story-engine-extract-query-text"
    });
    const tabs = this.contentRoot.createDiv({
      cls: "story-engine-extract-tabs"
    });
    const hasEntities = this.result.entities.length > 0;
    const hasRelations = this.result.relations.length > 0;
    const includeRelations = this.result.include_relations !== false;
    const entitiesDisabled = !hasEntities && this.status === "idle";
    const relationsDisabled = !hasRelations && this.status === "idle" || !includeRelations;
    const progressTab = tabs.createEl("button", {
      text: "Progress",
      cls: `story-engine-extract-tab ${this.activeTab === "progress" ? "is-active" : ""}`
    });
    progressTab.onclick = () => {
      this.setActiveTab("progress");
    };
    const entitiesTab = tabs.createEl("button", {
      text: "Entities",
      cls: `story-engine-extract-tab ${this.activeTab === "entities" ? "is-active" : ""}`
    });
    if (entitiesDisabled) {
      entitiesTab.disabled = true;
      entitiesTab.addClass("is-disabled");
    }
    entitiesTab.onclick = () => {
      if (entitiesDisabled)
        return;
      this.setActiveTab("entities");
    };
    const relationsTab = tabs.createEl("button", {
      text: "Relations",
      cls: `story-engine-extract-tab ${this.activeTab === "relations" ? "is-active" : ""}`
    });
    if (relationsDisabled) {
      relationsTab.disabled = true;
      relationsTab.addClass("is-disabled");
    }
    relationsTab.onclick = () => {
      if (relationsDisabled)
        return;
      this.setActiveTab("relations");
    };
    const panels = this.contentRoot.createDiv({
      cls: "story-engine-extract-panels"
    });
    const entitiesPanel = panels.createDiv({
      cls: `story-engine-extract-panel ${this.activeTab === "entities" ? "is-active" : ""}`
    });
    const relationsPanel = panels.createDiv({
      cls: `story-engine-extract-panel ${this.activeTab === "relations" ? "is-active" : ""}`
    });
    const progressPanel = panels.createDiv({
      cls: `story-engine-extract-panel ${this.activeTab === "progress" ? "is-active" : ""}`
    });
    const actions = this.contentRoot.createDiv({
      cls: "story-engine-extract-actions"
    });
    const clearButton = actions.createEl("button", {
      text: "Clear Results",
      cls: "story-engine-extract-clear"
    });
    clearButton.onclick = () => {
      this.plugin.extractResult = null;
      this.setResult(null);
      this.plugin.updateExtractViews();
    };
    this.renderLogs(progressPanel);
    if (hasEntities) {
      const list = entitiesPanel.createDiv({
        cls: "story-engine-extract-list"
      });
      this.result.entities.forEach((entity, index) => {
        this.renderEntity(list, entity, index);
      });
    } else {
      const emptyText = this.status === "running" ? "Extracting entities..." : "No entities returned from extraction.";
      entitiesPanel.createEl("p", {
        text: emptyText,
        cls: "story-engine-extract-empty"
      });
    }
    if (hasRelations) {
      const list = relationsPanel.createDiv({
        cls: "story-engine-extract-list"
      });
      this.result.relations.forEach((relation, index) => {
        this.renderRelation(list, relation, index);
      });
    } else {
      let emptyText = "No relations returned from extraction.";
      if (!includeRelations) {
        emptyText = "Relations not requested.";
      } else if (!hasEntities) {
        emptyText = "Waiting for entity extraction.";
      } else if (this.status === "running") {
        emptyText = "Extracting relations...";
      }
      relationsPanel.createEl("p", {
        text: emptyText,
        cls: "story-engine-extract-empty"
      });
    }
    this.applyPendingScroll();
  }
  renderLogs(container) {
    const root2 = container != null ? container : this.contentRoot;
    const logBlock = root2.createDiv({
      cls: "story-engine-extract-logs"
    });
    logBlock.createEl("div", {
      text: "Progress",
      cls: "story-engine-extract-label"
    });
    if (!this.logs.length) {
      logBlock.createEl("p", {
        text: "No events yet.",
        cls: "story-engine-extract-empty"
      });
      return;
    }
    const list = logBlock.createDiv({ cls: "story-engine-extract-log-list" });
    const lastIndex = this.logs.length - 1;
    this.logs.forEach((entry, index) => {
      const eventLabel = entry.phase ? `${entry.phase} \xB7 ${entry.eventType}` : entry.eventType;
      const item = list.createDiv({
        cls: `story-engine-extract-log-item ${index === lastIndex ? "is-latest" : ""}`
      });
      const header = item.createDiv({
        cls: "story-engine-extract-log-header"
      });
      header.createSpan({
        text: `${entry.timestamp} | ${eventLabel}`,
        cls: "story-engine-extract-log-title"
      });
      const label = item.createDiv({
        cls: "story-engine-extract-log-label"
      });
      label.createSpan({ text: entry.message });
      const toggle = label.createSpan({
        text: index === lastIndex ? "..." : this.expandedLogs.has(entry.id) ? "\u2212" : "+",
        cls: "story-engine-extract-log-toggle"
      });
      label.onclick = () => {
        if (this.expandedLogs.has(entry.id)) {
          this.expandedLogs.delete(entry.id);
        } else {
          this.expandedLogs.add(entry.id);
        }
        this.render();
      };
      if (index === lastIndex) {
        toggle.addClass("is-typing");
      }
      if (this.expandedLogs.has(entry.id) && entry.data) {
        item.createEl("pre", {
          text: JSON.stringify(entry.data, null, 2),
          cls: "story-engine-extract-log-data"
        });
      }
    });
    list.scrollTop = list.scrollHeight;
  }
  renderEntity(container, entity, index) {
    this.renderEntityCard(container, entity, index);
  }
  renderEntityCard(container, entity, index, onCreated) {
    const item = container.createDiv({ cls: "story-engine-extract-item" });
    item.dataset.relationIndex = String(index);
    const header = item.createDiv({ cls: "story-engine-extract-item-header" });
    header.createEl("div", {
      text: `#${index + 1}`,
      cls: "story-engine-extract-rank"
    });
    const statusText = entity.created ? "Created" : entity.found ? "Found" : "New";
    const statusClass = entity.created ? "is-created" : entity.found ? "is-found" : "is-new";
    header.createEl("div", {
      text: statusText,
      cls: `story-engine-extract-status ${statusClass}`
    });
    const title = item.createDiv({ cls: "story-engine-extract-item-title" });
    title.createEl("div", {
      text: entity.name,
      cls: "story-engine-extract-entity-name"
    });
    title.createEl("div", {
      text: entity.type,
      cls: "story-engine-extract-entity-type"
    });
    if (entity.summary) {
      item.createEl("div", {
        text: entity.summary,
        cls: "story-engine-extract-content"
      });
    }
    if (entity.match) {
      item.appendChild(this.renderMatch("Match", entity.match));
    }
    if (entity.candidates && entity.candidates.length) {
      const list = item.createDiv({ cls: "story-engine-extract-candidates" });
      list.createEl("div", {
        text: "Candidates",
        cls: "story-engine-extract-label"
      });
      entity.candidates.forEach((candidate) => {
        list.appendChild(this.renderMatch("", candidate));
      });
    }
    if (!entity.created) {
      const actions = item.createDiv({ cls: "story-engine-extract-actions" });
      const actionButton = actions.createEl("button", {
        text: entity.found ? "Update Entity" : "Create Entity",
        cls: "story-engine-extract-action"
      });
      actionButton.onclick = async () => {
        actionButton.disabled = true;
        try {
          if (entity.found) {
            await this.updateEntity(entity);
          } else {
            const createdId = await this.createEntity(entity);
            if (createdId && onCreated) {
              onCreated(createdId);
            }
          }
        } finally {
          actionButton.disabled = false;
        }
      };
    }
  }
  renderMatch(label, match) {
    const wrapper = document.createElement("div");
    wrapper.className = "story-engine-extract-match";
    const parts = [];
    if (label) {
      parts.push(label);
    }
    parts.push(`${match.source_type}:${match.source_id}`);
    if (match.entity_name) {
      parts.push(match.entity_name);
    }
    parts.push(`sim ${match.similarity.toFixed(3)}`);
    if (match.reason) {
      parts.push(match.reason);
    }
    wrapper.textContent = parts.join(" \xB7 ");
    return wrapper;
  }
  async createEntity(entity) {
    var _a, _b;
    if (!((_a = this.result) == null ? void 0 : _a.world_id)) {
      new import_obsidian17.Notice("World ID missing. Select a story or world first.", 4e3);
      return "";
    }
    const description = ((_b = entity.summary) == null ? void 0 : _b.trim()) || entity.name;
    let createdId = "";
    switch (entity.type) {
      case "character": {
        const created = await this.plugin.apiClient.createCharacter(
          this.result.world_id,
          { name: entity.name, description }
        );
        createdId = created.id;
        break;
      }
      case "location": {
        const created = await this.plugin.apiClient.createLocation(
          this.result.world_id,
          { name: entity.name, description }
        );
        createdId = created.id;
        break;
      }
      case "artefact": {
        const created = await this.plugin.apiClient.createArtifact(
          this.result.world_id,
          { name: entity.name, description }
        );
        createdId = created.id;
        break;
      }
      case "faction": {
        const created = await this.plugin.apiClient.createFaction(
          this.result.world_id,
          { name: entity.name, description }
        );
        createdId = created.id;
        break;
      }
      case "event": {
        const created = await this.plugin.apiClient.createEvent(
          this.result.world_id,
          { name: entity.name, description }
        );
        createdId = created.id;
        break;
      }
      default:
        new import_obsidian17.Notice(`Unsupported type: ${entity.type}`, 4e3);
        return "";
    }
    entity.found = false;
    entity.created = true;
    entity.match = {
      source_type: entity.type,
      source_id: createdId,
      entity_name: entity.name,
      similarity: 1,
      reason: "Created from extract"
    };
    this.render();
    new import_obsidian17.Notice(`Created ${entity.type}: ${entity.name}`, 3e3);
    return createdId;
  }
  async updateEntity(entity) {
    var _a, _b;
    if (!((_a = entity.match) == null ? void 0 : _a.source_id)) {
      new import_obsidian17.Notice("No match available to update.", 4e3);
      return;
    }
    const description = (_b = entity.summary) != null ? _b : "";
    switch (entity.type) {
      case "character":
        await this.plugin.apiClient.updateCharacter(entity.match.source_id, {
          name: entity.name,
          description
        });
        break;
      case "location":
        await this.plugin.apiClient.updateLocation(entity.match.source_id, {
          name: entity.name,
          description
        });
        break;
      case "artefact":
        await this.plugin.apiClient.updateArtifact(entity.match.source_id, {
          name: entity.name,
          description
        });
        break;
      case "faction":
        await this.plugin.apiClient.updateFaction(entity.match.source_id, {
          name: entity.name,
          description
        });
        break;
      case "event":
        await this.plugin.apiClient.updateEvent(entity.match.source_id, {
          name: entity.name,
          description
        });
        break;
      default:
        new import_obsidian17.Notice(`Unsupported type: ${entity.type}`, 4e3);
        return;
    }
    new import_obsidian17.Notice(`Updated ${entity.type}: ${entity.name}`, 3e3);
  }
  renderRelation(container, relation, index) {
    const item = container.createDiv({ cls: "story-engine-extract-item" });
    const header = item.createDiv({ cls: "story-engine-extract-item-header" });
    header.createEl("div", {
      text: `#${index + 1}`,
      cls: "story-engine-extract-rank"
    });
    const statusText = relation.status === "pending_entities" ? "Pending" : relation.status;
    const statusClass = relation.status === "pending_entities" ? "is-new" : "is-found";
    header.createEl("div", {
      text: statusText,
      cls: `story-engine-extract-status ${statusClass}`
    });
    const title = item.createDiv({ cls: "story-engine-extract-item-title" });
    const sourceLabel = relation.source.name || relation.source.ref;
    const targetLabel = relation.target.name || relation.target.ref;
    const relationLine = `#${index + 1} ${relation.relation_type} | ${sourceLabel} -> ${targetLabel}`;
    title.createEl("div", {
      text: relationLine,
      cls: "story-engine-extract-entity-name"
    });
    title.createEl("div", {
      text: relation.status,
      cls: "story-engine-extract-entity-type"
    });
    if (relation.summary) {
      item.createEl("div", {
        text: relation.summary,
        cls: "story-engine-extract-content"
      });
    }
    const hasPending = this.hasTempNode(relation.source) || this.hasTempNode(relation.target);
    const relationCreated = relation.status === "created";
    const actions = item.createDiv({ cls: "story-engine-extract-actions" });
    const createRelationButton = actions.createEl("button", {
      text: relationCreated ? "Relation Created" : "Create Relation",
      cls: "story-engine-extract-action"
    });
    if (relationCreated) {
      createRelationButton.disabled = true;
      createRelationButton.addClass("is-disabled");
      createRelationButton.title = "Relation already created.";
    } else if (hasPending) {
      createRelationButton.disabled = true;
      createRelationButton.addClass("is-disabled");
      createRelationButton.title = "Create pending entities first.";
    } else {
      createRelationButton.onclick = async () => {
        createRelationButton.disabled = true;
        try {
          await this.createRelation(relation);
        } finally {
          createRelationButton.disabled = false;
        }
      };
    }
    if (hasPending) {
      const createButton = actions.createEl("button", {
        text: "Create Pending",
        cls: "story-engine-extract-action"
      });
      createButton.onclick = async () => {
        createButton.disabled = true;
        try {
          await this.createPendingEntities(relation);
        } finally {
          createButton.disabled = false;
        }
      };
    }
    const accordionButton = actions.createEl("button", {
      text: "See Entities",
      cls: "story-engine-extract-action"
    });
    accordionButton.onclick = () => {
      const shouldExpand = this.expandedRelationIndex !== index;
      this.expandedRelationIndex = shouldExpand ? index : null;
      this.pendingRelationScrollIndex = shouldExpand ? index : null;
      this.render();
    };
    if (this.expandedRelationIndex === index) {
      const entitiesWrap = item.createDiv({
        cls: "story-engine-extract-relations-entities"
      });
      entitiesWrap.dataset.relationIndex = String(index);
      const entities = [
        this.resolveRelationEntity(relation.source),
        this.resolveRelationEntity(relation.target)
      ];
      entities.forEach((entity, entityIndex) => {
        this.renderEntityCard(entitiesWrap, entity, entityIndex, (createdId) => {
          this.applyCreatedIdToRelation(relation, entity, createdId);
        });
      });
    }
  }
  resolveRelationEntity(node) {
    if (!this.result) {
      return this.buildRelationEntity(node);
    }
    const existing = this.result.entities.find((entity) => {
      var _a;
      if (node.id && ((_a = entity.match) == null ? void 0 : _a.source_id) === node.id) {
        return true;
      }
      return entity.type === node.type && entity.name === node.name;
    });
    return existing != null ? existing : this.buildRelationEntity(node);
  }
  buildRelationEntity(node) {
    const hasId = !!(node.id && node.id.trim());
    return {
      type: node.type,
      name: node.name || node.ref,
      found: hasId,
      match: hasId ? {
        source_type: node.type,
        source_id: node.id,
        entity_name: node.name,
        similarity: 1,
        reason: "Relation match"
      } : void 0
    };
  }
  hasTempNode(node) {
    if (!node.id || !node.id.trim()) {
      return true;
    }
    if (node.id.startsWith("temp")) {
      return true;
    }
    return node.ref.startsWith("finding:");
  }
  async createPendingEntities(relation) {
    const nodes = [relation.source, relation.target];
    for (const node of nodes) {
      if (!this.hasTempNode(node)) {
        continue;
      }
      const entity = this.buildRelationEntity(node);
      const createdId = await this.createEntity(entity);
      if (createdId) {
        this.applyCreatedIdToRelation(relation, entity, createdId);
      }
    }
    this.render();
  }
  async createRelation(relation) {
    var _a, _b;
    if (!((_a = this.result) == null ? void 0 : _a.world_id)) {
      new import_obsidian17.Notice("World ID missing. Select a story or world first.", 4e3);
      return;
    }
    if (!relation.source.id || !relation.target.id) {
      new import_obsidian17.Notice("Create the related entities before creating the relation.", 4e3);
      return;
    }
    const created = await this.plugin.apiClient.createEntityRelation({
      world_id: this.result.world_id,
      source_type: relation.source.type,
      source_id: relation.source.id,
      target_type: relation.target.type,
      target_id: relation.target.id,
      relation_type: relation.relation_type,
      summary: relation.summary,
      create_mirror: (_b = relation.create_mirror) != null ? _b : false
    });
    relation.status = "created";
    relation.created_id = created.id;
    this.render();
    new import_obsidian17.Notice(`Relation created: ${relation.relation_type}`, 3e3);
  }
  applyCreatedIdToRelation(relation, entity, createdId) {
    const updateNode = (node) => {
      if (node.type !== entity.type)
        return false;
      if (entity.name && node.name && node.name !== entity.name)
        return false;
      node.id = createdId;
      node.name = entity.name;
      return true;
    };
    if (!updateNode(relation.source)) {
      updateNode(relation.target);
    }
    if (!this.hasTempNode(relation.source) && !this.hasTempNode(relation.target)) {
      relation.status = "ready";
    }
  }
  setActiveTab(tab) {
    this.activeTab = tab;
    this.pendingTabScroll = true;
    this.render();
  }
  applyPendingScroll() {
    if (!this.pendingTabScroll && this.pendingRelationScrollIndex === null) {
      return;
    }
    requestAnimationFrame(() => {
      if (this.pendingTabScroll) {
        const panel = this.contentRoot.querySelector(
          ".story-engine-extract-panel.is-active"
        );
        if (panel) {
          panel.scrollTop = 0;
          panel.scrollIntoView({ block: "start" });
        }
        this.pendingTabScroll = false;
      }
      if (this.pendingRelationScrollIndex !== null) {
        const selector = `.story-engine-extract-relations-entities[data-relation-index="${this.pendingRelationScrollIndex}"]`;
        const entityBlock = this.contentRoot.querySelector(selector);
        if (entityBlock) {
          entityBlock.scrollIntoView({ block: "start" });
        }
        this.pendingRelationScrollIndex = null;
      }
    });
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  apiUrl: "http://localhost:8080",
  llmGatewayUrl: "http://localhost:8081",
  apiKey: "",
  tenantId: "",
  tenantName: "",
  syncFolderPath: "Stories",
  autoVersionSnapshots: true,
  conflictResolution: "service",
  mode: "local",
  showHelpBox: true,
  localModeVideoUrl: "https://example.com/setup-video",
  autoSyncOnApiUpdates: true,
  autoPushOnFileBlur: true
};
var StoryEnginePlugin = class extends import_obsidian18.Plugin {
  constructor() {
    super(...arguments);
    this.extractResult = null;
    this.extractLogs = [];
    this.extractStatus = "idle";
    this.extractAbortController = null;
  }
  async onload() {
    var _a;
    await this.loadSettings();
    this.apiClient = new StoryEngineClient(
      this.settings.apiUrl,
      this.settings.apiKey,
      this.settings.tenantId || ""
    );
    this.apiClient.setMode(this.settings.mode || "local");
    this.apiClient.setAutoSyncOnApiUpdates(
      (_a = this.settings.autoSyncOnApiUpdates) != null ? _a : true
    );
    this.fileManager = new FileManager(
      this.app.vault,
      this.settings.syncFolderPath || "Stories"
    );
    this.syncService = new SyncService(
      this.apiClient,
      this.fileManager,
      this.settings,
      this.app
    );
    this.initializeAutoSyncManager();
    this.addSettingTab(new StoryEngineSettingTab(this.app, this));
    this.registerView(
      STORY_LIST_VIEW_TYPE,
      (leaf) => new StoryListView(leaf, this)
    );
    this.registerView(
      STORY_ENGINE_EXTRACT_VIEW_TYPE,
      (leaf) => new StoryEngineExtractView(leaf, this)
    );
    this.addRibbonIcon("book-open", "Story Engine", () => {
      this.activateView();
    });
    registerCommands(this);
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor) => {
        const selection2 = editor.getSelection().trim();
        if (!selection2) {
          return;
        }
        menu.addItem((item) => {
          item.setTitle("Story Engine: Extract Entities and Relations");
          item.setIcon("search");
          item.onClick(() => {
            this.extractSelectionCommand(selection2, true);
          });
        });
        menu.addItem((item) => {
          item.setTitle("Story Engine: Extract Entities Only");
          item.setIcon("search");
          item.onClick(() => {
            this.extractSelectionCommand(selection2, false);
          });
        });
      })
    );
  }
  async onunload() {
    this.app.workspace.detachLeavesOfType(STORY_LIST_VIEW_TYPE);
    this.app.workspace.detachLeavesOfType(STORY_ENGINE_EXTRACT_VIEW_TYPE);
    if (this.syncService) {
      this.syncService.dispose();
    }
    if (this.autoSyncManager) {
      this.autoSyncManager.dispose();
      this.autoSyncManager = void 0;
    }
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    var _a, _b;
    await this.saveData(this.settings);
    if (this.apiClient) {
      this.apiClient.setTenantId(this.settings.tenantId || "");
      this.apiClient.setMode(this.settings.mode || "local");
      this.apiClient.setAutoSyncOnApiUpdates(
        (_a = this.settings.autoSyncOnApiUpdates) != null ? _a : true
      );
    } else {
      this.apiClient = new StoryEngineClient(
        this.settings.apiUrl,
        this.settings.apiKey,
        this.settings.tenantId || ""
      );
      this.apiClient.setMode(this.settings.mode || "local");
      this.apiClient.setAutoSyncOnApiUpdates(
        (_b = this.settings.autoSyncOnApiUpdates) != null ? _b : true
      );
    }
    this.fileManager = new FileManager(
      this.app.vault,
      this.settings.syncFolderPath || "Stories"
    );
    if (this.syncService) {
      this.syncService.dispose();
    }
    this.syncService = new SyncService(
      this.apiClient,
      this.fileManager,
      this.settings,
      this.app
    );
    this.initializeAutoSyncManager();
  }
  initializeAutoSyncManager() {
    if (this.autoSyncManager) {
      this.autoSyncManager.dispose();
      this.autoSyncManager = void 0;
    }
    if (this.settings.autoPushOnFileBlur) {
      this.autoSyncManager = new AutoSyncManager(this);
    }
  }
  async createStoryCommand() {
    var _a;
    if (this.settings.mode === "remote") {
      const tenantId = (_a = this.settings.tenantId) == null ? void 0 : _a.trim();
      if (!tenantId) {
        new import_obsidian18.Notice("Please configure Tenant ID in settings", 5e3);
        return;
      }
      const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
      if (!uuidRegex.test(tenantId)) {
        new import_obsidian18.Notice("Invalid Tenant ID format. Please check your settings.", 5e3);
        return;
      }
    }
    new CreateStoryModal(this.app, this, async (title, worldId, shouldSync) => {
      try {
        new import_obsidian18.Notice(`Creating story "${title}"...`);
        const story = await this.apiClient.createStory(title, worldId);
        new import_obsidian18.Notice(`Story "${title}" created successfully`);
        if (shouldSync) {
          try {
            new import_obsidian18.Notice(`Syncing story to Obsidian...`);
            await this.syncService.pullStory(story.id);
            new import_obsidian18.Notice(`Story synced to your vault!`);
          } catch (syncErr) {
            const syncErrorMessage = syncErr instanceof Error ? syncErr.message : "Failed to sync story";
            new import_obsidian18.Notice(`Story created but sync failed: ${syncErrorMessage}`, 5e3);
          }
        }
        const openView = this.app.workspace.getLeavesOfType(STORY_LIST_VIEW_TYPE)[0];
        if (openView) {
          const view = openView.view;
          await view.refresh();
          if (!shouldSync) {
            await view.showStoryDetails(story);
          }
        }
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to create story";
        new import_obsidian18.Notice(`Error: ${errorMessage}`, 5e3);
      }
    }).open();
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(STORY_LIST_VIEW_TYPE)[0];
    if (!leaf) {
      const rightLeaf = workspace.getRightLeaf(false);
      if (!rightLeaf) {
        new import_obsidian18.Notice("Could not create view. Please try again.", 3e3);
        return;
      }
      leaf = rightLeaf;
      await leaf.setViewState({
        type: STORY_LIST_VIEW_TYPE,
        active: true
      });
    }
    workspace.revealLeaf(leaf);
  }
  async activateExtractView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(STORY_ENGINE_EXTRACT_VIEW_TYPE)[0];
    if (!leaf) {
      leaf = workspace.getLeavesOfType(STORY_LIST_VIEW_TYPE)[0];
    }
    if (!leaf) {
      new import_obsidian18.Notice("Could not open extract view. Please try again.", 3e3);
      return;
    }
    await leaf.setViewState({
      type: STORY_ENGINE_EXTRACT_VIEW_TYPE,
      active: true
    });
    workspace.revealLeaf(leaf);
  }
  async getActiveWorldId() {
    var _a;
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      return null;
    }
    const fileContent = await this.app.vault.read(activeFile);
    const frontmatter = this.fileManager.parseFrontmatter(fileContent);
    const storyId = frontmatter.story_id || (activeFile.name === "story.md" ? frontmatter.id : "");
    if (!storyId) {
      return null;
    }
    const story = await this.apiClient.getStory(storyId);
    return (_a = story.world_id) != null ? _a : null;
  }
  async extractSelectionCommand(selection2, includeRelations = true) {
    var _a, _b, _c;
    const trimmedSelection = selection2.trim();
    if (!trimmedSelection) {
      new import_obsidian18.Notice(
        includeRelations ? "Select text to extract entities and relations" : "Select text to extract entities",
        3e3
      );
      return;
    }
    if (this.settings.mode !== "remote") {
      new import_obsidian18.Notice("Extraction requires the full remote version.", 5e3);
      return;
    }
    const tenantId = (_a = this.settings.tenantId) == null ? void 0 : _a.trim();
    if (!tenantId) {
      new import_obsidian18.Notice("Please configure Tenant ID in settings", 5e3);
      return;
    }
    const gatewayUrl = (_b = this.settings.llmGatewayUrl) == null ? void 0 : _b.trim();
    if (!gatewayUrl) {
      new import_obsidian18.Notice("Please configure LLM Gateway URL in settings", 5e3);
      return;
    }
    let worldId = null;
    try {
      worldId = await this.getActiveWorldId();
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to resolve story";
      new import_obsidian18.Notice(`Error: ${errorMessage}`, 5e3);
      return;
    }
    if (!worldId) {
      new import_obsidian18.Notice(
        "Open a synced story document before extracting entities.",
        5e3
      );
      return;
    }
    this.resetExtractState(trimmedSelection, worldId, includeRelations);
    await this.activateView();
    await this.activateExtractView();
    this.updateExtractViews();
    try {
      if ((_c = navigator == null ? void 0 : navigator.clipboard) == null ? void 0 : _c.writeText) {
        await navigator.clipboard.writeText(trimmedSelection);
      }
    } catch (e) {
    }
    new import_obsidian18.Notice("Starting extraction stream...", 3e3);
    await this.startExtractStream({
      tenantId,
      gatewayUrl,
      worldId,
      text: trimmedSelection,
      includeRelations
    });
  }
  updateExtractViews() {
    const listLeaf = this.app.workspace.getLeavesOfType(STORY_LIST_VIEW_TYPE)[0];
    if (listLeaf) {
      const view = listLeaf.view;
      if (view.viewMode === "list") {
        view.renderListContent();
      }
    }
    const extractLeaf = this.app.workspace.getLeavesOfType(STORY_ENGINE_EXTRACT_VIEW_TYPE)[0];
    if (extractLeaf) {
      const view = extractLeaf.view;
      view.setResult(this.extractResult);
      view.setLogs(this.extractLogs, this.extractStatus);
    }
  }
  resetExtractState(text, worldId, includeRelations = true) {
    this.cancelExtractStream();
    this.extractResult = {
      text,
      world_id: worldId,
      entities: [],
      relations: [],
      received_at: (/* @__PURE__ */ new Date()).toISOString(),
      include_relations: includeRelations
    };
    this.extractLogs = [];
    this.extractStatus = "running";
  }
  cancelExtractStream() {
    if (this.extractAbortController) {
      this.extractAbortController.abort();
      this.extractAbortController = null;
      this.extractStatus = "canceled";
      this.appendExtractLog({
        type: "client.cancel",
        message: "Extraction canceled by user."
      });
      this.updateExtractViews();
    }
  }
  appendExtractLog(event) {
    const timestamp = event.timestamp ? new Date(event.timestamp).toISOString() : (/* @__PURE__ */ new Date()).toISOString();
    this.extractLogs.push({
      id: `${timestamp}-${this.extractLogs.length}`,
      eventType: event.type,
      phase: event.phase,
      message: event.message,
      data: event.data,
      timestamp
    });
  }
  async startExtractStream(params) {
    const { tenantId, gatewayUrl, worldId, text, includeRelations } = params;
    const controller = new AbortController();
    this.extractAbortController = controller;
    this.appendExtractLog({
      type: "client.start",
      message: "Opening extraction stream."
    });
    this.updateExtractViews();
    try {
      const response = await fetch(
        `${gatewayUrl.replace(/\/$/, "")}/api/v1/entity-extract/stream`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-Tenant-ID": tenantId,
            ...this.settings.apiKey ? { Authorization: `Bearer ${this.settings.apiKey}` } : {}
          },
          body: JSON.stringify({
            text,
            world_id: worldId,
            include_relations: includeRelations
          }),
          signal: controller.signal
        }
      );
      if (!response.ok) {
        let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
        try {
          const errorBody = await response.json();
          if (errorBody == null ? void 0 : errorBody.error) {
            errorMessage = errorBody.error;
          }
        } catch (e) {
        }
        throw new Error(errorMessage);
      }
      if (!response.body) {
        throw new Error("No response stream available.");
      }
      const reader = response.body.getReader();
      const decoder = new TextDecoder("utf-8");
      let buffer = "";
      let currentEvent = "message";
      let dataLines = [];
      const flushEvent = () => {
        var _a, _b, _c, _d, _e;
        if (!dataLines.length)
          return;
        const rawData = dataLines.join("\n").trim();
        dataLines = [];
        if (!rawData)
          return;
        let parsed = null;
        try {
          parsed = JSON.parse(rawData);
        } catch (e) {
          this.appendExtractLog({
            type: "parse.error",
            message: "Failed to parse stream event payload.",
            data: { raw: rawData, event: currentEvent }
          });
          this.updateExtractViews();
          return;
        }
        if (!parsed.type) {
          parsed.type = currentEvent || "message";
        }
        this.appendExtractLog(parsed);
        if (parsed.type === "result_entities" && ((_a = parsed.data) == null ? void 0 : _a.entities)) {
          const entities = parsed.data.entities;
          if (this.extractResult) {
            this.extractResult.entities = entities != null ? entities : [];
            this.extractResult.received_at = (/* @__PURE__ */ new Date()).toISOString();
          }
          const foundCount = (_b = this.extractResult) == null ? void 0 : _b.entities.filter(
            (entity) => entity.found
          ).length;
          new import_obsidian18.Notice(
            `Entities extracted: ${foundCount != null ? foundCount : 0}/${(_d = (_c = this.extractResult) == null ? void 0 : _c.entities.length) != null ? _d : 0} matched`,
            4e3
          );
        }
        if (parsed.type === "result_relations" && ((_e = parsed.data) == null ? void 0 : _e.relations)) {
          const relations = parsed.data.relations;
          if (this.extractResult) {
            this.extractResult.relations = relations != null ? relations : [];
            this.extractResult.received_at = (/* @__PURE__ */ new Date()).toISOString();
          }
        }
        if (parsed.type === "error") {
          this.extractStatus = "error";
        }
        this.updateExtractViews();
      };
      while (true) {
        const { value, done } = await reader.read();
        if (done)
          break;
        buffer += decoder.decode(value, { stream: true });
        let lineEnd = buffer.indexOf("\n");
        while (lineEnd !== -1) {
          const line = buffer.slice(0, lineEnd).replace(/\r$/, "");
          buffer = buffer.slice(lineEnd + 1);
          lineEnd = buffer.indexOf("\n");
          if (!line) {
            flushEvent();
            currentEvent = "message";
            continue;
          }
          if (line.startsWith("event:")) {
            currentEvent = line.replace("event:", "").trim();
            continue;
          }
          if (line.startsWith("data:")) {
            dataLines.push(line.replace("data:", "").trim());
          }
        }
      }
      this.extractAbortController = null;
      if (this.extractStatus === "running") {
        this.extractStatus = "done";
      }
    } catch (err) {
      if (err instanceof DOMException && err.name === "AbortError") {
        return;
      }
      const errorMessage = err instanceof Error ? err.message : "Failed to extract entities";
      this.extractStatus = "error";
      this.appendExtractLog({
        type: "error",
        message: errorMessage
      });
      new import_obsidian18.Notice(`Error: ${errorMessage}`, 5e3);
      this.updateExtractViews();
    }
  }
  openSettings() {
    const setting = this.app.setting;
    if (setting) {
      setting.open();
      setTimeout(() => {
        setting.openTabById(this.manifest.id);
      }, 100);
    }
  }
};
