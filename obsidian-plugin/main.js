/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => StoryEnginePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian22 = require("obsidian");

// src/sync/apiUpdateNotifier.ts
var ApiUpdateNotifier = class {
  constructor() {
    this.subscribers = /* @__PURE__ */ new Set();
  }
  subscribe(subscriber) {
    this.subscribers.add(subscriber);
    return () => {
      this.subscribers.delete(subscriber);
    };
  }
  async notify(payload) {
    for (const subscriber of this.subscribers) {
      try {
        await subscriber(payload);
      } catch (err) {
        console.error("Auto sync subscriber failed", err);
      }
    }
  }
};
var apiUpdateNotifier = new ApiUpdateNotifier();

// src/sync-v2/apiUpdateNotifier/ApiUpdateNotifierV2.ts
var ApiUpdateNotifierV2 = class {
  constructor() {
    this.subscribers = /* @__PURE__ */ new Set();
    this.eventQueue = [];
    this.processingTimeoutId = null;
    this.DEBOUNCE_MS = 1e3;
    // 1 second debounce
    this.MAX_QUEUE_SIZE = 100;
  }
  /**
   * Subscribe to API update events
   * @param subscriber Callback function to handle events
   * @returns Unsubscribe function
   */
  subscribe(subscriber) {
    this.subscribers.add(subscriber);
    return () => {
      this.subscribers.delete(subscriber);
    };
  }
  /**
   * Notify subscribers of an API update event
   * Events are debounced to avoid flooding
   */
  async notify(event) {
    this.eventQueue.push({
      event,
      timestamp: Date.now()
    });
    if (this.eventQueue.length > this.MAX_QUEUE_SIZE) {
      this.eventQueue.shift();
    }
    if (this.processingTimeoutId !== null) {
      const clearFn = typeof window !== "undefined" ? window.clearTimeout : globalThis.clearTimeout;
      clearFn(this.processingTimeoutId);
    }
    const setTimeoutFn = typeof window !== "undefined" ? window.setTimeout : globalThis.setTimeout;
    this.processingTimeoutId = setTimeoutFn(() => {
      this.processQueue();
    }, this.DEBOUNCE_MS);
  }
  /**
   * Process queued events and notify subscribers
   */
  async processQueue() {
    var _a;
    if (this.eventQueue.length === 0) {
      return;
    }
    const events = this.eventQueue.splice(0);
    const latestEvents = /* @__PURE__ */ new Map();
    for (const queuedEvent of events) {
      const key = `${queuedEvent.event.entityType}:${queuedEvent.event.entityId}`;
      const existing = latestEvents.get(key);
      if (!existing || queuedEvent.timestamp > (((_a = latestEvents.get(key)) == null ? void 0 : _a.timestamp) ? Date.parse(existing.timestamp) : 0)) {
        latestEvents.set(key, queuedEvent.event);
      }
    }
    for (const event of latestEvents.values()) {
      for (const subscriber of this.subscribers) {
        try {
          await subscriber(event);
        } catch (err) {
          console.error("ApiUpdateNotifier subscriber failed", err);
        }
      }
    }
    this.processingTimeoutId = null;
  }
  /**
   * Clear all queued events
   */
  clear() {
    this.eventQueue = [];
    if (this.processingTimeoutId !== null) {
      const clearFn = typeof window !== "undefined" ? window.clearTimeout : globalThis.clearTimeout;
      clearFn(this.processingTimeoutId);
      this.processingTimeoutId = null;
    }
  }
  dispose() {
    this.clear();
    this.subscribers.clear();
  }
};

// src/sync-v2/apiUpdateNotifier/apiUpdateNotifier.ts
var apiUpdateNotifierV2 = new ApiUpdateNotifierV2();

// src/sync-v2/apiUpdateNotifier/payloadAdapter.ts
function adaptPayloadToEvent(payload) {
  const timestamp = (/* @__PURE__ */ new Date()).toISOString();
  switch (payload.type) {
    case "chapter":
      return {
        type: "chapter.updated",
        entityId: payload.chapter.id,
        entityType: "chapter",
        storyId: payload.story.id,
        timestamp
      };
    case "scene":
      return {
        type: "scene.updated",
        entityId: payload.scene.id,
        entityType: "scene",
        storyId: payload.story.id,
        timestamp
      };
    case "content":
      return {
        type: "content_block.updated",
        entityId: payload.contentBlock.id,
        entityType: "content_block",
        storyId: payload.story.id,
        timestamp
      };
    default:
      const _exhaustive = payload;
      throw new Error(`Unsupported payload type: ${_exhaustive.type}`);
  }
}

// src/api/client.ts
var StoryEngineClient = class {
  constructor(apiUrl, apiKey, tenantId = "") {
    this.apiUrl = apiUrl;
    this.apiKey = apiKey;
    this.tenantId = tenantId;
    this.mode = "remote";
    this.autoSyncOnApiUpdates = true;
  }
  setTenantId(tenantId) {
    this.tenantId = tenantId.trim();
  }
  setMode(mode) {
    this.mode = mode;
  }
  setAutoSyncOnApiUpdates(enabled) {
    this.autoSyncOnApiUpdates = enabled;
  }
  async request(method, endpoint, body, tenantIdOverride) {
    const url = `${this.apiUrl}${endpoint}`;
    const headers = new Headers();
    headers.set("Content-Type", "application/json");
    if (this.apiKey) {
      headers.set("Authorization", `Bearer ${this.apiKey}`);
    }
    const effectiveTenantId = tenantIdOverride != null ? tenantIdOverride : this.tenantId;
    if (effectiveTenantId) {
      const trimmedTenantId = effectiveTenantId.trim();
      if (trimmedTenantId) {
        headers.set("X-Tenant-ID", trimmedTenantId);
      }
    }
    const options = {
      method,
      headers
    };
    if (body) {
      options.body = JSON.stringify(body);
    }
    const response = await fetch(url, options);
    if (!response.ok) {
      let error;
      try {
        error = await response.json();
      } catch (e) {
        error = {
          error: "unknown_error",
          message: `HTTP ${response.status}: ${response.statusText}`,
          code: "HTTP_ERROR"
        };
      }
      const errorMessage = error.message || error.error || `HTTP ${response.status}: ${response.statusText}`;
      throw new Error(errorMessage);
    }
    return response.json();
  }
  async listStories() {
    if (this.mode === "remote" && (!this.tenantId || !this.tenantId.trim())) {
      throw new Error("Tenant ID is required");
    }
    const response = await this.request(
      "GET",
      "/api/v1/stories"
    );
    return response.stories || [];
  }
  async getStory(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/stories/${id2}`
    );
    return response.story;
  }
  async createStory(title, worldId) {
    if (this.mode === "remote" && (!this.tenantId || !this.tenantId.trim())) {
      throw new Error("Tenant ID is required");
    }
    const body = { title: title.trim() };
    if (worldId) {
      body.world_id = worldId;
    }
    const response = await this.request(
      "POST",
      "/api/v1/stories",
      body
    );
    return response.story;
  }
  async cloneStory(id2) {
    if (!this.tenantId || !this.tenantId.trim()) {
      throw new Error("Tenant ID is required");
    }
    const response = await this.request(
      "POST",
      `/api/v1/stories/${id2}/clone`,
      {}
    );
    return response.story;
  }
  async getTenant(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/tenants/${id2}`
    );
    return response.tenant;
  }
  async testConnection() {
    try {
      await this.request("GET", "/health");
      return true;
    } catch (e) {
      return false;
    }
  }
  async updateStory(id2, title, status) {
    const body = { title: title.trim() };
    if (status) {
      body.status = status;
    }
    const response = await this.request(
      "PUT",
      `/api/v1/stories/${id2}`,
      body
    );
    return response.story;
  }
  async getStoryWithHierarchy(id2) {
    const story = await this.getStory(id2);
    const chapters = await this.getChapters(id2);
    const chaptersWithContent = await Promise.all(
      chapters.map(async (chapter) => {
        const scenes = await this.getScenes(chapter.id);
        const scenesWithBeats = await Promise.all(
          scenes.map(async (scene) => {
            const beats = await this.getBeats(scene.id);
            return { scene, beats };
          })
        );
        return { chapter, scenes: scenesWithBeats };
      })
    );
    return {
      story,
      chapters: chaptersWithContent
    };
  }
  async createChapter(storyId, chapter) {
    const response = await this.request(
      "POST",
      "/api/v1/chapters",
      {
        story_id: storyId,
        number: chapter.number,
        title: chapter.title,
        status: chapter.status
      }
    );
    void this.publishChapterUpdate(response.chapter.id);
    return response.chapter;
  }
  async updateChapter(id2, chapter) {
    const response = await this.request(
      "PUT",
      `/api/v1/chapters/${id2}`,
      chapter
    );
    void this.publishChapterUpdate(response.chapter.id);
    return response.chapter;
  }
  async getChapters(storyId) {
    const response = await this.request(
      "GET",
      `/api/v1/stories/${storyId}/chapters`
    );
    return response.chapters || [];
  }
  async getChapter(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/chapters/${id2}`
    );
    return response.chapter;
  }
  async deleteChapter(id2) {
    await this.request("DELETE", `/api/v1/chapters/${id2}`);
  }
  async createScene(scene) {
    const response = await this.request(
      "POST",
      "/api/v1/scenes",
      scene
    );
    void this.publishSceneTree(response.scene.id);
    return response.scene;
  }
  async updateScene(id2, scene) {
    const response = await this.request(
      "PUT",
      `/api/v1/scenes/${id2}`,
      scene
    );
    void this.publishSceneTree(response.scene.id);
    return response.scene;
  }
  async getScenes(chapterId) {
    const response = await this.request(
      "GET",
      `/api/v1/chapters/${chapterId}/scenes`
    );
    return response.scenes || [];
  }
  async getScene(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/scenes/${id2}`
    );
    return response.scene;
  }
  async deleteScene(id2) {
    await this.request("DELETE", `/api/v1/scenes/${id2}`);
  }
  async createBeat(beat) {
    if (!beat.scene_id) {
      throw new Error("scene_id is required to create a beat");
    }
    const payload = { ...beat };
    if (!payload.order_num || payload.order_num <= 0) {
      const existingBeats = await this.getBeats(beat.scene_id);
      const nextOrder = existingBeats.length > 0 ? Math.max(...existingBeats.map((b) => b.order_num || 0)) + 1 : 1;
      payload.order_num = nextOrder;
    }
    const response = await this.request(
      "POST",
      "/api/v1/beats",
      payload
    );
    void this.publishSceneTree(response.beat.scene_id);
    return response.beat;
  }
  async updateBeat(id2, beat) {
    const response = await this.request(
      "PUT",
      `/api/v1/beats/${id2}`,
      beat
    );
    void this.publishSceneTree(response.beat.scene_id);
    return response.beat;
  }
  async getBeats(sceneId) {
    const response = await this.request(
      "GET",
      `/api/v1/scenes/${sceneId}/beats`
    );
    return response.beats || [];
  }
  async getBeat(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/beats/${id2}`
    );
    return response.beat;
  }
  async deleteBeat(id2) {
    await this.request("DELETE", `/api/v1/beats/${id2}`);
  }
  // Get all versions of a story (for version history)
  async getStoryVersions(rootStoryId) {
    const response = await this.request(
      "GET",
      `/api/v1/stories/${rootStoryId}/versions`
    );
    return response.stories || [];
  }
  async getScenesByStory(storyId) {
    const response = await this.request(
      "GET",
      `/api/v1/stories/${storyId}/scenes`
    );
    return response.scenes || [];
  }
  async moveScene(sceneId, chapterId) {
    const body = {};
    if (chapterId !== null) {
      body.chapter_id = chapterId;
    } else {
      body.chapter_id = null;
    }
    const response = await this.request(
      "PUT",
      `/api/v1/scenes/${sceneId}/move`,
      body
    );
    void this.publishSceneTree(response.scene.id);
    return response.scene;
  }
  async getBeatsByStory(storyId) {
    const response = await this.request(
      "GET",
      `/api/v1/stories/${storyId}/beats`
    );
    return response.beats || [];
  }
  async moveBeat(beatId, sceneId) {
    const response = await this.request(
      "PUT",
      `/api/v1/beats/${beatId}/move`,
      { scene_id: sceneId }
    );
    void this.publishSceneTree(response.beat.scene_id);
    return response.beat;
  }
  async getContentBlocks(chapterId) {
    const response = await this.request(
      "GET",
      `/api/v1/chapters/${chapterId}/content-blocks`
    );
    return response.content_blocks || [];
  }
  async getContentBlock(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/content-blocks/${id2}`
    );
    return response.content_block;
  }
  async createContentBlock(chapterId, contentBlock) {
    const response = await this.request(
      "POST",
      `/api/v1/chapters/${chapterId}/content-blocks`,
      contentBlock
    );
    void this.publishContentBlockUpdate(response.content_block.id);
    return response.content_block;
  }
  async updateContentBlock(id2, contentBlock) {
    const response = await this.request(
      "PUT",
      `/api/v1/content-blocks/${id2}`,
      contentBlock
    );
    void this.publishContentBlockUpdate(response.content_block.id);
    return response.content_block;
  }
  async deleteContentBlock(id2) {
    await this.request("DELETE", `/api/v1/content-blocks/${id2}`);
  }
  async getContentAnchors(contentBlockId) {
    const response = await this.request(
      "GET",
      `/api/v1/content-blocks/${contentBlockId}/anchors`
    );
    return response.anchors || [];
  }
  async getContentBlocksByScene(sceneId) {
    const response = await this.request(
      "GET",
      `/api/v1/scenes/${sceneId}/content-blocks`
    );
    return response.content_blocks || [];
  }
  async getContentBlocksByBeat(beatId) {
    const response = await this.request(
      "GET",
      `/api/v1/beats/${beatId}/content-blocks`
    );
    return response.content_blocks || [];
  }
  async createContentAnchor(contentBlockId, entityType, entityId) {
    const response = await this.request(
      "POST",
      `/api/v1/content-blocks/${contentBlockId}/anchors`,
      {
        entity_type: entityType,
        entity_id: entityId
      }
    );
    return response.anchor;
  }
  async deleteContentAnchor(id2) {
    await this.request("DELETE", `/api/v1/content-anchors/${id2}`);
  }
  async getWorlds() {
    const response = await this.request(
      "GET",
      "/api/v1/worlds"
    );
    return response.worlds || [];
  }
  async getWorld(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/worlds/${id2}`
    );
    return response.world;
  }
  async createWorld(name, description, genre) {
    const response = await this.request(
      "POST",
      "/api/v1/worlds",
      {
        name: name.trim(),
        description: description.trim(),
        genre: genre.trim()
      }
    );
    return response.world;
  }
  async updateWorld(id2, name, description, genre) {
    const response = await this.request(
      "PUT",
      `/api/v1/worlds/${id2}`,
      {
        name: name.trim(),
        description: description.trim(),
        genre: genre.trim()
      }
    );
    return response.world;
  }
  async getRPGSystems() {
    const response = await this.request(
      "GET",
      "/api/v1/rpg-systems"
    );
    return response.rpg_systems || [];
  }
  async getRPGSystem(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/rpg-systems/${id2}`
    );
    return response.rpg_system;
  }
  // Character methods
  async getCharacters(worldId) {
    const response = await this.request(
      "GET",
      `/api/v1/worlds/${worldId}/characters`
    );
    return response.characters || [];
  }
  async getCharacter(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/characters/${id2}`
    );
    return response.character;
  }
  async createCharacter(worldId, data) {
    const response = await this.request(
      "POST",
      `/api/v1/worlds/${worldId}/characters`,
      data
    );
    return response.character;
  }
  async updateCharacter(id2, data) {
    const response = await this.request(
      "PUT",
      `/api/v1/characters/${id2}`,
      data
    );
    return response.character;
  }
  async deleteCharacter(id2) {
    await this.request("DELETE", `/api/v1/characters/${id2}`);
  }
  // Location methods
  async getLocations(worldId) {
    const response = await this.request(
      "GET",
      `/api/v1/worlds/${worldId}/locations`
    );
    return response.locations || [];
  }
  async getLocation(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/locations/${id2}`
    );
    return response.location;
  }
  async createLocation(worldId, data) {
    const response = await this.request(
      "POST",
      `/api/v1/worlds/${worldId}/locations`,
      data
    );
    return response.location;
  }
  async updateLocation(id2, data) {
    const response = await this.request(
      "PUT",
      `/api/v1/locations/${id2}`,
      data
    );
    return response.location;
  }
  async deleteLocation(id2) {
    await this.request("DELETE", `/api/v1/locations/${id2}`);
  }
  // Artifact methods
  async getArtifacts(worldId) {
    const response = await this.request(
      "GET",
      `/api/v1/worlds/${worldId}/artifacts`
    );
    return response.artifacts || [];
  }
  async getArtifact(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/artifacts/${id2}`
    );
    return response.artifact;
  }
  async createArtifact(worldId, data) {
    const response = await this.request(
      "POST",
      `/api/v1/worlds/${worldId}/artifacts`,
      data
    );
    return response.artifact;
  }
  async updateArtifact(id2, data) {
    const response = await this.request(
      "PUT",
      `/api/v1/artifacts/${id2}`,
      data
    );
    return response.artifact;
  }
  async deleteArtifact(id2) {
    await this.request("DELETE", `/api/v1/artifacts/${id2}`);
  }
  // Event methods
  async getEvents(worldId) {
    const response = await this.request(
      "GET",
      `/api/v1/worlds/${worldId}/events`
    );
    return response.events || [];
  }
  async getEvent(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/events/${id2}`
    );
    return response.event;
  }
  async createEvent(worldId, data) {
    const response = await this.request(
      "POST",
      `/api/v1/worlds/${worldId}/events`,
      data
    );
    return response.event;
  }
  async updateEvent(id2, data) {
    const response = await this.request(
      "PUT",
      `/api/v1/events/${id2}`,
      data
    );
    return response.event;
  }
  async deleteEvent(id2) {
    await this.request("DELETE", `/api/v1/events/${id2}`);
  }
  async moveEvent(id2, parentId) {
    const response = await this.request(
      "PUT",
      `/api/v1/events/${id2}/move`,
      { parent_id: parentId }
    );
    return response.event;
  }
  // Trait methods
  async getTraits() {
    const response = await this.request(
      "GET",
      "/api/v1/traits"
    );
    return response.traits || [];
  }
  async getTrait(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/traits/${id2}`
    );
    return response.trait;
  }
  async createTrait(data) {
    const response = await this.request(
      "POST",
      "/api/v1/traits",
      data
    );
    return response.trait;
  }
  async updateTrait(id2, data) {
    const response = await this.request(
      "PUT",
      `/api/v1/traits/${id2}`,
      data
    );
    return response.trait;
  }
  async deleteTrait(id2) {
    await this.request("DELETE", `/api/v1/traits/${id2}`);
  }
  // Archetype methods
  async getArchetypes() {
    const response = await this.request(
      "GET",
      "/api/v1/archetypes"
    );
    return response.archetypes || [];
  }
  async getArchetype(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/archetypes/${id2}`
    );
    return response.archetype;
  }
  async createArchetype(data) {
    const response = await this.request(
      "POST",
      "/api/v1/archetypes",
      data
    );
    return response.archetype;
  }
  async updateArchetype(id2, data) {
    const response = await this.request(
      "PUT",
      `/api/v1/archetypes/${id2}`,
      data
    );
    return response.archetype;
  }
  async deleteArchetype(id2) {
    await this.request("DELETE", `/api/v1/archetypes/${id2}`);
  }
  async getArchetypeTraits(archetypeId) {
    const response = await this.request(
      "GET",
      `/api/v1/archetypes/${archetypeId}/traits`
    );
    return response.archetype_traits || [];
  }
  async addArchetypeTrait(archetypeId, traitId, defaultValue) {
    await this.request(
      "POST",
      `/api/v1/archetypes/${archetypeId}/traits`,
      {
        trait_id: traitId,
        default_value: defaultValue
      }
    );
  }
  async removeArchetypeTrait(archetypeId, traitId) {
    await this.request(
      "DELETE",
      `/api/v1/archetypes/${archetypeId}/traits/${traitId}`
    );
  }
  // Faction methods
  async getFactions(worldId) {
    const response = await this.request(
      "GET",
      `/api/v1/worlds/${worldId}/factions`
    );
    return response.factions || [];
  }
  async getFaction(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/factions/${id2}`
    );
    return response.faction;
  }
  async createFaction(worldId, data) {
    const response = await this.request(
      "POST",
      `/api/v1/worlds/${worldId}/factions`,
      data
    );
    return response.faction;
  }
  async updateFaction(id2, data) {
    const response = await this.request(
      "PUT",
      `/api/v1/factions/${id2}`,
      data
    );
    return response.faction;
  }
  async deleteFaction(id2) {
    await this.request("DELETE", `/api/v1/factions/${id2}`);
  }
  async getFactionChildren(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/factions/${id2}/children`
    );
    return response.factions || [];
  }
  async getFactionReferences(factionId) {
    const response = await this.request(
      "GET",
      `/api/v1/factions/${factionId}/references`
    );
    return response.references || [];
  }
  async addFactionReference(factionId, entityType, entityId, role, notes) {
    const response = await this.request(
      "POST",
      `/api/v1/factions/${factionId}/references`,
      {
        entity_type: entityType,
        entity_id: entityId,
        role,
        notes
      }
    );
    return response.reference;
  }
  async updateFactionReference(id2, role, notes) {
    const response = await this.request(
      "PUT",
      `/api/v1/faction-references/${id2}`,
      {
        role,
        notes
      }
    );
    return response.reference;
  }
  async removeFactionReference(factionId, entityType, entityId) {
    await this.request(
      "DELETE",
      `/api/v1/factions/${factionId}/references/${entityType}/${entityId}`
    );
  }
  // Lore methods
  async getLores(worldId) {
    const response = await this.request(
      "GET",
      `/api/v1/worlds/${worldId}/lores`
    );
    return response.lores || [];
  }
  async getLore(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/lores/${id2}`
    );
    return response.lore;
  }
  async createLore(worldId, data) {
    const response = await this.request(
      "POST",
      `/api/v1/worlds/${worldId}/lores`,
      data
    );
    return response.lore;
  }
  async updateLore(id2, data) {
    const response = await this.request(
      "PUT",
      `/api/v1/lores/${id2}`,
      data
    );
    return response.lore;
  }
  async deleteLore(id2) {
    await this.request("DELETE", `/api/v1/lores/${id2}`);
  }
  async getLoreChildren(id2) {
    const response = await this.request(
      "GET",
      `/api/v1/lores/${id2}/children`
    );
    return response.lores || [];
  }
  async getLoreReferences(loreId) {
    const response = await this.request(
      "GET",
      `/api/v1/lores/${loreId}/references`
    );
    return response.references || [];
  }
  async addLoreReference(loreId, entityType, entityId, relationshipType, notes) {
    const response = await this.request(
      "POST",
      `/api/v1/lores/${loreId}/references`,
      {
        entity_type: entityType,
        entity_id: entityId,
        relationship_type: relationshipType,
        notes
      }
    );
    return response.reference;
  }
  async updateLoreReference(id2, relationshipType, notes) {
    const response = await this.request(
      "PUT",
      `/api/v1/lore-references/${id2}`,
      {
        relationship_type: relationshipType,
        notes
      }
    );
    return response.reference;
  }
  async removeLoreReference(loreId, entityType, entityId) {
    await this.request(
      "DELETE",
      `/api/v1/lores/${loreId}/references/${entityType}/${entityId}`
    );
  }
  // Character Traits methods
  async getCharacterTraits(characterId) {
    const response = await this.request(
      "GET",
      `/api/v1/characters/${characterId}/traits`
    );
    return response.character_traits || [];
  }
  async addCharacterTrait(characterId, traitId, value, notes) {
    const response = await this.request(
      "POST",
      `/api/v1/characters/${characterId}/traits`,
      {
        trait_id: traitId,
        value,
        notes
      }
    );
    return response.character_trait;
  }
  async updateCharacterTrait(characterId, traitId, value, notes) {
    const response = await this.request(
      "PUT",
      `/api/v1/characters/${characterId}/traits/${traitId}`,
      {
        value,
        notes
      }
    );
    return response.character_trait;
  }
  async removeCharacterTrait(characterId, traitId) {
    await this.request(
      "DELETE",
      `/api/v1/characters/${characterId}/traits/${traitId}`
    );
  }
  // Character Events methods
  async getCharacterEvents(characterId) {
    const response = await this.request(
      "GET",
      `/api/v1/characters/${characterId}/events`
    );
    return response.event_characters || [];
  }
  // Character Relationships methods
  async getCharacterRelationships(characterId) {
    const response = await this.request(
      "GET",
      `/api/v1/characters/${characterId}/relationships`
    );
    return response.relationships || [];
  }
  async createCharacterRelationship(characterId, data) {
    const response = await this.request(
      "POST",
      `/api/v1/characters/${characterId}/relationships`,
      data
    );
    return response.relationship;
  }
  async updateCharacterRelationship(id2, data) {
    const response = await this.request(
      "PUT",
      `/api/v1/character-relationships/${id2}`,
      data
    );
    return response.relationship;
  }
  async deleteCharacterRelationship(id2) {
    await this.request("DELETE", `/api/v1/character-relationships/${id2}`);
  }
  async createEntityRelation(input) {
    var _a;
    const response = await this.request(
      "POST",
      "/api/v1/relations",
      {
        world_id: input.world_id,
        source_type: input.source_type,
        source_id: input.source_id,
        target_type: input.target_type,
        target_id: input.target_id,
        relation_type: input.relation_type,
        summary: input.summary,
        create_mirror: (_a = input.create_mirror) != null ? _a : false
      }
    );
    return response.relation;
  }
  // Event Characters/References methods
  async getEventCharacters(eventId) {
    const response = await this.request(
      "GET",
      `/api/v1/events/${eventId}/characters`
    );
    return response.event_characters || [];
  }
  async addEventCharacter(eventId, characterId, role) {
    const response = await this.request(
      "POST",
      `/api/v1/events/${eventId}/characters`,
      {
        character_id: characterId,
        role
      }
    );
    return response.event_character;
  }
  async removeEventCharacter(eventId, characterId) {
    await this.request(
      "DELETE",
      `/api/v1/events/${eventId}/characters/${characterId}`
    );
  }
  async getEventReferences(eventId) {
    const response = await this.request(
      "GET",
      `/api/v1/events/${eventId}/references`
    );
    return response.references || [];
  }
  async addEventReference(eventId, entityType, entityId, relationshipType, notes) {
    const response = await this.request(
      "POST",
      `/api/v1/events/${eventId}/references`,
      {
        entity_type: entityType,
        entity_id: entityId,
        relationship_type: relationshipType,
        notes
      }
    );
    return response.reference;
  }
  async updateEventReference(id2, relationshipType, notes) {
    const response = await this.request(
      "PUT",
      `/api/v1/event-references/${id2}`,
      {
        relationship_type: relationshipType,
        notes
      }
    );
    return response.reference;
  }
  async removeEventReference(eventId, entityType, entityId) {
    await this.request(
      "DELETE",
      `/api/v1/events/${eventId}/references/${entityType}/${entityId}`
    );
  }
  // Scene References methods
  async getSceneReferences(sceneId) {
    const response = await this.request(
      "GET",
      `/api/v1/scenes/${sceneId}/references`
    );
    return response.references || [];
  }
  async addSceneReference(sceneId, entityType, entityId) {
    const response = await this.request(
      "POST",
      `/api/v1/scenes/${sceneId}/references`,
      {
        entity_type: entityType,
        entity_id: entityId
      }
    );
    return response.reference;
  }
  async removeSceneReference(sceneId, entityType, entityId) {
    await this.request(
      "DELETE",
      `/api/v1/scenes/${sceneId}/references/${entityType}/${entityId}`
    );
  }
  // Timeline methods
  async getTimeline(worldId, fromPos, toPos) {
    const queryParams = new URLSearchParams();
    if (fromPos !== void 0) {
      queryParams.append("from_pos", fromPos.toString());
    }
    if (toPos !== void 0) {
      queryParams.append("to_pos", toPos.toString());
    }
    const queryString = queryParams.toString();
    const endpoint = `/api/v1/worlds/${worldId}/timeline${queryString ? `?${queryString}` : ""}`;
    const response = await this.request(
      "GET",
      endpoint
    );
    return response.events || [];
  }
  async listRelationsBySource(params) {
    const query = this.buildRelationsQuery([
      ["source_type", params.sourceType],
      ["source_id", params.sourceId],
      ["relation_type", params.relationType],
      ["cursor", params.cursor],
      ["limit", params.limit],
      ["order_by", params.orderBy],
      ["order_dir", params.orderDir],
      ["exclude_mirrors", params.excludeMirrors]
    ]);
    const response = await this.request(
      "GET",
      `/api/v1/relations/source?${query}`
    );
    return this.normalizeRelationsResponse(response);
  }
  async listRelationsByTarget(params) {
    const query = this.buildRelationsQuery([
      ["target_type", params.targetType],
      ["target_id", params.targetId],
      ["relation_type", params.relationType],
      ["cursor", params.cursor],
      ["limit", params.limit],
      ["order_by", params.orderBy],
      ["order_dir", params.orderDir],
      ["exclude_mirrors", params.excludeMirrors]
    ]);
    const response = await this.request(
      "GET",
      `/api/v1/relations/target?${query}`
    );
    return this.normalizeRelationsResponse(response);
  }
  async listRelationsByWorld(params) {
    const query = this.buildRelationsQuery([
      ["relation_type", params.relationType],
      ["cursor", params.cursor],
      ["limit", params.limit],
      ["order_by", params.orderBy],
      ["order_dir", params.orderDir],
      ["exclude_mirrors", params.excludeMirrors]
    ]);
    const endpoint = query ? `/api/v1/worlds/${params.worldId}/relations?${query}` : `/api/v1/worlds/${params.worldId}/relations`;
    const response = await this.request("GET", endpoint);
    return this.normalizeRelationsResponse(response);
  }
  async createRelation(params) {
    const response = await this.request("POST", "/api/v1/relations", {
      source_type: params.sourceType,
      source_id: params.sourceId,
      target_type: params.targetType,
      target_id: params.targetId,
      relation_type: params.relationType,
      context: params.context
    });
    return response.relation;
  }
  async updateRelation(params) {
    const payload = {};
    if (params.relationType !== void 0) {
      payload.relation_type = params.relationType;
    }
    if (params.context !== void 0) {
      payload.context = params.context;
    }
    const response = await this.request(
      "PUT",
      `/api/v1/relations/${params.id}`,
      payload
    );
    return response.relation;
  }
  async deleteRelation(id2) {
    await this.request("DELETE", `/api/v1/relations/${id2}`);
  }
  // World TimeConfig methods
  async updateWorldTimeConfig(worldId, timeConfig) {
    const response = await this.request(
      "PUT",
      `/api/v1/worlds/${worldId}/time-config`,
      timeConfig
    );
    return response.world;
  }
  isAutoSyncEnabled() {
    return this.autoSyncOnApiUpdates;
  }
  buildRelationsQuery(entries) {
    const search = new URLSearchParams();
    for (const [key, rawValue] of entries) {
      if (rawValue === void 0 || rawValue === null)
        continue;
      if (typeof rawValue === "boolean") {
        if (rawValue) {
          search.set(key, "true");
        }
        continue;
      }
      search.set(key, String(rawValue));
    }
    return search.toString();
  }
  normalizeRelationsResponse(response) {
    var _a, _b, _c, _d;
    return {
      data: (_a = response == null ? void 0 : response.data) != null ? _a : [],
      pagination: {
        has_more: (_c = (_b = response == null ? void 0 : response.pagination) == null ? void 0 : _b.has_more) != null ? _c : false,
        next_cursor: (_d = response == null ? void 0 : response.pagination) == null ? void 0 : _d.next_cursor
      }
    };
  }
  async publishChapterUpdate(chapterId) {
    if (!this.isAutoSyncEnabled()) {
      return;
    }
    try {
      const chapter = await this.getChapter(chapterId);
      const story = await this.getStory(chapter.story_id);
      const scenes = await this.getScenes(chapterId);
      const scenesWithBeats = await Promise.all(
        scenes.map(async (scene) => {
          const beats = await this.getBeats(scene.id);
          return { scene, beats };
        })
      );
      const contentBlocks = await this.getContentBlocks(chapterId);
      const contentBlockRefs = [];
      for (const block of contentBlocks) {
        const refs = await this.getContentAnchors(block.id);
        contentBlockRefs.push(...refs);
      }
      await this.notifyEntityUpdate({
        type: "chapter",
        story,
        chapter,
        scenes: scenesWithBeats,
        contentBlocks,
        contentBlockRefs
      });
    } catch (err) {
      console.error("Failed to auto-sync chapter update", err);
    }
  }
  async publishSceneTree(sceneId) {
    if (!this.isAutoSyncEnabled()) {
      return;
    }
    try {
      const scene = await this.getScene(sceneId);
      if (scene.chapter_id) {
        await this.publishChapterUpdate(scene.chapter_id);
        return;
      }
      const story = await this.getStory(scene.story_id);
      const beats = await this.getBeats(scene.id);
      const sceneContentBlocks = await this.getContentBlocksByScene(scene.id);
      const beatContentBlocks = {};
      for (const beat of beats) {
        beatContentBlocks[beat.id] = await this.getContentBlocksByBeat(beat.id);
      }
      await this.notifyEntityUpdate({
        type: "scene",
        story,
        scene,
        beats,
        sceneContentBlocks,
        beatContentBlocks
      });
    } catch (err) {
      console.error("Failed to auto-sync scene update", err);
    }
  }
  async publishContentBlockUpdate(contentBlockId) {
    if (!this.isAutoSyncEnabled()) {
      return;
    }
    try {
      const contentBlock = await this.getContentBlock(contentBlockId);
      let story = null;
      if (contentBlock.chapter_id) {
        const chapter = await this.getChapter(contentBlock.chapter_id);
        story = await this.getStory(chapter.story_id);
      } else {
        const anchors = await this.getContentAnchors(contentBlock.id);
        const sceneAnchor = anchors.find((anchor) => anchor.entity_type === "scene");
        if (sceneAnchor) {
          const scene = await this.getScene(sceneAnchor.entity_id);
          story = await this.getStory(scene.story_id);
        }
      }
      if (!story) {
        console.warn("Unable to resolve story for content block auto-sync", contentBlockId);
        return;
      }
      await this.notifyEntityUpdate({
        type: "content",
        story,
        contentBlock
      });
    } catch (err) {
      console.error("Failed to auto-sync content block update", err);
    }
  }
  async notifyEntityUpdate(payload) {
    await apiUpdateNotifier.notify(payload);
    try {
      const event = adaptPayloadToEvent(payload);
      await apiUpdateNotifierV2.notify(event);
    } catch (err) {
      console.warn("Failed to notify V2 notifier", err);
    }
  }
};

// src/settings.ts
var import_obsidian = require("obsidian");
var StoryEngineSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Story Engine Settings" });
    let tenantIdSetting = null;
    let videoLinkSetting = null;
    let conflictResolutionSetting = null;
    const modeSetting = new import_obsidian.Setting(containerEl).setName("Connection Mode").setDesc("Choose between local (offline) or remote (cloud) mode").addDropdown(
      (dropdown) => dropdown.addOption("local", "Local").addOption("remote", "Remote").setValue(this.plugin.settings.mode || "local").onChange(async (value) => {
        this.plugin.settings.mode = value;
        if (value === "local") {
          this.plugin.settings.conflictResolution = "local";
          if (conflictResolutionSetting) {
            conflictResolutionSetting.settingEl.style.display = "none";
          }
        } else {
          if (conflictResolutionSetting) {
            conflictResolutionSetting.settingEl.style.display = "";
          }
        }
        if (tenantIdSetting) {
          tenantIdSetting.settingEl.style.display = value === "remote" ? "" : "none";
        }
        if (videoLinkSetting) {
          videoLinkSetting.settingEl.style.display = value === "local" ? "" : "none";
        }
        if (this.plugin.apiClient) {
          this.plugin.apiClient.setMode(value);
        }
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Sync Version").setDesc(
      "Toggle between the legacy sync engine (v1) and the new modular pipeline (v2 - experimental)"
    ).addDropdown(
      (dropdown) => dropdown.addOption("v1", "Legacy (v1)").addOption("v2", "Modular (v2, experimental)").setValue(this.plugin.settings.syncVersion || "v1").onChange(async (value) => {
        this.plugin.settings.syncVersion = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("API URL").setDesc("The base URL of the Story Engine API").addText(
      (text) => text.setPlaceholder("http://localhost:8080").setValue(this.plugin.settings.apiUrl).onChange(async (value) => {
        this.plugin.settings.apiUrl = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("LLM Gateway URL").setDesc("The base URL of the LLM Gateway service").addText(
      (text) => text.setPlaceholder("http://localhost:8081").setValue(this.plugin.settings.llmGatewayUrl).onChange(async (value) => {
        this.plugin.settings.llmGatewayUrl = value.trim();
        await this.plugin.saveSettings();
      })
    );
    tenantIdSetting = new import_obsidian.Setting(containerEl).setName("Tenant ID").setDesc("Your workspace tenant ID (UUID format) - Required in remote mode").addText(
      (text) => text.setPlaceholder("00000000-0000-0000-0000-000000000000").setValue(this.plugin.settings.tenantId || "").onChange(async (value) => {
        this.plugin.settings.tenantId = value.trim();
        if (this.plugin.apiClient) {
          this.plugin.apiClient.setTenantId(value.trim());
        }
        await this.plugin.saveSettings();
      })
    );
    if (this.plugin.settings.mode === "local") {
      tenantIdSetting.settingEl.style.display = "none";
    }
    const videoUrl = this.plugin.settings.localModeVideoUrl || "https://example.com/setup-video";
    videoLinkSetting = new import_obsidian.Setting(containerEl).setName("Setup Guide").setDesc(`\u{1F4F9} Learn how to setup local mode: ${videoUrl}`).addButton((button) => {
      button.setButtonText("Open Video").onClick(() => {
        window.open(videoUrl, "_blank");
      });
    });
    if (this.plugin.settings.mode === "remote") {
      videoLinkSetting.settingEl.style.display = "none";
    }
    new import_obsidian.Setting(containerEl).setName("API Key").setDesc("API key for authentication (optional for MVP)").addText((text) => {
      text.setPlaceholder("Enter API key").setValue(this.plugin.settings.apiKey).inputEl.type = "password";
      text.onChange(async (value) => {
        this.plugin.settings.apiKey = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Sync Folder Path").setDesc("Folder path where synced stories will be stored").addText(
      (text) => text.setPlaceholder("Stories").setValue(this.plugin.settings.syncFolderPath || "Stories").onChange(async (value) => {
        this.plugin.settings.syncFolderPath = value.trim() || "Stories";
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Auto Version Snapshots").setDesc("Automatically create version snapshots when syncing").addToggle(
      (toggle) => {
        var _a;
        return toggle.setValue((_a = this.plugin.settings.autoVersionSnapshots) != null ? _a : true).onChange(async (value) => {
          this.plugin.settings.autoVersionSnapshots = value;
          await this.plugin.saveSettings();
        });
      }
    );
    new import_obsidian.Setting(containerEl).setName("Auto Sync on API Updates").setDesc("Apply API update payloads directly to local files when available").addToggle(
      (toggle) => {
        var _a;
        return toggle.setValue((_a = this.plugin.settings.autoSyncOnApiUpdates) != null ? _a : true).onChange(async (value) => {
          this.plugin.settings.autoSyncOnApiUpdates = value;
          await this.plugin.saveSettings();
        });
      }
    );
    new import_obsidian.Setting(containerEl).setName("Auto Push on Blur/Idle").setDesc("When you leave a chapter/scene/beat or stay idle for 1 min, push changes upstream automatically").addToggle(
      (toggle) => {
        var _a;
        return toggle.setValue((_a = this.plugin.settings.autoPushOnFileBlur) != null ? _a : true).onChange(async (value) => {
          this.plugin.settings.autoPushOnFileBlur = value;
          await this.plugin.saveSettings();
        });
      }
    );
    conflictResolutionSetting = new import_obsidian.Setting(containerEl).setName("Conflict Resolution").setDesc("How to resolve conflicts when both local and service have changes").addDropdown(
      (dropdown) => dropdown.addOption("service", "Service Wins").addOption("local", "Local Wins").addOption("manual", "Manual (Newer Wins)").setValue(this.plugin.settings.conflictResolution || "service").onChange(async (value) => {
        this.plugin.settings.conflictResolution = value;
        await this.plugin.saveSettings();
      })
    );
    if (this.plugin.settings.mode === "local") {
      conflictResolutionSetting.settingEl.style.display = "none";
    }
    new import_obsidian.Setting(containerEl).setName("Show Help Box in MD Files").setDesc("Enable/disable info/help boxes in markdown files").addToggle(
      (toggle) => {
        var _a;
        return toggle.setValue((_a = this.plugin.settings.showHelpBox) != null ? _a : true).onChange(async (value) => {
          this.plugin.settings.showHelpBox = value;
          await this.plugin.saveSettings();
        });
      }
    );
    new import_obsidian.Setting(containerEl).setName("Unsplash Access Key").setDesc("Application ID / Access Key for Unsplash API (get one at https://unsplash.com/developers)").addText((text) => {
      text.setPlaceholder("Enter Unsplash access key").setValue(this.plugin.settings.unsplashAccessKey || "").inputEl.type = "password";
      text.onChange(async (value) => {
        this.plugin.settings.unsplashAccessKey = value.trim();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Unsplash Secret Key").setDesc("Secret Key for Unsplash API (optional, needed for some operations)").addText((text) => {
      text.setPlaceholder("Enter Unsplash secret key").setValue(this.plugin.settings.unsplashSecretKey || "").inputEl.type = "password";
      text.onChange(async (value) => {
        this.plugin.settings.unsplashSecretKey = value.trim();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Test Connection").setDesc("Test connection to the Story Engine API").addButton(
      (button) => button.setButtonText("Test").onClick(async () => {
        button.setButtonText("Testing...");
        button.setDisabled(true);
        try {
          const result = await this.plugin.apiClient.testConnection();
          if (result) {
            button.setButtonText("Success!");
            setTimeout(() => {
              button.setButtonText("Test");
              button.setDisabled(false);
            }, 2e3);
          } else {
            button.setButtonText("Failed");
            setTimeout(() => {
              button.setButtonText("Test");
              button.setDisabled(false);
            }, 2e3);
          }
        } catch (err) {
          button.setButtonText("Error");
          setTimeout(() => {
            button.setButtonText("Test");
            button.setDisabled(false);
          }, 2e3);
        }
      })
    );
  }
};

// src/commands.ts
var import_obsidian3 = require("obsidian");

// src/views/StorySyncModal.ts
var import_obsidian2 = require("obsidian");
var StorySyncModal = class extends import_obsidian2.Modal {
  constructor(plugin, mode) {
    super(plugin.app);
    this.stories = [];
    this.loading = true;
    this.error = null;
    this.plugin = plugin;
    this.mode = mode;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    const title = this.mode === "pull" ? "Sync Story from Service" : "Push Story to Service";
    contentEl.createEl("h2", { text: title });
    await this.loadStories();
    if (this.loading) {
      contentEl.createEl("p", { text: "Loading stories..." });
      return;
    }
    if (this.error) {
      contentEl.createEl("p", {
        text: `Error: ${this.error}`,
        cls: "story-engine-error"
      });
      return;
    }
    if (this.stories.length === 0) {
      contentEl.createEl("p", { text: "No stories found." });
      return;
    }
    const storiesList = contentEl.createEl("div", { cls: "story-engine-list" });
    for (const story of this.stories) {
      const storyItem = storiesList.createEl("div", {
        cls: "story-engine-item"
      });
      const title2 = storyItem.createEl("div", {
        cls: "story-engine-title",
        text: story.title
      });
      const meta = storyItem.createEl("div", {
        cls: "story-engine-meta"
      });
      meta.createEl("span", {
        text: `Version ${story.version_number}`
      });
      meta.createEl("span", {
        text: `Status: ${story.status}`
      });
      storyItem.onclick = async () => {
        this.close();
        try {
          if (this.mode === "pull") {
            await this.plugin.syncService.pullStory(story.id);
          } else {
            const folderPath = this.plugin.fileManager.getStoryFolderPath(
              story.title
            );
            await this.plugin.syncService.pushStory(folderPath);
          }
        } catch (err) {
          const errorMessage = err instanceof Error ? err.message : "Failed to sync story";
          new import_obsidian2.Notice(`Error: ${errorMessage}`, 5e3);
        }
      };
    }
  }
  async loadStories() {
    this.loading = true;
    this.error = null;
    try {
      if (!this.plugin.settings.tenantId) {
        this.error = "Tenant ID not configured";
        this.loading = false;
        return;
      }
      this.stories = await this.plugin.apiClient.listStories();
    } catch (err) {
      this.error = err instanceof Error ? err.message : "Unknown error";
    } finally {
      this.loading = false;
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/commands.ts
function registerCommands(plugin) {
  plugin.addCommand({
    id: "list-stories",
    name: "List Stories",
    callback: () => {
      plugin.activateView();
    }
  });
  plugin.addCommand({
    id: "create-story",
    name: "Create Story",
    callback: () => {
      plugin.createStoryCommand();
    }
  });
  plugin.addCommand({
    id: "sync-story-from-service",
    name: "Sync Story from Service",
    callback: () => {
      new StorySyncModal(plugin, "pull").open();
    }
  });
  plugin.addCommand({
    id: "push-story-to-service",
    name: "Push Story to Service",
    callback: () => {
      new StorySyncModal(plugin, "push").open();
    }
  });
  plugin.addCommand({
    id: "sync-all-stories",
    name: "Sync All Stories",
    callback: async () => {
      if (plugin.settings.mode === "remote" && !plugin.settings.tenantId) {
        new import_obsidian3.Notice("Please configure Tenant ID in settings", 5e3);
        return;
      }
      try {
        new import_obsidian3.Notice("Syncing all stories...");
        await plugin.syncService.pullAllStories();
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to sync stories";
        new import_obsidian3.Notice(`Error: ${errorMessage}`, 5e3);
      }
    }
  });
  plugin.addCommand({
    id: "extract-entities-from-selection",
    name: "Extract Entities and Relations from Selection",
    editorCallback: (editor) => {
      const selection2 = editor.getSelection();
      if (!selection2.trim()) {
        new import_obsidian3.Notice("Select text to extract entities and relations", 3e3);
        return;
      }
      plugin.extractSelectionCommand(selection2, true);
    }
  });
  plugin.addCommand({
    id: "extract-entities-only-from-selection",
    name: "Extract Entities Only from Selection",
    editorCallback: (editor) => {
      const selection2 = editor.getSelection();
      if (!selection2.trim()) {
        new import_obsidian3.Notice("Select text to extract entities", 3e3);
        return;
      }
      plugin.extractSelectionCommand(selection2, false);
    }
  });
}

// src/views/CreateStoryModal.ts
var import_obsidian5 = require("obsidian");

// src/views/CreateWorldModal.ts
var import_obsidian4 = require("obsidian");
var CreateWorldModal = class extends import_obsidian4.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.name = "";
    this.description = "";
    this.genre = "";
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Create New World" });
    new import_obsidian4.Setting(contentEl).setName("World Name").setDesc("Enter the name for your new world").addText(
      (text) => text.setPlaceholder("My New World").setValue(this.name).onChange((value) => {
        this.name = value;
      }).inputEl.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          const descriptionInput = contentEl.querySelector("textarea");
          if (descriptionInput) {
            descriptionInput.focus();
          }
        }
      })
    );
    new import_obsidian4.Setting(contentEl).setName("Description").setDesc("Enter a description for your world").addTextArea(
      (text) => text.setPlaceholder("A brief description of your world...").setValue(this.description).onChange((value) => {
        this.description = value;
      })
    );
    new import_obsidian4.Setting(contentEl).setName("Genre").setDesc("Enter the genre of your world").addText(
      (text) => text.setPlaceholder("Fantasy, Sci-Fi, Contemporary, etc.").setValue(this.genre).onChange((value) => {
        this.genre = value;
      }).inputEl.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          this.submit();
        }
      })
    );
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const createButton = buttonContainer.createEl("button", {
      text: "Create",
      cls: "mod-cta"
    });
    createButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
    const nameInput = contentEl.querySelector("input");
    if (nameInput) {
      nameInput.focus();
    }
  }
  submit() {
    const trimmedName = this.name.trim();
    const trimmedDescription = this.description.trim();
    const trimmedGenre = this.genre.trim();
    if (!trimmedName) {
      new import_obsidian4.Notice("Please enter a world name", 3e3);
      return;
    }
    if (!trimmedGenre) {
      new import_obsidian4.Notice("Please enter a genre", 3e3);
      return;
    }
    this.close();
    this.onSubmit(trimmedName, trimmedDescription, trimmedGenre);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/CreateStoryModal.ts
var CreateStoryModal = class extends import_obsidian5.Modal {
  constructor(app, plugin, onSubmit) {
    super(app);
    this.title = "";
    this.selectedWorldId = "";
    this.shouldSync = true;
    this.worlds = [];
    this.plugin = plugin;
    this.onSubmit = onSubmit;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Create New Story" });
    try {
      this.worlds = await this.plugin.apiClient.getWorlds();
    } catch (err) {
      console.error("Failed to load worlds:", err);
      this.worlds = [];
    }
    new import_obsidian5.Setting(contentEl).setName("Story Title").setDesc("Enter the title for your new story").addText(
      (text) => text.setPlaceholder("My New Story").setValue(this.title).onChange((value) => {
        this.title = value;
      }).inputEl.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          this.submit();
        }
      })
    );
    const worldOptions = {
      "": "No World"
    };
    for (const world of this.worlds) {
      worldOptions[world.id] = world.name;
    }
    worldOptions["__create_new__"] = "Create new world...";
    new import_obsidian5.Setting(contentEl).setName("World").setDesc("Select a world for this story (optional)").addDropdown((dropdown) => {
      for (const [value, label] of Object.entries(worldOptions)) {
        dropdown.addOption(value, label);
      }
      dropdown.setValue(this.selectedWorldId || "");
      dropdown.onChange(async (value) => {
        if (value === "__create_new__") {
          new CreateWorldModal(this.app, async (name, description, genre) => {
            try {
              const newWorld = await this.plugin.apiClient.createWorld(name, description, genre);
              this.worlds.push(newWorld);
              this.onClose();
              this.onOpen();
              this.selectedWorldId = newWorld.id;
            } catch (err) {
              const errorMessage = err instanceof Error ? err.message : "Failed to create world";
              new import_obsidian5.Notice(`Error: ${errorMessage}`, 5e3);
            }
          }).open();
        } else {
          this.selectedWorldId = value;
        }
      });
    });
    new import_obsidian5.Setting(contentEl).setName("Sync to Obsidian").setDesc("Automatically sync the story files to your vault after creation").addToggle(
      (toggle) => toggle.setValue(this.shouldSync).onChange((value) => {
        this.shouldSync = value;
      })
    );
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const createButton = buttonContainer.createEl("button", {
      text: "Create",
      cls: "mod-cta"
    });
    createButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
    const titleInput = contentEl.querySelector("input");
    if (titleInput) {
      titleInput.focus();
    }
  }
  submit() {
    const trimmedTitle = this.title.trim();
    if (!trimmedTitle) {
      new import_obsidian5.Notice("Please enter a story title", 3e3);
      return;
    }
    this.close();
    const worldId = this.selectedWorldId && this.selectedWorldId !== "__create_new__" ? this.selectedWorldId : void 0;
    this.onSubmit(trimmedTitle, worldId, this.shouldSync);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/ExtractConfigModal.ts
var import_obsidian6 = require("obsidian");
var ENTITY_TYPE_OPTIONS = [
  { value: "character", label: "Character" },
  { value: "location", label: "Location" },
  { value: "artefact", label: "Artefact" },
  { value: "faction", label: "Faction" },
  { value: "event", label: "Event" }
];
var ExtractConfigModal = class _ExtractConfigModal extends import_obsidian6.Modal {
  constructor(app, defaultTypes, defaultIncludeRelations) {
    super(app);
    this.resolve = null;
    this.selectedTypes = /* @__PURE__ */ new Set();
    this.includeRelations = true;
    defaultTypes.forEach((type2) => this.selectedTypes.add(type2));
    this.includeRelations = defaultIncludeRelations;
  }
  static open(app, defaultTypes, defaultIncludeRelations) {
    return new Promise((resolve) => {
      const modal = new _ExtractConfigModal(
        app,
        defaultTypes,
        defaultIncludeRelations
      );
      modal.resolve = resolve;
      modal.open();
    });
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h3", { text: "Extract Configuration" });
    contentEl.createEl("p", {
      text: "Choose which entity types to extract and whether to include relations."
    });
    const typeBlock = contentEl.createDiv({ cls: "story-engine-extract-config" });
    typeBlock.createEl("div", {
      text: "Entity types",
      cls: "story-engine-extract-label"
    });
    ENTITY_TYPE_OPTIONS.forEach((option) => {
      const row = typeBlock.createDiv({
        cls: "story-engine-extract-config-row"
      });
      const checkbox = row.createEl("input", {
        type: "checkbox"
      });
      checkbox.checked = this.selectedTypes.has(option.value);
      checkbox.onchange = () => {
        if (checkbox.checked) {
          this.selectedTypes.add(option.value);
        } else {
          this.selectedTypes.delete(option.value);
        }
      };
      row.createEl("span", { text: option.label });
    });
    const relationRow = contentEl.createDiv({
      cls: "story-engine-extract-config-row"
    });
    const relationsCheckbox = relationRow.createEl("input", {
      type: "checkbox"
    });
    relationsCheckbox.checked = this.includeRelations;
    relationsCheckbox.onchange = () => {
      this.includeRelations = relationsCheckbox.checked;
    };
    relationRow.createEl("span", { text: "Include relations" });
    const buttonContainer = contentEl.createDiv({
      cls: "modal-button-container"
    });
    const submitButton = buttonContainer.createEl("button", {
      text: "Start Extraction",
      cls: "mod-cta"
    });
    submitButton.onclick = () => this.submit();
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.onclick = () => this.cancel();
  }
  submit() {
    const types = Array.from(this.selectedTypes);
    if (types.length === 0) {
      new import_obsidian6.Notice("Select at least one entity type.", 3e3);
      return;
    }
    if (this.resolve) {
      this.resolve({
        entityTypes: types,
        includeRelations: this.includeRelations
      });
    }
    this.close();
  }
  cancel() {
    if (this.resolve) {
      this.resolve(null);
    }
    this.close();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/sync/fileManager.ts
var import_obsidian7 = require("obsidian");
var FileManager = class {
  constructor(vault, baseFolder) {
    this.vault = vault;
    this.baseFolder = baseFolder;
  }
  // Expose vault for sync operations
  getVault() {
    return this.vault;
  }
  // Get the folder path for a specific story
  getStoryFolderPath(storyTitle) {
    const sanitized = this.sanitizeFolderName(storyTitle);
    return `${this.baseFolder}/${sanitized}`;
  }
  getWorldsRootPath() {
    return `${this.baseFolder}/worlds`;
  }
  // Sanitize folder/file names
  sanitizeFolderName(name) {
    return name.replace(/[<>:"/\\|?*]/g, "-").replace(/\s+/g, " ").trim();
  }
  // Generate frontmatter with Obsidian tags
  generateFrontmatter(baseFields, extraFields, options) {
    const fields = { ...baseFields };
    if (extraFields) {
      Object.assign(fields, extraFields);
    }
    const tags = [];
    if (options) {
      tags.push(`story-engine/${options.entityType}`);
      if (options.storyName) {
        const sanitizedStoryName = this.sanitizeFolderName(options.storyName).toLowerCase().replace(/\s+/g, "-");
        tags.push(`story/${sanitizedStoryName}`);
      }
      if (options.worldName) {
        const sanitizedWorldName = this.sanitizeFolderName(options.worldName).toLowerCase().replace(/\s+/g, "-");
        tags.push(`world/${sanitizedWorldName}`);
      }
      if (options.date) {
        const date = typeof options.date === "string" ? new Date(options.date) : options.date;
        if (!isNaN(date.getTime())) {
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, "0");
          const day = String(date.getDate()).padStart(2, "0");
          tags.push(`date/${year}/${month}/${day}`);
        }
      }
    }
    const lines = ["---"];
    for (const [key, value] of Object.entries(fields)) {
      if (value === null || value === void 0) {
        lines.push(`${key}: null`);
      } else if (typeof value === "string") {
        const escaped = value.replace(/"/g, '\\"');
        if (value.includes(":") || value.includes("\n") || value.includes('"')) {
          lines.push(`${key}: "${escaped}"`);
        } else {
          lines.push(`${key}: ${escaped}`);
        }
      } else {
        lines.push(`${key}: ${value}`);
      }
    }
    if (tags.length > 0) {
      lines.push(`tags:`);
      for (const tag of tags) {
        lines.push(`  - ${tag}`);
      }
    }
    lines.push("---", "");
    return lines.join("\n");
  }
  getWorldFolderPath(worldName) {
    const sanitized = this.sanitizeFolderName(worldName);
    return `${this.baseFolder}/worlds/${sanitized}`;
  }
  async writeWorldMetadata(world, folderPath) {
    var _a;
    await this.ensureFolderExists(folderPath);
    const frontmatter = this.generateFrontmatter(
      {
        id: world.id,
        genre: world.genre,
        rpg_system_id: (_a = world.rpg_system_id) != null ? _a : null,
        time_config: world.time_config ? JSON.stringify(world.time_config) : null,
        created_at: world.created_at,
        updated_at: world.updated_at
      },
      void 0,
      {
        entityType: "world",
        worldName: world.name,
        date: world.created_at
      }
    );
    const content = [
      frontmatter,
      `# ${world.name}`,
      "",
      world.description || "_No description yet._",
      "",
      world.is_implicit ? "> This world is implicit (auto-created)." : ""
    ].filter(Boolean).join("\n");
    await this.writeFile(`${folderPath}/world.md`, content.trim() + "\n");
  }
  // Ensure folder exists
  async ensureFolderExists(path) {
    const folder = this.vault.getAbstractFileByPath(path);
    if (!folder) {
      await this.vault.createFolder(path);
    }
  }
  async writeFile(filePath, content) {
    const folderPath = filePath.split("/").slice(0, -1).join("/");
    if (folderPath) {
      await this.ensureFolderExists(folderPath);
    }
    const existing = this.vault.getAbstractFileByPath(filePath);
    if (existing instanceof import_obsidian7.TFile) {
      await this.vault.modify(existing, content);
    } else {
      await this.vault.create(filePath, content);
    }
  }
  async readFile(filePath) {
    const file = this.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian7.TFile)) {
      throw new Error(`File not found: ${filePath}`);
    }
    return this.vault.read(file);
  }
  async renameFile(oldPath, newPath) {
    const file = this.vault.getAbstractFileByPath(oldPath);
    if (!(file instanceof import_obsidian7.TFile)) {
      throw new Error(`File not found: ${oldPath}`);
    }
    const folderPath = newPath.split("/").slice(0, -1).join("/");
    if (folderPath) {
      await this.ensureFolderExists(folderPath);
    }
    await this.vault.rename(file, newPath);
  }
  fileExists(path) {
    const file = this.vault.getAbstractFileByPath(path);
    return !!file;
  }
  async createSnapshot(_label) {
  }
  // Write story metadata (story.md)
  async writeStoryMetadata(story, folderPath, chapters, orphanScenes, orphanBeats, chapterContentData, options) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    await this.ensureFolderExists(folderPath);
    const baseFields = {
      id: story.id,
      title: story.title,
      status: story.status,
      version: story.version_number,
      root_story_id: story.root_story_id,
      previous_version_id: story.previous_story_id,
      created_at: story.created_at,
      updated_at: story.updated_at
    };
    const frontmatter = this.generateFrontmatter(baseFields, void 0, {
      entityType: "story",
      storyName: story.title,
      date: story.created_at
    });
    let content = `${frontmatter}
# ${story.title}

Version: ${story.version_number}
Status: ${story.status}

`;
    const temporaryChapterTitles = ["Story Prose", "Scene-Level Prose", "Beat-Level Prose"];
    const filteredChapters = (chapters == null ? void 0 : chapters.filter(
      (c) => !temporaryChapterTitles.includes(c.chapter.title) && c.chapter.number < 9e3
    )) || [];
    if (filteredChapters.length > 0) {
      content += `## Chapters, Scenes & Beats

`;
      content += `> [!info] How to use this list
`;
      content += `> - **Create new item**: Add a line with \`-\` followed by the text
`;
      content += `>   - **Chapter**: No indentation (level 0)
`;
      content += `>   - **Scene**: Use 1 tab indentation (inside a chapter)
`;
      content += `>   - **Beat**: Use 2 tabs indentation (inside a scene)
`;
      content += `> - **Reorder**: Move items up/down to change order
`;
      content += `> - **Links**: Use \`[[link-name|text]]\` to create links to existing files
`;
      content += `> - **Format**:
`;
      content += `>   - **Chapter**:
`;
      content += `>     - Complete: \`Chapter N: title\`
`;
      content += `>     - Simplified: \`title\`
`;
      content += `>   - **Scene**:
`;
      content += `>     - Complete: \`Scene N: goal - timeRef\`
`;
      content += `>     - Simplified:
`;
      content += `>       - \`goal - timeRef\`
`;
      content += `>       - \`goal\`
`;
      content += `>   - **Beat**:
`;
      content += `>     - Complete: \`Beat N: intent -> outcome\`
`;
      content += `>     - Simplified:
`;
      content += `>       - \`intent -> outcome\`
`;
      content += `>       - \`intent\`
`;
      content += `> - **Markers**: \`-\` indicates no associated prose, \`+\` indicates associated prose

`;
      for (const chapterWithContent of filteredChapters) {
        const chapter = chapterWithContent.chapter;
        const chapterFileName = `Chapter-${chapter.number}.md`;
        const chapterLinkName = chapterFileName.replace(/\.md$/, "");
        const chapterLinkPath = (options == null ? void 0 : options.linkMode) === "full_path" ? this.buildStoryEntityPath(folderPath, "chapter", chapter.number, chapter.title) : chapterLinkName;
        content += `- [[${chapterLinkPath}|Chapter ${chapter.number}: ${chapter.title}]]
`;
        for (const { scene, beats } of chapterWithContent.scenes) {
          const sceneFileName = this.generateSceneFileName(scene);
          const sceneLinkName = sceneFileName.replace(/\.md$/, "");
          const sceneLinkPath = (options == null ? void 0 : options.linkMode) === "full_path" ? this.buildStoryEntityPath(
            folderPath,
            "scene",
            (_a = scene.order_num) != null ? _a : 0,
            scene.goal || "scene",
            { chapterOrder: chapter.number }
          ) : sceneLinkName;
          const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
          content += `	- [[${sceneLinkPath}|Scene ${scene.order_num}: ${sceneDisplayText}]]
`;
          for (const beat of beats) {
            const beatFileName = this.generateBeatFileName(beat);
            const beatLinkName = beatFileName.replace(/\.md$/, "");
            const beatLinkPath = (options == null ? void 0 : options.linkMode) === "full_path" ? this.buildStoryEntityPath(
              folderPath,
              "beat",
              (_b = beat.order_num) != null ? _b : 0,
              beat.intent || "beat",
              { chapterOrder: chapter.number, sceneOrder: (_c = scene.order_num) != null ? _c : 0 }
            ) : beatLinkName;
            const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
            content += `		- [[${beatLinkPath}|Beat ${beat.order_num}: ${beatDisplayText}]]
`;
          }
        }
      }
      content += `
`;
    }
    if (orphanScenes && orphanScenes.length > 0) {
      content += `## Orphan Scenes

`;
      content += `> [!info] Scenes without a chapter
`;
      content += `> These scenes are not associated with any chapter. You can:
`;
      content += `> - **Reorder**: Move items up/down to change order
`;
      content += `> - **Links**: Use \`[[link-name|text]]\` to create links to existing files
`;
      content += `> - **Format**:
`;
      content += `>   - Complete: \`Scene N: goal - timeRef\`
`;
      content += `>   - Simplified:
`;
      content += `>     - \`goal - timeRef\`
`;
      content += `>     - \`goal\`
`;
      content += `> - **Markers**: \`-\` indicates no associated prose, \`+\` indicates associated prose

`;
      for (const { scene, beats } of orphanScenes) {
        const sceneFileName = this.generateSceneFileName(scene);
        const sceneLinkName = sceneFileName.replace(/\.md$/, "");
        const sceneLinkPath = (options == null ? void 0 : options.linkMode) === "full_path" ? this.buildStoryEntityPath(
          folderPath,
          "scene",
          (_d = scene.order_num) != null ? _d : 0,
          scene.goal || "scene",
          { chapterOrder: 0 }
        ) : sceneLinkName;
        const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
        content += `- [[${sceneLinkPath}|Scene ${scene.order_num}: ${sceneDisplayText}]]
`;
        for (const beat of beats) {
          const beatFileName = this.generateBeatFileName(beat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          const beatLinkPath = (options == null ? void 0 : options.linkMode) === "full_path" ? this.buildStoryEntityPath(
            folderPath,
            "beat",
            (_e = beat.order_num) != null ? _e : 0,
            beat.intent || "beat",
            { chapterOrder: 0, sceneOrder: (_f = scene.order_num) != null ? _f : 0 }
          ) : beatLinkName;
          const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
          content += `	- [[${beatLinkPath}|Beat ${beat.order_num}: ${beatDisplayText}]]
`;
        }
      }
      content += `
`;
    }
    if (orphanBeats && orphanBeats.length > 0) {
      content += `## Orphan Beats

`;
      content += `> [!info] Beats without a scene
`;
      content += `> These beats are not associated with any scene. You can:
`;
      content += `> - **Reorder**: Move items up/down to change order
`;
      content += `> - **Links**: Use \`[[link-name|text]]\` to create links to existing files
`;
      content += `> - **Format**:
`;
      content += `>   - Complete: \`Beat N: intent -> outcome\`
`;
      content += `>   - Simplified:
`;
      content += `>     - \`intent -> outcome\`
`;
      content += `>     - \`intent\`
`;
      content += `> - **Markers**: \`-\` indicates no associated prose, \`+\` indicates associated prose

`;
      for (const beat of orphanBeats) {
        const beatFileName = this.generateBeatFileName(beat);
        const beatLinkName = beatFileName.replace(/\.md$/, "");
        const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
        content += `- [[${beatLinkName}|Beat ${beat.order_num}: ${beatDisplayText}]]
`;
      }
      content += `
`;
    }
    content += `# Story: ${story.title}

`;
    if (filteredChapters.length > 0) {
      for (const chapterWithContent of filteredChapters) {
        const chapter = chapterWithContent.chapter;
        const chapterFileName = `Chapter-${chapter.number}.md`;
        const chapterLinkName = chapterFileName.replace(/\.md$/, "");
        content += `## Chapter ${chapter.number}: [[${chapterLinkName}|${chapter.title}]]

`;
        const contentData = chapterContentData == null ? void 0 : chapterContentData.get(chapter.id);
        let organization = null;
        if (contentData) {
          organization = this.organizeContentBlocks(
            contentData.contentBlocks,
            contentData.contentBlockRefs,
            chapterWithContent.scenes
          );
          for (const contentBlock of organization.chapterOnly) {
            const fileName = this.generateContentBlockFileName(contentBlock);
            const linkName = fileName.replace(/\.md$/, "");
            content += `[[${linkName}|${contentBlock.content.substring(0, 50)}...]]

`;
          }
        }
        for (const { scene, beats } of chapterWithContent.scenes) {
          const sceneFileName = this.generateSceneFileName(scene);
          const sceneLinkName = sceneFileName.replace(/\.md$/, "");
          const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
          content += `### Scene: [[${sceneLinkName}|${sceneDisplayText}]]

`;
          if (organization) {
            const sceneContentBlocks = ((_g = organization.byScene.get(scene.id)) == null ? void 0 : _g.contentBlocks) || [];
            for (const contentBlock of sceneContentBlocks) {
              const fileName = this.generateContentBlockFileName(contentBlock);
              const linkName = fileName.replace(/\.md$/, "");
              content += `[[${linkName}|${contentBlock.content.substring(0, 50)}...]]

`;
            }
          }
          for (const beat of beats) {
            const beatFileName = this.generateBeatFileName(beat);
            const beatLinkName = beatFileName.replace(/\.md$/, "");
            const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
            content += `#### Beat: [[${beatLinkName}|${beatDisplayText}]]

`;
            if (organization) {
              const beatContentBlocks = ((_h = organization.byBeat.get(beat.id)) == null ? void 0 : _h.contentBlocks) || [];
              for (const contentBlock of beatContentBlocks) {
                const fileName = this.generateContentBlockFileName(contentBlock);
                const linkName = fileName.replace(/\.md$/, "");
                content += `[[${linkName}|${contentBlock.content.substring(0, 50)}...]]

`;
              }
            }
          }
        }
      }
    }
    if (orphanScenes && orphanScenes.length > 0) {
      for (const { scene, beats } of orphanScenes) {
        const sceneFileName = this.generateSceneFileName(scene);
        const sceneLinkName = sceneFileName.replace(/\.md$/, "");
        const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
        content += `### Scene: [[${sceneLinkName}|${sceneDisplayText}]]

`;
        for (const beat of beats) {
          const beatFileName = this.generateBeatFileName(beat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
          content += `#### Beat: [[${beatLinkName}|${beatDisplayText}]]

`;
        }
      }
    }
    const filePath = `${folderPath}/story.md`;
    const file = this.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian7.TFile) {
      await this.vault.modify(file, content);
    } else {
      await this.vault.create(filePath, content);
    }
  }
  // Write chapter file
  async writeChapterFile(chapterWithContent, filePath, storyName, contentBlocks, contentBlockRefs, orphanScenes, options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
    const { chapter, scenes } = chapterWithContent;
    const baseFields = {
      id: chapter.id,
      story_id: chapter.story_id,
      number: chapter.number,
      title: chapter.title,
      status: chapter.status,
      created_at: chapter.created_at,
      updated_at: chapter.updated_at
    };
    const frontmatter = this.generateFrontmatter(baseFields, void 0, {
      entityType: "chapter",
      storyName,
      date: chapter.created_at
    });
    let content = `${frontmatter}
# ${chapter.title}

`;
    const organization = this.organizeContentBlocks(
      contentBlocks || [],
      contentBlockRefs || [],
      scenes
    );
    content += `## Scenes & Beats

`;
    content += `> [!info] How to use this list
`;
    content += `> - **Create new item**: Add a line with \`-\` followed by the text
`;
    content += `>   - **Scene**: No indentation (level 0)
`;
    content += `>   - **Beat**: Use 1 tab indentation (inside a scene)
`;
    content += `> - **Reorder**: Move items up/down to change order
`;
    content += `> - **Links**: Use \`[[link-name|text]]\` to create links to existing files
`;
    content += `> - **Format**:
`;
    content += `>   - **Scene**:
`;
    content += `>     - Complete: \`Scene N: goal - timeRef\`
`;
    content += `>     - Simplified:
`;
    content += `>       - \`goal - timeRef\`
`;
    content += `>       - \`goal\`
`;
    content += `>   - **Beat**:
`;
    content += `>     - Complete: \`Beat N: intent -> outcome\`
`;
    content += `>     - Simplified:
`;
    content += `>       - \`intent -> outcome\`
`;
    content += `>       - \`intent\`
`;
    content += `> - **Markers**: \`-\` indicates no associated prose, \`+\` indicates associated prose
`;
    content += `> - **Orphan scenes** (without chapter) are shown below for easy association

`;
    const storyFolderPath = (_a = options == null ? void 0 : options.storyFolderPath) != null ? _a : this.resolveStoryFolderPath(filePath, "00-chapters");
    for (const { scene, beats } of scenes) {
      const sceneFileName = this.generateSceneFileName(scene);
      const sceneLinkName = sceneFileName.replace(/\.md$/, "");
      const sceneLinkPath = (options == null ? void 0 : options.linkMode) === "full_path" && storyFolderPath ? this.buildStoryEntityPath(
        storyFolderPath,
        "scene",
        (_b = scene.order_num) != null ? _b : 0,
        scene.goal || "scene",
        { chapterOrder: chapter.number }
      ) : sceneLinkName;
      const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
      const sceneContentBlocks = ((_c = organization.byScene.get(scene.id)) == null ? void 0 : _c.contentBlocks) || [];
      const hasSceneContent = sceneContentBlocks.length > 0;
      const sceneMarker = hasSceneContent ? "+" : "-";
      content += `${sceneMarker} [[${sceneLinkPath}|Scene ${scene.order_num}: ${sceneDisplayText}]]
`;
      for (const beat of beats) {
        const beatFileName = this.generateBeatFileName(beat);
        const beatLinkName = beatFileName.replace(/\.md$/, "");
        const beatLinkPath = (options == null ? void 0 : options.linkMode) === "full_path" && storyFolderPath ? this.buildStoryEntityPath(
          storyFolderPath,
          "beat",
          (_d = beat.order_num) != null ? _d : 0,
          beat.intent || "beat",
          { chapterOrder: chapter.number, sceneOrder: (_e = scene.order_num) != null ? _e : 0 }
        ) : beatLinkName;
        const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
        const beatContentBlocks = ((_f = organization.byBeat.get(beat.id)) == null ? void 0 : _f.contentBlocks) || [];
        const hasBeatContent = beatContentBlocks.length > 0;
        const beatMarker = hasBeatContent ? "+" : "-";
        content += `	${beatMarker} [[${beatLinkPath}|Beat ${beat.order_num}: ${beatDisplayText}]]
`;
      }
    }
    if (orphanScenes && orphanScenes.length > 0) {
      content += `
`;
      content += `> [!info] Orphan Scenes (not yet associated with this chapter)
`;
      content += `> You can associate these scenes with this chapter by moving them here.

`;
      for (const { scene, beats } of orphanScenes) {
        const sceneFileName = this.generateSceneFileName(scene);
        const sceneLinkName = sceneFileName.replace(/\.md$/, "");
        const sceneLinkPath = (options == null ? void 0 : options.linkMode) === "full_path" && storyFolderPath ? this.buildStoryEntityPath(
          storyFolderPath,
          "scene",
          (_g = scene.order_num) != null ? _g : 0,
          scene.goal || "scene",
          { chapterOrder: 0 }
        ) : sceneLinkName;
        const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
        content += `- [[${sceneLinkPath}|Scene ${scene.order_num}: ${sceneDisplayText}]]
`;
        for (const beat of beats) {
          const beatFileName = this.generateBeatFileName(beat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          const beatLinkPath = (options == null ? void 0 : options.linkMode) === "full_path" && storyFolderPath ? this.buildStoryEntityPath(
            storyFolderPath,
            "beat",
            (_h = beat.order_num) != null ? _h : 0,
            beat.intent || "beat",
            { chapterOrder: 0, sceneOrder: (_i = scene.order_num) != null ? _i : 0 }
          ) : beatLinkName;
          const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
          content += `	- [[${beatLinkPath}|Beat ${beat.order_num}: ${beatDisplayText}]]
`;
        }
      }
    }
    content += `
`;
    content += `## Chapter ${chapter.number}: ${chapter.title}

`;
    for (const contentBlock of organization.chapterOnly) {
      const fileName = this.generateContentBlockFileName(contentBlock);
      const linkName = fileName.replace(/\.md$/, "");
      content += `[[${linkName}|${contentBlock.content.substring(0, 50)}...]]

`;
    }
    for (const { scene, beats } of scenes) {
      const sceneFileName = this.generateSceneFileName(scene);
      const sceneLinkName = sceneFileName.replace(/\.md$/, "");
      const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
      content += `## Scene: [[${sceneLinkName}|${sceneDisplayText}]]

`;
      const sceneContentBlocks = ((_j = organization.byScene.get(scene.id)) == null ? void 0 : _j.contentBlocks) || [];
      for (const contentBlock of sceneContentBlocks) {
        const fileName = this.generateContentBlockFileName(contentBlock);
        const linkName = fileName.replace(/\.md$/, "");
        content += `[[${linkName}|${contentBlock.content.substring(0, 50)}...]]

`;
      }
      for (const beat of beats) {
        const beatFileName = this.generateBeatFileName(beat);
        const beatLinkName = beatFileName.replace(/\.md$/, "");
        const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
        content += `### Beat: [[${beatLinkName}|${beatDisplayText}]]

`;
        const beatContentBlocks = ((_k = organization.byBeat.get(beat.id)) == null ? void 0 : _k.contentBlocks) || [];
        for (const contentBlock of beatContentBlocks) {
          const fileName = this.generateContentBlockFileName(contentBlock);
          const linkName = fileName.replace(/\.md$/, "");
          content += `[[${linkName}|${contentBlock.content.substring(0, 50)}...]]

`;
        }
      }
    }
    const file = this.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian7.TFile) {
      await this.vault.modify(file, content);
    } else {
      await this.vault.create(filePath, content);
    }
  }
  // Read story metadata
  async readStoryMetadata(folderPath, idField) {
    const filePath = `${folderPath}/story.md`;
    const file = this.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian7.TFile)) {
      throw new Error(`Story metadata file not found: ${filePath}`);
    }
    const content = await this.vault.read(file);
    const frontmatter = this.parseFrontmatter(content);
    const effectiveIdField = idField || "id";
    const storyId = frontmatter[effectiveIdField] || frontmatter.id || "";
    return {
      frontmatter: {
        id: storyId,
        title: frontmatter.title,
        status: frontmatter.status,
        version: parseInt(frontmatter.version),
        root_story_id: frontmatter.root_story_id,
        previous_version_id: frontmatter.previous_version_id || null,
        created_at: frontmatter.created_at,
        updated_at: frontmatter.updated_at
      },
      content: content.split("---").slice(2).join("---").trim()
    };
  }
  // Parse YAML frontmatter
  parseFrontmatter(content) {
    const match = content.match(/^---\n([\s\S]*?)\n---/);
    if (!match) {
      return {};
    }
    const frontmatterText = match[1];
    const result = {};
    for (const line of frontmatterText.split("\n")) {
      const colonIndex = line.indexOf(":");
      if (colonIndex > 0) {
        const key = line.slice(0, colonIndex).trim();
        const value = line.slice(colonIndex + 1).trim().replace(/^["']|["']$/g, "");
        result[key] = value;
      }
    }
    return result;
  }
  // Copy story folder to versions folder
  async createVersionSnapshot(storyFolderPath, versionNumber) {
    const versionsPath = `${storyFolderPath}/versions`;
    await this.ensureFolderExists(versionsPath);
    const versionFolderPath = `${versionsPath}/v${versionNumber}`;
    const existingVersion = this.vault.getAbstractFileByPath(versionFolderPath);
    if (existingVersion) {
      console.log(`Version v${versionNumber} already exists, skipping snapshot`);
      return;
    }
    await this.ensureFolderExists(versionFolderPath);
    const storyFolder = this.vault.getAbstractFileByPath(storyFolderPath);
    if (!(storyFolder instanceof import_obsidian7.TFolder)) {
      throw new Error(`Story folder not found: ${storyFolderPath}`);
    }
    await this.copyFolderContents(storyFolder, versionFolderPath, "versions");
    console.log(`Created version snapshot: v${versionNumber}`);
  }
  // Recursively copy folder contents
  async copyFolderContents(sourceFolder, destPath, excludeFolderName) {
    for (const child of sourceFolder.children) {
      if (child instanceof import_obsidian7.TFile) {
        const relativePath = child.path.replace(sourceFolder.path + "/", "");
        const destFilePath = `${destPath}/${relativePath}`;
        const content = await this.vault.read(child);
        await this.vault.create(destFilePath, content);
      } else if (child instanceof import_obsidian7.TFolder) {
        if (excludeFolderName && child.name === excludeFolderName) {
          continue;
        }
        const relativePath = child.path.replace(sourceFolder.path + "/", "");
        const destFolderPath = `${destPath}/${relativePath}`;
        await this.ensureFolderExists(destFolderPath);
        await this.copyFolderContents(child, destFolderPath, excludeFolderName);
      }
    }
  }
  // Write scene file
  async writeSceneFile(sceneWithBeats, filePath, storyName, contentBlocks, orphanBeats, options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    const { scene, beats } = sceneWithBeats;
    const storyFolderPath = (_a = options == null ? void 0 : options.storyFolderPath) != null ? _a : this.resolveStoryFolderPath(filePath, "01-scenes");
    const chapterOrder = (_b = options == null ? void 0 : options.chapterOrder) != null ? _b : 0;
    const baseFields = {
      id: scene.id,
      story_id: scene.story_id,
      chapter_id: (_c = scene.chapter_id) != null ? _c : null,
      order_num: scene.order_num,
      time_ref: scene.time_ref || "",
      goal: scene.goal || "",
      created_at: scene.created_at,
      updated_at: scene.updated_at
    };
    const extraFields = {};
    if (scene.pov_character_id) {
      extraFields.pov_character_id = scene.pov_character_id;
    }
    if (scene.location_id) {
      extraFields.location_id = scene.location_id;
    }
    const frontmatter = this.generateFrontmatter(baseFields, extraFields, {
      entityType: "scene",
      storyName,
      date: scene.created_at
    });
    let content = `${frontmatter}
# Scene ${scene.order_num}

`;
    if (scene.goal) {
      content += `**Goal:** ${scene.goal}

`;
    }
    if (scene.time_ref) {
      content += `**Time:** ${scene.time_ref}

`;
    }
    if (beats.length > 0) {
      content += `## Beats

`;
      content += `> [!info] How to use this list
`;
      content += `> - **Create new item**: Add a line with \`-\` followed by the text
`;
      content += `>   - **Beat**: No indentation (level 0)
`;
      content += `> - **Reorder**: Move items up/down to change order
`;
      content += `> - **Links**: Use \`[[link-name|text]]\` to create links to existing files
`;
      content += `> - **Format**:
`;
      content += `>   - **Beat**:
`;
      content += `>     - Complete: \`Beat N: intent -> outcome\`
`;
      content += `>     - Simplified:
`;
      content += `>       - \`intent -> outcome\`
`;
      content += `>       - \`intent\`
`;
      content += `> - **Markers**: \`-\` indicates no associated prose, \`+\` indicates associated prose
`;
      content += `> - **Orphan beats** (without scene) are shown below for easy association

`;
      const beatsWithProse = /* @__PURE__ */ new Set();
      if (contentBlocks) {
        for (const contentBlock of contentBlocks) {
        }
      }
      for (const beat of beats.sort((a, b) => a.order_num - b.order_num)) {
        const beatFileName = this.generateBeatFileName(beat);
        const beatLinkName = beatFileName.replace(/\.md$/, "");
        const beatLinkPath = (options == null ? void 0 : options.linkMode) === "full_path" && storyFolderPath ? this.buildStoryEntityPath(
          storyFolderPath,
          "beat",
          (_d = beat.order_num) != null ? _d : 0,
          beat.intent || "beat",
          { chapterOrder, sceneOrder: (_e = scene.order_num) != null ? _e : 0 }
        ) : beatLinkName;
        const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
        const hasBeatProse = beatsWithProse.has(beat.id);
        const beatMarker = hasBeatProse ? "+" : "-";
        content += `${beatMarker} [[${beatLinkPath}|Beat ${beat.order_num}: ${beatDisplayText}]]
`;
      }
      if (orphanBeats && orphanBeats.length > 0) {
        content += `
`;
        content += `> [!info] Orphan Beats (not yet associated with this scene)
`;
        content += `> You can associate these beats with this scene by moving them here.

`;
        for (const beat of orphanBeats) {
          const beatFileName = this.generateBeatFileName(beat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          const beatLinkPath = (options == null ? void 0 : options.linkMode) === "full_path" && storyFolderPath ? this.buildStoryEntityPath(
            storyFolderPath,
            "beat",
            (_f = beat.order_num) != null ? _f : 0,
            beat.intent || "beat"
          ) : beatLinkName;
          const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
          content += `- [[${beatLinkPath}|Beat ${beat.order_num}: ${beatDisplayText}]]
`;
        }
      }
      content += `
`;
    }
    const sceneFileName = this.generateSceneFileName(scene);
    const sceneLinkName = sceneFileName.replace(/\.md$/, "");
    const sceneLinkPath = (options == null ? void 0 : options.linkMode) === "full_path" && storyFolderPath ? this.buildStoryEntityPath(
      storyFolderPath,
      "scene",
      (_g = scene.order_num) != null ? _g : 0,
      scene.goal || "scene",
      { chapterOrder }
    ) : sceneLinkName;
    const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
    content += `## Scene: [[${sceneLinkPath}|${sceneDisplayText}]]

`;
    if (contentBlocks && contentBlocks.length > 0) {
      const sortedContentBlocks = [...contentBlocks].sort((a, b) => (a.order_num || 0) - (b.order_num || 0));
      for (const contentBlock of sortedContentBlocks) {
        const fileName = this.generateContentBlockFileName(contentBlock);
        const linkName = fileName.replace(/\.md$/, "");
        const linkPath = (options == null ? void 0 : options.linkMode) === "full_path" && storyFolderPath ? this.buildContentBlockPath(storyFolderPath, contentBlock) : linkName;
        content += `[[${linkPath}|${contentBlock.content.substring(0, 50)}...]]

`;
      }
    }
    for (const beat of beats.sort((a, b) => a.order_num - b.order_num)) {
      const beatFileName = this.generateBeatFileName(beat);
      const beatLinkName = beatFileName.replace(/\.md$/, "");
      const beatLinkPath = (options == null ? void 0 : options.linkMode) === "full_path" && storyFolderPath ? this.buildStoryEntityPath(
        storyFolderPath,
        "beat",
        (_h = beat.order_num) != null ? _h : 0,
        beat.intent || "beat",
        { chapterOrder, sceneOrder: (_i = scene.order_num) != null ? _i : 0 }
      ) : beatLinkName;
      const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
      content += `### Beat: [[${beatLinkPath}|${beatDisplayText}]]

`;
    }
    const file = this.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian7.TFile) {
      await this.vault.modify(file, content);
    } else {
      await this.vault.create(filePath, content);
    }
  }
  // Write beat file
  async writeBeatFile(beat, filePath, storyName, contentBlocks, options) {
    var _a, _b, _c, _d;
    const baseFields = {
      id: beat.id,
      scene_id: beat.scene_id,
      order_num: beat.order_num,
      type: beat.type,
      intent: beat.intent || "",
      outcome: beat.outcome || "",
      created_at: beat.created_at,
      updated_at: beat.updated_at
    };
    const frontmatter = this.generateFrontmatter(baseFields, void 0, {
      entityType: "beat",
      storyName,
      date: beat.created_at
    });
    let content = `${frontmatter}
# Beat ${beat.order_num} - ${beat.type}

`;
    if (beat.intent) {
      content += `**Intent:** ${beat.intent}

`;
    }
    if (beat.outcome) {
      content += `**Outcome:** ${beat.outcome}

`;
    }
    const beatFileName = this.generateBeatFileName(beat);
    const beatLinkName = beatFileName.replace(/\.md$/, "");
    const storyFolderPath = (_a = options == null ? void 0 : options.storyFolderPath) != null ? _a : this.resolveStoryFolderPath(filePath, "02-beats");
    const beatLinkPath = (options == null ? void 0 : options.linkMode) === "full_path" && storyFolderPath ? this.buildStoryEntityPath(
      storyFolderPath,
      "beat",
      (_b = beat.order_num) != null ? _b : 0,
      beat.intent || "beat",
      {
        chapterOrder: (_c = options == null ? void 0 : options.chapterOrder) != null ? _c : 0,
        sceneOrder: (_d = options == null ? void 0 : options.sceneOrder) != null ? _d : 0
      }
    ) : beatLinkName;
    const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
    content += `## Beat: [[${beatLinkPath}|${beatDisplayText}]]

`;
    if (contentBlocks && contentBlocks.length > 0) {
      const sortedContentBlocks = [...contentBlocks].sort((a, b) => (a.order_num || 0) - (b.order_num || 0));
      for (const contentBlock of sortedContentBlocks) {
        const fileName = this.generateContentBlockFileName(contentBlock);
        const linkName = fileName.replace(/\.md$/, "");
        const linkPath = (options == null ? void 0 : options.linkMode) === "full_path" && storyFolderPath ? this.buildContentBlockPath(storyFolderPath, contentBlock) : linkName;
        content += `[[${linkPath}|${contentBlock.content.substring(0, 50)}...]]

`;
      }
    }
    const file = this.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian7.TFile) {
      await this.vault.modify(file, content);
    } else {
      await this.vault.create(filePath, content);
    }
  }
  // List all chapter files in a story folder
  async listChapterFiles(storyFolderPath) {
    const chaptersPath = `${storyFolderPath}/00-chapters`;
    const folder = this.vault.getAbstractFileByPath(chaptersPath);
    if (!(folder instanceof import_obsidian7.TFolder)) {
      return [];
    }
    const chapterFiles = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian7.TFile && child.extension === "md") {
        chapterFiles.push(child.path);
      }
    }
    return chapterFiles.sort();
  }
  // List all scene files in a chapter folder
  async listSceneFiles(chapterFolderPath) {
    const scenesPath = `${chapterFolderPath}/01-scenes`;
    const folder = this.vault.getAbstractFileByPath(scenesPath);
    if (!(folder instanceof import_obsidian7.TFolder)) {
      return [];
    }
    const sceneFiles = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian7.TFile && child.extension === "md") {
        sceneFiles.push(child.path);
      }
    }
    return sceneFiles.sort();
  }
  // List all scene files in a story folder
  async listStorySceneFiles(storyFolderPath) {
    const scenesPath = `${storyFolderPath}/01-scenes`;
    const folder = this.vault.getAbstractFileByPath(scenesPath);
    if (!(folder instanceof import_obsidian7.TFolder)) {
      return [];
    }
    const sceneFiles = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian7.TFile && child.extension === "md") {
        sceneFiles.push(child.path);
      }
    }
    return sceneFiles.sort();
  }
  // List all beat files in a story folder
  async listStoryBeatFiles(storyFolderPath) {
    const beatsPath = `${storyFolderPath}/02-beats`;
    const folder = this.vault.getAbstractFileByPath(beatsPath);
    if (!(folder instanceof import_obsidian7.TFolder)) {
      return [];
    }
    const beatFiles = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian7.TFile && child.extension === "md") {
        beatFiles.push(child.path);
      }
    }
    return beatFiles.sort();
  }
  // List all beat files in a scene folder
  async listBeatFiles(sceneFolderPath) {
    const beatsPath = `${sceneFolderPath}/02-beats`;
    const folder = this.vault.getAbstractFileByPath(beatsPath);
    if (!(folder instanceof import_obsidian7.TFolder)) {
      return [];
    }
    const beatFiles = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian7.TFile && child.extension === "md") {
        beatFiles.push(child.path);
      }
    }
    return beatFiles.sort();
  }
  // Get the subfolder name for a content block type
  getContentTypeFolder(type2) {
    const typeFolders = {
      text: "00-texts",
      image: "01-images",
      video: "02-videos",
      audio: "03-audios",
      embed: "04-embeds",
      link: "05-links"
    };
    return typeFolders[type2] || "99-other";
  }
  // Get the full folder path for content blocks of a specific type
  getContentBlockFolderPath(storyFolderPath, type2) {
    const typeFolder = this.getContentTypeFolder(type2);
    return `${storyFolderPath}/03-contents/${typeFolder}`;
  }
  // Generate filename for content block based on date and content preview
  generateContentBlockFileName(contentBlock) {
    const date = new Date(contentBlock.created_at);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    const hours = String(date.getHours()).padStart(2, "0");
    const minutes = String(date.getMinutes()).padStart(2, "0");
    const dateStr = `${year}-${month}-${day}T${hours}-${minutes}`;
    let textPart;
    const type2 = contentBlock.type || "text";
    if (type2 === "text") {
      textPart = contentBlock.content.substring(0, 30).trim().replace(/[<>:"/\\|?*\n\r\t]/g, "-").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "").toLowerCase() || "content";
    } else if (type2 === "image" || type2 === "video" || type2 === "audio") {
      const meta = contentBlock.metadata || {};
      textPart = (meta.alt_text || meta.caption || meta.title || type2).substring(0, 30).trim().replace(/[<>:"/\\|?*\n\r\t]/g, "-").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "").toLowerCase();
    } else if (type2 === "embed") {
      const meta = contentBlock.metadata || {};
      textPart = (meta.provider || meta.title || "embed").substring(0, 30).trim().replace(/[<>:"/\\|?*\n\r\t]/g, "-").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "").toLowerCase();
    } else if (type2 === "link") {
      const meta = contentBlock.metadata || {};
      textPart = (meta.title || meta.site_name || "link").substring(0, 30).trim().replace(/[<>:"/\\|?*\n\r\t]/g, "-").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "").toLowerCase();
    } else {
      textPart = "content";
    }
    return `${dateStr}_${textPart}.md`;
  }
  // Organize content blocks by their associations (chapter, scene, beat)
  organizeContentBlocks(contentBlocks, contentBlockRefs, scenes) {
    const organization = {
      chapterOnly: [],
      byScene: /* @__PURE__ */ new Map(),
      byBeat: /* @__PURE__ */ new Map()
    };
    const contentBlockRefsByContentBlock = /* @__PURE__ */ new Map();
    for (const ref of contentBlockRefs) {
      if (!contentBlockRefsByContentBlock.has(ref.content_block_id)) {
        contentBlockRefsByContentBlock.set(ref.content_block_id, []);
      }
      contentBlockRefsByContentBlock.get(ref.content_block_id).push(ref);
    }
    const sceneMap = /* @__PURE__ */ new Map();
    const beatMap = /* @__PURE__ */ new Map();
    for (const { scene, beats } of scenes) {
      sceneMap.set(scene.id, scene);
      for (const beat of beats) {
        beatMap.set(beat.id, beat);
      }
    }
    const sortedContentBlocks = [...contentBlocks].sort((a, b) => (a.order_num || 0) - (b.order_num || 0));
    for (const contentBlock of sortedContentBlocks) {
      const refs = contentBlockRefsByContentBlock.get(contentBlock.id) || [];
      const sceneRef = refs.find((r) => r.entity_type === "scene");
      const beatRef = refs.find((r) => r.entity_type === "beat");
      if (beatRef && beatMap.has(beatRef.entity_id)) {
        const beat = beatMap.get(beatRef.entity_id);
        if (!organization.byBeat.has(beat.id)) {
          organization.byBeat.set(beat.id, { beat, contentBlocks: [] });
        }
        organization.byBeat.get(beat.id).contentBlocks.push(contentBlock);
      } else if (sceneRef && sceneMap.has(sceneRef.entity_id)) {
        const scene = sceneMap.get(sceneRef.entity_id);
        if (!organization.byScene.has(scene.id)) {
          organization.byScene.set(scene.id, { scene, contentBlocks: [] });
        }
        organization.byScene.get(scene.id).contentBlocks.push(contentBlock);
      } else {
        organization.chapterOnly.push(contentBlock);
      }
    }
    return organization;
  }
  // Generate filename for scene based on date and goal
  generateSceneFileName(scene) {
    const date = new Date(scene.created_at);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    const hours = String(date.getHours()).padStart(2, "0");
    const minutes = String(date.getMinutes()).padStart(2, "0");
    const dateStr = `${year}-${month}-${day}T${hours}-${minutes}`;
    const goalSanitized = (scene.goal || "scene").trim().replace(/[<>:"/\\|?*\n\r\t]/g, "-").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "").toLowerCase();
    return `${dateStr}_${goalSanitized}.md`;
  }
  // Generate filename for beat based on date and intent
  generateBeatFileName(beat) {
    const date = new Date(beat.created_at);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    const hours = String(date.getHours()).padStart(2, "0");
    const minutes = String(date.getMinutes()).padStart(2, "0");
    const dateStr = `${year}-${month}-${day}T${hours}-${minutes}`;
    const intentSanitized = (beat.intent || "beat").trim().replace(/[<>:"/\\|?*\n\r\t]/g, "-").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "").toLowerCase();
    return `${dateStr}_${intentSanitized}.md`;
  }
  resolveStoryFolderPath(filePath, folderName) {
    const marker = `/${folderName}/`;
    const index = filePath.indexOf(marker);
    if (index === -1) {
      return null;
    }
    return filePath.slice(0, index);
  }
  sanitizeSlug(value) {
    return value.normalize("NFKD").replace(/[^\w\s-]/g, "").replace(/\s+/g, " ").trim().replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "").toLowerCase();
  }
  buildStoryEntityPath(storyFolderPath, type2, order, title, overrides) {
    var _a, _b, _c;
    const folder = type2 === "chapter" ? "00-chapters" : type2 === "scene" ? "01-scenes" : "02-beats";
    const prefix = type2 === "chapter" ? "ch" : type2 === "scene" ? "sc" : "bt";
    const slug = this.sanitizeSlug(title || type2);
    const orderTag = String(order).padStart(4, "0");
    if (type2 === "scene") {
      const chapterTag = String((_a = overrides == null ? void 0 : overrides.chapterOrder) != null ? _a : 0).padStart(4, "0");
      return `${storyFolderPath}/${folder}/${prefix}-${chapterTag}-${orderTag}-${slug}.md`;
    }
    if (type2 === "beat") {
      const chapterTag = String((_b = overrides == null ? void 0 : overrides.chapterOrder) != null ? _b : 0).padStart(4, "0");
      const sceneTag = String((_c = overrides == null ? void 0 : overrides.sceneOrder) != null ? _c : 0).padStart(4, "0");
      return `${storyFolderPath}/${folder}/${prefix}-${chapterTag}-${sceneTag}-${orderTag}-${slug}.md`;
    }
    return `${storyFolderPath}/${folder}/${prefix}-${orderTag}-${slug}.md`;
  }
  buildContentBlockPath(storyFolderPath, contentBlock) {
    var _a, _b;
    const type2 = contentBlock.type || "text";
    const folder = this.getContentTypeFolder(type2);
    const orderTag = String((_a = contentBlock.order_num) != null ? _a : 0).padStart(4, "0");
    const titleSource = ((_b = contentBlock.metadata) == null ? void 0 : _b.title) || contentBlock.kind || contentBlock.type || "content";
    const slug = this.sanitizeSlug(titleSource);
    return `${storyFolderPath}/03-contents/${folder}/cb-${orderTag}-${slug}.md`;
  }
  // Write content block file
  async writeContentBlockFile(contentBlock, filePath, storyName) {
    const type2 = contentBlock.type || "text";
    const baseFields = {
      id: contentBlock.id,
      chapter_id: contentBlock.chapter_id || null,
      order_num: contentBlock.order_num || 0,
      type: type2,
      kind: contentBlock.kind,
      created_at: contentBlock.created_at,
      updated_at: contentBlock.updated_at
    };
    const meta = contentBlock.metadata || {};
    if (type2 === "text" && meta.word_count) {
      baseFields.word_count = meta.word_count;
    } else if (type2 === "image") {
      if (contentBlock.content && contentBlock.content.startsWith("http")) {
        baseFields.original_url = contentBlock.content;
      }
      if (meta.alt_text)
        baseFields.alt_text = meta.alt_text;
      if (meta.caption)
        baseFields.caption = meta.caption;
      if (meta.width)
        baseFields.width = meta.width;
      if (meta.height)
        baseFields.height = meta.height;
      if (meta.mime_type)
        baseFields.mime_type = meta.mime_type;
      if (meta.source)
        baseFields.source = meta.source;
      if (meta.author_name)
        baseFields.author_name = meta.author_name;
      if (meta.attribution)
        baseFields.attribution = meta.attribution;
      if (meta.attribution_url)
        baseFields.attribution_url = meta.attribution_url;
    } else if (type2 === "video" || type2 === "audio") {
      if (meta.provider)
        baseFields.provider = meta.provider;
      if (meta.video_id)
        baseFields.video_id = meta.video_id;
      if (meta.duration)
        baseFields.duration = meta.duration;
      if (meta.thumbnail_url)
        baseFields.thumbnail_url = meta.thumbnail_url;
    } else if (type2 === "embed") {
      if (meta.provider)
        baseFields.provider = meta.provider;
      if (meta.html)
        baseFields.embed_html = meta.html;
    } else if (type2 === "link") {
      if (meta.title)
        baseFields.link_title = meta.title;
      if (meta.description)
        baseFields.link_description = meta.description;
      if (meta.image_url)
        baseFields.link_image = meta.image_url;
      if (meta.site_name)
        baseFields.site_name = meta.site_name;
    }
    const frontmatter = this.generateFrontmatter(baseFields, void 0, {
      entityType: "content-block",
      storyName,
      date: contentBlock.created_at
    });
    let fileContent;
    if (type2 === "text") {
      fileContent = `${frontmatter}${contentBlock.content}`;
    } else if (type2 === "image") {
      let localImagePath = contentBlock.content || "";
      if (contentBlock.content && !contentBlock.content.startsWith("http")) {
        localImagePath = contentBlock.content;
      } else if (contentBlock.content) {
        try {
          localImagePath = await this.downloadImage(contentBlock.content, filePath, contentBlock.id);
        } catch (err) {
          console.error("Failed to download image:", err);
          localImagePath = contentBlock.content;
        }
      }
      const altText = meta.alt_text || "";
      fileContent = `${frontmatter}![${altText}](${localImagePath})`;
      if (meta.caption) {
        fileContent += `

*${meta.caption}*`;
      }
    } else if (type2 === "video") {
      fileContent = `${frontmatter}[Video](${contentBlock.content})`;
      if (meta.thumbnail_url) {
        fileContent += `

![Thumbnail](${meta.thumbnail_url})`;
      }
    } else if (type2 === "audio") {
      fileContent = `${frontmatter}[Audio](${contentBlock.content})`;
    } else if (type2 === "embed") {
      fileContent = `${frontmatter}${meta.html || contentBlock.content}`;
    } else if (type2 === "link") {
      const title = meta.title || contentBlock.content;
      fileContent = `${frontmatter}[${title}](${contentBlock.content})`;
      if (meta.description) {
        fileContent += `

${meta.description}`;
      }
    } else {
      fileContent = `${frontmatter}${contentBlock.content}`;
    }
    const file = this.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian7.TFile) {
      await this.vault.modify(file, fileContent);
    } else {
      await this.vault.create(filePath, fileContent);
    }
  }
  // Download image from URL and save locally (same folder as content block .md)
  async downloadImage(imageUrl, contentBlockFilePath, contentBlockId) {
    try {
      const response = await fetch(imageUrl);
      if (!response.ok) {
        throw new Error(`Failed to fetch image: ${response.statusText}`);
      }
      const blob = await response.blob();
      const arrayBuffer = await blob.arrayBuffer();
      let extension = "jpg";
      const contentType = response.headers.get("content-type");
      if (contentType) {
        if (contentType.includes("png"))
          extension = "png";
        else if (contentType.includes("gif"))
          extension = "gif";
        else if (contentType.includes("webp"))
          extension = "webp";
        else if (contentType.includes("svg"))
          extension = "svg";
      } else {
        const urlMatch = imageUrl.match(/\.(jpg|jpeg|png|gif|webp|svg)(\?|$)/i);
        if (urlMatch) {
          extension = urlMatch[1].toLowerCase();
        }
      }
      const contentBlockDir = contentBlockFilePath.substring(0, contentBlockFilePath.lastIndexOf("/"));
      const imageFileName = `${contentBlockId}.${extension}`;
      const imagePath = `${contentBlockDir}/${imageFileName}`;
      const existingFile = this.vault.getAbstractFileByPath(imagePath);
      if (existingFile instanceof import_obsidian7.TFile) {
        await this.vault.modifyBinary(existingFile, arrayBuffer);
      } else {
        await this.vault.createBinary(imagePath, arrayBuffer);
      }
      return imageFileName;
    } catch (err) {
      console.error("Error downloading image:", err);
      throw err;
    }
  }
  // Read content block from file
  async readContentBlockFromFile(filePath) {
    const file = this.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian7.TFile)) {
      return null;
    }
    try {
      const fileContent = await this.vault.read(file);
      const frontmatter = this.parseFrontmatter(fileContent);
      const contentMatch = fileContent.match(/^---\n[\s\S]*?\n---\n([\s\S]*)$/);
      let blockContent = contentMatch ? contentMatch[1].trim() : "";
      if (!frontmatter.id) {
        return null;
      }
      const type2 = frontmatter.type || "text";
      const metadata = {};
      if (type2 === "image") {
        const imgMatch = blockContent.match(/!\[[^\]]*\]\(([^)]+)\)/);
        if (imgMatch) {
          blockContent = imgMatch[1];
          if (!blockContent.startsWith("http") && frontmatter.original_url) {
            blockContent = frontmatter.original_url;
          }
        }
      } else if (type2 === "video" || type2 === "audio" || type2 === "link") {
        const linkMatch = blockContent.match(/\[[^\]]*\]\(([^)]+)\)/);
        if (linkMatch) {
          blockContent = linkMatch[1];
        }
      }
      if (frontmatter.word_count)
        metadata.word_count = parseInt(frontmatter.word_count, 10);
      if (frontmatter.alt_text)
        metadata.alt_text = frontmatter.alt_text;
      if (frontmatter.caption)
        metadata.caption = frontmatter.caption;
      if (frontmatter.width)
        metadata.width = parseInt(frontmatter.width, 10);
      if (frontmatter.height)
        metadata.height = parseInt(frontmatter.height, 10);
      if (frontmatter.mime_type)
        metadata.mime_type = frontmatter.mime_type;
      if (frontmatter.source)
        metadata.source = frontmatter.source;
      if (frontmatter.author_name)
        metadata.author_name = frontmatter.author_name;
      if (frontmatter.attribution)
        metadata.attribution = frontmatter.attribution;
      if (frontmatter.attribution_url)
        metadata.attribution_url = frontmatter.attribution_url;
      if (frontmatter.provider)
        metadata.provider = frontmatter.provider;
      if (frontmatter.video_id)
        metadata.video_id = frontmatter.video_id;
      if (frontmatter.duration)
        metadata.duration = parseInt(frontmatter.duration, 10);
      if (frontmatter.thumbnail_url)
        metadata.thumbnail_url = frontmatter.thumbnail_url;
      if (frontmatter.embed_html)
        metadata.html = frontmatter.embed_html;
      if (frontmatter.link_title)
        metadata.title = frontmatter.link_title;
      if (frontmatter.link_description)
        metadata.description = frontmatter.link_description;
      if (frontmatter.link_image)
        metadata.image_url = frontmatter.link_image;
      if (frontmatter.site_name)
        metadata.site_name = frontmatter.site_name;
      return {
        id: frontmatter.id,
        chapter_id: frontmatter.chapter_id || null,
        order_num: parseInt(frontmatter.order_num || "0", 10),
        type: type2,
        kind: frontmatter.kind || "final",
        content: blockContent,
        metadata,
        created_at: frontmatter.created_at || "",
        updated_at: frontmatter.updated_at || ""
      };
    } catch (err) {
      console.error(`Failed to read content block from ${filePath}:`, err);
      return null;
    }
  }
  // List all content block files in a story folder (across all type subfolders)
  async listContentBlockFiles(storyFolderPath) {
    const contentsPath = `${storyFolderPath}/03-contents`;
    const folder = this.vault.getAbstractFileByPath(contentsPath);
    if (!(folder instanceof import_obsidian7.TFolder)) {
      return [];
    }
    const contentFiles = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian7.TFolder) {
        for (const file of child.children) {
          if (file instanceof import_obsidian7.TFile && file.extension === "md") {
            contentFiles.push(file.path);
          }
        }
      }
    }
    return contentFiles.sort();
  }
};

// src/sync/autoSyncManager.ts
var import_obsidian8 = require("obsidian");
var IDLE_DELAY_MS = 6e4;
var AutoSyncManager = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.idleTimeoutId = null;
    this.activeFile = null;
    this.lastEditTs = 0;
    this.dirtyFiles = /* @__PURE__ */ new Set();
    this.pendingSyncs = /* @__PURE__ */ new Set();
    this.handleActiveLeafChange = (leaf) => {
      const previousFile = this.activeFile;
      const newFile = this.plugin.app.workspace.getActiveFile();
      if (previousFile && (!newFile || previousFile.path !== newFile.path) && this.dirtyFiles.has(previousFile.path)) {
        void this.triggerSyncForFile(previousFile, "blur");
      }
      this.activeFile = newFile;
      this.lastEditTs = Date.now();
      this.resetIdleTimer();
    };
    this.activeFile = this.plugin.app.workspace.getActiveFile();
    this.lastEditTs = Date.now();
    this.registerEvents();
    this.resetIdleTimer();
  }
  dispose() {
    if (this.leafChangeRef) {
      this.plugin.app.workspace.offref(this.leafChangeRef);
      this.leafChangeRef = void 0;
    }
    if (this.editorChangeRef) {
      this.plugin.app.workspace.offref(this.editorChangeRef);
      this.editorChangeRef = void 0;
    }
    if (this.idleTimeoutId !== null) {
      window.clearTimeout(this.idleTimeoutId);
      this.idleTimeoutId = null;
    }
    this.dirtyFiles.clear();
    this.pendingSyncs.clear();
  }
  registerEvents() {
    this.leafChangeRef = this.plugin.app.workspace.on(
      "active-leaf-change",
      this.handleActiveLeafChange
    );
    this.plugin.registerEvent(this.leafChangeRef);
    this.editorChangeRef = this.plugin.app.workspace.on("editor-change", () => {
      const file = this.plugin.app.workspace.getActiveFile();
      if (!file) {
        return;
      }
      this.activeFile = file;
      this.lastEditTs = Date.now();
      this.dirtyFiles.add(file.path);
      this.resetIdleTimer();
    });
    this.plugin.registerEvent(this.editorChangeRef);
  }
  resetIdleTimer() {
    if (this.idleTimeoutId !== null) {
      window.clearTimeout(this.idleTimeoutId);
    }
    if (!this.activeFile) {
      this.idleTimeoutId = null;
      return;
    }
    this.idleTimeoutId = window.setTimeout(() => {
      const file = this.activeFile;
      if (!file) {
        return;
      }
      const idleDuration = Date.now() - this.lastEditTs;
      if (idleDuration >= IDLE_DELAY_MS && this.dirtyFiles.has(file.path)) {
        void this.triggerSyncForFile(file, "idle");
      } else {
        this.resetIdleTimer();
      }
    }, IDLE_DELAY_MS);
  }
  async triggerSyncForFile(file, reason) {
    const path = file.path;
    if (this.pendingSyncs.has(path)) {
      return;
    }
    this.pendingSyncs.add(path);
    try {
      const target = await this.resolveTarget(file);
      if (!target) {
        return;
      }
      if (target.pushWholeStory) {
        await this.plugin.syncService.pushStory(target.folderPath);
      } else if (target.syncTarget) {
        await this.plugin.syncService.pushStory(target.folderPath, target.syncTarget);
      }
      this.dirtyFiles.delete(path);
      if (reason === "idle") {
        this.lastEditTs = Date.now();
        this.resetIdleTimer();
      }
    } catch (err) {
      console.error(`Auto push failed for ${file.path}`, err);
    } finally {
      this.pendingSyncs.delete(path);
    }
  }
  async resolveTarget(file) {
    const folderPath = this.findStoryFolderPath(file);
    if (!folderPath) {
      return null;
    }
    if (file.name === "story.md") {
      return { folderPath, pushWholeStory: true };
    }
    const content = await this.plugin.app.vault.read(file);
    const frontmatter = this.plugin.fileManager.parseFrontmatter(content);
    const entityId = frontmatter == null ? void 0 : frontmatter.id;
    if (!entityId) {
      return null;
    }
    const sceneId = frontmatter.scene_id;
    const chapterId = frontmatter.chapter_id;
    const isContentFile = file.path.includes("/03-contents/");
    const isChapterFile = file.path.includes("/00-chapters/");
    const isSceneFile = file.path.includes("/01-scenes/");
    if (frontmatter.story_id && frontmatter.number && isChapterFile) {
      return {
        folderPath,
        pushWholeStory: false,
        syncTarget: { type: "chapter", id: entityId }
      };
    }
    if (frontmatter.story_id && (isSceneFile || chapterId)) {
      return {
        folderPath,
        pushWholeStory: false,
        syncTarget: { type: "scene", id: entityId }
      };
    }
    if (sceneId) {
      return {
        folderPath,
        pushWholeStory: false,
        syncTarget: { type: "scene", id: sceneId }
      };
    }
    if (isContentFile) {
      return {
        folderPath,
        pushWholeStory: false,
        syncTarget: { type: "content", id: entityId }
      };
    }
    return null;
  }
  findStoryFolderPath(file) {
    let current = file.parent;
    while (current) {
      const storyFilePath = `${current.path}/story.md`;
      const maybeStoryFile = this.plugin.app.vault.getAbstractFileByPath(storyFilePath);
      if (maybeStoryFile instanceof import_obsidian8.TFile) {
        return current.path;
      }
      const parent = current.parent;
      if (parent instanceof import_obsidian8.TFolder) {
        current = parent;
      } else {
        current = null;
      }
    }
    return null;
  }
};

// src/sync-v2/autoSync/AutoSyncManagerV2.ts
var TYPING_PAUSE_DELAY_MS = 1e3;
var IDLE_DELAY_MS2 = 5e3;
var AutoSyncManagerV2 = class {
  constructor(plugin, orchestrator, context) {
    this.plugin = plugin;
    this.orchestrator = orchestrator;
    this.context = context;
    this.typingPauseTimeoutId = null;
    this.idleTimeoutId = null;
    this.activeFile = null;
    this.lastEditTs = 0;
    this.dirtyFiles = /* @__PURE__ */ new Set();
    this.pendingOperations = /* @__PURE__ */ new Map();
    this.operationQueue = [];
    this.isProcessingQueue = false;
    this.lastOnlineCheck = 0;
    this.onlineCheckInFlight = false;
    this.isOnlineCached = true;
    this.handleActiveLeafChange = () => {
      const previousFile = this.activeFile;
      const newFile = this.plugin.app.workspace.getActiveFile();
      if (previousFile && (!newFile || previousFile.path !== newFile.path) && this.dirtyFiles.has(previousFile.path) && this.isStoryEntityFile(previousFile)) {
        void this.triggerSyncForFile(previousFile, "blur");
      }
      this.activeFile = newFile;
      this.lastEditTs = Date.now();
      this.resetTypingPauseTimer(newFile);
      this.resetIdleTimer();
    };
    this.activeFile = this.plugin.app.workspace.getActiveFile();
    this.lastEditTs = Date.now();
    this.registerEvents();
  }
  dispose() {
    if (this.leafChangeRef) {
      this.plugin.app.workspace.offref(this.leafChangeRef);
      this.leafChangeRef = void 0;
    }
    if (this.editorChangeRef) {
      this.plugin.app.workspace.offref(this.editorChangeRef);
      this.editorChangeRef = void 0;
    }
    if (this.typingPauseTimeoutId !== null) {
      const clearFn = typeof window !== "undefined" ? window.clearTimeout : globalThis.clearTimeout;
      clearFn(this.typingPauseTimeoutId);
      this.typingPauseTimeoutId = null;
    }
    if (this.idleTimeoutId !== null) {
      const clearFn = typeof window !== "undefined" ? window.clearTimeout : globalThis.clearTimeout;
      clearFn(this.idleTimeoutId);
      this.idleTimeoutId = null;
    }
    this.dirtyFiles.clear();
    this.pendingOperations.clear();
    this.operationQueue = [];
  }
  registerEvents() {
    this.leafChangeRef = this.plugin.app.workspace.on(
      "active-leaf-change",
      this.handleActiveLeafChange
    );
    this.plugin.registerEvent(this.leafChangeRef);
    this.editorChangeRef = this.plugin.app.workspace.on("editor-change", () => {
      const file = this.plugin.app.workspace.getActiveFile();
      if (!file || !this.isStoryEntityFile(file)) {
        return;
      }
      this.activeFile = file;
      this.lastEditTs = Date.now();
      this.dirtyFiles.add(file.path);
      this.resetTypingPauseTimer(file);
      this.resetIdleTimer();
    });
    this.plugin.registerEvent(this.editorChangeRef);
  }
  resetTypingPauseTimer(file) {
    if (this.typingPauseTimeoutId !== null) {
      const clearFn = typeof window !== "undefined" ? window.clearTimeout : globalThis.clearTimeout;
      clearFn(this.typingPauseTimeoutId);
    }
    if (!file || !this.isStoryEntityFile(file)) {
      this.typingPauseTimeoutId = null;
      return;
    }
    const setTimeoutFn = typeof window !== "undefined" ? window.setTimeout : globalThis.setTimeout;
    this.typingPauseTimeoutId = setTimeoutFn(async () => {
      if (this.dirtyFiles.has(file.path)) {
        await this.triggerSyncForFile(file, "typing_pause");
      }
    }, TYPING_PAUSE_DELAY_MS);
  }
  resetIdleTimer() {
    if (this.idleTimeoutId !== null) {
      const clearFn = typeof window !== "undefined" ? window.clearTimeout : globalThis.clearTimeout;
      clearFn(this.idleTimeoutId);
    }
    if (!this.activeFile || !this.isStoryEntityFile(this.activeFile)) {
      this.idleTimeoutId = null;
      return;
    }
    const setTimeoutFn = typeof window !== "undefined" ? window.setTimeout : globalThis.setTimeout;
    this.idleTimeoutId = setTimeoutFn(async () => {
      const file = this.activeFile;
      if (!file) {
        return;
      }
      const idleDuration = Date.now() - this.lastEditTs;
      if (idleDuration >= IDLE_DELAY_MS2 && this.dirtyFiles.has(file.path)) {
        await this.triggerSyncForFile(file, "idle");
      } else {
        this.resetIdleTimer();
      }
    }, IDLE_DELAY_MS2);
  }
  async triggerSyncForFile(file, reason) {
    const path = file.path;
    if (this.pendingOperations.has(path)) {
      const existing = this.pendingOperations.get(path);
      const priority = { blur: 3, idle: 2, typing_pause: 1 };
      if (priority[reason] > priority[existing.reason]) {
        existing.reason = reason;
        existing.timestamp = Date.now();
      }
      return;
    }
    const operation = await this.resolveOperation(file);
    if (!operation) {
      this.dirtyFiles.delete(path);
      return;
    }
    const pendingOp = {
      filePath: path,
      operation,
      reason,
      timestamp: Date.now()
    };
    this.pendingOperations.set(path, pendingOp);
    this.operationQueue.push(pendingOp);
    this.dirtyFiles.delete(path);
    if (!this.isProcessingQueue) {
      void this.processOperationQueue();
    }
    if (reason === "idle") {
      this.lastEditTs = Date.now();
      this.resetIdleTimer();
    }
  }
  async processOperationQueue() {
    var _a, _b;
    if (this.isProcessingQueue) {
      return;
    }
    if (this.operationQueue.length === 0) {
      return;
    }
    this.isProcessingQueue = true;
    try {
      const queueSnapshot = [...this.operationQueue];
      this.operationQueue = [];
      const batches = this.batchOperationsFromSnapshot(queueSnapshot);
      const processedFiles = /* @__PURE__ */ new Set();
      for (const batch of batches) {
        for (const pendingOp of batch) {
          processedFiles.add(pendingOp.filePath);
          try {
            const result = await this.orchestrator.run(pendingOp.operation);
            this.handleSyncResult(pendingOp, result);
          } catch (err) {
            console.error(`Auto sync failed for ${pendingOp.filePath}`, err);
            (_b = (_a = this.context).emitWarning) == null ? void 0 : _b.call(_a, {
              code: "auto_sync_error",
              message: `Auto sync failed for ${pendingOp.filePath}: ${err instanceof Error ? err.message : String(err)}`,
              filePath: pendingOp.filePath,
              details: err
            });
            if (this.isNetworkError(err)) {
              this.dirtyFiles.add(pendingOp.filePath);
            }
          } finally {
            this.pendingOperations.delete(pendingOp.filePath);
          }
        }
      }
    } catch (err) {
      console.error("Error processing operation queue", err);
    } finally {
      this.isProcessingQueue = false;
      if (this.operationQueue.length > 0) {
        void this.processOperationQueue();
      }
    }
  }
  batchOperationsFromSnapshot(snapshot) {
    const storyBatches = /* @__PURE__ */ new Map();
    const otherOperations = [];
    for (const pendingOp of snapshot) {
      if (pendingOp.operation.type === "push_story") {
        const folderPath = pendingOp.operation.payload.folderPath;
        const existing = storyBatches.get(folderPath);
        if (!existing) {
          storyBatches.set(folderPath, pendingOp);
        } else {
          const priority = { blur: 3, idle: 2, typing_pause: 1 };
          if (priority[pendingOp.reason] > priority[existing.reason] || priority[pendingOp.reason] === priority[existing.reason] && pendingOp.timestamp > existing.timestamp) {
            storyBatches.set(folderPath, pendingOp);
          }
        }
      } else {
        otherOperations.push(pendingOp);
      }
    }
    const batches = [];
    for (const op of storyBatches.values()) {
      batches.push([op]);
    }
    for (const op of otherOperations) {
      batches.push([op]);
    }
    return batches;
  }
  isNetworkError(err) {
    if (err instanceof Error) {
      return err.message.includes("network") || err.message.includes("fetch") || err.message.includes("timeout") || err.message.includes("ECONNREFUSED") || err.message.includes("ENOTFOUND");
    }
    return false;
  }
  handleSyncResult(pendingOp, result) {
    var _a, _b, _c;
    if (!result.success) {
      console.error(`Sync failed for ${pendingOp.filePath}:`, result.errors);
      if ((_a = result.errors) == null ? void 0 : _a.some((e) => e.recoverable)) {
        this.dirtyFiles.add(pendingOp.filePath);
      }
    } else {
      console.log(`Sync succeeded for ${pendingOp.filePath}:`, result.message);
    }
    if (result.warnings) {
      for (const warning of result.warnings) {
        (_c = (_b = this.context).emitWarning) == null ? void 0 : _c.call(_b, warning);
      }
    }
  }
  async resolveOperation(file) {
    const folderPath = this.findStoryFolderPath(file);
    if (!folderPath) {
      return null;
    }
    if (file.name === "story.md" || this.isStoryEntityFile(file)) {
      return {
        type: "push_story",
        payload: {
          folderPath
        }
      };
    }
    return null;
  }
  isStoryEntityFile(file) {
    if (!file) {
      return false;
    }
    const path = file.path;
    return path.includes("/00-chapters/") || path.includes("/01-scenes/") || path.includes("/02-beats/") || path.includes("/03-contents/") || path.includes("/worlds/");
  }
  findStoryFolderPath(file) {
    let current = file.parent;
    while (current) {
      const storyFilePath = `${current.path}/story.md`;
      const maybeStoryFile = this.plugin.app.vault.getAbstractFileByPath(storyFilePath);
      if (maybeStoryFile && "path" in maybeStoryFile && !("children" in maybeStoryFile)) {
        return current.path;
      }
      const worldFilePath = `${current.path}/world.md`;
      const maybeWorldFile = this.plugin.app.vault.getAbstractFileByPath(worldFilePath);
      if (maybeWorldFile && "path" in maybeWorldFile && !("children" in maybeWorldFile)) {
        const worldRoot = current.parent;
        if (worldRoot && "children" in worldRoot) {
          return worldRoot.path;
        }
        return current.path;
      }
      const parent = current.parent;
      if (parent && "children" in parent) {
        current = parent;
      } else {
        current = null;
      }
    }
    return null;
  }
  /**
   * Add operation to queue (for manual triggers or offline mode)
   * This method allows adding operations that will be processed when online
   */
  async enqueueOperation(operation, filePath) {
    const pendingOp = {
      filePath,
      operation,
      reason: "typing_pause",
      timestamp: Date.now()
    };
    const existingIndex = this.operationQueue.findIndex((op) => op.filePath === filePath);
    if (existingIndex !== -1) {
      this.operationQueue[existingIndex] = pendingOp;
    } else {
      this.operationQueue.push(pendingOp);
    }
    this.dirtyFiles.add(filePath);
    if (!this.isProcessingQueue && this.isOnline()) {
      void this.processOperationQueue();
    }
  }
  /**
   * Check if we're online (can make API calls)
   * For now, always return true - can be enhanced with actual network detection
   */
  isOnline() {
    if (typeof navigator !== "undefined" && navigator.onLine === false) {
      this.isOnlineCached = false;
      return false;
    }
    const now2 = Date.now();
    if (now2 - this.lastOnlineCheck > 15e3 && !this.onlineCheckInFlight) {
      void this.refreshOnlineStatus();
    }
    return this.isOnlineCached;
  }
  async refreshOnlineStatus() {
    this.onlineCheckInFlight = true;
    try {
      await this.context.apiClient.listStories();
      this.isOnlineCached = true;
    } catch (e) {
      this.isOnlineCached = false;
    } finally {
      this.lastOnlineCheck = Date.now();
      this.onlineCheckInFlight = false;
    }
  }
  /**
   * Process pending queue (call this when connection is restored)
   */
  async processPendingQueue() {
    if (this.operationQueue.length > 0 && !this.isProcessingQueue) {
      void this.processOperationQueue();
    }
  }
  /**
   * Get pending operations count (for UI/status)
   */
  getPendingOperationsCount() {
    return this.operationQueue.length + this.pendingOperations.size;
  }
  /**
   * Clear pending operations (for reset/cleanup)
   */
  clearPendingOperations() {
    this.operationQueue = [];
    this.pendingOperations.clear();
    this.dirtyFiles.clear();
  }
};

// src/views/StoryListView.ts
var import_obsidian16 = require("obsidian");

// src/views/modals/ChapterModal.ts
var import_obsidian9 = require("obsidian");
var ChapterModal = class extends import_obsidian9.Modal {
  constructor(app, onSubmit, existingChapters = [], chapter) {
    super(app);
    this.chapter = {
      title: "",
      status: "draft"
    };
    this.isEdit = false;
    this.existingChapters = [];
    this.onSubmit = onSubmit;
    this.existingChapters = existingChapters;
    if (chapter) {
      this.isEdit = true;
      this.chapter = {
        number: chapter.number,
        title: chapter.title,
        status: chapter.status
      };
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", {
      text: this.isEdit ? "Edit Chapter" : "Create Chapter"
    });
    if (this.isEdit) {
      new import_obsidian9.Setting(contentEl).setName("Chapter Number").setDesc("The chapter number").addText(
        (text) => {
          var _a;
          return text.setPlaceholder("1").setValue(((_a = this.chapter.number) == null ? void 0 : _a.toString()) || "1").onChange((value) => {
            const num = parseInt(value);
            if (!isNaN(num) && num > 0) {
              this.chapter.number = num;
            }
          });
        }
      );
    }
    new import_obsidian9.Setting(contentEl).setName("Title").setDesc("Chapter title").addText(
      (text) => text.setPlaceholder("Chapter Title").setValue(this.chapter.title || "").onChange((value) => {
        this.chapter.title = value;
      }).inputEl.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          this.submit();
        }
      })
    );
    new import_obsidian9.Setting(contentEl).setName("Status").setDesc("Chapter status").addDropdown(
      (dropdown) => dropdown.addOption("draft", "Draft").addOption("in_progress", "In Progress").addOption("completed", "Completed").setValue(this.chapter.status || "draft").onChange((value) => {
        this.chapter.status = value;
      })
    );
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const submitButton = buttonContainer.createEl("button", {
      text: this.isEdit ? "Update" : "Create",
      cls: "mod-cta"
    });
    submitButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
    const titleInput = contentEl.querySelector("input[placeholder='Chapter Title']");
    if (titleInput) {
      titleInput.focus();
    }
  }
  async submit() {
    var _a;
    if (!((_a = this.chapter.title) == null ? void 0 : _a.trim())) {
      new import_obsidian9.Notice("Please enter a chapter title", 3e3);
      return;
    }
    if (!this.isEdit) {
      const maxNumber = this.existingChapters.length > 0 ? Math.max(...this.existingChapters.map((c) => c.number)) : 0;
      this.chapter.number = maxNumber + 1;
    } else {
      if (!this.chapter.number || this.chapter.number < 1) {
        new import_obsidian9.Notice("Chapter number must be greater than 0", 3e3);
        return;
      }
    }
    try {
      await this.onSubmit(this.chapter);
      this.close();
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to save chapter";
      new import_obsidian9.Notice(`Error: ${errorMessage}`, 5e3);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/modals/SceneModal.ts
var import_obsidian10 = require("obsidian");
var SceneModal = class extends import_obsidian10.Modal {
  constructor(app, storyId, chapters, onSubmit, existingScenes = [], scene, defaultChapterId) {
    super(app);
    this.scene = {
      time_ref: "",
      goal: ""
    };
    this.isEdit = false;
    this.chapters = [];
    this.existingScenes = [];
    this.storyId = storyId;
    this.chapters = chapters;
    this.existingScenes = existingScenes;
    this.defaultChapterId = defaultChapterId;
    this.onSubmit = onSubmit;
    if (scene) {
      this.isEdit = true;
      this.scene = {
        story_id: scene.story_id,
        chapter_id: scene.chapter_id || null,
        order_num: scene.order_num,
        time_ref: scene.time_ref,
        goal: scene.goal,
        pov_character_id: scene.pov_character_id,
        location_id: scene.location_id
      };
    } else {
      this.scene.story_id = storyId;
      if (defaultChapterId !== void 0) {
        this.scene.chapter_id = defaultChapterId;
      }
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", {
      text: this.isEdit ? "Edit Scene" : "Create Scene"
    });
    new import_obsidian10.Setting(contentEl).setName("Chapter").setDesc("Select the chapter for this scene (optional)").addDropdown((dropdown) => {
      dropdown.addOption("", "No Chapter");
      for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
        dropdown.addOption(
          chapter.id,
          `Chapter ${chapter.number}: ${chapter.title}`
        );
      }
      dropdown.setValue(this.scene.chapter_id || "");
      dropdown.onChange((value) => {
        this.scene.chapter_id = value || null;
      });
    });
    if (this.isEdit) {
      new import_obsidian10.Setting(contentEl).setName("Order Number").setDesc("Scene order within chapter").addText(
        (text) => {
          var _a;
          return text.setPlaceholder("1").setValue(((_a = this.scene.order_num) == null ? void 0 : _a.toString()) || "1").onChange((value) => {
            const num = parseInt(value);
            if (!isNaN(num) && num > 0) {
              this.scene.order_num = num;
            }
          });
        }
      );
    }
    new import_obsidian10.Setting(contentEl).setName("Goal").setDesc("Scene goal or description").addTextArea(
      (text) => text.setPlaceholder("What happens in this scene?").setValue(this.scene.goal || "").onChange((value) => {
        this.scene.goal = value;
      })
    );
    new import_obsidian10.Setting(contentEl).setName("Time Reference").setDesc("When does this scene take place?").addText(
      (text) => text.setPlaceholder("Morning, Evening, etc.").setValue(this.scene.time_ref || "").onChange((value) => {
        this.scene.time_ref = value;
      })
    );
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const submitButton = buttonContainer.createEl("button", {
      text: this.isEdit ? "Update" : "Create",
      cls: "mod-cta"
    });
    submitButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
    const goalInput = contentEl.querySelector("textarea");
    if (goalInput) {
      goalInput.focus();
    }
  }
  async submit() {
    if (!this.isEdit) {
      const chapterId = this.scene.chapter_id || null;
      const scenesInChapter = this.existingScenes.filter(
        (s) => (s.chapter_id || null) === chapterId
      );
      const maxOrderNum = scenesInChapter.length > 0 ? Math.max(...scenesInChapter.map((s) => s.order_num)) : 0;
      this.scene.order_num = maxOrderNum + 1;
    } else {
      if (!this.scene.order_num || this.scene.order_num < 1) {
        new import_obsidian10.Notice("Order number must be greater than 0", 3e3);
        return;
      }
    }
    try {
      await this.onSubmit(this.scene);
      this.close();
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to save scene";
      new import_obsidian10.Notice(`Error: ${errorMessage}`, 5e3);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/modals/BeatModal.ts
var import_obsidian11 = require("obsidian");
var BeatModal = class extends import_obsidian11.Modal {
  constructor(app, storyId, scenes, onSubmit, existingBeats = [], beat, chapters = [], defaultSceneId) {
    super(app);
    this.beat = {
      type: "setup",
      intent: "",
      outcome: ""
    };
    this.isEdit = false;
    this.scenes = [];
    this.chapters = [];
    this.existingBeats = [];
    this.storyId = storyId;
    this.scenes = scenes;
    this.chapters = chapters;
    this.existingBeats = existingBeats;
    this.defaultSceneId = defaultSceneId;
    this.onSubmit = onSubmit;
    if (beat) {
      this.isEdit = true;
      this.beat = {
        scene_id: beat.scene_id,
        order_num: beat.order_num,
        type: beat.type,
        intent: beat.intent,
        outcome: beat.outcome
      };
    } else if (defaultSceneId) {
      this.beat.scene_id = defaultSceneId;
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", {
      text: this.isEdit ? "Edit Beat" : "Create Beat"
    });
    new import_obsidian11.Setting(contentEl).setName("Scene").setDesc("Select the scene for this beat").addDropdown((dropdown) => {
      const scenesByChapter = /* @__PURE__ */ new Map();
      for (const scene of this.scenes) {
        const chapterId = scene.chapter_id || null;
        if (!scenesByChapter.has(chapterId)) {
          scenesByChapter.set(chapterId, []);
        }
        scenesByChapter.get(chapterId).push(scene);
      }
      const getChapterLabel = (chapterId) => {
        if (!chapterId)
          return "No Chapter";
        const chapter = this.chapters.find((c) => c.id === chapterId);
        return chapter ? `Chapter ${chapter.number}: ${chapter.title}` : "No Chapter";
      };
      for (const [chapterId, chapterScenes] of scenesByChapter.entries()) {
        const label = getChapterLabel(chapterId);
        for (const scene of chapterScenes.sort((a, b) => a.order_num - b.order_num)) {
          dropdown.addOption(
            scene.id,
            `${label} > Scene ${scene.order_num}: ${scene.goal || "Untitled"}`
          );
        }
      }
      dropdown.setValue(this.beat.scene_id || "");
      dropdown.onChange((value) => {
        this.beat.scene_id = value;
      });
    });
    if (this.isEdit) {
      new import_obsidian11.Setting(contentEl).setName("Order Number").setDesc("Beat order within scene").addText(
        (text) => {
          var _a;
          return text.setPlaceholder("1").setValue(((_a = this.beat.order_num) == null ? void 0 : _a.toString()) || "1").onChange((value) => {
            const num = parseInt(value);
            if (!isNaN(num) && num > 0) {
              this.beat.order_num = num;
            }
          });
        }
      );
    }
    new import_obsidian11.Setting(contentEl).setName("Type").setDesc("Beat type").addDropdown(
      (dropdown) => dropdown.addOption("setup", "Setup").addOption("turn", "Turn").addOption("reveal", "Reveal").addOption("conflict", "Conflict").addOption("climax", "Climax").addOption("resolution", "Resolution").addOption("hook", "Hook").addOption("transition", "Transition").setValue(this.beat.type || "setup").onChange((value) => {
        this.beat.type = value;
      })
    );
    new import_obsidian11.Setting(contentEl).setName("Intent").setDesc("What is the intent of this beat?").addTextArea(
      (text) => text.setPlaceholder("What does the character want?").setValue(this.beat.intent || "").onChange((value) => {
        this.beat.intent = value;
      })
    );
    new import_obsidian11.Setting(contentEl).setName("Outcome").setDesc("What is the outcome of this beat?").addTextArea(
      (text) => text.setPlaceholder("What happens as a result?").setValue(this.beat.outcome || "").onChange((value) => {
        this.beat.outcome = value;
      })
    );
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const submitButton = buttonContainer.createEl("button", {
      text: this.isEdit ? "Update" : "Create",
      cls: "mod-cta"
    });
    submitButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
    const intentInput = contentEl.querySelector("textarea");
    if (intentInput) {
      intentInput.focus();
    }
  }
  async submit() {
    if (!this.beat.scene_id) {
      new import_obsidian11.Notice("Please select a scene", 3e3);
      return;
    }
    if (!this.beat.type) {
      new import_obsidian11.Notice("Please select a beat type", 3e3);
      return;
    }
    if (!this.isEdit) {
      const beatsInScene = this.existingBeats.filter((b) => b.scene_id === this.beat.scene_id);
      const maxOrderNum = beatsInScene.length > 0 ? Math.max(...beatsInScene.map((b) => b.order_num)) : 0;
      this.beat.order_num = maxOrderNum + 1;
    } else {
      if (!this.beat.order_num || this.beat.order_num < 1) {
        new import_obsidian11.Notice("Order number must be greater than 0", 3e3);
        return;
      }
    }
    try {
      await this.onSubmit(this.beat);
      this.close();
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to save beat";
      new import_obsidian11.Notice(`Error: ${errorMessage}`, 5e3);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/modals/ContentBlockModal.ts
var import_obsidian12 = require("obsidian");

// src/api/unsplash.ts
var UnsplashClient = class {
  constructor(accessKey, secretKey) {
    this.apiUrl = "https://api.unsplash.com";
    this.accessKey = accessKey || "YOUR_UNSPLASH_ACCESS_KEY";
    this.secretKey = secretKey || "";
  }
  async searchImages(query, page = 1, perPage = 20) {
    const url = `${this.apiUrl}/search/photos?query=${encodeURIComponent(query)}&page=${page}&per_page=${perPage}`;
    const headers = {
      "Accept-Version": "v1"
    };
    if (!this.accessKey || this.accessKey === "YOUR_UNSPLASH_ACCESS_KEY") {
      throw new Error("Unsplash access key is required. Please configure it in plugin settings.");
    }
    headers["Authorization"] = `Client-ID ${this.accessKey}`;
    const response = await fetch(url, { headers });
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Unsplash API error: ${response.status} ${response.statusText}. ${errorText}`);
    }
    return response.json();
  }
  getImageUrl(photo, size = "regular") {
    return photo.urls[size];
  }
  getAttributionUrl(photo) {
    return photo.links.html;
  }
  getAttributionText(photo) {
    return `Photo by ${photo.user.name} on Unsplash`;
  }
};

// src/views/modals/ContentBlockModal.ts
var ContentBlockModal = class extends import_obsidian12.Modal {
  constructor(app, onSubmit, contentBlock, plugin) {
    var _a, _b, _c, _d;
    super(app);
    this.contentBlock = {
      type: "text",
      kind: "final",
      content: "",
      metadata: {}
    };
    this.isEdit = false;
    this.unsplashResults = [];
    this.unsplashSearchQuery = "";
    this.unsplashSearching = false;
    this.selectedImageUrl = "";
    this.currentImageSourceTab = "internet link";
    this.onSubmit = onSubmit;
    this.plugin = plugin;
    const unsplashAccessKey = ((_b = (_a = this.plugin) == null ? void 0 : _a.settings) == null ? void 0 : _b.unsplashAccessKey) || "";
    const unsplashSecretKey = ((_d = (_c = this.plugin) == null ? void 0 : _c.settings) == null ? void 0 : _d.unsplashSecretKey) || "";
    this.unsplashClient = new UnsplashClient(unsplashAccessKey, unsplashSecretKey);
    if (contentBlock) {
      this.isEdit = true;
      this.contentBlock = {
        type: contentBlock.type,
        kind: contentBlock.kind || "final",
        content: contentBlock.content,
        metadata: contentBlock.metadata || {}
      };
      if (contentBlock.type === "image" && contentBlock.content) {
        this.selectedImageUrl = contentBlock.content;
      }
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", {
      text: this.isEdit ? "Edit Content Block" : "Create Content Block"
    });
    if (this.isEdit && !this.contentBlock.type) {
      new import_obsidian12.Setting(contentEl).setName("Type").setDesc("Select the content type").addDropdown(
        (dropdown) => dropdown.addOption("text", "Text").addOption("image", "Image").setValue(this.contentBlock.type || "text").onChange((value) => {
          this.contentBlock.type = value;
          this.renderContentFields();
        })
      );
    }
    this.renderContentFields();
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const submitButton = buttonContainer.createEl("button", {
      text: this.isEdit ? "Update" : "Create",
      cls: "mod-cta"
    });
    submitButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
  }
  renderContentFields() {
    var _a, _b, _c, _d, _e, _f, _g;
    const { contentEl } = this;
    const existingFields = contentEl.querySelectorAll(".content-block-field");
    existingFields.forEach((el) => el.remove());
    if (this.contentBlock.type === "text") {
      const textField = contentEl.createDiv({ cls: "content-block-field" });
      new import_obsidian12.Setting(textField).setName("Content").setDesc("Enter the text content").addTextArea(
        (text) => text.setPlaceholder("Enter text...").setValue(this.contentBlock.content || "").onChange((value) => {
          this.contentBlock.content = value;
          if (!this.contentBlock.metadata) {
            this.contentBlock.metadata = {};
          }
          this.contentBlock.metadata.word_count = value.trim().split(/\s+/).filter((w) => w.length > 0).length;
        })
      );
    } else if (this.contentBlock.type === "image") {
      const imageField = contentEl.createDiv({ cls: "content-block-field" });
      const sourceValue = ((_a = this.contentBlock.metadata) == null ? void 0 : _a.source) || "internet link";
      this.currentImageSourceTab = sourceValue;
      const tabsContainer = imageField.createDiv({ cls: "content-block-source-tabs" });
      const unsplashTab = tabsContainer.createEl("button", {
        text: "Unsplash",
        cls: `content-block-source-tab ${this.currentImageSourceTab === "unsplash" ? "is-active" : ""}`
      });
      const internetTab = tabsContainer.createEl("button", {
        text: "Internet Link",
        cls: `content-block-source-tab ${this.currentImageSourceTab === "internet link" ? "is-active" : ""}`
      });
      const localTab = tabsContainer.createEl("button", {
        text: "Local Upload",
        cls: `content-block-source-tab ${this.currentImageSourceTab === "local" ? "is-active" : ""}`
      });
      const tabContent = imageField.createDiv({ cls: "content-block-source-tab-content" });
      unsplashTab.onclick = () => {
        this.currentImageSourceTab = "unsplash";
        if (!this.contentBlock.metadata) {
          this.contentBlock.metadata = {};
        }
        this.contentBlock.metadata.source = "unsplash";
        this.renderContentFields();
      };
      internetTab.onclick = () => {
        this.currentImageSourceTab = "internet link";
        if (!this.contentBlock.metadata) {
          this.contentBlock.metadata = {};
        }
        this.contentBlock.metadata.source = "internet link";
        this.renderContentFields();
      };
      localTab.onclick = () => {
        this.currentImageSourceTab = "local";
        if (!this.contentBlock.metadata) {
          this.contentBlock.metadata = {};
        }
        this.contentBlock.metadata.source = "local";
        this.renderContentFields();
      };
      if (this.currentImageSourceTab === "unsplash") {
        const unsplashAccessKey = ((_c = (_b = this.plugin) == null ? void 0 : _b.settings) == null ? void 0 : _c.unsplashAccessKey) || "";
        if (unsplashAccessKey && unsplashAccessKey !== "YOUR_UNSPLASH_ACCESS_KEY") {
          const unsplashSetting = new import_obsidian12.Setting(tabContent);
          unsplashSetting.setName("Search Unsplash");
          unsplashSetting.setDesc("Search for free images");
          unsplashSetting.addButton((button) => {
            button.setButtonText("Search");
            button.onClick(() => {
              this.showUnsplashSearch();
            });
          });
        } else {
          const unsplashSetting = new import_obsidian12.Setting(tabContent);
          unsplashSetting.setName("Search Unsplash");
          unsplashSetting.setDesc("Configure Unsplash Access Key and Secret Key in plugin settings to enable image search");
          unsplashSetting.addButton((button) => {
            button.setButtonText("Search");
            button.setDisabled(true);
          });
        }
        if (this.selectedImageUrl) {
          new import_obsidian12.Setting(tabContent).setName("Selected Image URL").setDesc("Image URL from Unsplash").addText(
            (text) => text.setValue(this.selectedImageUrl).setDisabled(true)
          );
        }
      } else if (this.currentImageSourceTab === "internet link") {
        new import_obsidian12.Setting(tabContent).setName("Image URL").setDesc("Enter image URL").addText(
          (text) => text.setPlaceholder("https://example.com/image.jpg").setValue(this.selectedImageUrl).onChange((value) => {
            this.selectedImageUrl = value;
            this.contentBlock.content = value;
            if (!this.contentBlock.metadata) {
              this.contentBlock.metadata = {};
            }
            this.contentBlock.metadata.source = "internet link";
          })
        );
      } else if (this.currentImageSourceTab === "local") {
        new import_obsidian12.Setting(tabContent).setName("Upload from Computer").setDesc("Upload image from your computer (coming soon)").addButton((button) => {
          button.setButtonText("Choose File");
          button.setDisabled(true);
        });
      }
      const altTextValue = ((_d = this.contentBlock.metadata) == null ? void 0 : _d.alt_text) || "";
      const altTextSetting = new import_obsidian12.Setting(imageField);
      altTextSetting.setName("Alt Text");
      altTextSetting.setDesc("Alt text for accessibility");
      altTextSetting.addText(
        (text) => text.setPlaceholder("Describe the image for accessibility").setValue(altTextValue).onChange((value) => {
          if (!this.contentBlock.metadata) {
            this.contentBlock.metadata = {};
          }
          this.contentBlock.metadata.alt_text = value || void 0;
        })
      );
      const authorNameValue = ((_e = this.contentBlock.metadata) == null ? void 0 : _e.author_name) || "";
      new import_obsidian12.Setting(imageField).setName("Author Name").setDesc("Name of the image author/photographer").addText(
        (text) => text.setPlaceholder("Author name").setValue(authorNameValue).onChange((value) => {
          if (!this.contentBlock.metadata) {
            this.contentBlock.metadata = {};
          }
          this.contentBlock.metadata.author_name = value || void 0;
        })
      );
      const attributionValue = ((_f = this.contentBlock.metadata) == null ? void 0 : _f.attribution) || "";
      new import_obsidian12.Setting(imageField).setName("Attribution").setDesc("Attribution text (e.g., 'Photo by John Doe on Unsplash')").addText(
        (text) => text.setPlaceholder("Photo by Author Name on Source").setValue(attributionValue).onChange((value) => {
          if (!this.contentBlock.metadata) {
            this.contentBlock.metadata = {};
          }
          this.contentBlock.metadata.attribution = value || void 0;
        })
      );
      const attributionUrlValue = ((_g = this.contentBlock.metadata) == null ? void 0 : _g.attribution_url) || "";
      new import_obsidian12.Setting(imageField).setName("Attribution URL").setDesc("Link to the original image or author page").addText(
        (text) => text.setPlaceholder("https://example.com/photo").setValue(attributionUrlValue).onChange((value) => {
          if (!this.contentBlock.metadata) {
            this.contentBlock.metadata = {};
          }
          this.contentBlock.metadata.attribution_url = value || void 0;
        })
      );
    }
  }
  showUnsplashSearch() {
    const { contentEl } = this;
    const searchModal = new import_obsidian12.Modal(this.app);
    searchModal.titleEl.setText("Search Unsplash");
    const searchContent = searchModal.contentEl;
    const searchInput = searchContent.createEl("input", {
      type: "text",
      placeholder: "Search for images...",
      cls: "unsplash-search-input"
    });
    searchInput.value = this.unsplashSearchQuery;
    searchInput.style.width = "100%";
    searchInput.style.padding = "0.5rem";
    searchInput.style.marginBottom = "1rem";
    const searchButton = searchContent.createEl("button", {
      text: "Search",
      cls: "mod-cta"
    });
    searchButton.style.marginBottom = "1rem";
    const resultsContainer = searchContent.createDiv({ cls: "unsplash-results-grid" });
    const performSearch = async () => {
      const query = searchInput.value.trim();
      if (!query) {
        new import_obsidian12.Notice("Please enter a search query", 3e3);
        return;
      }
      this.unsplashSearching = true;
      searchButton.disabled = true;
      searchButton.setText("Searching...");
      resultsContainer.empty();
      resultsContainer.createEl("p", { text: "Searching..." });
      try {
        const response = await this.unsplashClient.searchImages(query, 1, 20);
        this.unsplashResults = response.results;
        resultsContainer.empty();
        if (this.unsplashResults.length === 0) {
          resultsContainer.createEl("p", { text: "No results found." });
        } else {
          for (const photo of this.unsplashResults) {
            const photoItem = resultsContainer.createDiv({ cls: "unsplash-photo-item" });
            const img = photoItem.createEl("img", {
              attr: {
                src: this.unsplashClient.getImageUrl(photo, "thumb"),
                alt: photo.alt_description || photo.description || "Unsplash photo"
              }
            });
            img.style.width = "100%";
            img.style.height = "150px";
            img.style.objectFit = "cover";
            img.style.borderRadius = "4px";
            img.style.cursor = "pointer";
            const photoInfo = photoItem.createDiv({ cls: "unsplash-photo-info" });
            photoInfo.createEl("p", {
              text: photo.alt_description || photo.description || "Untitled",
              cls: "unsplash-photo-title"
            });
            photoInfo.createEl("p", {
              text: this.unsplashClient.getAttributionText(photo),
              cls: "unsplash-photo-attribution"
            });
            photoItem.onclick = () => {
              const imageUrl = this.unsplashClient.getImageUrl(photo, "regular");
              this.selectedImageUrl = imageUrl;
              this.contentBlock.content = imageUrl;
              if (!this.contentBlock.metadata) {
                this.contentBlock.metadata = {};
              }
              const altText = photo.alt_description || photo.description || "";
              this.contentBlock.metadata.alt_text = altText;
              this.contentBlock.metadata.attribution = this.unsplashClient.getAttributionText(photo);
              this.contentBlock.metadata.attribution_url = this.unsplashClient.getAttributionUrl(photo);
              this.contentBlock.metadata.author_name = photo.user.name;
              this.contentBlock.metadata.source = "unsplash";
              searchModal.close();
              this.renderContentFields();
              new import_obsidian12.Notice("Image selected");
            };
          }
        }
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to search Unsplash";
        new import_obsidian12.Notice(`Error: ${errorMessage}`, 5e3);
        resultsContainer.empty();
        resultsContainer.createEl("p", {
          text: `Error: ${errorMessage}`,
          cls: "story-engine-error"
        });
      } finally {
        this.unsplashSearching = false;
        searchButton.disabled = false;
        searchButton.setText("Search");
      }
    };
    searchButton.onclick = performSearch;
    searchInput.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        performSearch();
      }
    });
    if (this.unsplashSearchQuery) {
      performSearch();
    }
    searchModal.open();
  }
  async submit() {
    var _a, _b;
    if (!this.contentBlock.type) {
      this.contentBlock.type = "text";
    }
    if (this.contentBlock.type === "text" && !((_a = this.contentBlock.content) == null ? void 0 : _a.trim())) {
      new import_obsidian12.Notice("Please enter text content", 3e3);
      return;
    }
    if (this.contentBlock.type === "image" && !((_b = this.contentBlock.content) == null ? void 0 : _b.trim())) {
      new import_obsidian12.Notice("Please enter an image URL or select an image", 3e3);
      return;
    }
    try {
      await this.onSubmit(this.contentBlock);
      this.close();
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to save content block";
      new import_obsidian12.Notice(`Error: ${errorMessage}`, 5e3);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/TimelineModal.ts
var import_obsidian13 = require("obsidian");

// node_modules/d3-array/src/ascending.js
function ascending(a, b) {
  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

// node_modules/d3-array/src/descending.js
function descending(a, b) {
  return a == null || b == null ? NaN : b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

// node_modules/d3-array/src/bisector.js
function bisector(f) {
  let compare1, compare2, delta;
  if (f.length !== 2) {
    compare1 = ascending;
    compare2 = (d, x) => ascending(f(d), x);
    delta = (d, x) => f(d) - x;
  } else {
    compare1 = f === ascending || f === descending ? f : zero;
    compare2 = f;
    delta = f;
  }
  function left2(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a[mid], x) < 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right2(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a[mid], x) <= 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center2(a, x, lo = 0, hi = a.length) {
    const i = left2(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }
  return { left: left2, center: center2, right: right2 };
}
function zero() {
  return 0;
}

// node_modules/d3-array/src/number.js
function number(x) {
  return x === null ? NaN : +x;
}

// node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector(number).center;
var bisect_default = bisectRight;

// node_modules/d3-array/src/extent.js
function extent(values, valueof) {
  let min2;
  let max2;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null) {
        if (min2 === void 0) {
          if (value >= value)
            min2 = max2 = value;
        } else {
          if (min2 > value)
            min2 = value;
          if (max2 < value)
            max2 = value;
        }
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null) {
        if (min2 === void 0) {
          if (value >= value)
            min2 = max2 = value;
        } else {
          if (min2 > value)
            min2 = value;
          if (max2 < value)
            max2 = value;
        }
      }
    }
  }
  return [min2, max2];
}

// node_modules/internmap/src/index.js
var InternMap = class extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (entries != null)
      for (const [key2, value] of entries)
        this.set(key2, value);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value) {
    return super.set(intern_set(this, key), value);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
};
function intern_get({ _intern, _key }, value) {
  const key = _key(value);
  return _intern.has(key) ? _intern.get(key) : value;
}
function intern_set({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key))
    return _intern.get(key);
  _intern.set(key, value);
  return value;
}
function intern_delete({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key)) {
    value = _intern.get(key);
    _intern.delete(key);
  }
  return value;
}
function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}

// node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
function tickSpec(start2, stop, count) {
  const step = (stop - start2) / Math.max(0, count), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start2 * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start2)
      ++i1;
    if (i2 / inc > stop)
      --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start2 / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start2)
      ++i1;
    if (i2 * inc > stop)
      --i2;
  }
  if (i2 < i1 && 0.5 <= count && count < 2)
    return tickSpec(start2, stop, count * 2);
  return [i1, i2, inc];
}
function ticks(start2, stop, count) {
  stop = +stop, start2 = +start2, count = +count;
  if (!(count > 0))
    return [];
  if (start2 === stop)
    return [start2];
  const reverse = stop < start2, [i1, i2, inc] = reverse ? tickSpec(stop, start2, count) : tickSpec(start2, stop, count);
  if (!(i2 >= i1))
    return [];
  const n = i2 - i1 + 1, ticks2 = new Array(n);
  if (reverse) {
    if (inc < 0)
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i2 - i) / -inc;
    else
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i2 - i) * inc;
  } else {
    if (inc < 0)
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i1 + i) / -inc;
    else
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i1 + i) * inc;
  }
  return ticks2;
}
function tickIncrement(start2, stop, count) {
  stop = +stop, start2 = +start2, count = +count;
  return tickSpec(start2, stop, count)[2];
}
function tickStep(start2, stop, count) {
  stop = +stop, start2 = +start2, count = +count;
  const reverse = stop < start2, inc = reverse ? tickIncrement(stop, start2, count) : tickIncrement(start2, stop, count);
  return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}

// node_modules/d3-axis/src/identity.js
function identity_default(x) {
  return x;
}

// node_modules/d3-axis/src/axis.js
var top = 1;
var right = 2;
var bottom = 3;
var left = 4;
var epsilon = 1e-6;
function translateX(x) {
  return "translate(" + x + ",0)";
}
function translateY(y) {
  return "translate(0," + y + ")";
}
function number2(scale) {
  return (d) => +scale(d);
}
function center(scale, offset) {
  offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;
  if (scale.round())
    offset = Math.round(offset);
  return (d) => +scale(d) + offset;
}
function entering() {
  return !this.__axis;
}
function axis(orient, scale) {
  var tickArguments = [], tickValues = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5, k = orient === top || orient === left ? -1 : 1, x = orient === left || orient === right ? "x" : "y", transform2 = orient === top || orient === bottom ? translateX : translateY;
  function axis2(context) {
    var values = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues, format2 = tickFormat2 == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity_default : tickFormat2, spacing = Math.max(tickSizeInner, 0) + tickPadding, range = scale.range(), range0 = +range[0] + offset, range1 = +range[range.length - 1] + offset, position = (scale.bandwidth ? center : number2)(scale.copy(), offset), selection2 = context.selection ? context.selection() : context, path = selection2.selectAll(".domain").data([null]), tick = selection2.selectAll(".tick").data(values, scale).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line = tick.select("line"), text = tick.select("text");
    path = path.merge(path.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
    tick = tick.merge(tickEnter);
    line = line.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x + "2", k * tickSizeInner));
    text = text.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x, k * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
    if (context !== selection2) {
      path = path.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text = text.transition(context);
      tickExit = tickExit.transition(context).attr("opacity", epsilon).attr("transform", function(d) {
        return isFinite(d = position(d)) ? transform2(d + offset) : this.getAttribute("transform");
      });
      tickEnter.attr("opacity", epsilon).attr("transform", function(d) {
        var p = this.parentNode.__axis;
        return transform2((p && isFinite(p = p(d)) ? p : position(d)) + offset);
      });
    }
    tickExit.remove();
    path.attr("d", orient === left || orient === right ? tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1);
    tick.attr("opacity", 1).attr("transform", function(d) {
      return transform2(position(d) + offset);
    });
    line.attr(x + "2", k * tickSizeInner);
    text.attr(x, k * spacing).text(format2);
    selection2.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
    selection2.each(function() {
      this.__axis = position;
    });
  }
  axis2.scale = function(_) {
    return arguments.length ? (scale = _, axis2) : scale;
  };
  axis2.ticks = function() {
    return tickArguments = Array.from(arguments), axis2;
  };
  axis2.tickArguments = function(_) {
    return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis2) : tickArguments.slice();
  };
  axis2.tickValues = function(_) {
    return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis2) : tickValues && tickValues.slice();
  };
  axis2.tickFormat = function(_) {
    return arguments.length ? (tickFormat2 = _, axis2) : tickFormat2;
  };
  axis2.tickSize = function(_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis2) : tickSizeInner;
  };
  axis2.tickSizeInner = function(_) {
    return arguments.length ? (tickSizeInner = +_, axis2) : tickSizeInner;
  };
  axis2.tickSizeOuter = function(_) {
    return arguments.length ? (tickSizeOuter = +_, axis2) : tickSizeOuter;
  };
  axis2.tickPadding = function(_) {
    return arguments.length ? (tickPadding = +_, axis2) : tickPadding;
  };
  axis2.offset = function(_) {
    return arguments.length ? (offset = +_, axis2) : offset;
  };
  return axis2;
}
function axisBottom(scale) {
  return axis(bottom, scale);
}
function axisLeft(scale) {
  return axis(left, scale);
}

// node_modules/d3-dispatch/src/dispatch.js
var noop = { value: () => {
} };
function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t))
      throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0)
      name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t))
      throw new Error("unknown type: " + t);
    return { type: t, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._, T = parseTypenames(typename + "", _), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n)
        if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name)))
          return t;
      return;
    }
    if (callback != null && typeof callback !== "function")
      throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type)
        _[t] = set(_[t], typename.name, callback);
      else if (callback == null)
        for (t in _)
          _[t] = set(_[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy2 = {}, _ = this._;
    for (var t in _)
      copy2[t] = _[t].slice();
    return new Dispatch(copy2);
  },
  call: function(type2, that) {
    if ((n = arguments.length - 2) > 0)
      for (var args = new Array(n), i = 0, n, t; i < n; ++i)
        args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (t = this._[type2], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  },
  apply: function(type2, that, args) {
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (var t = this._[type2], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  }
};
function get(type2, name) {
  for (var i = 0, n = type2.length, c; i < n; ++i) {
    if ((c = type2[i]).name === name) {
      return c.value;
    }
  }
}
function set(type2, name, callback) {
  for (var i = 0, n = type2.length; i < n; ++i) {
    if (type2[i].name === name) {
      type2[i] = noop, type2 = type2.slice(0, i).concat(type2.slice(i + 1));
      break;
    }
  }
  if (callback != null)
    type2.push({ name, value: callback });
  return type2;
}
var dispatch_default = dispatch;

// node_modules/d3-selection/src/namespaces.js
var xhtml = "http://www.w3.org/1999/xhtml";
var namespaces_default = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

// node_modules/d3-selection/src/namespace.js
function namespace_default(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns")
    name = name.slice(i + 1);
  return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name } : name;
}

// node_modules/d3-selection/src/creator.js
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator_default(name) {
  var fullname = namespace_default(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}

// node_modules/d3-selection/src/selector.js
function none() {
}
function selector_default(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

// node_modules/d3-selection/src/selection/select.js
function select_default(select) {
  if (typeof select !== "function")
    select = selector_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/array.js
function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}

// node_modules/d3-selection/src/selectorAll.js
function empty() {
  return [];
}
function selectorAll_default(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}

// node_modules/d3-selection/src/selection/selectAll.js
function arrayAll(select) {
  return function() {
    return array(select.apply(this, arguments));
  };
}
function selectAll_default(select) {
  if (typeof select === "function")
    select = arrayAll(select);
  else
    select = selectorAll_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }
  return new Selection(subgroups, parents);
}

// node_modules/d3-selection/src/matcher.js
function matcher_default(selector) {
  return function() {
    return this.matches(selector);
  };
}
function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}

// node_modules/d3-selection/src/selection/selectChild.js
var find = Array.prototype.find;
function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selectChild_default(match) {
  return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/d3-selection/src/selection/selectChildren.js
var filter = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}
function selectChildren_default(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/d3-selection/src/selection/filter.js
function filter_default(match) {
  if (typeof match !== "function")
    match = matcher_default(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/selection/sparse.js
function sparse_default(update) {
  return new Array(update.length);
}

// node_modules/d3-selection/src/selection/enter.js
function enter_default() {
  return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector) {
    return this._parent.querySelector(selector);
  },
  querySelectorAll: function(selector) {
    return this._parent.querySelectorAll(selector);
  }
};

// node_modules/d3-selection/src/constant.js
function constant_default(x) {
  return function() {
    return x;
  };
}

// node_modules/d3-selection/src/selection/data.js
function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0, node, groupLength = group.length, dataLength = data.length;
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}
function bindKey(parent, group, enter, update, exit, data, key) {
  var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
      exit[i] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function data_default(value, key) {
  if (!arguments.length)
    return Array.from(this, datum);
  var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
  if (typeof value !== "function")
    value = constant_default(value);
  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j], group = groups[j], groupLength = group.length, data = arraylike(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1)
          i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength)
          ;
        previous._next = next || null;
      }
    }
  }
  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}

// node_modules/d3-selection/src/selection/exit.js
function exit_default() {
  return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
}

// node_modules/d3-selection/src/selection/join.js
function join_default(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter)
      enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update)
      update = update.selection();
  }
  if (onexit == null)
    exit.remove();
  else
    onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}

// node_modules/d3-selection/src/selection/merge.js
function merge_default(context) {
  var selection2 = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection(merges, this._parents);
}

// node_modules/d3-selection/src/selection/order.js
function order_default() {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4)
          next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/sort.js
function sort_default(compare) {
  if (!compare)
    compare = ascending2;
  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }
  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection(sortgroups, this._parents).order();
}
function ascending2(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

// node_modules/d3-selection/src/selection/call.js
function call_default() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

// node_modules/d3-selection/src/selection/nodes.js
function nodes_default() {
  return Array.from(this);
}

// node_modules/d3-selection/src/selection/node.js
function node_default() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node)
        return node;
    }
  }
  return null;
}

// node_modules/d3-selection/src/selection/size.js
function size_default() {
  let size = 0;
  for (const node of this)
    ++size;
  return size;
}

// node_modules/d3-selection/src/selection/empty.js
function empty_default() {
  return !this.node();
}

// node_modules/d3-selection/src/selection/each.js
function each_default(callback) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i])
        callback.call(node, node.__data__, i, group);
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/attr.js
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.removeAttribute(name);
    else
      this.setAttribute(name, v);
  };
}
function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.removeAttributeNS(fullname.space, fullname.local);
    else
      this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
function attr_default(name, value) {
  var fullname = namespace_default(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
}

// node_modules/d3-selection/src/window.js
function window_default(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}

// node_modules/d3-selection/src/selection/style.js
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.style.removeProperty(name);
    else
      this.style.setProperty(name, v, priority);
  };
}
function style_default(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || window_default(node).getComputedStyle(node, null).getPropertyValue(name);
}

// node_modules/d3-selection/src/selection/property.js
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      delete this[name];
    else
      this[name] = v;
  };
}
function property_default(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}

// node_modules/d3-selection/src/selection/classed.js
function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n)
    list.add(names[i]);
}
function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n)
    list.remove(names[i]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function classed_default(name, value) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n)
      if (!list.contains(names[i]))
        return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}

// node_modules/d3-selection/src/selection/text.js
function textRemove() {
  this.textContent = "";
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}
function text_default(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
}

// node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}
function html_default(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}

// node_modules/d3-selection/src/selection/raise.js
function raise() {
  if (this.nextSibling)
    this.parentNode.appendChild(this);
}
function raise_default() {
  return this.each(raise);
}

// node_modules/d3-selection/src/selection/lower.js
function lower() {
  if (this.previousSibling)
    this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function lower_default() {
  return this.each(lower);
}

// node_modules/d3-selection/src/selection/append.js
function append_default(name) {
  var create2 = typeof name === "function" ? name : creator_default(name);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}

// node_modules/d3-selection/src/selection/insert.js
function constantNull() {
  return null;
}
function insert_default(name, before) {
  var create2 = typeof name === "function" ? name : creator_default(name), select = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

// node_modules/d3-selection/src/selection/remove.js
function remove() {
  var parent = this.parentNode;
  if (parent)
    parent.removeChild(this);
}
function remove_default() {
  return this.each(remove);
}

// node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function clone_default(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

// node_modules/d3-selection/src/selection/datum.js
function datum_default(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}

// node_modules/d3-selection/src/selection/on.js
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames2(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0)
      name = t.slice(i + 1), t = t.slice(0, i);
    return { type: t, name };
  });
}
function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on)
      return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i)
      on.length = i;
    else
      delete this.__on;
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on)
      for (var j = 0, m = on.length; j < m; ++j) {
        if ((o = on[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
          this.addEventListener(o.type, o.listener = listener, o.options = options);
          o.value = value;
          return;
        }
      }
    this.addEventListener(typename.type, listener, options);
    o = { type: typename.type, name: typename.name, value, listener, options };
    if (!on)
      this.__on = [o];
    else
      on.push(o);
  };
}
function on_default(typename, value, options) {
  var typenames = parseTypenames2(typename + ""), i, n = typenames.length, t;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on)
      for (var j = 0, m = on.length, o; j < m; ++j) {
        for (i = 0, o = on[j]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
    return;
  }
  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i)
    this.each(on(typenames[i], value, options));
  return this;
}

// node_modules/d3-selection/src/selection/dispatch.js
function dispatchEvent(node, type2, params) {
  var window2 = window_default(node), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type2, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params)
      event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;
    else
      event.initEvent(type2, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params);
  };
}
function dispatchFunction(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params.apply(this, arguments));
  };
}
function dispatch_default2(type2, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
}

// node_modules/d3-selection/src/selection/iterator.js
function* iterator_default() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i])
        yield node;
    }
  }
}

// node_modules/d3-selection/src/selection/index.js
var root = [null];
function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection() {
  return new Selection([[document.documentElement]], root);
}
function selection_selection() {
  return this;
}
Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: select_default,
  selectAll: selectAll_default,
  selectChild: selectChild_default,
  selectChildren: selectChildren_default,
  filter: filter_default,
  data: data_default,
  enter: enter_default,
  exit: exit_default,
  join: join_default,
  merge: merge_default,
  selection: selection_selection,
  order: order_default,
  sort: sort_default,
  call: call_default,
  nodes: nodes_default,
  node: node_default,
  size: size_default,
  empty: empty_default,
  each: each_default,
  attr: attr_default,
  style: style_default,
  property: property_default,
  classed: classed_default,
  text: text_default,
  html: html_default,
  raise: raise_default,
  lower: lower_default,
  append: append_default,
  insert: insert_default,
  remove: remove_default,
  clone: clone_default,
  datum: datum_default,
  on: on_default,
  dispatch: dispatch_default2,
  [Symbol.iterator]: iterator_default
};
var selection_default = selection;

// node_modules/d3-selection/src/select.js
function select_default2(selector) {
  return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
}

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m, l;
  format2 = (format2 + "").trim().toLowerCase();
  return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0)
    r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s, l, a) {
  if (a <= 0)
    h = s = l = NaN;
  else if (l <= 0 || l >= 1)
    h = s = NaN;
  else if (s <= 0)
    h = NaN;
  return new Hsl(h, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min2 = Math.min(r, g, b), max2 = Math.max(r, g, b), h = NaN, s = max2 - min2, l = (max2 + min2) / 2;
  if (s) {
    if (r === max2)
      h = (g - b) / s + (g < b) * 6;
    else if (g === max2)
      h = (b - r) / s + 2;
    else
      h = (r - g) / s + 4;
    s /= l < 0.5 ? max2 + min2 : 2 - max2 - min2;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

// node_modules/d3-interpolate/src/basis.js
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}
function basis_default(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default2 = (x) => () => x;

// node_modules/d3-interpolate/src/color.js
function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}
function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}
function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant_default2(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant_default2(isNaN(a) ? b : a);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y) {
  var color2 = gamma(y);
  function rgb2(start2, end) {
    var r = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
    return function(t) {
      start2.r = r(t);
      start2.g = g(t);
      start2.b = b(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
    for (i = 0; i < n; ++i) {
      color2 = rgb(colors[i]);
      r[i] = color2.r || 0;
      g[i] = color2.g || 0;
      b[i] = color2.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color2.opacity = 1;
    return function(t) {
      color2.r = r(t);
      color2.g = g(t);
      color2.b = b(t);
      return color2 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a, b) {
  if (!b)
    b = [];
  var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i)
      c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}
function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}

// node_modules/d3-interpolate/src/array.js
function genericArray(a, b) {
  var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
  for (i = 0; i < na; ++i)
    x[i] = value_default(a[i], b[i]);
  for (; i < nb; ++i)
    c[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i)
      c[i] = x[i](t);
    return c;
  };
}

// node_modules/d3-interpolate/src/date.js
function date_default(a, b) {
  var d = /* @__PURE__ */ new Date();
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}

// node_modules/d3-interpolate/src/number.js
function number_default(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}

// node_modules/d3-interpolate/src/object.js
function object_default(a, b) {
  var i = {}, c = {}, k;
  if (a === null || typeof a !== "object")
    a = {};
  if (b === null || typeof b !== "object")
    b = {};
  for (k in b) {
    if (k in a) {
      i[k] = value_default(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }
  return function(t) {
    for (k in i)
      c[k] = i[k](t);
    return c;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero2(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function string_default(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a = a + "", b = b + "";
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s[i])
        s[i] += bs;
      else
        s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i])
        s[i] += bm;
      else
        s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({ i, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i])
      s[i] += bs;
    else
      s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one(q[0].x) : zero2(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2)
      s[(o = q[i2]).i] = o.x(t);
    return s.join("");
  });
}

// node_modules/d3-interpolate/src/value.js
function value_default(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant_default2(b) : (t === "number" ? number_default : t === "string" ? (c = color(b)) ? (b = c, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a, b);
}

// node_modules/d3-interpolate/src/round.js
function round_default(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
}

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees = 180 / Math.PI;
var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b))
    a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d)
    c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d))
    c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c)
    a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? identity : decompose_default(m.a, m.b, m.c, m.d, m.e, m.f);
}
function parseSvg(value) {
  if (value == null)
    return identity;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate()))
    return identity;
  value = value.matrix;
  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180)
        b += 360;
      else if (b - a > 180)
        a += 360;
      q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number_default(a, b) });
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }
  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number_default(a, b) });
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a, b) {
    var s = [], q = [];
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n)
        s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t = new Timer();
  t.restart(callback, delay, time);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0)
      t._call.call(void 0, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time)
        time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}
function sleep(time) {
  if (frame)
    return;
  if (timeout)
    timeout = clearTimeout(timeout);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity)
      timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/d3-timer/src/timeout.js
function timeout_default(callback, delay, time) {
  var t = new Timer();
  delay = delay == null ? 0 : +delay;
  t.restart((elapsed) => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}

// node_modules/d3-transition/src/transition/schedule.js
var emptyOn = dispatch_default("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule_default(node, name, id2, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules)
    node.__transition = {};
  else if (id2 in schedules)
    return;
  create(node, id2, {
    name,
    index,
    // For context during callback.
    group,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init(node, id2) {
  var schedule = get2(node, id2);
  if (schedule.state > CREATED)
    throw new Error("too late; already scheduled");
  return schedule;
}
function set2(node, id2) {
  var schedule = get2(node, id2);
  if (schedule.state > STARTED)
    throw new Error("too late; already running");
  return schedule;
}
function get2(node, id2) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id2]))
    throw new Error("transition not found");
  return schedule;
}
function create(node, id2, self) {
  var schedules = node.__transition, tween;
  schedules[id2] = self;
  self.timer = timer(schedule, 0, self.time);
  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start2, self.delay, self.time);
    if (self.delay <= elapsed)
      start2(elapsed - self.delay);
  }
  function start2(elapsed) {
    var i, j, n, o;
    if (self.state !== SCHEDULED)
      return stop();
    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name)
        continue;
      if (o.state === STARTED)
        return timeout_default(start2);
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      } else if (+i < id2) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }
    timeout_default(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING)
      return;
    self.state = STARTED;
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }
  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1), i = -1, n = tween.length;
    while (++i < n) {
      tween[i].call(node, t);
    }
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }
  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id2];
    for (var i in schedules)
      return;
    delete node.__transition;
  }
}

// node_modules/d3-transition/src/interrupt.js
function interrupt_default(node, name) {
  var schedules = node.__transition, schedule, active, empty2 = true, i;
  if (!schedules)
    return;
  name = name == null ? null : name + "";
  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) {
      empty2 = false;
      continue;
    }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }
  if (empty2)
    delete node.__transition;
}

// node_modules/d3-transition/src/selection/interrupt.js
function interrupt_default2(name) {
  return this.each(function() {
    interrupt_default(this, name);
  });
}

// node_modules/d3-transition/src/transition/tween.js
function tweenRemove(id2, name) {
  var tween0, tween1;
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }
    schedule.tween = tween1;
  };
}
function tweenFunction(id2, name, value) {
  var tween0, tween1;
  if (typeof value !== "function")
    throw new Error();
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = { name, value }, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n)
        tween1.push(t);
    }
    schedule.tween = tween1;
  };
}
function tween_default(name, value) {
  var id2 = this._id;
  name += "";
  if (arguments.length < 2) {
    var tween = get2(this.node(), id2).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
}
function tweenValue(transition2, name, value) {
  var id2 = transition2._id;
  transition2.each(function() {
    var schedule = set2(this, id2);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });
  return function(node) {
    return get2(node, id2).value[name];
  };
}

// node_modules/d3-transition/src/transition/interpolate.js
function interpolate_default(a, b) {
  var c;
  return (typeof b === "number" ? number_default : b instanceof color ? rgb_default : (c = color(b)) ? (b = c, rgb_default) : string_default)(a, b);
}

// node_modules/d3-transition/src/transition/attr.js
function attrRemove2(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS2(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrConstantNS2(fullname, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attrFunctionNS2(fullname, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attr_default2(name, value) {
  var fullname = namespace_default(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i, value));
}

// node_modules/d3-transition/src/transition/attrTween.js
function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}
function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}
function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function attrTween_default(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  var fullname = namespace_default(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

// node_modules/d3-transition/src/transition/delay.js
function delayFunction(id2, value) {
  return function() {
    init(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init(this, id2).delay = value;
  };
}
function delay_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get2(this.node(), id2).delay;
}

// node_modules/d3-transition/src/transition/duration.js
function durationFunction(id2, value) {
  return function() {
    set2(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set2(this, id2).duration = value;
  };
}
function duration_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get2(this.node(), id2).duration;
}

// node_modules/d3-transition/src/transition/ease.js
function easeConstant(id2, value) {
  if (typeof value !== "function")
    throw new Error();
  return function() {
    set2(this, id2).ease = value;
  };
}
function ease_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get2(this.node(), id2).ease;
}

// node_modules/d3-transition/src/transition/easeVarying.js
function easeVarying(id2, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function")
      throw new Error();
    set2(this, id2).ease = v;
  };
}
function easeVarying_default(value) {
  if (typeof value !== "function")
    throw new Error();
  return this.each(easeVarying(this._id, value));
}

// node_modules/d3-transition/src/transition/filter.js
function filter_default2(match) {
  if (typeof match !== "function")
    match = matcher_default(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/merge.js
function merge_default2(transition2) {
  if (transition2._id !== this._id)
    throw new Error();
  for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/on.js
function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0)
      t = t.slice(0, i);
    return !t || t === "start";
  });
}
function onFunction(id2, name, listener) {
  var on0, on1, sit = start(name) ? init : set2;
  return function() {
    var schedule = sit(this, id2), on = schedule.on;
    if (on !== on0)
      (on1 = (on0 = on).copy()).on(name, listener);
    schedule.on = on1;
  };
}
function on_default2(name, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get2(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
}

// node_modules/d3-transition/src/transition/remove.js
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition)
      if (+i !== id2)
        return;
    if (parent)
      parent.removeChild(this);
  };
}
function remove_default2() {
  return this.on("end.remove", removeFunction(this._id));
}

// node_modules/d3-transition/src/transition/select.js
function select_default3(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function")
    select = selector_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule_default(subgroup[i], name, id2, i, subgroup, get2(node, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name, id2);
}

// node_modules/d3-transition/src/transition/selectAll.js
function selectAll_default2(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function")
    select = selectorAll_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children2 = select.call(node, node.__data__, i, group), child, inherit2 = get2(node, id2), k = 0, l = children2.length; k < l; ++k) {
          if (child = children2[k]) {
            schedule_default(child, name, id2, k, children2, inherit2);
          }
        }
        subgroups.push(children2);
        parents.push(node);
      }
    }
  }
  return new Transition(subgroups, parents, name, id2);
}

// node_modules/d3-transition/src/transition/selection.js
var Selection2 = selection_default.prototype.constructor;
function selection_default2() {
  return new Selection2(this._groups, this._parents);
}

// node_modules/d3-transition/src/transition/style.js
function styleNull(name, interpolate) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}
function styleRemove2(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function styleFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
    if (value1 == null)
      string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove2;
  return function() {
    var schedule = set2(this, id2), on = schedule.on, listener = schedule.value[key] == null ? remove2 || (remove2 = styleRemove2(name)) : void 0;
    if (on !== on0 || listener0 !== listener)
      (on1 = (on0 = on).copy()).on(event, listener0 = listener);
    schedule.on = on1;
  };
}
function style_default2(name, value, priority) {
  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate_default;
  return value == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove2(name)) : typeof value === "function" ? this.styleTween(name, styleFunction2(name, i, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant2(name, i, value), priority).on("end.style." + name, null);
}

// node_modules/d3-transition/src/transition/styleTween.js
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}
function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}
function styleTween_default(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}

// node_modules/d3-transition/src/transition/text.js
function textConstant2(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction2(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function text_default2(value) {
  return this.tween("text", typeof value === "function" ? textFunction2(tweenValue(this, "text", value)) : textConstant2(value == null ? "" : value + ""));
}

// node_modules/d3-transition/src/transition/textTween.js
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}
function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function textTween_default(value) {
  var key = "text";
  if (arguments.length < 1)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, textTween(value));
}

// node_modules/d3-transition/src/transition/transition.js
function transition_default() {
  var name = this._name, id0 = this._id, id1 = newId();
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit2 = get2(node, id0);
        schedule_default(node, name, id1, i, group, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
    }
  }
  return new Transition(groups, this._parents, name, id1);
}

// node_modules/d3-transition/src/transition/end.js
function end_default() {
  var on0, on1, that = this, id2 = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = { value: reject }, end = { value: function() {
      if (--size === 0)
        resolve();
    } };
    that.each(function() {
      var schedule = set2(this, id2), on = schedule.on;
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule.on = on1;
    });
    if (size === 0)
      resolve();
  });
}

// node_modules/d3-transition/src/transition/index.js
var id = 0;
function Transition(groups, parents, name, id2) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id2;
}
function transition(name) {
  return selection_default().transition(name);
}
function newId() {
  return ++id;
}
var selection_prototype = selection_default.prototype;
Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: select_default3,
  selectAll: selectAll_default2,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: filter_default2,
  merge: merge_default2,
  selection: selection_default2,
  transition: transition_default,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: on_default2,
  attr: attr_default2,
  attrTween: attrTween_default,
  style: style_default2,
  styleTween: styleTween_default,
  text: text_default2,
  textTween: textTween_default,
  remove: remove_default2,
  tween: tween_default,
  delay: delay_default,
  duration: duration_default,
  ease: ease_default,
  easeVarying: easeVarying_default,
  end: end_default,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};

// node_modules/d3-ease/src/cubic.js
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

// node_modules/d3-transition/src/selection/transition.js
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node, id2) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id2])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id2} not found`);
    }
  }
  return timing;
}
function transition_default2(name) {
  var id2, timing;
  if (name instanceof Transition) {
    id2 = name._id, name = name._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule_default(node, name, id2, i, group, timing || inherit(node, id2));
      }
    }
  }
  return new Transition(groups, this._parents, name, id2);
}

// node_modules/d3-transition/src/selection/index.js
selection_default.prototype.interrupt = interrupt_default2;
selection_default.prototype.transition = transition_default2;

// node_modules/d3-brush/src/brush.js
var { abs, max, min } = Math;
function number1(e) {
  return [+e[0], +e[1]];
}
function number22(e) {
  return [number1(e[0]), number1(e[1])];
}
var X = {
  name: "x",
  handles: ["w", "e"].map(type),
  input: function(x, e) {
    return x == null ? null : [[+x[0], e[0][1]], [+x[1], e[1][1]]];
  },
  output: function(xy) {
    return xy && [xy[0][0], xy[1][0]];
  }
};
var Y = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function(y, e) {
    return y == null ? null : [[e[0][0], +y[0]], [e[1][0], +y[1]]];
  },
  output: function(xy) {
    return xy && [xy[0][1], xy[1][1]];
  }
};
var XY = {
  name: "xy",
  handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
  input: function(xy) {
    return xy == null ? null : number22(xy);
  },
  output: function(xy) {
    return xy;
  }
};
function type(t) {
  return { type: t };
}

// node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x) {
  return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
}
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}

// node_modules/d3-format/src/exponent.js
function exponent_default(x) {
  return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
}

// node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value, width) {
    var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
    while (i > 0 && g > 0) {
      if (length + g + 1 > width)
        g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width)
        break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}

// node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s) {
  out:
    for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (!+s[i])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

// node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d)
    return x + "";
  var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0];
}

// node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d)
    return x + "";
  var coefficient = d[0], exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": (x, p) => (x * 100).toFixed(p),
  "b": (x) => Math.round(x).toString(2),
  "c": (x) => x + "",
  "d": formatDecimal_default,
  "e": (x, p) => x.toExponential(p),
  "f": (x, p) => x.toFixed(p),
  "g": (x, p) => x.toPrecision(p),
  "o": (x) => Math.round(x).toString(8),
  "p": (x, p) => formatRounded_default(x * 100, p),
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": (x) => Math.round(x).toString(16).toUpperCase(),
  "x": (x) => Math.round(x).toString(16)
};

// node_modules/d3-format/src/identity.js
function identity_default2(x) {
  return x;
}

// node_modules/d3-format/src/locale.js
var map = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale2) {
  var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity_default2 : formatGroup_default(map.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity_default2 : formatNumerals_default(map.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "\u2212" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero3 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type2 = specifier.type;
    if (type2 === "n")
      comma = true, type2 = "g";
    else if (!formatTypes_default[type2])
      precision === void 0 && (precision = 12), trim = true, type2 = "g";
    if (zero3 || fill === "0" && align === "=")
      zero3 = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
    var formatType = formatTypes_default[type2], maybeSuffix = /[defgprs%]/.test(type2);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
      if (type2 === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim)
          value = formatTrim_default(value);
        if (valueNegative && +value === 0 && sign !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type2 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero3)
        value = group(value, Infinity);
      var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
      if (comma && zero3)
        value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
    return function(value2) {
      return f(k * value2) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// node_modules/d3-format/src/defaultLocale.js
var locale;
var format;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = locale_default(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default(step) {
  return Math.max(0, -exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionRound.js
function precisionRound_default(step, max2) {
  step = Math.abs(step), max2 = Math.abs(max2) - step;
  return Math.max(0, exponent_default(max2) - exponent_default(step)) + 1;
}

// node_modules/d3-scale/src/init.js
function initRange(domain, range) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range).domain(domain);
      break;
  }
  return this;
}

// node_modules/d3-scale/src/ordinal.js
var implicit = Symbol("implicit");
function ordinal() {
  var index = new InternMap(), domain = [], range = [], unknown = implicit;
  function scale(d) {
    let i = index.get(d);
    if (i === void 0) {
      if (unknown !== implicit)
        return unknown;
      index.set(d, i = domain.push(d) - 1);
    }
    return range[i % range.length];
  }
  scale.domain = function(_) {
    if (!arguments.length)
      return domain.slice();
    domain = [], index = new InternMap();
    for (const value of _) {
      if (index.has(value))
        continue;
      index.set(value, domain.push(value) - 1);
    }
    return scale;
  };
  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), scale) : range.slice();
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.copy = function() {
    return ordinal(domain, range).unknown(unknown);
  };
  initRange.apply(scale, arguments);
  return scale;
}

// node_modules/d3-scale/src/constant.js
function constants(x) {
  return function() {
    return x;
  };
}

// node_modules/d3-scale/src/number.js
function number3(x) {
  return +x;
}

// node_modules/d3-scale/src/continuous.js
var unit = [0, 1];
function identity2(x) {
  return x;
}
function normalize(a, b) {
  return (b -= a = +a) ? function(x) {
    return (x - a) / b;
  } : constants(isNaN(b) ? NaN : 0.5);
}
function clamper(a, b) {
  var t;
  if (a > b)
    t = a, a = b, b = t;
  return function(x) {
    return Math.max(a, Math.min(b, x));
  };
}
function bimap(domain, range, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0)
    d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else
    d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x) {
    return r0(d0(x));
  };
}
function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1, d = new Array(j), r = new Array(j), i = -1;
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }
  return function(x) {
    var i2 = bisect_default(domain, x, 1, j) - 1;
    return r[i2](d[i2](x));
  };
}
function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer() {
  var domain = unit, range = unit, interpolate = value_default, transform2, untransform, unknown, clamp = identity2, piecewise, output, input;
  function rescale() {
    var n = Math.min(domain.length, range.length);
    if (clamp !== identity2)
      clamp = clamper(domain[0], domain[n - 1]);
    piecewise = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }
  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform2), range, interpolate)))(transform2(clamp(x)));
  }
  scale.invert = function(y) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform2), number_default)))(y)));
  };
  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, number3), rescale()) : domain.slice();
  };
  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };
  scale.rangeRound = function(_) {
    return range = Array.from(_), interpolate = round_default, rescale();
  };
  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? true : identity2, rescale()) : clamp !== identity2;
  };
  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function(t, u) {
    transform2 = t, untransform = u;
    return rescale();
  };
}
function continuous() {
  return transformer()(identity2, identity2);
}

// node_modules/d3-scale/src/tickFormat.js
function tickFormat(start2, stop, count, specifier) {
  var step = tickStep(start2, stop, count), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start2), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value)))
        specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start2), Math.abs(stop)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}

// node_modules/d3-scale/src/linear.js
function linearish(scale) {
  var domain = scale.domain;
  scale.ticks = function(count) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
  };
  scale.tickFormat = function(count, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };
  scale.nice = function(count) {
    if (count == null)
      count = 10;
    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start2 = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start2) {
      step = start2, start2 = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start2, stop, count);
      if (step === prestep) {
        d[i0] = start2;
        d[i1] = stop;
        return domain(d);
      } else if (step > 0) {
        start2 = Math.floor(start2 / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start2 = Math.ceil(start2 * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale;
  };
  return scale;
}
function linear2() {
  var scale = continuous();
  scale.copy = function() {
    return copy(scale, linear2());
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}

// node_modules/d3-scale-chromatic/src/colors.js
function colors_default(specifier) {
  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
  while (i < n)
    colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
  return colors;
}

// node_modules/d3-scale-chromatic/src/categorical/category10.js
var category10_default = colors_default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

// node_modules/d3-zoom/src/transform.js
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity3 = new Transform(1, 0, 0);
transform.prototype = Transform.prototype;
function transform(node) {
  while (!node.__zoom)
    if (!(node = node.parentNode))
      return identity3;
  return node.__zoom;
}

// src/views/TimelineModal.ts
var TimelineModal = class extends import_obsidian13.Modal {
  constructor(app, events, timeConfig) {
    super(app);
    this.events = events;
    this.timeConfig = timeConfig;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("story-engine-timeline-modal");
    contentEl.createEl("h2", { text: "World Timeline" });
    const chartContainer = contentEl.createDiv({ cls: "story-engine-timeline-chart" });
    this.renderTimeline(chartContainer);
  }
  renderTimeline(container) {
    if (this.events.length === 0) {
      container.createEl("p", { text: "No events with timeline data found." });
      return;
    }
    const width = 800;
    const height = 400;
    const margin = { top: 20, right: 30, bottom: 50, left: 60 };
    const svg = select_default2(container).append("svg").attr("width", width).attr("height", height);
    const eventsWithPosition = this.events.map((e, i) => {
      var _a, _b, _c;
      return {
        ...e,
        timeline_position: (_a = e.timeline_position) != null ? _a : i * 10,
        parent_id: (_b = e.parent_id) != null ? _b : null,
        is_epoch: (_c = e.is_epoch) != null ? _c : false
      };
    });
    const xExtent = extent(eventsWithPosition, (d) => d.timeline_position);
    const xScale = linear2().domain([xExtent[0] - 1, xExtent[1] + 1]).range([margin.left, width - margin.right]);
    const yScale = linear2().domain([0, 10]).range([height - margin.bottom, margin.top]);
    const colorScale = ordinal(category10_default);
    svg.append("g").attr("transform", `translate(0,${height - margin.bottom})`).call(axisBottom(xScale).tickFormat((d) => `Year ${d}`));
    svg.append("g").attr("transform", `translate(${margin.left},0)`).call(axisLeft(yScale).tickFormat((d) => `Imp ${d}`));
    const eventsWithParent = eventsWithPosition.filter((e) => e.parent_id);
    svg.selectAll("line.parent-link").data(eventsWithParent).join("line").attr("class", "parent-link").attr("x1", (d) => {
      const parent = eventsWithPosition.find((e) => e.id === d.parent_id);
      return parent ? xScale(parent.timeline_position) : 0;
    }).attr("y1", (d) => {
      const parent = eventsWithPosition.find((e) => e.id === d.parent_id);
      return parent ? yScale(parent.importance) : 0;
    }).attr("x2", (d) => xScale(d.timeline_position)).attr("y2", (d) => yScale(d.importance)).attr("stroke", "#999").attr("stroke-dasharray", "4,2").attr("stroke-width", 1);
    svg.selectAll("circle").data(eventsWithPosition).join("circle").attr("cx", (d) => xScale(d.timeline_position)).attr("cy", (d) => yScale(d.importance)).attr("r", (d) => d.is_epoch ? 10 : 6).attr("fill", (d) => colorScale(d.type || "default")).attr("stroke", (d) => d.is_epoch ? "gold" : "none").attr("stroke-width", 3).style("cursor", "pointer").on("click", (_event, d) => this.showEventDetails(d)).append("title").text((d) => `${d.name} (Year ${d.timeline_position})`);
    svg.selectAll("text.event-label").data(eventsWithPosition.filter((e) => e.importance >= 8)).join("text").attr("class", "event-label").attr("x", (d) => xScale(d.timeline_position)).attr("y", (d) => yScale(d.importance) - 12).attr("text-anchor", "middle").attr("font-size", "10px").text((d) => d.name.substring(0, 15) + (d.name.length > 15 ? "..." : ""));
  }
  showEventDetails(event) {
    var _a;
    new import_obsidian13.Notice(`Event: ${event.name}
Year: ${(_a = event.timeline_position) != null ? _a : "N/A"}
Importance: ${event.importance}`);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/CharacterDetailsView.ts
var import_obsidian14 = require("obsidian");
var CharacterDetailsView = class {
  constructor(plugin, character, headerEl, contentEl, onBack, onEditCharacter, world = null, characters = [], archetypes = [], traits = [], events = []) {
    // State
    this.characterTab = "overview";
    this.characterTraits = [];
    this.characterEvents = [];
    this.characterScenes = [];
    this.characterRelationships = [];
    this.plugin = plugin;
    this.character = character;
    this.world = world;
    this.characters = characters;
    this.archetypes = archetypes;
    this.traits = traits;
    this.events = events;
    this.headerEl = headerEl;
    this.contentEl = contentEl;
    this.onBack = onBack;
    this.onEditCharacter = onEditCharacter;
  }
  async render() {
    await this.loadCharacterData();
    this.renderHeader();
    this.renderTabs();
    this.renderTabContent();
  }
  async loadCharacterData() {
    try {
      this.characterTraits = await this.plugin.apiClient.getCharacterTraits(this.character.id);
      const eventCharacters = await this.plugin.apiClient.getCharacterEvents(this.character.id);
      this.characterEvents = await Promise.all(
        eventCharacters.map(async (ec) => {
          const event = await this.plugin.apiClient.getEvent(ec.event_id);
          return { event, role: ec.role || void 0 };
        })
      );
      this.characterRelationships = await this.plugin.apiClient.getCharacterRelationships(this.character.id);
      this.characterScenes = [];
      if (this.world) {
        const allStories = await this.plugin.apiClient.listStories();
        const worldStories = allStories.filter((s) => s.world_id === this.world.id);
        for (const story of worldStories) {
          const scenes = await this.plugin.apiClient.getScenesByStory(story.id);
          const povScenes = scenes.filter((s) => s.pov_character_id === this.character.id);
          for (const scene of povScenes) {
            this.characterScenes.push({ scene, story, type: "pov" });
          }
          for (const scene of scenes) {
            const refs = await this.plugin.apiClient.getSceneReferences(scene.id);
            const charRef = refs.find(
              (r) => r.entity_type === "character" && r.entity_id === this.character.id
            );
            if (charRef) {
              this.characterScenes.push({ scene, story, type: "coadjuvante" });
            }
          }
        }
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to load character data";
      new import_obsidian14.Notice(`Error: ${errorMessage}`, 5e3);
    }
  }
  renderHeader() {
    if (!this.headerEl)
      return;
    this.headerEl.empty();
    const headerLeft = this.headerEl.createDiv({ cls: "story-engine-header-left" });
    const backButton = headerLeft.createEl("button", {
      text: "\u2190 Back",
      cls: "story-engine-back-btn"
    });
    backButton.onclick = () => {
      this.onBack();
    };
    const titleDiv = headerLeft.createDiv({ cls: "story-engine-header-title" });
    titleDiv.createEl("h2", { text: this.character.name });
    if (this.character.archetype_id) {
      const archetype = this.archetypes.find((a) => a.id === this.character.archetype_id);
      if (archetype) {
        const archetypePill = titleDiv.createSpan({ cls: "story-engine-badge" });
        archetypePill.textContent = archetype.name;
      }
    }
    const uuidDiv = headerLeft.createDiv({ cls: "story-engine-uuid" });
    uuidDiv.createEl("span", { text: this.character.id });
    const copyIcon = uuidDiv.createEl("span", { cls: "story-engine-copy-icon" });
    (0, import_obsidian14.setIcon)(copyIcon, "copy");
    copyIcon.onclick = () => {
      navigator.clipboard.writeText(this.character.id);
      new import_obsidian14.Notice("UUID copied to clipboard");
    };
    const headerRight = this.headerEl.createDiv({ cls: "story-engine-header-right" });
    const menuButton = headerRight.createEl("button", { text: "Edit Character" });
    menuButton.onclick = () => {
      this.onEditCharacter(this.character);
    };
  }
  renderTabs() {
    if (!this.contentEl)
      return;
    const existingTabs = this.contentEl.querySelector(".story-engine-tabs");
    if (existingTabs) {
      existingTabs.remove();
    }
    const tabsContainer = this.contentEl.createDiv({ cls: "story-engine-tabs" });
    const tabs = [
      { key: "overview", label: "Overview" },
      { key: "traits", label: "Traits" },
      { key: "events", label: "Events" },
      { key: "scenes", label: "Scenes" },
      { key: "relationships", label: "Relationships" }
    ];
    for (const tab of tabs) {
      const tabEl = tabsContainer.createEl("button", {
        text: tab.label,
        cls: this.characterTab === tab.key ? "story-engine-tab-active" : "story-engine-tab"
      });
      tabEl.onclick = () => {
        this.characterTab = tab.key;
        this.renderTabContent();
      };
    }
  }
  renderTabContent() {
    if (!this.contentEl)
      return;
    const existingContainer = this.contentEl.querySelector(".story-engine-tab-content");
    if (existingContainer) {
      existingContainer.remove();
    }
    const contentContainer = this.contentEl.createDiv({ cls: "story-engine-tab-content" });
    switch (this.characterTab) {
      case "overview":
        this.renderOverviewTab(contentContainer);
        break;
      case "traits":
        this.renderTraitsTab(contentContainer);
        break;
      case "events":
        this.renderEventsTab(contentContainer);
        break;
      case "scenes":
        this.renderScenesTab(contentContainer);
        break;
      case "relationships":
        this.renderRelationshipsTab(contentContainer);
        break;
    }
  }
  renderOverviewTab(container) {
    const descSection = container.createDiv({ cls: "story-engine-section" });
    descSection.createEl("h3", { text: "Description" });
    const descTextarea = descSection.createEl("textarea", {
      cls: "story-engine-textarea",
      attr: { rows: "5" }
    });
    descTextarea.value = this.character.description || "";
    descTextarea.placeholder = "Enter character description...";
    const descActions = descSection.createDiv({ cls: "story-engine-actions" });
    const saveDescBtn = descActions.createEl("button", { text: "Save Description", cls: "mod-cta" });
    saveDescBtn.onclick = async () => {
      try {
        const updated = await this.plugin.apiClient.updateCharacter(this.character.id, {
          description: descTextarea.value
        });
        this.character = updated;
        new import_obsidian14.Notice("Description saved");
      } catch (err) {
        new import_obsidian14.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    const archetypeSection = container.createDiv({ cls: "story-engine-section" });
    archetypeSection.createEl("h3", { text: "Archetype" });
    const archetypeSelect = archetypeSection.createEl("select", { cls: "story-engine-select" });
    const noneOption = archetypeSelect.createEl("option", { text: "None", value: "" });
    if (!this.character.archetype_id) {
      noneOption.selected = true;
    }
    for (const archetype of this.archetypes) {
      const option = archetypeSelect.createEl("option", {
        text: archetype.name,
        value: archetype.id
      });
      if (this.character.archetype_id === archetype.id) {
        option.selected = true;
      }
    }
    const archetypeActions = archetypeSection.createDiv({ cls: "story-engine-actions" });
    const saveArchetypeBtn = archetypeActions.createEl("button", { text: "Save Archetype", cls: "mod-cta" });
    saveArchetypeBtn.onclick = async () => {
      try {
        const archetypeId = archetypeSelect.value || null;
        const updated = await this.plugin.apiClient.updateCharacter(this.character.id, {
          archetype_id: archetypeId
        });
        this.character = updated;
        await this.loadCharacterData();
        this.renderHeader();
        this.renderTabContent();
        new import_obsidian14.Notice("Archetype saved");
      } catch (err) {
        new import_obsidian14.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
  }
  renderTraitsTab(container) {
    const actionsBar = container.createDiv({ cls: "story-engine-actions-bar" });
    const addBtn = actionsBar.createEl("button", { text: "Add Trait", cls: "mod-cta" });
    addBtn.onclick = () => {
      this.showAddTraitModal();
    };
    if (this.characterTraits.length === 0) {
      container.createEl("p", { text: "No traits assigned. Add a trait to get started!" });
      return;
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const charTrait of this.characterTraits) {
      const item = list.createDiv({ cls: "story-engine-item" });
      const titleRow = item.createDiv({ cls: "story-engine-title" });
      titleRow.createEl("strong", { text: charTrait.trait_name });
      const categoryPill = titleRow.createSpan({ cls: "story-engine-badge" });
      categoryPill.textContent = charTrait.trait_category;
      const meta = item.createDiv({ cls: "story-engine-meta" });
      meta.createEl("span", { text: `Value: ${charTrait.value || "N/A"}` });
      if (charTrait.notes) {
        meta.createEl("span", { text: ` | Notes: ${charTrait.notes}` });
      }
      const actions = item.createDiv({ cls: "story-engine-item-actions" });
      actions.createEl("button", { text: "Edit" }).onclick = () => {
        this.showEditTraitModal(charTrait);
      };
      actions.createEl("button", { text: "Delete" }).onclick = async () => {
        if (confirm(`Remove trait "${charTrait.trait_name}"?`)) {
          try {
            await this.plugin.apiClient.removeCharacterTrait(this.character.id, charTrait.trait_id);
            await this.loadCharacterData();
            this.renderTabContent();
            new import_obsidian14.Notice("Trait removed");
          } catch (err) {
            new import_obsidian14.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
          }
        }
      };
    }
  }
  renderEventsTab(container) {
    const actionsBar = container.createDiv({ cls: "story-engine-actions-bar" });
    const addBtn = actionsBar.createEl("button", { text: "Add Event", cls: "mod-cta" });
    addBtn.onclick = () => {
      this.showAddEventModal();
    };
    if (this.characterEvents.length === 0) {
      container.createEl("p", { text: "No events assigned. Add an event to get started!" });
      return;
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const { event, role } of this.characterEvents) {
      const item = list.createDiv({ cls: "story-engine-item" });
      item.createDiv({ cls: "story-engine-title", text: event.name });
      const meta = item.createDiv({ cls: "story-engine-meta" });
      if (role) {
        meta.createEl("span", { text: `Role: ${role}` });
      }
      const actions = item.createDiv({ cls: "story-engine-item-actions" });
      actions.createEl("button", { text: "Edit Role" }).onclick = () => {
        this.showEditEventRoleModal(event, role);
      };
      actions.createEl("button", { text: "Remove" }).onclick = async () => {
        if (confirm(`Remove character from event "${event.name}"?`)) {
          try {
            await this.plugin.apiClient.removeEventCharacter(event.id, this.character.id);
            await this.loadCharacterData();
            this.renderTabContent();
            new import_obsidian14.Notice("Character removed from event");
          } catch (err) {
            new import_obsidian14.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
          }
        }
      };
    }
  }
  renderScenesTab(container) {
    if (this.characterScenes.length === 0) {
      container.createEl("p", { text: "No scenes found for this character." });
      return;
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const { scene, story, type: type2 } of this.characterScenes) {
      const item = list.createDiv({ cls: "story-engine-item" });
      const titleRow = item.createDiv({ cls: "story-engine-title" });
      titleRow.createEl("span", { text: scene.goal || "No goal" });
      const typePill = titleRow.createSpan({
        cls: type2 === "pov" ? "story-engine-badge story-engine-badge-green" : "story-engine-badge story-engine-badge-blue"
      });
      typePill.textContent = type2 === "pov" ? "POV" : "Coadjuvante";
      const meta = item.createDiv({ cls: "story-engine-meta" });
      meta.createEl("span", { text: `Story: ${story.title}` });
    }
  }
  renderRelationshipsTab(container) {
    const actionsBar = container.createDiv({ cls: "story-engine-actions-bar" });
    const addBtn = actionsBar.createEl("button", { text: "Add Relationship", cls: "mod-cta" });
    addBtn.onclick = () => {
      this.showAddRelationshipModal();
    };
    if (this.characterRelationships.length === 0) {
      container.createEl("p", { text: "No relationships defined. Add a relationship to get started!" });
      return;
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const rel of this.characterRelationships) {
      const otherCharId = rel.character1_id === this.character.id ? rel.character2_id : rel.character1_id;
      const otherChar = this.characters.find((c) => c.id === otherCharId);
      const otherCharName = otherChar ? otherChar.name : "Unknown";
      const item = list.createDiv({ cls: "story-engine-item" });
      const titleRow = item.createDiv({ cls: "story-engine-title" });
      titleRow.createEl("strong", { text: otherCharName });
      const typePill = titleRow.createSpan({ cls: "story-engine-badge" });
      typePill.textContent = rel.relationship_type;
      const directionIcon = titleRow.createSpan({ cls: "story-engine-direction" });
      directionIcon.textContent = rel.bidirectional ? "\u2194" : "\u2192";
      const meta = item.createDiv({ cls: "story-engine-meta" });
      if (rel.description) {
        meta.createEl("span", { text: rel.description });
      }
      const actions = item.createDiv({ cls: "story-engine-item-actions" });
      actions.createEl("button", { text: "Edit" }).onclick = () => {
        this.showEditRelationshipModal(rel);
      };
      actions.createEl("button", { text: "Delete" }).onclick = async () => {
        if (confirm(`Delete relationship with "${otherCharName}"?`)) {
          try {
            await this.plugin.apiClient.deleteCharacterRelationship(rel.id);
            await this.loadCharacterData();
            this.renderTabContent();
            new import_obsidian14.Notice("Relationship deleted");
          } catch (err) {
            new import_obsidian14.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
          }
        }
      };
    }
  }
  // Modal methods
  showAddTraitModal() {
    const modal = new import_obsidian14.Modal(this.plugin.app);
    modal.titleEl.textContent = "Add Trait";
    const content = modal.contentEl;
    content.createEl("p", { text: "Select a trait to add:" });
    const traitSelect = content.createEl("select", { cls: "story-engine-select" });
    const availableTraits = this.traits.filter(
      (t) => !this.characterTraits.some((ct) => ct.trait_id === t.id)
    );
    if (availableTraits.length === 0) {
      content.createEl("p", { text: "No available traits. Create a trait first!" });
      const buttonContainer2 = content.createDiv({ cls: "modal-button-container" });
      const closeBtn = buttonContainer2.createEl("button", { text: "Close" });
      closeBtn.onclick = () => modal.close();
      return;
    }
    for (const trait of availableTraits) {
      traitSelect.createEl("option", { text: `${trait.name} (${trait.category})`, value: trait.id });
    }
    const valueInput = content.createEl("input", {
      cls: "story-engine-input",
      attr: { type: "text", placeholder: "Value (optional)" }
    });
    const notesInput = content.createEl("textarea", {
      cls: "story-engine-textarea",
      attr: { rows: "3", placeholder: "Notes (optional)" }
    });
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Add", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      try {
        await this.plugin.apiClient.addCharacterTrait(
          this.character.id,
          traitSelect.value,
          valueInput.value || void 0,
          notesInput.value || void 0
        );
        await this.loadCharacterData();
        this.renderTabContent();
        modal.close();
        new import_obsidian14.Notice("Trait added");
      } catch (err) {
        new import_obsidian14.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => modal.close();
    modal.open();
  }
  showEditTraitModal(charTrait) {
    const modal = new import_obsidian14.Modal(this.plugin.app);
    modal.titleEl.textContent = "Edit Trait";
    const content = modal.contentEl;
    content.createEl("p", { text: `Editing: ${charTrait.trait_name}` });
    const valueInput = content.createEl("input", {
      cls: "story-engine-input",
      attr: { type: "text", placeholder: "Value" }
    });
    valueInput.value = charTrait.value || "";
    const notesInput = content.createEl("textarea", {
      cls: "story-engine-textarea",
      attr: { rows: "3", placeholder: "Notes" }
    });
    notesInput.value = charTrait.notes || "";
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      try {
        await this.plugin.apiClient.updateCharacterTrait(
          this.character.id,
          charTrait.trait_id,
          valueInput.value || void 0,
          notesInput.value || void 0
        );
        await this.loadCharacterData();
        this.renderTabContent();
        modal.close();
        new import_obsidian14.Notice("Trait updated");
      } catch (err) {
        new import_obsidian14.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => modal.close();
    modal.open();
  }
  showAddEventModal() {
    if (!this.world)
      return;
    const modal = new import_obsidian14.Modal(this.plugin.app);
    modal.titleEl.textContent = "Add Event";
    const content = modal.contentEl;
    content.createEl("p", { text: "Select an event:" });
    const eventSelect = content.createEl("select", { cls: "story-engine-select" });
    const availableEvents = this.events.filter(
      (e) => !this.characterEvents.some((ce) => ce.event.id === e.id)
    );
    if (availableEvents.length === 0) {
      content.createEl("p", { text: "No available events. Create an event first!" });
      const buttonContainer2 = content.createDiv({ cls: "modal-button-container" });
      const closeBtn = buttonContainer2.createEl("button", { text: "Close" });
      closeBtn.onclick = () => modal.close();
      return;
    }
    for (const event of availableEvents) {
      eventSelect.createEl("option", { text: event.name, value: event.id });
    }
    const roleInput = content.createEl("input", {
      cls: "story-engine-input",
      attr: { type: "text", placeholder: "Role (optional)" }
    });
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Add", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      try {
        await this.plugin.apiClient.addEventCharacter(
          eventSelect.value,
          this.character.id,
          roleInput.value || void 0
        );
        await this.loadCharacterData();
        this.renderTabContent();
        modal.close();
        new import_obsidian14.Notice("Character added to event");
      } catch (err) {
        new import_obsidian14.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => modal.close();
    modal.open();
  }
  showEditEventRoleModal(event, currentRole) {
    const modal = new import_obsidian14.Modal(this.plugin.app);
    modal.titleEl.textContent = "Edit Role";
    const content = modal.contentEl;
    content.createEl("p", { text: `Event: ${event.name}` });
    const roleInput = content.createEl("input", {
      cls: "story-engine-input",
      attr: { type: "text", placeholder: "Role" },
      value: currentRole || ""
    });
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      try {
        await this.plugin.apiClient.removeEventCharacter(event.id, this.character.id);
        await this.plugin.apiClient.addEventCharacter(
          event.id,
          this.character.id,
          roleInput.value || void 0
        );
        await this.loadCharacterData();
        this.renderTabContent();
        modal.close();
        new import_obsidian14.Notice("Role updated");
      } catch (err) {
        new import_obsidian14.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => modal.close();
    modal.open();
  }
  showAddRelationshipModal() {
    const modal = new import_obsidian14.Modal(this.plugin.app);
    modal.titleEl.textContent = "Add Relationship";
    const content = modal.contentEl;
    content.createEl("p", { text: "Select another character:" });
    const characterSelect = content.createEl("select", { cls: "story-engine-select" });
    const availableCharacters = this.characters.filter((c) => c.id !== this.character.id);
    if (availableCharacters.length === 0) {
      content.createEl("p", { text: "No other characters available." });
      const buttonContainer2 = content.createDiv({ cls: "modal-button-container" });
      const closeBtn = buttonContainer2.createEl("button", { text: "Close" });
      closeBtn.onclick = () => modal.close();
      return;
    }
    for (const char of availableCharacters) {
      characterSelect.createEl("option", { text: char.name, value: char.id });
    }
    const relationshipTypeSelect = content.createEl("select", { cls: "story-engine-select" });
    relationshipTypeSelect.createEl("option", { text: "Ally", value: "ally" });
    relationshipTypeSelect.createEl("option", { text: "Enemy", value: "enemy" });
    relationshipTypeSelect.createEl("option", { text: "Family", value: "family" });
    relationshipTypeSelect.createEl("option", { text: "Lover", value: "lover" });
    relationshipTypeSelect.createEl("option", { text: "Rival", value: "rival" });
    relationshipTypeSelect.createEl("option", { text: "Mentor", value: "mentor" });
    relationshipTypeSelect.createEl("option", { text: "Student", value: "student" });
    const descriptionInput = content.createEl("textarea", {
      cls: "story-engine-textarea",
      attr: { rows: "3", placeholder: "Description (optional)" }
    });
    const bidirectionalCheckbox = content.createEl("input", {
      attr: { type: "checkbox" }
    });
    bidirectionalCheckbox.checked = true;
    const bidirectionalLabel = content.createEl("label");
    bidirectionalLabel.appendChild(bidirectionalCheckbox);
    bidirectionalLabel.appendChild(document.createTextNode(" Bidirectional"));
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Add", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      try {
        await this.plugin.apiClient.createCharacterRelationship(this.character.id, {
          character1_id: this.character.id,
          character2_id: characterSelect.value,
          relationship_type: relationshipTypeSelect.value,
          description: descriptionInput.value || "",
          bidirectional: bidirectionalCheckbox.checked
        });
        await this.loadCharacterData();
        this.renderTabContent();
        modal.close();
        new import_obsidian14.Notice("Relationship added");
      } catch (err) {
        new import_obsidian14.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => modal.close();
    modal.open();
  }
  showEditRelationshipModal(rel) {
    const modal = new import_obsidian14.Modal(this.plugin.app);
    modal.titleEl.textContent = "Edit Relationship";
    const content = modal.contentEl;
    const relationshipTypeSelect = content.createEl("select", { cls: "story-engine-select" });
    relationshipTypeSelect.createEl("option", { text: "Ally", value: "ally" });
    relationshipTypeSelect.createEl("option", { text: "Enemy", value: "enemy" });
    relationshipTypeSelect.createEl("option", { text: "Family", value: "family" });
    relationshipTypeSelect.createEl("option", { text: "Lover", value: "lover" });
    relationshipTypeSelect.createEl("option", { text: "Rival", value: "rival" });
    relationshipTypeSelect.createEl("option", { text: "Mentor", value: "mentor" });
    relationshipTypeSelect.createEl("option", { text: "Student", value: "student" });
    relationshipTypeSelect.value = rel.relationship_type;
    const descriptionInput = content.createEl("textarea", {
      cls: "story-engine-textarea",
      attr: { rows: "3", placeholder: "Description" },
      text: rel.description || ""
    });
    const bidirectionalCheckbox = content.createEl("input", {
      attr: { type: "checkbox" }
    });
    bidirectionalCheckbox.checked = rel.bidirectional;
    const bidirectionalLabel = content.createEl("label");
    bidirectionalLabel.appendChild(bidirectionalCheckbox);
    bidirectionalLabel.appendChild(document.createTextNode(" Bidirectional"));
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      try {
        await this.plugin.apiClient.updateCharacterRelationship(rel.id, {
          relationship_type: relationshipTypeSelect.value,
          description: descriptionInput.value || "",
          bidirectional: bidirectionalCheckbox.checked
        });
        await this.loadCharacterData();
        this.renderTabContent();
        modal.close();
        new import_obsidian14.Notice("Relationship updated");
      } catch (err) {
        new import_obsidian14.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => modal.close();
    modal.open();
  }
  // Method to update character after edit
  updateCharacter(character) {
    this.character = character;
    this.renderHeader();
    this.renderTabContent();
  }
};

// src/sync-v2/utils/slugify.ts
var ACCENTS_REGEX = /[\u0300-\u036f]/g;
var NON_ALNUM = /[^a-z0-9\s-]/gi;
var SPACES = /\s+/g;
var MULTIPLE_DASH = /-+/g;
var EDGE_DASH = /^-+|-+$/g;
function slugify(value, fallback = "untitled") {
  const normalized = value.normalize("NFKD").toLowerCase().replace(ACCENTS_REGEX, "").replace(NON_ALNUM, "").trim().replace(SPACES, "-").replace(MULTIPLE_DASH, "-").replace(EDGE_DASH, "");
  return normalized || fallback;
}

// src/sync-v2/utils/frontmatterHelpers.ts
function getIdFieldName(idField) {
  return idField || "id";
}
function getFrontmatterId(frontmatter, idField) {
  const fieldName = getIdFieldName(idField);
  const value = frontmatter[fieldName];
  if (value === null || value === void 0) {
    return void 0;
  }
  if (typeof value === "string") {
    const trimmed = value.trim();
    return trimmed === "" ? void 0 : value;
  }
  return String(value);
}

// src/sync-v2/utils/linkBuilder.ts
var STORY_FOLDER_MAP = {
  chapter: { folder: "00-chapters", prefix: "ch" },
  scene: { folder: "01-scenes", prefix: "sc" },
  beat: { folder: "02-beats", prefix: "bt" }
};
var WORLD_FOLDER_MAP = {
  character: "characters",
  location: "locations",
  faction: "factions",
  artifact: "artifacts",
  event: "events",
  lore: "lore"
};
function buildWikiLink(path, label) {
  return `[[${path}|${label}]]`;
}
function buildStoryEntityPath(storyFolderPath, type2, order, title, overrides) {
  var _a, _b, _c;
  const entry = STORY_FOLDER_MAP[type2];
  const slug = slugify(title);
  const orderTag = String(order).padStart(4, "0");
  if (type2 === "scene") {
    const chapterTag = String((_a = overrides == null ? void 0 : overrides.chapterOrder) != null ? _a : 0).padStart(4, "0");
    return `${storyFolderPath}/${entry.folder}/${entry.prefix}-${chapterTag}-${orderTag}-${slug}.md`;
  }
  if (type2 === "beat") {
    const chapterTag = String((_b = overrides == null ? void 0 : overrides.chapterOrder) != null ? _b : 0).padStart(4, "0");
    const sceneTag = String((_c = overrides == null ? void 0 : overrides.sceneOrder) != null ? _c : 0).padStart(4, "0");
    return `${storyFolderPath}/${entry.folder}/${entry.prefix}-${chapterTag}-${sceneTag}-${orderTag}-${slug}.md`;
  }
  return `${storyFolderPath}/${entry.folder}/${entry.prefix}-${orderTag}-${slug}.md`;
}
function buildWorldEntityPath(worldFolderPath, entityType, name) {
  const folder = WORLD_FOLDER_MAP[entityType];
  const slug = slugify(name);
  return `${worldFolderPath}/${folder}/${slug}.md`;
}
function buildWorldFolderLink(worldFolderPath) {
  return `${worldFolderPath}/world.md`;
}
function resolveLinkBasename(link) {
  var _a;
  const trimmed = link.split("|")[0].trim();
  const base = (_a = trimmed.split("/").pop()) != null ? _a : trimmed;
  return base.endsWith(".md") ? base.slice(0, -3) : base;
}

// src/sync-v2/generators/RelationsGenerator.ts
var TARGET_LABELS = {
  character: "Main Characters",
  location: "Key Locations",
  faction: "Referenced Factions",
  event: "Timeline Events",
  artifact: "Artifacts",
  lore: "Lore References"
};
var RelationsGenerator = class {
  constructor(now2 = () => (/* @__PURE__ */ new Date()).toISOString()) {
    this.now = now2;
  }
  generate(input) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const { entity, relations } = input;
    const lines = [];
    const idField = getIdFieldName((_a = input.options) == null ? void 0 : _a.idField);
    lines.push(
      "---",
      `${idField}: ${entity.id}`,
      `type: ${entity.type}-relations`,
      `synced_at: ${(_c = (_b = input.options) == null ? void 0 : _b.syncedAt) != null ? _c : this.now()}`
    );
    if (entity.worldId) {
      lines.push(`world_id: ${entity.worldId}`);
    }
    lines.push("---", "", `# ${entity.name} - Relations`, "");
    if (((_d = input.options) == null ? void 0 : _d.showHelpBox) !== false) {
      lines.push(
        "> [!tip] Como editar rela\xE7\xF5es",
        "> - **Adicionar**: Edite a linha `_Add new..._` da se\xE7\xE3o",
        "> - **Remover**: Delete a linha da rela\xE7\xE3o",
        "> - **Formato**: `[[path/to/file.md|Name]] - description`",
        ""
      );
    }
    if (entity.worldId && entity.worldName) {
      lines.push("## World");
      if ((_e = input.options) == null ? void 0 : _e.worldFolderPath) {
        lines.push(buildWikiLink(buildWorldFolderLink(input.options.worldFolderPath), entity.worldName), "");
      } else {
        lines.push(`[[${entity.worldId}|${entity.worldName}]]`, "");
      }
    }
    const grouped = this.groupByTarget(relations);
    for (const [targetType, items] of grouped.entries()) {
      lines.push(`## ${(_f = TARGET_LABELS[targetType]) != null ? _f : targetType}`);
      if (items.length === 0) {
        lines.push(this.placeholderLine(targetType, (_g = input.options) == null ? void 0 : _g.worldFolderPath));
        lines.push("");
        continue;
      }
      items.sort((a, b) => a.targetName.localeCompare(b.targetName)).forEach((entry) => {
        var _a2, _b2, _c2;
        const description = (_b2 = (_a2 = entry.summary) != null ? _a2 : entry.contextLabel) != null ? _b2 : "";
        const desc = description ? ` - ${description}` : "";
        if (((_c2 = input.options) == null ? void 0 : _c2.worldFolderPath) && this.isWorldEntity(entry.targetType)) {
          const path = buildWorldEntityPath(
            input.options.worldFolderPath,
            entry.targetType,
            entry.targetName
          );
          lines.push(`- ${buildWikiLink(path, entry.targetName)}${desc}`);
        } else {
          lines.push(`- [[${entry.targetId}|${entry.targetName}]]${desc}`);
        }
      });
      lines.push(this.placeholderLine(targetType, (_h = input.options) == null ? void 0 : _h.worldFolderPath), "");
    }
    return lines.join("\n").trimEnd() + "\n";
  }
  groupByTarget(relations) {
    const map2 = /* @__PURE__ */ new Map();
    relations.forEach((relation) => {
      const key = relation.targetType;
      if (!map2.has(key)) {
        map2.set(key, []);
      }
      map2.get(key).push(relation);
    });
    Object.keys(TARGET_LABELS).forEach((type2) => {
      if (!map2.has(type2)) {
        map2.set(type2, []);
      }
    });
    return map2;
  }
  placeholderLine(targetType, worldFolderPath) {
    var _a;
    const label = (_a = TARGET_LABELS[targetType]) != null ? _a : targetType;
    const noun = label.replace(/s$/, "").toLowerCase();
    if (worldFolderPath && this.isWorldEntity(targetType)) {
      const path = buildWorldEntityPath(
        worldFolderPath,
        targetType,
        "file"
      );
      return `- _Add new ${noun}: ${buildWikiLink(path, "Name")} - description_`;
    }
    return `- _Add new ${noun}: [[file|Name]] - description_`;
  }
  isWorldEntity(targetType) {
    return Object.prototype.hasOwnProperty.call(TARGET_LABELS, targetType);
  }
};

// src/sync-v2/generators/CitationsGenerator.ts
var CitationsGenerator = class {
  constructor(now2 = () => (/* @__PURE__ */ new Date()).toISOString()) {
    this.now = now2;
  }
  generate(input) {
    var _a, _b, _c, _d;
    const { entity, citations } = input;
    const lines = [];
    const idField = getIdFieldName((_a = input.options) == null ? void 0 : _a.idField);
    lines.push(
      "---",
      `${idField}: ${entity.id}`,
      `type: ${entity.type}-citations`,
      `synced_at: ${(_c = (_b = input.options) == null ? void 0 : _b.syncedAt) != null ? _c : this.now()}`,
      "---",
      "",
      `# ${entity.name} - Citations`,
      ""
    );
    lines.push(
      "> [!warning] \u26A0\uFE0F Arquivo auto-gerado - N\xC3O EDITE",
      "> Este arquivo \xE9 atualizado automaticamente durante o sync.",
      ">",
      "> **Para adicionar cita\xE7\xF5es**: Atualize os arquivos `.relations.md` relevantes.",
      ""
    );
    const grouped = this.groupByStory(citations);
    for (const [storyId, entries] of grouped.entries()) {
      const storyLabel = entries[0].storyTitle;
      const storyPath = (_d = entries[0].storyPath) != null ? _d : storyId;
      lines.push(`## [[${storyPath}|${storyLabel}]]`, "");
      const byRelation = this.groupByRelationType(entries);
      for (const [relationType, relationEntries] of byRelation.entries()) {
        lines.push(`### ${this.titleCase(relationType)} (\`relation_type: ${relationType}\`)`);
        relationEntries.forEach((entry) => {
          var _a2;
          const context = entry.chapterTitle ? ` (Chapter: ${entry.chapterTitle})` : "";
          const sourcePath = (_a2 = entry.sourcePath) != null ? _a2 : entry.sourceId;
          lines.push(
            `- [[${sourcePath}|${entry.sourceTitle}]]${context}${entry.summary ? `
  - *"${entry.summary}"*` : ""}`
          );
        });
        lines.push("");
      }
    }
    lines.push("---", "", "## Summary", "", "| Story | relation_type | Count |", "|-------|---------------|-------|");
    for (const [storyId, entries] of grouped.entries()) {
      const byRelation = this.groupByRelationType(entries);
      for (const [relationType, relationEntries] of byRelation.entries()) {
        lines.push(`| ${entries[0].storyTitle} | ${relationType} | ${relationEntries.length} |`);
      }
    }
    const total = citations.length;
    lines.push(`| **Total** | | **${total}** |`);
    return lines.join("\n").trimEnd() + "\n";
  }
  groupByStory(citations) {
    const map2 = /* @__PURE__ */ new Map();
    citations.forEach((citation) => {
      if (!map2.has(citation.storyId)) {
        map2.set(citation.storyId, []);
      }
      map2.get(citation.storyId).push(citation);
    });
    return map2;
  }
  groupByRelationType(citations) {
    const map2 = /* @__PURE__ */ new Map();
    citations.forEach((citation) => {
      if (!map2.has(citation.relationType)) {
        map2.set(citation.relationType, []);
      }
      map2.get(citation.relationType).push(citation);
    });
    return map2;
  }
  titleCase(value) {
    return value.split(/[_\s]/g).map((part) => part.charAt(0).toUpperCase() + part.slice(1)).join(" ");
  }
};

// src/sync-v2/relations/mappers.ts
function mapRelationsToGeneratorInput({
  entity,
  relations,
  resolveTarget,
  options
}) {
  const parsed = [];
  relations.forEach((relation) => {
    var _a;
    const resolved = resolveTarget == null ? void 0 : resolveTarget(relation);
    if (!resolved) {
      if (!resolveTarget) {
        parsed.push({
          targetType: relation.target_type,
          targetId: relation.target_id,
          targetName: relation.target_id,
          relationType: relation.relation_type,
          summary: relation.context
        });
      }
      return;
    }
    parsed.push({
      targetType: relation.target_type,
      targetId: resolved.targetId,
      targetName: resolved.targetName,
      relationType: relation.relation_type,
      summary: (_a = resolved.summary) != null ? _a : relation.context,
      contextLabel: resolved.contextLabel
    });
  });
  return {
    entity,
    relations: parsed,
    options
  };
}
function mapCitationsToGeneratorInput({
  entity,
  relations,
  resolveSource,
  options
}) {
  const citations = [];
  relations.forEach((relation) => {
    var _a;
    const source = resolveSource(relation);
    if (!source) {
      return;
    }
    citations.push({
      storyId: source.storyId,
      storyTitle: source.storyTitle,
      storyPath: source.storyPath,
      relationType: relation.relation_type,
      sourceType: source.sourceType,
      sourceId: relation.source_id,
      sourceTitle: source.sourceTitle,
      sourcePath: source.sourcePath,
      chapterTitle: source.chapterTitle,
      summary: (_a = source.summary) != null ? _a : relation.context
    });
  });
  return {
    entity,
    citations,
    options
  };
}

// src/sync-v2/parsers/relationsParser.ts
var FRONTMATTER_REGEX = /^---\n([\s\S]*?)\n---/;
var HEADING_REGEX = /^##\s+(.+)$/;
var ENTRY_REGEX = /^-\s+(.*)$/;
var LINK_REGEX = /\[\[([^[\]|]+)(?:\|([^[\]]+))?\]\]/;
var RelationsParser = class {
  parse(content) {
    var _a;
    const frontmatter = this.parseFrontmatter(content);
    const body = content.replace(FRONTMATTER_REGEX, "").trim();
    const sections = [];
    let currentSection = null;
    for (const rawLine of body.split("\n")) {
      const line = rawLine.trimEnd();
      if (!line)
        continue;
      const headingMatch = line.match(HEADING_REGEX);
      if (headingMatch) {
        currentSection = {
          name: headingMatch[1].trim(),
          entries: []
        };
        sections.push(currentSection);
        continue;
      }
      if (!currentSection) {
        continue;
      }
      const entryMatch = line.match(ENTRY_REGEX);
      if (!entryMatch) {
        continue;
      }
      const entry = entryMatch[1].trim();
      const placeholder = entry.startsWith("_") && entry.endsWith("_");
      const linkMatch = entry.match(LINK_REGEX);
      let link;
      let displayText = entry;
      let description;
      if (linkMatch) {
        link = linkMatch[1].trim();
        displayText = ((_a = linkMatch[2]) != null ? _a : linkMatch[1]).trim();
        const remainder = entry.slice(linkMatch[0].length).trim();
        if (remainder.startsWith("-")) {
          description = remainder.slice(1).trim();
        }
      } else if (entry.includes("-")) {
        const [name, desc] = entry.split("-").map((part) => part.trim());
        displayText = name;
        description = desc;
      }
      currentSection.entries.push({
        link,
        displayText,
        description,
        placeholder,
        raw: line
      });
    }
    return { frontmatter, sections };
  }
  formatEntry(entry) {
    const prefix = entry.placeholder ? "_" : "- ";
    const suffix = entry.placeholder ? "_" : "";
    const link = entry.link ? `[[${entry.link}|${entry.displayText}]]` : entry.displayText;
    const description = entry.description ? ` - ${entry.description}` : "";
    return `${prefix}${link}${description}${suffix}`;
  }
  parseFrontmatter(content) {
    const match = content.match(FRONTMATTER_REGEX);
    if (!match) {
      return {};
    }
    const lines = match[1].split("\n");
    const data = {};
    for (const line of lines) {
      const colon = line.indexOf(":");
      if (colon === -1)
        continue;
      const key = line.slice(0, colon).trim();
      const value = line.slice(colon + 1).trim().replace(/^["']|["']$/g, "");
      data[key] = value;
    }
    return data;
  }
};

// src/sync-v2/push/RelationsPushHandler.ts
var TARGET_TYPE_MAP = {
  "Main Characters": "character",
  "Key Locations": "location",
  "Referenced Factions": "faction",
  "Timeline Events": "event",
  "Artifacts": "artifact",
  "Lore References": "lore"
};
var RelationsPushHandler = class {
  constructor(parser = new RelationsParser()) {
    this.parser = parser;
  }
  async pushRelations(relationsFilePath, sourceEntityType, sourceEntityId, context, worldId) {
    var _a, _b;
    const result = {
      created: 0,
      updated: 0,
      deleted: 0,
      warnings: []
    };
    try {
      const currentContent = await context.fileManager.readFile(relationsFilePath);
      const parsed = this.parser.parse(currentContent);
      const idField = context.settings.frontmatterIdField;
      const frontmatterId = getFrontmatterId(parsed.frontmatter, idField);
      if (!frontmatterId || frontmatterId !== sourceEntityId) {
        result.warnings.push(
          `Frontmatter ID mismatch: expected ${sourceEntityId}, found ${frontmatterId != null ? frontmatterId : "none"} (using field: ${idField || "id"})`
        );
        return result;
      }
      let existingRelations;
      if (worldId) {
        const existingRelationsResponse = await context.apiClient.listRelationsByWorld({
          worldId
        });
        existingRelations = existingRelationsResponse.data;
      } else {
        const existingRelationsResponse = await context.apiClient.listRelationsByTarget({
          targetType: sourceEntityType,
          targetId: sourceEntityId
        });
        existingRelations = existingRelationsResponse.data;
      }
      const existingRelationsMap = /* @__PURE__ */ new Map();
      existingRelations.forEach((rel) => {
        if (worldId) {
          const key = `${rel.target_type}:${rel.target_id}:${rel.relation_type}`;
          if (!existingRelationsMap.has(key)) {
            existingRelationsMap.set(key, []);
          }
          existingRelationsMap.get(key).push(rel);
        } else {
          const key = `${rel.source_type}:${rel.source_id}:${rel.relation_type}`;
          if (!existingRelationsMap.has(key)) {
            existingRelationsMap.set(key, []);
          }
          existingRelationsMap.get(key).push(rel);
        }
      });
      const fileRelationsMap = /* @__PURE__ */ new Map();
      for (const section of parsed.sections) {
        if (section.name === "World")
          continue;
        const entityType = TARGET_TYPE_MAP[section.name];
        if (!entityType) {
          result.warnings.push(`Unknown section type: ${section.name}`);
          continue;
        }
        for (const entry of section.entries) {
          if (entry.placeholder)
            continue;
          if (!entry.link) {
            result.warnings.push(`Entry without link in section ${section.name}: ${entry.displayText}`);
            continue;
          }
          const entityId = await this.resolveEntityId(entry.link, entityType, context);
          if (!entityId) {
            result.warnings.push(`Could not resolve entity ID for link: ${entry.link}`);
            continue;
          }
          const relationType = this.inferRelationType(entityType, section.name);
          if (worldId) {
            const key = `${entityType}:${entityId}:${relationType}`;
            if (!fileRelationsMap.has(key)) {
              fileRelationsMap.set(key, { entry, sectionName: section.name });
            }
          } else {
            const key = `${entityType}:${entityId}:${relationType}`;
            fileRelationsMap.set(key, { entry, sectionName: section.name });
          }
        }
      }
      if (worldId) {
        for (const [key, { entry, sectionName }] of fileRelationsMap.entries()) {
          if (!entry.link)
            continue;
          const targetType = TARGET_TYPE_MAP[sectionName];
          if (!targetType)
            continue;
          const targetId = await this.resolveEntityId(entry.link, targetType, context);
          if (!targetId)
            continue;
          const relationType = this.inferRelationType(targetType, sectionName);
          const existingRelations2 = (_a = existingRelationsMap.get(key)) != null ? _a : [];
          if (existingRelations2.length === 0) {
            result.warnings.push(
              `No existing relation found for target ${targetType}:${targetId} with type ${relationType}. Cannot create new relation without source.`
            );
            continue;
          }
          const relationToUpdate = existingRelations2[0];
          if (relationToUpdate.context !== entry.description) {
            try {
              await context.apiClient.updateRelation({
                id: relationToUpdate.id,
                context: entry.description
              });
              result.updated++;
            } catch (error) {
              result.warnings.push(`Failed to update relation ${relationToUpdate.id}: ${error}`);
            }
          }
        }
        for (const [key, relations] of existingRelationsMap.entries()) {
          if (!fileRelationsMap.has(key)) {
          }
        }
      } else {
        for (const [key, relations] of existingRelationsMap.entries()) {
          if (!fileRelationsMap.has(key)) {
            for (const relation of relations) {
              try {
                await context.apiClient.deleteRelation(relation.id);
                result.deleted++;
              } catch (error) {
                result.warnings.push(`Failed to delete relation ${relation.id}: ${error}`);
              }
            }
          }
        }
        for (const [key, { entry, sectionName }] of fileRelationsMap.entries()) {
          if (!entry.link)
            continue;
          const sourceType = TARGET_TYPE_MAP[sectionName];
          if (!sourceType)
            continue;
          const sourceId = await this.resolveEntityId(entry.link, sourceType, context);
          if (!sourceId)
            continue;
          const relationType = this.inferRelationType(sourceType, sectionName);
          const existingRelations2 = (_b = existingRelationsMap.get(key)) != null ? _b : [];
          const existingRelation = existingRelations2[0];
          if (existingRelation) {
            if (existingRelation.context !== entry.description) {
              try {
                await context.apiClient.updateRelation({
                  id: existingRelation.id,
                  context: entry.description
                });
                result.updated++;
              } catch (error) {
                result.warnings.push(`Failed to update relation ${existingRelation.id}: ${error}`);
              }
            }
          } else {
            try {
              const sourceExists = await this.validateEntityExists(sourceType, sourceId, context);
              if (!sourceExists) {
                result.warnings.push(`Source entity ${sourceType}:${sourceId} does not exist`);
                continue;
              }
              const targetExists = await this.validateEntityExists(sourceEntityType, sourceEntityId, context);
              if (!targetExists) {
                result.warnings.push(`Target entity ${sourceEntityType}:${sourceEntityId} does not exist`);
                continue;
              }
              await context.apiClient.createRelation({
                sourceType,
                sourceId,
                targetType: sourceEntityType,
                targetId: sourceEntityId,
                relationType,
                context: entry.description
              });
              result.created++;
            } catch (error) {
              result.warnings.push(
                `Failed to create relation from ${sourceType}:${sourceId} to ${sourceEntityType}:${sourceEntityId}: ${error}`
              );
            }
          }
        }
      }
    } catch (error) {
      result.warnings.push(`Failed to push relations: ${error}`);
    }
    return result;
  }
  async resolveEntityId(link, entityType, context) {
    const normalized = resolveLinkBasename(link);
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    if (uuidRegex.test(normalized)) {
      return normalized;
    }
    try {
      switch (entityType) {
        case "character": {
          try {
            const char = await context.apiClient.getCharacter(normalized);
            return char.id;
          } catch (e) {
            return null;
          }
        }
        case "location": {
          try {
            const loc = await context.apiClient.getLocation(normalized);
            return loc.id;
          } catch (e) {
            return null;
          }
        }
        case "faction": {
          try {
            const faction = await context.apiClient.getFaction(normalized);
            return faction.id;
          } catch (e) {
            return null;
          }
        }
        case "artifact": {
          try {
            const artifact = await context.apiClient.getArtifact(normalized);
            return artifact.id;
          } catch (e) {
            return null;
          }
        }
        case "event": {
          try {
            const event = await context.apiClient.getEvent(normalized);
            return event.id;
          } catch (e) {
            return null;
          }
        }
        case "lore": {
          try {
            const lore = await context.apiClient.getLore(normalized);
            return lore.id;
          } catch (e) {
            return null;
          }
        }
        default:
          return null;
      }
    } catch (error) {
      console.warn(`[RelationsPushHandler] Failed to resolve entity ID for ${entityType}:${link}`, error);
      return null;
    }
  }
  inferRelationType(targetType, sectionName) {
    switch (sectionName) {
      case "Main Characters":
        return "pov";
      case "Key Locations":
        return "setting";
      case "Referenced Factions":
        return "faction_reference";
      case "Timeline Events":
        return "timeline_event";
      case "Artifacts":
        return "artifact_reference";
      case "Lore References":
        return "lore_reference";
      default:
        return "reference";
    }
  }
  async validateEntityExists(entityType, entityId, context) {
    try {
      switch (entityType) {
        case "character":
          await context.apiClient.getCharacter(entityId);
          return true;
        case "location":
          await context.apiClient.getLocation(entityId);
          return true;
        case "faction":
          await context.apiClient.getFaction(entityId);
          return true;
        case "artifact":
          await context.apiClient.getArtifact(entityId);
          return true;
        case "event":
          await context.apiClient.getEvent(entityId);
          return true;
        case "lore":
          await context.apiClient.getLore(entityId);
          return true;
        case "story":
          await context.apiClient.getStory(entityId);
          return true;
        case "world":
          await context.apiClient.getWorld(entityId);
          return true;
        default:
          return true;
      }
    } catch (error) {
      return false;
    }
  }
};

// src/sync-v2/fileRenamer/PathResolver.ts
var import_obsidian15 = require("obsidian");
var CONTENT_FOLDER_BY_TYPE = {
  text: "00-texts",
  image: "01-images",
  video: "02-videos",
  audio: "03-audios",
  embed: "04-embeds",
  link: "05-links"
};
var PathResolver = class {
  constructor(storyFolder) {
    this.storyFolder = storyFolder;
  }
  getChapterPath(chapter, overrides) {
    var _a, _b, _c, _d;
    const order = (_b = (_a = overrides == null ? void 0 : overrides.order) != null ? _a : chapter.number) != null ? _b : 0;
    const title = (_d = (_c = overrides == null ? void 0 : overrides.title) != null ? _c : chapter.title) != null ? _d : "chapter";
    return (0, import_obsidian15.normalizePath)(
      `${this.storyFolder}/00-chapters/${this.buildFileName("ch", order, title)}`
    );
  }
  getScenePath(scene, overrides) {
    var _a, _b, _c, _d, _e;
    const order = (_b = (_a = overrides == null ? void 0 : overrides.order) != null ? _a : scene.order_num) != null ? _b : 0;
    const chapterOrder = (_c = overrides == null ? void 0 : overrides.chapterOrder) != null ? _c : 0;
    const goal = (_e = (_d = overrides == null ? void 0 : overrides.goal) != null ? _d : scene.goal) != null ? _e : "scene";
    return (0, import_obsidian15.normalizePath)(
      `${this.storyFolder}/01-scenes/${this.buildCompositeFileName(
        "sc",
        [chapterOrder, order],
        goal
      )}`
    );
  }
  getBeatPath(beat, overrides) {
    var _a, _b, _c, _d, _e, _f;
    const order = (_b = (_a = overrides == null ? void 0 : overrides.order) != null ? _a : beat.order_num) != null ? _b : 0;
    const chapterOrder = (_c = overrides == null ? void 0 : overrides.chapterOrder) != null ? _c : 0;
    const sceneOrder = (_d = overrides == null ? void 0 : overrides.sceneOrder) != null ? _d : 0;
    const intent = (_f = (_e = overrides == null ? void 0 : overrides.intent) != null ? _e : beat.intent) != null ? _f : "beat";
    return (0, import_obsidian15.normalizePath)(
      `${this.storyFolder}/02-beats/${this.buildCompositeFileName(
        "bt",
        [chapterOrder, sceneOrder, order],
        intent
      )}`
    );
  }
  getContentBlockPath(contentBlock, overrides) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    const order = (_b = (_a = overrides == null ? void 0 : overrides.order) != null ? _a : contentBlock.order_num) != null ? _b : 0;
    const title = (_g = (_f = (_e = (_d = overrides == null ? void 0 : overrides.title) != null ? _d : (_c = contentBlock.metadata) == null ? void 0 : _c.title) != null ? _e : contentBlock.kind) != null ? _f : contentBlock.type) != null ? _g : "content";
    const type2 = ((_i = (_h = overrides == null ? void 0 : overrides.type) != null ? _h : contentBlock.type) != null ? _i : "text").toLowerCase();
    const folder = (_j = CONTENT_FOLDER_BY_TYPE[type2]) != null ? _j : "99-other";
    return (0, import_obsidian15.normalizePath)(
      `${this.storyFolder}/03-contents/${folder}/${this.buildFileName("cb", order, title)}`
    );
  }
  buildFileName(prefix, order, label) {
    return `${prefix}-${this.padOrder(order)}-${this.sanitize(label)}.md`;
  }
  buildCompositeFileName(prefix, orders, label) {
    const orderTags = orders.map((order) => this.padOrder(order)).join("-");
    return `${prefix}-${orderTags}-${this.sanitize(label)}.md`;
  }
  padOrder(order) {
    const value = typeof order === "number" && Number.isFinite(order) ? Math.max(0, order) : 0;
    return String(value).padStart(4, "0");
  }
  sanitize(value) {
    const sanitized = value.normalize("NFKD").replace(/[^\w\s-]/g, "").trim().replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "").toLowerCase();
    return sanitized || "untitled";
  }
};

// src/sync-v2/generators/FrontmatterGenerator.ts
var FrontmatterGenerator = class {
  generate(baseFields, extraFields, options) {
    const idField = options == null ? void 0 : options.idField;
    const customIdField = getIdFieldName(idField);
    let fields = { ...baseFields };
    if (customIdField !== "id" && "id" in fields) {
      const idValue = fields.id;
      delete fields.id;
      fields = {
        [customIdField]: idValue,
        ...fields
      };
    }
    if (extraFields) {
      const sanitizedExtraFields = { ...extraFields };
      if (customIdField !== "id" && "id" in sanitizedExtraFields) {
        delete sanitizedExtraFields.id;
      }
      Object.assign(fields, sanitizedExtraFields);
    }
    if (customIdField !== "id" && "id" in fields) {
      delete fields.id;
    }
    const tags = [];
    if (options) {
      tags.push(`story-engine/${options.entityType}`);
      if (options.storyName) {
        const sanitizedStoryName = this.sanitizeForTag(options.storyName);
        tags.push(`story/${sanitizedStoryName}`);
      }
      if (options.worldName) {
        const sanitizedWorldName = this.sanitizeForTag(options.worldName);
        tags.push(`world/${sanitizedWorldName}`);
      }
      if (options.date) {
        const date = typeof options.date === "string" ? new Date(options.date) : options.date;
        if (!isNaN(date.getTime())) {
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, "0");
          const day = String(date.getDate()).padStart(2, "0");
          tags.push(`date/${year}/${month}/${day}`);
        }
      }
    }
    const lines = ["---"];
    for (const [key, value] of Object.entries(fields)) {
      if (value === null || value === void 0) {
        lines.push(`${key}: null`);
      } else if (typeof value === "string") {
        const escaped = value.replace(/"/g, '\\"');
        if (value.includes(":") || value.includes("\n") || value.includes('"')) {
          lines.push(`${key}: "${escaped}"`);
        } else {
          lines.push(`${key}: ${escaped}`);
        }
      } else {
        lines.push(`${key}: ${value}`);
      }
    }
    if (tags.length > 0) {
      lines.push(`tags:`);
      for (const tag of tags) {
        lines.push(`  - ${tag}`);
      }
    }
    lines.push("---");
    return lines.join("\n");
  }
  sanitizeForTag(value) {
    return value.toLowerCase().normalize("NFKD").replace(/[^\w\s-]/g, "").trim().replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "");
  }
};

// src/sync-v2/utils/detectEntityMentions.ts
function detectEntityMentions(content) {
  const mentions = [];
  const linkRegex = /\[\[([^\]]+)\]\]/g;
  let match;
  while ((match = linkRegex.exec(content)) !== null) {
    const fullLink = match[0];
    const linkContent = match[1];
    const [filenamePath, displayLabel] = linkContent.split("|").map((s) => s.trim());
    const format2 = filenamePath.includes("/") ? "official" : "obsidian";
    mentions.push({
      linkText: fullLink,
      filenamePath,
      displayLabel: displayLabel || void 0,
      format: format2
    });
  }
  return mentions;
}
async function resolveEntityMention(mention, context) {
  try {
    const vault = context.app.vault;
    const metadataCache = context.app.metadataCache;
    let file = null;
    if (mention.format === "official") {
      const filePath = mention.filenamePath.endsWith(".md") ? mention.filenamePath : `${mention.filenamePath}.md`;
      const abstractFile = vault.getAbstractFileByPath(filePath);
      if (abstractFile && "path" in abstractFile && !("children" in abstractFile)) {
        file = abstractFile;
      }
    } else {
      const markdownFiles = vault.getMarkdownFiles();
      file = markdownFiles.find((f) => {
        return f.basename === mention.filenamePath;
      }) || null;
      if (!file) {
        const resolvedFile = metadataCache.getFirstLinkpathDest(mention.filenamePath, "");
        if (resolvedFile && "path" in resolvedFile && !("children" in resolvedFile)) {
          file = resolvedFile;
        }
      }
      if (!file) {
        file = markdownFiles.find((f) => {
          return f.name === `${mention.filenamePath}.md`;
        }) || null;
      }
    }
    if (!file) {
      return null;
    }
    const fileContent = await vault.read(file);
    const frontmatter = parseFrontmatter(fileContent);
    const entityType = inferEntityTypeFromFile(file.path, frontmatter);
    if (!entityType) {
      return null;
    }
    const idField = context.settings.frontmatterIdField;
    const entityId = getFrontmatterId(frontmatter, idField);
    if (!entityId) {
      return null;
    }
    const worldId = frontmatter.world_id;
    return {
      entityId,
      entityType,
      worldId: worldId === null ? void 0 : worldId
    };
  } catch (error) {
    console.warn("[Sync V2] Failed to resolve entity mention", {
      mention,
      error
    });
    return null;
  }
}
function parseFrontmatter(content) {
  const match = content.match(/^---\n([\s\S]*?)\n---/);
  if (!match) {
    return {};
  }
  const frontmatterText = match[1];
  const result = {};
  const lines = frontmatterText.split("\n");
  let i = 0;
  while (i < lines.length) {
    const line = lines[i].trim();
    if (!line || line.startsWith("#")) {
      i++;
      continue;
    }
    const colonIndex = line.indexOf(":");
    if (colonIndex > 0) {
      const key = line.slice(0, colonIndex).trim();
      let value = line.slice(colonIndex + 1).trim();
      if (key === "tags" && (value === "" || value === "[]")) {
        const tags = [];
        i++;
        while (i < lines.length) {
          const nextLine = lines[i].trim();
          if (nextLine.startsWith("-")) {
            const tagMatch = nextLine.match(/^\s*-\s*(.+)/);
            if (tagMatch) {
              let tagValue = tagMatch[1].trim().replace(/^["']|["']$/g, "");
              tags.push(tagValue);
            }
            i++;
          } else if (nextLine === "" || nextLine.startsWith("#")) {
            i++;
          } else {
            break;
          }
        }
        result[key] = tags;
        continue;
      }
      if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
        value = value.slice(1, -1);
      }
      if (value === "null" || value === "") {
        result[key] = null;
      } else if (value === "true" || value === "false") {
        result[key] = value === "true";
      } else if (/^-?\d+$/.test(value)) {
        result[key] = parseInt(value, 10);
      } else if (/^-?\d+\.\d+$/.test(value)) {
        result[key] = parseFloat(value);
      } else {
        result[key] = value;
      }
    } else if (line.startsWith("-")) {
    }
    i++;
  }
  return result;
}
function inferEntityTypeFromFile(filePath, frontmatter) {
  if (frontmatter.entity_type && typeof frontmatter.entity_type === "string") {
    return frontmatter.entity_type;
  }
  if (frontmatter.tags && Array.isArray(frontmatter.tags)) {
    for (const tag of frontmatter.tags) {
      if (typeof tag === "string" && tag.startsWith("story-engine/")) {
        const entityType = tag.replace("story-engine/", "");
        return entityType;
      }
    }
  }
  const pathPatterns = {
    "/_archetypes/": "archetype",
    // More specific patterns first
    "/_traits/": "trait",
    "/worlds/": "world",
    "/characters/": "character",
    "/locations/": "location",
    "/factions/": "faction",
    "/artifacts/": "artifact",
    "/events/": "event",
    "/lore/": "lore",
    "/chapters/": "chapter",
    "/scenes/": "scene",
    "/beats/": "beat",
    "/contents/": "content_block"
  };
  for (const [pattern, entityType] of Object.entries(pathPatterns)) {
    if (filePath.includes(pattern)) {
      return entityType;
    }
  }
  return null;
}

// src/sync-v2/parsers/worldEntityParser.ts
function parseWorldEntityFile(content) {
  var _a;
  const frontmatter = parseFrontmatter(content);
  const nameMatch = content.match(/^#\s+(.+)$/m);
  const name = nameMatch ? nameMatch[1].trim() : "";
  const descriptionMatch = content.match(/##\s+Description\n([\s\S]*?)(?=\n##|$)/);
  let description = null;
  if (descriptionMatch) {
    const desc = descriptionMatch[1].trim();
    if (desc && desc !== "_No description yet._") {
      description = desc;
    }
  }
  return {
    id: (_a = frontmatter.id) != null ? _a : "",
    name,
    description,
    frontmatter
  };
}

// src/sync-v2/handlers/world/CharacterHandler.ts
var CharacterHandler = class {
  constructor() {
    this.entityType = "character";
    this.frontmatterGenerator = new FrontmatterGenerator();
  }
  async pull(id2, context) {
    const character = await context.apiClient.getCharacter(id2);
    const world = await context.apiClient.getWorld(character.world_id);
    const folderPath = context.fileManager.getWorldFolderPath(world.name);
    const charactersFolder = `${folderPath}/characters`;
    await context.fileManager.ensureFolderExists(charactersFolder);
    const filePath = `${charactersFolder}/${slugify(character.name)}.md`;
    await context.fileManager.writeFile(filePath, this.renderCharacter(character, world, context));
    return character;
  }
  async push(entity, context) {
    var _a, _b;
    const world = await context.apiClient.getWorld(entity.world_id);
    const folderPath = context.fileManager.getWorldFolderPath(world.name);
    const filePath = `${folderPath}/characters/${slugify(entity.name)}.md`;
    let localContent;
    try {
      localContent = await context.fileManager.readFile(filePath);
    } catch (e) {
      return;
    }
    const parsed = parseWorldEntityFile(localContent);
    const normalizedDescription = (_a = parsed.description) != null ? _a : void 0;
    const existingDescription = (_b = entity.description) != null ? _b : void 0;
    if (parsed.name === entity.name && (normalizedDescription != null ? normalizedDescription : "") === (existingDescription != null ? existingDescription : "")) {
      return;
    }
    await context.apiClient.updateCharacter(entity.id, {
      name: parsed.name,
      description: normalizedDescription
    });
  }
  async delete(id2, context) {
    await context.apiClient.deleteCharacter(id2);
  }
  renderCharacter(character, world, context) {
    var _a, _b, _c;
    const baseFields = {
      id: character.id,
      world_id: character.world_id,
      class_level: character.class_level,
      archetype_id: (_a = character.archetype_id) != null ? _a : null,
      current_class_id: (_b = character.current_class_id) != null ? _b : null,
      created_at: character.created_at,
      updated_at: character.updated_at
    };
    const frontmatter = this.frontmatterGenerator.generate(baseFields, void 0, {
      entityType: "character",
      worldName: world.name,
      date: character.created_at,
      idField: context.settings.frontmatterIdField
    });
    return [
      frontmatter,
      "",
      `# ${character.name}`,
      "",
      "## Description",
      character.description || "_No description yet._",
      "",
      "## Metadata",
      `- Tenant: ${character.tenant_id}`,
      `- Archetype: ${(_c = character.archetype_id) != null ? _c : "\u2014"}`,
      `- Class Level: ${character.class_level}`,
      ""
    ].join("\n");
  }
};

// src/sync-v2/handlers/world/LocationHandler.ts
var LocationHandler = class {
  constructor() {
    this.entityType = "location";
    this.frontmatterGenerator = new FrontmatterGenerator();
  }
  async pull(id2, context) {
    const location = await context.apiClient.getLocation(id2);
    const world = await context.apiClient.getWorld(location.world_id);
    const folderPath = context.fileManager.getWorldFolderPath(world.name);
    const locationsFolder = `${folderPath}/locations`;
    await context.fileManager.ensureFolderExists(locationsFolder);
    const filePath = `${locationsFolder}/${slugify(location.name)}.md`;
    await context.fileManager.writeFile(filePath, this.renderLocation(location, world, context));
    return location;
  }
  async push(entity, context) {
    var _a, _b, _c;
    const world = await context.apiClient.getWorld((_a = entity.world_id) != null ? _a : "");
    const folderPath = context.fileManager.getWorldFolderPath(world.name);
    const filePath = `${folderPath}/locations/${slugify(entity.name) || entity.id}.md`;
    let localContent;
    try {
      localContent = await context.fileManager.readFile(filePath);
    } catch (e) {
      return;
    }
    const parsed = parseWorldEntityFile(localContent);
    const description = (_b = parsed.description) != null ? _b : void 0;
    if (parsed.name === entity.name && (description != null ? description : "") === ((_c = entity.description) != null ? _c : "")) {
      return;
    }
    await context.apiClient.updateLocation(entity.id, {
      name: parsed.name,
      description
    });
  }
  async delete(id2, context) {
    await context.apiClient.deleteLocation(id2);
  }
  renderLocation(location, world, context) {
    var _a;
    const baseFields = {
      id: location.id,
      world_id: location.world_id,
      type: location.type,
      hierarchy_level: location.hierarchy_level,
      parent_id: (_a = location.parent_id) != null ? _a : null,
      created_at: location.created_at,
      updated_at: location.updated_at
    };
    const frontmatter = this.frontmatterGenerator.generate(baseFields, void 0, {
      entityType: "location",
      worldName: world.name,
      date: location.created_at,
      idField: context.settings.frontmatterIdField
    });
    return [
      frontmatter,
      "",
      `# ${location.name}`,
      "",
      "## Description",
      location.description || "_No description yet._",
      "",
      "## Notes",
      location.type ? `- Type: ${location.type}` : "- Type: \u2014",
      ""
    ].join("\n");
  }
};

// src/sync-v2/handlers/world/FactionHandler.ts
var FactionHandler = class {
  constructor() {
    this.entityType = "faction";
    this.frontmatterGenerator = new FrontmatterGenerator();
  }
  async pull(id2, context) {
    const faction = await context.apiClient.getFaction(id2);
    const world = await context.apiClient.getWorld(faction.world_id);
    const folderPath = context.fileManager.getWorldFolderPath(world.name);
    const factionsFolder = `${folderPath}/factions`;
    await context.fileManager.ensureFolderExists(factionsFolder);
    const filePath = `${factionsFolder}/${slugify(faction.name)}.md`;
    await context.fileManager.writeFile(filePath, this.renderFaction(faction, world, context));
    return faction;
  }
  async push(entity, context) {
    var _a, _b;
    const world = await context.apiClient.getWorld(entity.world_id);
    const folderPath = context.fileManager.getWorldFolderPath(world.name);
    const filePath = `${folderPath}/factions/${slugify(entity.name)}.md`;
    let localContent;
    try {
      localContent = await context.fileManager.readFile(filePath);
    } catch (e) {
      return;
    }
    const parsed = parseWorldEntityFile(localContent);
    const description = (_a = parsed.description) != null ? _a : void 0;
    if (parsed.name === entity.name && (description != null ? description : "") === ((_b = entity.description) != null ? _b : "")) {
      return;
    }
    await context.apiClient.updateFaction(entity.id, {
      name: parsed.name,
      description
    });
  }
  async delete(id2, context) {
    await context.apiClient.deleteFaction(id2);
  }
  renderFaction(faction, world, context) {
    var _a, _b;
    const baseFields = {
      id: faction.id,
      world_id: faction.world_id,
      type: (_a = faction.type) != null ? _a : null,
      hierarchy_level: faction.hierarchy_level,
      parent_id: (_b = faction.parent_id) != null ? _b : null,
      created_at: faction.created_at,
      updated_at: faction.updated_at
    };
    const frontmatter = this.frontmatterGenerator.generate(baseFields, void 0, {
      entityType: "faction",
      worldName: world.name,
      date: faction.created_at,
      idField: context.settings.frontmatterIdField
    });
    return [
      frontmatter,
      "",
      `# ${faction.name}`,
      "",
      "## Description",
      faction.description || "_No description yet._",
      "",
      "## Beliefs & Structure",
      faction.beliefs || "_Beliefs pending._",
      "",
      faction.structure || "_Structure pending._",
      ""
    ].join("\n");
  }
};

// src/sync-v2/handlers/world/ArtifactHandler.ts
var ArtifactHandler = class {
  constructor() {
    this.entityType = "artifact";
    this.frontmatterGenerator = new FrontmatterGenerator();
  }
  async pull(id2, context) {
    const artifact = await context.apiClient.getArtifact(id2);
    const world = await context.apiClient.getWorld(artifact.world_id);
    const folderPath = context.fileManager.getWorldFolderPath(world.name);
    const artifactsFolder = `${folderPath}/artifacts`;
    await context.fileManager.ensureFolderExists(artifactsFolder);
    const filePath = `${artifactsFolder}/${slugify(artifact.name)}.md`;
    await context.fileManager.writeFile(filePath, this.renderArtifact(artifact, world, context));
    return artifact;
  }
  async push(entity, context) {
    var _a, _b;
    const world = await context.apiClient.getWorld(entity.world_id);
    const folderPath = context.fileManager.getWorldFolderPath(world.name);
    const filePath = `${folderPath}/artifacts/${slugify(entity.name)}.md`;
    let localContent;
    try {
      localContent = await context.fileManager.readFile(filePath);
    } catch (e) {
      return;
    }
    const parsed = parseWorldEntityFile(localContent);
    const description = (_a = parsed.description) != null ? _a : void 0;
    if (parsed.name === entity.name && (description != null ? description : "") === ((_b = entity.description) != null ? _b : "")) {
      return;
    }
    await context.apiClient.updateArtifact(entity.id, {
      name: parsed.name,
      description
    });
  }
  async delete(id2, context) {
    await context.apiClient.deleteArtifact(id2);
  }
  renderArtifact(artifact, world, context) {
    const baseFields = {
      id: artifact.id,
      world_id: artifact.world_id,
      rarity: artifact.rarity,
      created_at: artifact.created_at,
      updated_at: artifact.updated_at
    };
    const frontmatter = this.frontmatterGenerator.generate(baseFields, void 0, {
      entityType: "artifact",
      worldName: world.name,
      date: artifact.created_at,
      idField: context.settings.frontmatterIdField
    });
    return [
      frontmatter,
      "",
      `# ${artifact.name}`,
      "",
      "## Description",
      artifact.description || "_No description yet._",
      ""
    ].join("\n");
  }
};

// src/sync-v2/handlers/world/EventHandler.ts
var EventHandler = class {
  constructor() {
    this.entityType = "event";
    this.frontmatterGenerator = new FrontmatterGenerator();
  }
  async pull(id2, context) {
    const event = await context.apiClient.getEvent(id2);
    const world = await context.apiClient.getWorld(event.world_id);
    const folderPath = context.fileManager.getWorldFolderPath(world.name);
    const eventsFolder = `${folderPath}/events`;
    await context.fileManager.ensureFolderExists(eventsFolder);
    const filePath = `${eventsFolder}/${slugify(event.name)}.md`;
    await context.fileManager.writeFile(filePath, this.renderEvent(event, world, context));
    return event;
  }
  async push(entity, context) {
    var _a, _b;
    const world = await context.apiClient.getWorld(entity.world_id);
    const folderPath = context.fileManager.getWorldFolderPath(world.name);
    const filePath = `${folderPath}/events/${slugify(entity.name)}.md`;
    let localContent;
    try {
      localContent = await context.fileManager.readFile(filePath);
    } catch (e) {
      return;
    }
    const parsed = parseWorldEntityFile(localContent);
    const description = (_a = parsed.description) != null ? _a : null;
    if (parsed.name === entity.name && description === ((_b = entity.description) != null ? _b : null)) {
      return;
    }
    await context.apiClient.updateEvent(entity.id, {
      name: parsed.name,
      description
    });
  }
  async delete(id2, context) {
    await context.apiClient.deleteEvent(id2);
  }
  renderEvent(event, world, context) {
    var _a, _b, _c;
    const baseFields = {
      id: event.id,
      world_id: event.world_id,
      type: (_a = event.type) != null ? _a : null,
      importance: event.importance,
      timeline: (_b = event.timeline) != null ? _b : null,
      parent_id: (_c = event.parent_id) != null ? _c : null,
      created_at: event.created_at,
      updated_at: event.updated_at
    };
    const frontmatter = this.frontmatterGenerator.generate(baseFields, void 0, {
      entityType: "event",
      worldName: world.name,
      date: event.created_at,
      idField: context.settings.frontmatterIdField
    });
    return [
      frontmatter,
      "",
      `# ${event.name}`,
      "",
      "## Description",
      event.description || "_No description yet._",
      ""
    ].join("\n");
  }
};

// src/sync-v2/handlers/world/LoreHandler.ts
var LoreHandler = class {
  constructor() {
    this.entityType = "lore";
    this.frontmatterGenerator = new FrontmatterGenerator();
  }
  async pull(id2, context) {
    const lore = await context.apiClient.getLore(id2);
    const world = await context.apiClient.getWorld(lore.world_id);
    const folderPath = context.fileManager.getWorldFolderPath(world.name);
    const loreFolder = `${folderPath}/lore`;
    await context.fileManager.ensureFolderExists(loreFolder);
    const filePath = `${loreFolder}/${slugify(lore.name)}.md`;
    await context.fileManager.writeFile(filePath, this.renderLore(lore, world, context));
    return lore;
  }
  async push(entity, context) {
    var _a, _b;
    const world = await context.apiClient.getWorld(entity.world_id);
    const folderPath = context.fileManager.getWorldFolderPath(world.name);
    const filePath = `${folderPath}/lore/${slugify(entity.name)}.md`;
    let localContent;
    try {
      localContent = await context.fileManager.readFile(filePath);
    } catch (e) {
      return;
    }
    const parsed = parseWorldEntityFile(localContent);
    const description = (_a = parsed.description) != null ? _a : void 0;
    if (parsed.name === entity.name && (description != null ? description : "") === ((_b = entity.description) != null ? _b : "")) {
      return;
    }
    await context.apiClient.updateLore(entity.id, {
      name: parsed.name,
      description
    });
  }
  async delete(id2, context) {
    await context.apiClient.deleteLore(id2);
  }
  renderLore(lore, world, context) {
    var _a, _b;
    const baseFields = {
      id: lore.id,
      world_id: lore.world_id,
      category: (_a = lore.category) != null ? _a : null,
      parent_id: (_b = lore.parent_id) != null ? _b : null,
      hierarchy_level: lore.hierarchy_level,
      created_at: lore.created_at,
      updated_at: lore.updated_at
    };
    const frontmatter = this.frontmatterGenerator.generate(baseFields, void 0, {
      entityType: "lore",
      worldName: world.name,
      date: lore.created_at,
      idField: context.settings.frontmatterIdField
    });
    return [
      frontmatter,
      "",
      `# ${lore.name}`,
      "",
      "## Description",
      lore.description || "_No description yet._",
      "",
      "## Rules",
      lore.rules || "_Rules not documented._",
      ""
    ].join("\n");
  }
};

// src/sync-v2/handlers/world/WorldHandler.ts
var WorldHandler = class {
  constructor(now2 = () => (/* @__PURE__ */ new Date()).toISOString(), relationsGenerator = new RelationsGenerator(), citationsGenerator = new CitationsGenerator(), relationsPushHandler = new RelationsPushHandler()) {
    this.now = now2;
    this.relationsGenerator = relationsGenerator;
    this.citationsGenerator = citationsGenerator;
    this.relationsPushHandler = relationsPushHandler;
    this.entityType = "world";
  }
  async pull(id2, context) {
    const world = await context.apiClient.getWorld(id2);
    const folderPath = context.fileManager.getWorldFolderPath(world.name);
    await context.fileManager.ensureFolderExists(folderPath);
    await context.fileManager.ensureFolderExists(`${folderPath}/characters`);
    await context.fileManager.ensureFolderExists(`${folderPath}/locations`);
    await context.fileManager.ensureFolderExists(`${folderPath}/factions`);
    await context.fileManager.ensureFolderExists(`${folderPath}/artifacts`);
    await context.fileManager.ensureFolderExists(`${folderPath}/events`);
    await context.fileManager.ensureFolderExists(`${folderPath}/lore`);
    await context.fileManager.writeWorldMetadata(world, folderPath);
    const [characters, locations, factions, artifacts, events, loreList] = await Promise.all([
      context.apiClient.getCharacters(world.id),
      context.apiClient.getLocations(world.id),
      context.apiClient.getFactions(world.id),
      context.apiClient.getArtifacts(world.id),
      context.apiClient.getEvents(world.id),
      context.apiClient.getLores(world.id)
    ]);
    await context.fileManager.writeFile(
      `${folderPath}/world.outline.md`,
      this.renderOutline(world, { characters, locations, factions, artifacts, events, loreList }, folderPath)
    );
    await context.fileManager.writeFile(
      `${folderPath}/world.contents.md`,
      this.renderContents(world, { characters, locations, factions, artifacts, events, loreList }, folderPath)
    );
    await this.writeWorldEntityFiles(
      { characters, locations, factions, artifacts, events, loreList },
      context
    );
    await this.generateRelations(world, folderPath, context);
    await this.generateCitations(world, folderPath, context);
    return world;
  }
  async push(entity, context) {
    var _a, _b;
    const folderPath = context.fileManager.getWorldFolderPath(entity.name);
    const relationsFilePath = `${folderPath}/world.relations.md`;
    try {
      await context.fileManager.readFile(relationsFilePath);
      const result = await this.relationsPushHandler.pushRelations(
        relationsFilePath,
        "world",
        entity.id,
        context,
        entity.id
      );
      if (result.warnings.length > 0) {
        result.warnings.forEach(
          (warning) => {
            var _a2;
            return (_a2 = context.emitWarning) == null ? void 0 : _a2.call(context, {
              code: "relations_push_warning",
              message: warning,
              filePath: relationsFilePath
            });
          }
        );
      }
    } catch (error) {
      if (((_a = error == null ? void 0 : error.message) == null ? void 0 : _a.includes("missing")) || (error == null ? void 0 : error.code) === "ENOENT") {
        return;
      }
      (_b = context.emitWarning) == null ? void 0 : _b.call(context, {
        code: "relations_push_error",
        message: `Failed to push relations: ${error}`,
        filePath: relationsFilePath
      });
    }
  }
  async delete(_id, _context) {
  }
  renderOutline(world, opts, folderPath) {
    const sections = [
      {
        label: "Characters",
        items: opts.characters.map((character) => ({
          name: character.name,
          extra: `Lvl ${character.class_level}`
        }))
      },
      {
        label: "Locations",
        items: opts.locations.map((location) => {
          var _a;
          return {
            name: location.name,
            extra: (_a = location.type) != null ? _a : void 0
          };
        })
      },
      {
        label: "Factions",
        items: opts.factions.map((faction) => {
          var _a;
          return {
            name: faction.name,
            extra: (_a = faction.type) != null ? _a : void 0
          };
        })
      },
      {
        label: "Artifacts",
        items: opts.artifacts.map((artifact) => ({
          name: artifact.name,
          extra: artifact.rarity
        }))
      },
      {
        label: "Events",
        items: opts.events.map((event) => {
          var _a;
          return {
            name: event.name,
            extra: (_a = event.timeline) != null ? _a : void 0
          };
        })
      },
      {
        label: "Lore",
        items: opts.loreList.map((lore) => {
          var _a;
          return {
            name: lore.name,
            extra: (_a = lore.category) != null ? _a : void 0
          };
        })
      }
    ];
    const lines = [
      `# ${world.name} - Outline`,
      "",
      `_Atualizado em ${this.now()}_`,
      ""
    ];
    const linkFor = (name, folder) => `[[${folderPath}/${folder}/${slugify(name)}.md|${name}]]`;
    for (const section of sections) {
      lines.push(`## ${section.label}`, "");
      if (!section.items.length) {
        lines.push("_Nenhum item sincronizado ainda._", "");
        continue;
      }
      section.items.forEach((item) => {
        const folder = section.label === "Characters" ? "characters" : section.label === "Locations" ? "locations" : section.label === "Factions" ? "factions" : section.label === "Artifacts" ? "artifacts" : section.label === "Events" ? "events" : "lore";
        const link = linkFor(item.name, folder);
        lines.push(`- ${link}${item.extra ? ` (${item.extra})` : ""}`);
      });
      lines.push("");
    }
    return lines.join("\n").trimEnd() + "\n";
  }
  async writeWorldEntityFiles(entities, context) {
    const characterHandler = new CharacterHandler();
    const locationHandler = new LocationHandler();
    const factionHandler = new FactionHandler();
    const artifactHandler = new ArtifactHandler();
    const eventHandler = new EventHandler();
    const loreHandler = new LoreHandler();
    await Promise.all([
      Promise.all(entities.characters.map((character) => characterHandler.pull(character.id, context))),
      Promise.all(entities.locations.map((location) => locationHandler.pull(location.id, context))),
      Promise.all(entities.factions.map((faction) => factionHandler.pull(faction.id, context))),
      Promise.all(entities.artifacts.map((artifact) => artifactHandler.pull(artifact.id, context))),
      Promise.all(entities.events.map((event) => eventHandler.pull(event.id, context))),
      Promise.all(entities.loreList.map((lore) => loreHandler.pull(lore.id, context)))
    ]);
  }
  renderContents(world, opts, folderPath) {
    const lines = [
      `# ${world.name} - Contents`,
      "",
      "## Overview",
      world.description || "_Sem descri\xE7\xE3o._",
      "",
      "## Time Configuration",
      world.time_config ? "```json\n" + JSON.stringify(world.time_config, null, 2) + "\n```" : "_N\xE3o configurado._",
      ""
    ];
    const addSection = (label, items) => {
      lines.push(`## ${label}`, "");
      if (!items.length) {
        lines.push("_Nenhum item sincronizado ainda._", "");
        return;
      }
      items.forEach((item) => {
        const link = `[[${item.path}|${item.name}]]`;
        lines.push(`- ${link}${item.extra ? ` (${item.extra})` : ""}`);
      });
      lines.push("");
    };
    addSection(
      "Characters",
      opts.characters.map((character) => ({
        name: character.name,
        path: `${folderPath}/characters/${slugify(character.name)}.md`,
        extra: `Lvl ${character.class_level}`
      }))
    );
    addSection(
      "Locations",
      opts.locations.map((location) => {
        var _a;
        return {
          name: location.name,
          path: `${folderPath}/locations/${slugify(location.name)}.md`,
          extra: (_a = location.type) != null ? _a : void 0
        };
      })
    );
    addSection(
      "Factions",
      opts.factions.map((faction) => {
        var _a;
        return {
          name: faction.name,
          path: `${folderPath}/factions/${slugify(faction.name)}.md`,
          extra: (_a = faction.type) != null ? _a : void 0
        };
      })
    );
    addSection(
      "Artifacts",
      opts.artifacts.map((artifact) => ({
        name: artifact.name,
        path: `${folderPath}/artifacts/${slugify(artifact.name)}.md`,
        extra: artifact.rarity
      }))
    );
    addSection(
      "Events",
      opts.events.map((event) => {
        var _a;
        return {
          name: event.name,
          path: `${folderPath}/events/${slugify(event.name)}.md`,
          extra: (_a = event.timeline) != null ? _a : void 0
        };
      })
    );
    addSection(
      "Lore",
      opts.loreList.map((lore) => {
        var _a;
        return {
          name: lore.name,
          path: `${folderPath}/lore/${slugify(lore.name)}.md`,
          extra: (_a = lore.category) != null ? _a : void 0
        };
      })
    );
    return lines.join("\n");
  }
  renderRelationsPlaceholder(world) {
    return [
      `# ${world.name} - Relations`,
      "",
      "_As rela\xE7\xF5es entre characters, locations e stories ser\xE3o preenchidas na Fase 8._",
      ""
    ].join("\n");
  }
  async generateRelations(world, folderPath, context) {
    try {
      const relationsResponse = await context.apiClient.listRelationsByWorld({
        worldId: world.id
      });
      const entityCache = /* @__PURE__ */ new Map();
      const resolvedRelations = await Promise.all(
        relationsResponse.data.map(async (relation) => {
          try {
            let targetName = relation.target_id;
            let targetId = relation.target_id;
            let targetType = relation.target_type;
            const cacheKey = `${relation.target_type}:${relation.target_id}`;
            if (entityCache.has(cacheKey)) {
              const cached = entityCache.get(cacheKey);
              targetName = cached.name;
              targetId = relation.target_id;
              targetType = cached.type;
            } else {
              switch (relation.target_type) {
                case "character": {
                  const char = await context.apiClient.getCharacter(relation.target_id);
                  targetName = char.name;
                  targetId = char.id;
                  entityCache.set(cacheKey, { name: char.name, type: "character" });
                  break;
                }
                case "location": {
                  const loc = await context.apiClient.getLocation(relation.target_id);
                  targetName = loc.name;
                  targetId = loc.id;
                  entityCache.set(cacheKey, { name: loc.name, type: "location" });
                  break;
                }
                case "faction": {
                  const faction = await context.apiClient.getFaction(relation.target_id);
                  targetName = faction.name;
                  targetId = faction.id;
                  entityCache.set(cacheKey, { name: faction.name, type: "faction" });
                  break;
                }
                case "artifact": {
                  const artifact = await context.apiClient.getArtifact(relation.target_id);
                  targetName = artifact.name;
                  targetId = artifact.id;
                  entityCache.set(cacheKey, { name: artifact.name, type: "artifact" });
                  break;
                }
                case "event": {
                  const event = await context.apiClient.getEvent(relation.target_id);
                  targetName = event.name;
                  targetId = event.id;
                  entityCache.set(cacheKey, { name: event.name, type: "event" });
                  break;
                }
                case "lore": {
                  const lore = await context.apiClient.getLore(relation.target_id);
                  targetName = lore.name;
                  targetId = lore.id;
                  entityCache.set(cacheKey, { name: lore.name, type: "lore" });
                  break;
                }
                case "story": {
                  const story = await context.apiClient.getStory(relation.target_id);
                  targetName = story.title;
                  targetId = story.id;
                  entityCache.set(cacheKey, { name: story.title, type: "story" });
                  break;
                }
              }
            }
            return {
              targetType,
              targetId,
              targetName,
              relationType: relation.relation_type,
              summary: relation.context
            };
          } catch (error) {
            console.warn(`[Sync V2] Failed to resolve target for world relation`, {
              relation,
              error
            });
            return {
              targetType: relation.target_type,
              targetId: relation.target_id,
              targetName: relation.target_id,
              relationType: relation.relation_type,
              summary: relation.context
            };
          }
        })
      );
      const entityMap = new Map(
        resolvedRelations.map((r) => [`${r.targetType}:${r.targetId}`, r])
      );
      const resolveTarget = (relation) => {
        const key = `${relation.target_type}:${relation.target_id}`;
        const resolved = entityMap.get(key);
        if (!resolved)
          return null;
        return {
          targetId: resolved.targetId,
          targetName: resolved.targetName,
          summary: resolved.summary
        };
      };
      const input = mapRelationsToGeneratorInput({
        entity: {
          id: world.id,
          name: world.name,
          type: "world"
        },
        relations: relationsResponse.data,
        resolveTarget,
        options: {
          syncedAt: this.now(),
          showHelpBox: context.settings.showHelpBox,
          idField: context.settings.frontmatterIdField,
          worldFolderPath: folderPath
        }
      });
      const relationsContent = this.relationsGenerator.generate(input);
      await context.fileManager.writeFile(`${folderPath}/world.relations.md`, relationsContent);
    } catch (error) {
      console.warn("[Sync V2] Failed to generate world relations file", { worldId: world.id, error });
      await context.fileManager.writeFile(
        `${folderPath}/world.relations.md`,
        this.renderRelationsPlaceholder(world)
      );
    }
  }
  async generateCitations(world, folderPath, context) {
    try {
      const relationsResponse = await context.apiClient.listRelationsByWorld({
        worldId: world.id
      });
      const storyElementRelations = relationsResponse.data.filter(
        (rel) => ["chapter", "scene", "beat", "content_block"].includes(rel.source_type)
      );
      if (storyElementRelations.length === 0) {
        const input2 = mapCitationsToGeneratorInput({
          entity: {
            id: world.id,
            name: world.name,
            type: "world"
          },
          relations: [],
          resolveSource: () => null,
          options: {
            syncedAt: this.now(),
            idField: context.settings.frontmatterIdField
          }
        });
        const citationsContent2 = this.citationsGenerator.generate(input2);
        await context.fileManager.writeFile(`${folderPath}/world.citations.md`, citationsContent2);
        return;
      }
      const relationsBySource = /* @__PURE__ */ new Map();
      for (const rel of storyElementRelations) {
        if (!relationsBySource.has(rel.source_id)) {
          relationsBySource.set(rel.source_id, []);
        }
        relationsBySource.get(rel.source_id).push(rel);
      }
      const storyCache = /* @__PURE__ */ new Map();
      const chapterCache = /* @__PURE__ */ new Map();
      const sceneCache = /* @__PURE__ */ new Map();
      const beatCache = /* @__PURE__ */ new Map();
      const contentBlockCache = /* @__PURE__ */ new Map();
      const resolverCache = /* @__PURE__ */ new Map();
      const storyIdsToFetch = /* @__PURE__ */ new Set();
      for (const [sourceId, relations] of relationsBySource.entries()) {
        const firstRel = relations[0];
        if (firstRel.source_type === "chapter") {
          try {
          } catch (error) {
            console.warn(`[Sync V2] Failed to resolve story for chapter`, { sourceId, error });
          }
        }
      }
      const getStory = async (storyId) => {
        const cached = storyCache.get(storyId);
        if (cached)
          return cached;
        const story = await context.apiClient.getStory(storyId);
        storyCache.set(storyId, story);
        return story;
      };
      const getChapter = async (chapterId) => {
        const cached = chapterCache.get(chapterId);
        if (cached)
          return cached;
        const chapter = await context.apiClient.getChapter(chapterId);
        chapterCache.set(chapterId, chapter);
        return chapter;
      };
      const getScene = async (sceneId) => {
        const cached = sceneCache.get(sceneId);
        if (cached)
          return cached;
        const scene = await context.apiClient.getScene(sceneId);
        sceneCache.set(sceneId, scene);
        return scene;
      };
      const getBeat = async (beatId) => {
        const cached = beatCache.get(beatId);
        if (cached)
          return cached;
        const beat = await context.apiClient.getBeat(beatId);
        beatCache.set(beatId, beat);
        return beat;
      };
      const getContentBlock = async (contentBlockId) => {
        const cached = contentBlockCache.get(contentBlockId);
        if (cached)
          return cached;
        const contentBlock = await context.apiClient.getContentBlock(contentBlockId);
        contentBlockCache.set(contentBlockId, contentBlock);
        return contentBlock;
      };
      const getResolver = (story) => {
        const cached = resolverCache.get(story.id);
        if (cached)
          return cached;
        const storyFolder = context.fileManager.getStoryFolderPath(story.title);
        const resolver = new PathResolver(storyFolder);
        resolverCache.set(story.id, resolver);
        return resolver;
      };
      const resolveSource = (relation) => {
        if (!["chapter", "scene", "beat", "content_block"].includes(relation.source_type)) {
          return null;
        }
        return {
          storyId: "unknown",
          storyTitle: "Unknown Story",
          sourceTitle: relation.source_id,
          sourceType: relation.source_type,
          summary: relation.context
        };
      };
      const resolveSourceAsync = async (relation) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i;
        if (relation.source_type === "chapter") {
          const chapter = await getChapter(relation.source_id);
          const story = await getStory(chapter.story_id);
          const resolver = getResolver(story);
          const storyFolder = context.fileManager.getStoryFolderPath(story.title);
          return {
            storyId: story.id,
            storyTitle: story.title,
            storyPath: `${storyFolder}/story.md`,
            sourceTitle: `Chapter ${chapter.number}: ${chapter.title}`,
            sourceType: "chapter",
            sourcePath: resolver.getChapterPath(chapter),
            chapterTitle: chapter.title,
            summary: relation.context
          };
        }
        if (relation.source_type === "scene") {
          const scene = await getScene(relation.source_id);
          const story = await getStory(scene.story_id);
          const resolver = getResolver(story);
          const storyFolder = context.fileManager.getStoryFolderPath(story.title);
          let chapterTitle;
          let chapterOrder = 0;
          if (scene.chapter_id) {
            const chapter = await getChapter(scene.chapter_id);
            chapterTitle = chapter.title;
            chapterOrder = (_a = chapter.number) != null ? _a : 0;
          }
          return {
            storyId: story.id,
            storyTitle: story.title,
            storyPath: `${storyFolder}/story.md`,
            sourceTitle: `Scene ${(_b = scene.order_num) != null ? _b : 0}: ${scene.goal || "Untitled"}`,
            sourceType: "scene",
            sourcePath: resolver.getScenePath(scene, { chapterOrder }),
            chapterTitle,
            summary: relation.context
          };
        }
        if (relation.source_type === "beat") {
          const beat = await getBeat(relation.source_id);
          const scene = await getScene(beat.scene_id);
          const story = await getStory(scene.story_id);
          const resolver = getResolver(story);
          const storyFolder = context.fileManager.getStoryFolderPath(story.title);
          let chapterTitle;
          let chapterOrder = 0;
          if (scene.chapter_id) {
            const chapter = await getChapter(scene.chapter_id);
            chapterTitle = chapter.title;
            chapterOrder = (_c = chapter.number) != null ? _c : 0;
          }
          return {
            storyId: story.id,
            storyTitle: story.title,
            storyPath: `${storyFolder}/story.md`,
            sourceTitle: `Beat ${(_d = beat.order_num) != null ? _d : 0}: ${beat.intent || "Untitled"}`,
            sourceType: "beat",
            sourcePath: resolver.getBeatPath(beat, {
              chapterOrder,
              sceneOrder: (_e = scene.order_num) != null ? _e : 0
            }),
            chapterTitle,
            summary: relation.context
          };
        }
        if (relation.source_type === "content_block") {
          const block = await getContentBlock(relation.source_id);
          if (!block.chapter_id) {
            return null;
          }
          const chapter = await getChapter(block.chapter_id);
          const story = await getStory(chapter.story_id);
          const resolver = getResolver(story);
          const storyFolder = context.fileManager.getStoryFolderPath(story.title);
          const sourceTitle = (_i = (_h = (_g = (_f = block.metadata) == null ? void 0 : _f.title) != null ? _g : block.kind) != null ? _h : block.type) != null ? _i : "Content Block";
          return {
            storyId: story.id,
            storyTitle: story.title,
            storyPath: `${storyFolder}/story.md`,
            sourceTitle,
            sourceType: "content_block",
            sourcePath: resolver.getContentBlockPath(block),
            chapterTitle: chapter.title,
            summary: relation.context
          };
        }
        return null;
      };
      const resolvedSources = await Promise.all(
        storyElementRelations.map(async (relation) => ({
          relation,
          source: await resolveSourceAsync(relation)
        }))
      );
      const input = mapCitationsToGeneratorInput({
        entity: {
          id: world.id,
          name: world.name,
          type: "world"
        },
        relations: storyElementRelations,
        resolveSource: (relation) => {
          var _a, _b;
          return (_b = (_a = resolvedSources.find((item) => item.relation === relation)) == null ? void 0 : _a.source) != null ? _b : resolveSource(relation);
        },
        options: {
          syncedAt: this.now(),
          idField: context.settings.frontmatterIdField
        }
      });
      const citationsContent = this.citationsGenerator.generate(input);
      await context.fileManager.writeFile(`${folderPath}/world.citations.md`, citationsContent);
    } catch (error) {
      console.warn("[Sync V2] Failed to generate world citations file", { worldId: world.id, error });
      await context.fileManager.writeFile(
        `${folderPath}/world.citations.md`,
        this.renderCitationsPlaceholder(world)
      );
    }
  }
  renderCitationsPlaceholder(world) {
    return [
      `# ${world.name} - Citations`,
      "",
      "_Cita\xE7\xF5es para este world ser\xE3o sincronizadas quando o Relations/Citations pipeline estiver ativo._",
      ""
    ].join("\n");
  }
};

// src/views/StoryListView.ts
var STORY_LIST_VIEW_TYPE = "story-engine-list-view";
var StoryListView = class extends import_obsidian16.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.stories = [];
    this.worlds = [];
    this.rpgSystems = [];
    this.loading = true;
    this.error = null;
    this.currentStory = null;
    this.currentWorld = null;
    this.viewMode = "list";
    this.currentTab = "chapters";
    this.storyCharacters = [];
    this.worldTab = "characters";
    this.listTab = "stories";
    this.expandedWorldId = null;
    // Character Details View
    this.characterDetailsView = null;
    this.chapters = [];
    this.scenes = [];
    this.beats = [];
    this.contentBlocks = [];
    this.contentBlockRefs = [];
    this.loadingHierarchy = false;
    // World entities
    this.characters = [];
    this.locations = [];
    this.artifacts = [];
    this.events = [];
    this.traits = [];
    this.archetypes = [];
    this.factions = [];
    this.lores = [];
    this.loadingWorldData = false;
    this.plugin = plugin;
  }
  getViewType() {
    return STORY_LIST_VIEW_TYPE;
  }
  getDisplayText() {
    if (this.viewMode === "details" && this.currentStory) {
      return this.currentStory.title;
    }
    if (this.viewMode === "world-details" && this.currentWorld) {
      return this.currentWorld.name;
    }
    if (this.viewMode === "character-details" && this.characterDetailsView) {
      return this.characterDetailsView["character"].name;
    }
    return "Stories";
  }
  getIcon() {
    return "book-open";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("story-engine-view-container");
    await this.render(container);
    await this.loadStories();
  }
  async onClose() {
  }
  async render(container) {
    container.empty();
    this.headerEl = container.createDiv({ cls: "story-engine-view-header" });
    this.contentEl = container.createDiv({ cls: "story-engine-view-content" });
    if (this.viewMode === "details" && this.currentStory) {
      this.renderDetails();
    } else if (this.viewMode === "world-details" && this.currentWorld) {
      this.renderWorldDetails();
    } else if (this.viewMode === "character-details" && this.characterDetailsView) {
      this.characterDetailsView.render();
    } else {
      this.renderListHeader();
      this.renderListContent();
    }
  }
  renderListHeader() {
    if (!this.headerEl)
      return;
    this.headerEl.empty();
    this.headerEl.createEl("h2", { text: "Stories" });
    const tabsContainer = this.headerEl.createDiv({ cls: "story-engine-tabs" });
    const storiesTab = tabsContainer.createEl("button", {
      text: "Stories",
      cls: `story-engine-tab ${this.listTab === "stories" ? "is-active" : ""}`
    });
    storiesTab.onclick = () => {
      this.listTab = "stories";
      this.renderListHeader();
      this.renderListContent();
    };
    const worldsTab = tabsContainer.createEl("button", {
      text: "Worlds",
      cls: `story-engine-tab ${this.listTab === "worlds" ? "is-active" : ""}`
    });
    worldsTab.onclick = () => {
      this.listTab = "worlds";
      this.renderListHeader();
      this.renderListContent();
    };
    const rpgSystemsTab = tabsContainer.createEl("button", {
      text: "RPG Systems",
      cls: `story-engine-tab ${this.listTab === "rpg-systems" ? "is-active" : ""}`
    });
    rpgSystemsTab.onclick = () => {
      this.listTab = "rpg-systems";
      this.renderListHeader();
      this.renderListContent();
    };
    const settingsButton = tabsContainer.createEl("button", {
      cls: "story-engine-settings-btn story-engine-tab",
      attr: { "aria-label": "Open Settings" }
    });
    (0, import_obsidian16.setIcon)(settingsButton, "gear");
    settingsButton.onclick = () => {
      this.plugin.openSettings();
    };
  }
  renderListContent() {
    if (!this.contentEl)
      return;
    this.contentEl.empty();
    if (this.loading) {
      this.contentEl.createEl("p", { text: "Loading..." });
      return;
    }
    if (this.error) {
      this.contentEl.createEl("p", {
        text: `Error: ${this.error}`,
        cls: "story-engine-error"
      });
      this.renderActionsBar();
      return;
    }
    switch (this.listTab) {
      case "stories":
        this.renderStoriesTab();
        break;
      case "worlds":
        this.renderWorldsTab();
        break;
      case "rpg-systems":
        this.renderRPGSystemsTab();
        break;
    }
    this.renderActionsBar();
  }
  renderActionsBar() {
    if (!this.contentEl)
      return;
    const actionsBar = this.contentEl.createDiv({ cls: "story-engine-actions-bar" });
    const refreshButton = actionsBar.createEl("button", {
      text: "Refresh",
      cls: "story-engine-refresh-btn"
    });
    refreshButton.onclick = async () => {
      await this.loadStories();
    };
    const syncAllButton = actionsBar.createEl("button", {
      text: "Sync All",
      cls: "story-engine-sync-all-btn"
    });
    syncAllButton.onclick = async () => {
      if (!this.plugin.settings.tenantId) {
        new import_obsidian16.Notice("Please configure Tenant ID in settings", 5e3);
        return;
      }
      try {
        new import_obsidian16.Notice("Syncing all stories...");
        await this.plugin.syncService.pullAllStories();
        await this.loadStories();
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to sync stories";
        new import_obsidian16.Notice(`Error: ${errorMessage}`, 5e3);
      }
    };
    let createButtonText = "Create Story";
    let createButtonAction = () => {
      this.plugin.createStoryCommand();
    };
    if (this.listTab === "worlds") {
      createButtonText = "Create World";
      createButtonAction = async () => {
        new CreateWorldModal(this.app, async (name, description, genre) => {
          try {
            new import_obsidian16.Notice(`Creating world "${name}"...`);
            const newWorld = await this.plugin.apiClient.createWorld(name, description, genre);
            new import_obsidian16.Notice(`World "${name}" created successfully`);
            await this.loadStories();
          } catch (err) {
            const errorMessage = err instanceof Error ? err.message : "Failed to create world";
            new import_obsidian16.Notice(`Error: ${errorMessage}`, 5e3);
          }
        }).open();
      };
    } else if (this.listTab === "rpg-systems") {
      createButtonText = "Create RPG System";
      createButtonAction = () => {
        new import_obsidian16.Notice("Create RPG System - Coming soon", 3e3);
      };
    }
    const createButton = actionsBar.createEl("button", {
      text: createButtonText,
      cls: "mod-cta story-engine-create-btn"
    });
    createButton.onclick = createButtonAction;
  }
  renderDetailsHeader() {
    if (!this.headerEl || !this.currentStory)
      return;
    this.headerEl.empty();
    const headerLeft = this.headerEl.createDiv({ cls: "story-engine-header-left" });
    const backButton = headerLeft.createEl("button", {
      text: "\u2190 Back",
      cls: "story-engine-back-btn"
    });
    backButton.onclick = () => {
      this.showList();
    };
    const titleContainer = headerLeft.createDiv({ cls: "story-engine-title-container" });
    const titleRow = titleContainer.createDiv({ cls: "story-engine-title-row" });
    const titleH2 = titleRow.createEl("h2", {
      text: this.currentStory.title,
      cls: "story-engine-title-header"
    });
    const statusPill = titleRow.createSpan({
      cls: `story-engine-status-pill story-engine-status-${this.currentStory.status.toLowerCase().replace(/\s+/g, "-")}`
    });
    statusPill.textContent = this.currentStory.status;
    const versionSpan = titleRow.createSpan({ cls: "story-engine-version" });
    versionSpan.textContent = `v.${this.currentStory.version_number}`;
    const uuidRow = titleContainer.createDiv({ cls: "story-engine-uuid-row" });
    const uuidSpan = uuidRow.createSpan({ cls: "story-engine-uuid" });
    uuidSpan.textContent = this.currentStory.id;
    const copyUuidButton = uuidRow.createEl("button", {
      cls: "story-engine-copy-uuid-btn",
      attr: { "aria-label": "Copy UUID" }
    });
    (0, import_obsidian16.setIcon)(copyUuidButton, "copy");
    copyUuidButton.onclick = () => {
      this.copyStoryId();
    };
    const headerActions = this.headerEl.createDiv({ cls: "story-engine-header-actions" });
    if (this.currentStory.world_id) {
      const world = this.worlds.find((w) => w.id === this.currentStory.world_id);
      if (world) {
        const worldButton = headerActions.createEl("button", {
          cls: "story-engine-world-btn",
          attr: { "aria-label": `Go to World: ${world.name}` }
        });
        (0, import_obsidian16.setIcon)(worldButton, "globe");
        worldButton.createSpan({ text: "World" });
        worldButton.onclick = () => {
          this.showWorldDetails(world);
        };
      }
    }
    const contextButton = headerActions.createEl("button", {
      cls: "story-engine-context-btn",
      attr: { "aria-label": "Story Actions" }
    });
    (0, import_obsidian16.setIcon)(contextButton, "more-vertical");
    const dropdownMenu = headerActions.createDiv({ cls: "story-engine-dropdown-menu" });
    dropdownMenu.style.display = "none";
    const editOption = dropdownMenu.createEl("button", {
      cls: "story-engine-dropdown-item"
    });
    (0, import_obsidian16.setIcon)(editOption, "pencil");
    editOption.createSpan({ text: "Edit Story Name" });
    editOption.onclick = () => {
      dropdownMenu.style.display = "none";
      this.showEditStoryNameModal();
    };
    const cloneOption = dropdownMenu.createEl("button", {
      cls: "story-engine-dropdown-item"
    });
    (0, import_obsidian16.setIcon)(cloneOption, "copy");
    cloneOption.createSpan({ text: "Clone Story" });
    cloneOption.onclick = async () => {
      dropdownMenu.style.display = "none";
      await this.cloneStory();
    };
    const pullOption = dropdownMenu.createEl("button", {
      cls: "story-engine-dropdown-item"
    });
    (0, import_obsidian16.setIcon)(pullOption, "download");
    pullOption.createSpan({ text: "Pull from Service" });
    pullOption.onclick = async () => {
      dropdownMenu.style.display = "none";
      if (!this.currentStory)
        return;
      try {
        new import_obsidian16.Notice(`Pulling story "${this.currentStory.title}"...`);
        await this.plugin.syncService.pullStory(this.currentStory.id);
        await this.loadHierarchy();
        this.renderTabContent();
        new import_obsidian16.Notice(`Story pulled successfully!`);
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to pull story";
        new import_obsidian16.Notice(`Error: ${errorMessage}`, 5e3);
      }
    };
    const pushOption = dropdownMenu.createEl("button", {
      cls: "story-engine-dropdown-item"
    });
    (0, import_obsidian16.setIcon)(pushOption, "upload");
    pushOption.createSpan({ text: "Push to Service" });
    pushOption.onclick = async () => {
      dropdownMenu.style.display = "none";
      if (!this.currentStory)
        return;
      try {
        const folderPath = this.plugin.fileManager.getStoryFolderPath(this.currentStory.title);
        new import_obsidian16.Notice(`Pushing story "${this.currentStory.title}"...`);
        await this.plugin.syncService.pushStory(folderPath);
        new import_obsidian16.Notice(`Story pushed successfully!`);
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to push story";
        new import_obsidian16.Notice(`Error: ${errorMessage}`, 5e3);
      }
    };
    contextButton.onclick = (e) => {
      e.stopPropagation();
      const isVisible = dropdownMenu.style.display !== "none";
      dropdownMenu.style.display = isVisible ? "none" : "block";
    };
    document.addEventListener("click", () => {
      dropdownMenu.style.display = "none";
    }, { once: true });
  }
  renderStoriesTab() {
    if (this.stories.length === 0) {
      this.contentEl.createEl("p", { text: "No stories found." });
      return;
    }
    const storiesList = this.contentEl.createDiv({ cls: "story-engine-list" });
    for (const story of this.stories) {
      this.renderStoryItem(storiesList, story);
    }
  }
  renderWorldsTab() {
    if (this.worlds.length === 0) {
      this.contentEl.createEl("p", { text: "No worlds found." });
      return;
    }
    const storiesByWorld = /* @__PURE__ */ new Map();
    for (const story of this.stories) {
      const worldId = story.world_id || null;
      if (!storiesByWorld.has(worldId)) {
        storiesByWorld.set(worldId, []);
      }
      storiesByWorld.get(worldId).push(story);
    }
    const worldsList = this.contentEl.createDiv({ cls: "story-engine-list" });
    for (const world of this.worlds) {
      const worldStories = storiesByWorld.get(world.id) || [];
      const worldItem = worldsList.createDiv({ cls: "story-engine-world-item" });
      const worldHeader = worldItem.createDiv({ cls: "story-engine-world-item-header" });
      const worldTitle = worldHeader.createDiv({ cls: "story-engine-world-title" });
      worldTitle.createEl("h3", { text: world.name });
      if (world.description) {
        worldTitle.createEl("p", {
          text: world.description,
          cls: "story-engine-world-description"
        });
      }
      worldTitle.style.cursor = "pointer";
      worldTitle.onclick = () => {
        this.showWorldDetails(world);
      };
      const accordionButton = worldHeader.createEl("button", {
        text: worldStories.length > 0 ? `${worldStories.length} story${worldStories.length !== 1 ? "s" : ""}` : "No stories",
        cls: `story-engine-accordion-btn ${this.expandedWorldId === world.id ? "is-expanded" : ""}`
      });
      accordionButton.onclick = (e) => {
        e.stopPropagation();
        if (this.expandedWorldId === world.id) {
          this.expandedWorldId = null;
        } else {
          this.expandedWorldId = world.id;
        }
        this.renderListContent();
      };
      if (this.expandedWorldId === world.id && worldStories.length > 0) {
        const storiesContent = worldItem.createDiv({ cls: "story-engine-world-stories-content" });
        for (const story of worldStories) {
          this.renderStoryItem(storiesContent, story);
        }
      }
    }
    const storiesWithoutWorld = storiesByWorld.get(null) || [];
    if (storiesWithoutWorld.length > 0) {
      const noWorldItem = worldsList.createDiv({ cls: "story-engine-world-item" });
      const noWorldHeader = noWorldItem.createDiv({ cls: "story-engine-world-item-header" });
      noWorldHeader.createEl("h3", { text: "No World" });
      const accordionButton = noWorldHeader.createEl("button", {
        text: `${storiesWithoutWorld.length} story${storiesWithoutWorld.length !== 1 ? "s" : ""}`,
        cls: `story-engine-accordion-btn ${this.expandedWorldId === "no-world" ? "is-expanded" : ""}`
      });
      accordionButton.onclick = () => {
        if (this.expandedWorldId === "no-world") {
          this.expandedWorldId = null;
        } else {
          this.expandedWorldId = "no-world";
        }
        this.renderListContent();
      };
      if (this.expandedWorldId === "no-world") {
        const storiesContent = noWorldItem.createDiv({ cls: "story-engine-world-stories-content" });
        for (const story of storiesWithoutWorld) {
          this.renderStoryItem(storiesContent, story);
        }
      }
    }
  }
  renderRPGSystemsTab() {
    if (this.rpgSystems.length === 0) {
      if (this.plugin.settings.mode === "local") {
        this.contentEl.createEl("p", { text: "RPG systems are not available in local mode." });
      } else {
        this.contentEl.createEl("p", { text: "No RPG systems found." });
      }
      return;
    }
    const rpgSystemsList = this.contentEl.createDiv({ cls: "story-engine-list" });
    for (const rpgSystem of this.rpgSystems) {
      const rpgSystemItem = rpgSystemsList.createDiv({
        cls: "story-engine-item"
      });
      const title = rpgSystemItem.createDiv({
        cls: "story-engine-title",
        text: rpgSystem.name
      });
      const meta = rpgSystemItem.createDiv({
        cls: "story-engine-meta"
      });
      if (rpgSystem.description) {
        meta.createEl("span", {
          text: rpgSystem.description
        });
      }
      if (rpgSystem.is_builtin) {
        meta.createEl("span", {
          text: "Built-in",
          cls: "story-engine-badge"
        });
      }
    }
  }
  renderStoryItem(container, story) {
    const storyItem = container.createDiv({
      cls: "story-engine-item"
    });
    const title = storyItem.createDiv({
      cls: "story-engine-title",
      text: story.title
    });
    const meta = storyItem.createDiv({
      cls: "story-engine-meta"
    });
    meta.createEl("span", {
      text: `Version ${story.version_number}`
    });
    meta.createEl("span", {
      text: `Status: ${story.status}`
    });
    if (story.world_id) {
      const world = this.worlds.find((w) => w.id === story.world_id);
      if (world) {
        meta.createEl("span", {
          text: `World: ${world.name}`
        });
      }
    }
    storyItem.onclick = async () => {
      await this.showStoryDetails(story);
    };
  }
  async loadStories() {
    this.loading = true;
    this.error = null;
    try {
      if (this.plugin.settings.mode === "remote" && !this.plugin.settings.tenantId) {
        this.error = "Tenant ID not configured";
        this.loading = false;
        this.renderListContent();
        return;
      }
      this.worlds = await this.plugin.apiClient.getWorlds();
      this.stories = await this.plugin.apiClient.listStories();
      try {
        this.rpgSystems = await this.plugin.apiClient.getRPGSystems();
      } catch (rpgErr) {
        console.warn("RPG systems not available:", rpgErr);
        this.rpgSystems = [];
      }
    } catch (err) {
      this.error = err instanceof Error ? err.message : "Failed to load stories";
      console.error("Error loading stories:", err);
    } finally {
      this.loading = false;
      this.renderListContent();
    }
  }
  // Method to refresh the view
  async refresh() {
    await this.loadStories();
  }
  async showStoryDetails(story) {
    this.currentStory = story;
    this.viewMode = "details";
    this.currentTab = "chapters";
    await this.loadHierarchy();
    this.renderDetails();
  }
  async loadHierarchy() {
    if (!this.currentStory)
      return;
    this.loadingHierarchy = true;
    try {
      this.chapters = await this.plugin.apiClient.getChapters(this.currentStory.id);
      this.scenes = await this.plugin.apiClient.getScenesByStory(this.currentStory.id);
      this.beats = await this.plugin.apiClient.getBeatsByStory(this.currentStory.id);
      const contentBlocksMap = /* @__PURE__ */ new Map();
      this.contentBlockRefs = [];
      for (const chapter of this.chapters) {
        const chapterBlocks = await this.plugin.apiClient.getContentBlocks(chapter.id);
        for (const block of chapterBlocks) {
          contentBlocksMap.set(block.id, block);
        }
      }
      for (const scene of this.scenes) {
        const sceneBlocks = await this.plugin.apiClient.getContentBlocksByScene(scene.id);
        for (const block of sceneBlocks) {
          contentBlocksMap.set(block.id, block);
        }
      }
      for (const beat of this.beats) {
        const beatBlocks = await this.plugin.apiClient.getContentBlocksByBeat(beat.id);
        for (const block of beatBlocks) {
          contentBlocksMap.set(block.id, block);
        }
      }
      this.contentBlocks = Array.from(contentBlocksMap.values());
      for (const block of this.contentBlocks) {
        const refs = await this.plugin.apiClient.getContentAnchors(block.id);
        this.contentBlockRefs.push(...refs);
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to load hierarchy";
      new import_obsidian16.Notice(`Error: ${errorMessage}`, 5e3);
    } finally {
      this.loadingHierarchy = false;
    }
  }
  showList() {
    this.currentStory = null;
    this.viewMode = "list";
    this.renderListHeader();
    this.renderListContent();
  }
  renderDetails() {
    if (!this.contentEl || !this.currentStory)
      return;
    this.renderDetailsHeader();
    this.contentEl.empty();
    this.renderTabs();
    this.renderTabContent();
  }
  renderTabs() {
    if (!this.contentEl)
      return;
    const existingTabs = this.contentEl.querySelector(".story-engine-tabs");
    if (existingTabs) {
      existingTabs.remove();
    }
    const tabsContainer = this.contentEl.createDiv({ cls: "story-engine-tabs" });
    const chaptersTab = tabsContainer.createEl("button", {
      text: "Chapters",
      cls: `story-engine-tab ${this.currentTab === "chapters" ? "is-active" : ""}`
    });
    chaptersTab.onclick = () => {
      this.currentTab = "chapters";
      this.renderTabs();
      this.renderTabContent();
    };
    const scenesTab = tabsContainer.createEl("button", {
      text: "Scenes",
      cls: `story-engine-tab ${this.currentTab === "scenes" ? "is-active" : ""}`
    });
    scenesTab.onclick = () => {
      this.currentTab = "scenes";
      this.renderTabs();
      this.renderTabContent();
    };
    const beatsTab = tabsContainer.createEl("button", {
      text: "Beats",
      cls: `story-engine-tab ${this.currentTab === "beats" ? "is-active" : ""}`
    });
    beatsTab.onclick = () => {
      this.currentTab = "beats";
      this.renderTabs();
      this.renderTabContent();
    };
    const contentsTab = tabsContainer.createEl("button", {
      text: "Contents",
      cls: `story-engine-tab ${this.currentTab === "contents" ? "is-active" : ""}`
    });
    contentsTab.onclick = () => {
      this.currentTab = "contents";
      this.renderTabs();
      this.renderTabContent();
    };
    const charactersTab = tabsContainer.createEl("button", {
      text: "Characters",
      cls: `story-engine-tab ${this.currentTab === "characters" ? "is-active" : ""}`
    });
    charactersTab.onclick = async () => {
      this.currentTab = "characters";
      this.renderTabs();
      await this.loadStoryCharacters();
      this.renderTabContent();
    };
  }
  renderTabContent() {
    if (!this.contentEl)
      return;
    const existingContent = this.contentEl.querySelector(".story-engine-tab-content");
    if (existingContent) {
      existingContent.remove();
    }
    const tabContent = this.contentEl.createDiv({ cls: "story-engine-tab-content" });
    if (this.loadingHierarchy) {
      tabContent.createEl("p", { text: "Loading..." });
      return;
    }
    switch (this.currentTab) {
      case "chapters":
        this.renderChaptersTab(tabContent);
        break;
      case "scenes":
        this.renderScenesTab(tabContent);
        break;
      case "beats":
        this.renderBeatsTab(tabContent);
        break;
      case "contents":
        this.renderContentsTab(tabContent);
        break;
      case "characters":
        this.renderStoryCharactersTab(tabContent);
        break;
    }
  }
  renderChaptersTab(container) {
    container.empty();
    const list = container.createDiv({ cls: "story-engine-list" });
    if (this.chapters.length === 0) {
      list.createEl("p", { text: "No chapters found." });
    } else {
      for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
        const item = list.createDiv({ cls: "story-engine-item" });
        item.createDiv({
          cls: "story-engine-title",
          text: `Chapter ${chapter.number}: ${chapter.title}`
        });
        const meta = item.createDiv({ cls: "story-engine-meta" });
        meta.createEl("span", { text: `Status: ${chapter.status}` });
        const actions = item.createDiv({ cls: "story-engine-item-actions" });
        actions.createEl("button", { text: "Edit" }).onclick = () => {
          new ChapterModal(this.app, async (updatedChapter) => {
            try {
              await this.plugin.apiClient.updateChapter(chapter.id, updatedChapter);
              await this.loadHierarchy();
              this.renderTabContent();
              new import_obsidian16.Notice("Chapter updated successfully");
            } catch (err) {
              throw err;
            }
          }, this.chapters, chapter).open();
        };
        if (chapter.number > 1) {
          actions.createEl("button", { text: "Up" }).onclick = () => {
            this.moveChapterUp(chapter);
          };
        }
        if (chapter.number < this.chapters.length) {
          actions.createEl("button", { text: "Down" }).onclick = () => {
            this.moveChapterDown(chapter);
          };
        }
        if (this.currentTab === "contents") {
          actions.createEl("button", { text: "+ Content" }).onclick = () => {
            this.createContentForEntity("chapter", chapter.id, chapter.id);
          };
        }
        actions.createEl("button", { text: "Delete" }).onclick = async () => {
          if (confirm("Delete this chapter?")) {
            try {
              await this.plugin.apiClient.deleteChapter(chapter.id);
              await this.loadHierarchy();
              this.renderTabContent();
              new import_obsidian16.Notice("Chapter deleted");
            } catch (err) {
              new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
            }
          }
        };
      }
    }
    const footer = container.createDiv({ cls: "story-engine-list-footer" });
    const createButton = footer.createEl("button", {
      text: "Create Chapter",
      cls: "mod-cta"
    });
    createButton.onclick = () => {
      if (!this.currentStory)
        return;
      new ChapterModal(this.app, async (chapter) => {
        try {
          await this.plugin.apiClient.createChapter(this.currentStory.id, chapter);
          await this.loadHierarchy();
          this.renderTabContent();
          new import_obsidian16.Notice("Chapter created successfully");
        } catch (err) {
          throw err;
        }
      }, this.chapters).open();
    };
  }
  renderScenesTab(container) {
    container.empty();
    const scenesByChapter = /* @__PURE__ */ new Map();
    for (const scene of this.scenes) {
      const chapterId = scene.chapter_id || null;
      if (!scenesByChapter.has(chapterId)) {
        scenesByChapter.set(chapterId, []);
      }
      scenesByChapter.get(chapterId).push(scene);
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
      const chapterScenes = scenesByChapter.get(chapter.id) || [];
      const group = list.createDiv({ cls: "story-engine-group" });
      const groupHeader = group.createDiv({ cls: "story-engine-group-header" });
      groupHeader.createEl("h3", { text: `Chapter ${chapter.number}: ${chapter.title}` });
      const groupItems = group.createDiv({ cls: "story-engine-group-items" });
      if (chapterScenes.length === 0) {
        groupItems.createEl("p", { text: "No scenes in this chapter." });
      } else {
        for (const scene of chapterScenes.sort((a, b) => a.order_num - b.order_num)) {
          this.renderSceneItem(groupItems, scene);
        }
      }
      const groupFooter = group.createDiv({ cls: "story-engine-group-footer" });
      const addButton = groupFooter.createEl("button", {
        text: "+ Add Scene",
        cls: "story-engine-add-btn"
      });
      addButton.onclick = () => {
        if (!this.currentStory)
          return;
        new SceneModal(this.app, this.currentStory.id, this.chapters, async (scene) => {
          try {
            scene.chapter_id = chapter.id;
            await this.plugin.apiClient.createScene(scene);
            await this.loadHierarchy();
            this.renderTabContent();
            new import_obsidian16.Notice("Scene created successfully");
          } catch (err) {
            throw err;
          }
        }, this.scenes, void 0, chapter.id).open();
      };
    }
    const orphanScenes = scenesByChapter.get(null) || [];
    if (orphanScenes.length > 0 || scenesByChapter.size === 0) {
      const group = list.createDiv({ cls: "story-engine-group" });
      const groupHeader = group.createDiv({ cls: "story-engine-group-header" });
      groupHeader.createEl("h3", { text: "Without Chapter" });
      const groupItems = group.createDiv({ cls: "story-engine-group-items" });
      for (const scene of orphanScenes.sort((a, b) => a.order_num - b.order_num)) {
        this.renderSceneItem(groupItems, scene);
      }
      const groupFooter = group.createDiv({ cls: "story-engine-group-footer" });
      const addButton = groupFooter.createEl("button", {
        text: "+ Add Scene",
        cls: "story-engine-add-btn"
      });
      addButton.onclick = () => {
        if (!this.currentStory)
          return;
        new SceneModal(this.app, this.currentStory.id, this.chapters, async (scene) => {
          try {
            scene.chapter_id = null;
            await this.plugin.apiClient.createScene(scene);
            await this.loadHierarchy();
            this.renderTabContent();
            new import_obsidian16.Notice("Scene created successfully");
          } catch (err) {
            throw err;
          }
        }, this.scenes, void 0, null).open();
      };
    }
  }
  renderSceneItem(container, scene) {
    const item = container.createDiv({ cls: "story-engine-item" });
    item.createDiv({
      cls: "story-engine-title",
      text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`
    });
    const meta = item.createDiv({ cls: "story-engine-meta" });
    if (scene.time_ref) {
      meta.createEl("span", { text: `Time: ${scene.time_ref}` });
    }
    const actions = item.createDiv({ cls: "story-engine-item-actions" });
    actions.createEl("button", { text: "Edit" }).onclick = () => {
      if (!this.currentStory)
        return;
      new SceneModal(this.app, this.currentStory.id, this.chapters, async (updatedScene) => {
        try {
          await this.plugin.apiClient.updateScene(scene.id, updatedScene);
          await this.loadHierarchy();
          this.renderTabContent();
          new import_obsidian16.Notice("Scene updated successfully");
        } catch (err) {
          throw err;
        }
      }, this.scenes, scene).open();
    };
    const siblingScenes = this.scenes.filter((s) => s.chapter_id === scene.chapter_id).sort((a, b) => a.order_num - b.order_num);
    const minOrderNum = siblingScenes.length > 0 ? Math.min(...siblingScenes.map((s) => s.order_num)) : scene.order_num;
    const maxOrderNum = siblingScenes.length > 0 ? Math.max(...siblingScenes.map((s) => s.order_num)) : scene.order_num;
    if (scene.order_num > minOrderNum) {
      actions.createEl("button", { text: "Up" }).onclick = () => {
        this.moveSceneUp(scene);
      };
    }
    if (scene.order_num < maxOrderNum) {
      actions.createEl("button", { text: "Down" }).onclick = () => {
        this.moveSceneDown(scene);
      };
    }
    actions.createEl("button", { text: "Relinkar" }).onclick = async () => {
      await this.showMoveSceneModal(scene);
    };
    if (this.currentTab === "contents") {
      const chapterId = scene.chapter_id || (this.chapters.length > 0 ? this.chapters[0].id : "");
      if (chapterId) {
        actions.createEl("button", { text: "+ Content" }).onclick = () => {
          this.createContentForEntity("scene", scene.id, chapterId);
        };
      }
    }
    actions.createEl("button", { text: "Delete" }).onclick = async () => {
      if (confirm("Delete this scene?")) {
        try {
          await this.plugin.apiClient.deleteScene(scene.id);
          await this.loadHierarchy();
          this.renderTabContent();
          new import_obsidian16.Notice("Scene deleted");
        } catch (err) {
          new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
        }
      }
    };
  }
  renderBeatsTab(container) {
    container.empty();
    const beatsByScene = /* @__PURE__ */ new Map();
    for (const beat of this.beats) {
      if (!beatsByScene.has(beat.scene_id)) {
        beatsByScene.set(beat.scene_id, []);
      }
      beatsByScene.get(beat.scene_id).push(beat);
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
      const chapterScenes = this.scenes.filter((s) => s.chapter_id === chapter.id).sort((a, b) => a.order_num - b.order_num);
      if (chapterScenes.length > 0) {
        const chapterGroup = list.createDiv({ cls: "story-engine-chapter-group" });
        const chapterHeader = chapterGroup.createDiv({ cls: "story-engine-chapter-group-header" });
        chapterHeader.createEl("h2", {
          text: `Chapter ${chapter.number}: ${chapter.title}`
        });
        const chapterContent = chapterGroup.createDiv({ cls: "story-engine-chapter-group-content" });
        for (const scene of chapterScenes) {
          const sceneBeats = beatsByScene.get(scene.id) || [];
          const sceneGroup = chapterContent.createDiv({ cls: "story-engine-group" });
          const sceneHeader = sceneGroup.createDiv({ cls: "story-engine-group-header" });
          sceneHeader.createEl("h3", {
            text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`
          });
          const sceneItems = sceneGroup.createDiv({ cls: "story-engine-group-items" });
          if (sceneBeats.length === 0) {
            sceneItems.createEl("p", { text: "No beats in this scene." });
          } else {
            for (const beat of sceneBeats.sort((a, b) => a.order_num - b.order_num)) {
              this.renderBeatItem(sceneItems, beat);
            }
          }
          const sceneFooter = sceneGroup.createDiv({ cls: "story-engine-group-footer" });
          const addButton = sceneFooter.createEl("button", {
            text: "+ Add Beat",
            cls: "story-engine-add-btn"
          });
          addButton.onclick = () => {
            if (!this.currentStory)
              return;
            new BeatModal(this.app, this.currentStory.id, this.scenes, async (beat) => {
              try {
                beat.scene_id = scene.id;
                await this.plugin.apiClient.createBeat(beat);
                await this.loadHierarchy();
                this.renderTabContent();
                new import_obsidian16.Notice("Beat created successfully");
              } catch (err) {
                throw err;
              }
            }, this.beats, void 0, this.chapters, scene.id).open();
          };
        }
      }
    }
    const orphanBeats = this.beats.filter((b) => {
      const scene = this.scenes.find((s) => s.id === b.scene_id);
      return !scene || !scene.chapter_id;
    });
    if (this.chapters.length === 0 || orphanBeats.length > 0 || this.scenes.some((s) => !s.chapter_id)) {
      const orphanGroup = list.createDiv({ cls: "story-engine-chapter-group" });
      const orphanHeader = orphanGroup.createDiv({ cls: "story-engine-chapter-group-header" });
      orphanHeader.createEl("h2", { text: "Without Chapter" });
      const orphanContent = orphanGroup.createDiv({ cls: "story-engine-chapter-group-content" });
      const orphanScenes = this.scenes.filter((s) => !s.chapter_id).sort((a, b) => a.order_num - b.order_num);
      for (const scene of orphanScenes) {
        const sceneBeats = beatsByScene.get(scene.id) || [];
        const sceneGroup = orphanContent.createDiv({ cls: "story-engine-group" });
        const sceneHeader = sceneGroup.createDiv({ cls: "story-engine-group-header" });
        sceneHeader.createEl("h3", {
          text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`
        });
        const sceneItems = sceneGroup.createDiv({ cls: "story-engine-group-items" });
        if (sceneBeats.length === 0) {
          sceneItems.createEl("p", { text: "No beats in this scene." });
        } else {
          for (const beat of sceneBeats.sort((a, b) => a.order_num - b.order_num)) {
            this.renderBeatItem(sceneItems, beat);
          }
        }
        const sceneFooter = sceneGroup.createDiv({ cls: "story-engine-group-footer" });
        const addButton = sceneFooter.createEl("button", {
          text: "+ Add Beat",
          cls: "story-engine-add-btn"
        });
        addButton.onclick = () => {
          if (!this.currentStory)
            return;
          new BeatModal(this.app, this.currentStory.id, this.scenes, async (beat) => {
            try {
              beat.scene_id = scene.id;
              await this.plugin.apiClient.createBeat(beat);
              await this.loadHierarchy();
              this.renderTabContent();
              new import_obsidian16.Notice("Beat created successfully");
            } catch (err) {
              throw err;
            }
          }, this.beats, void 0, this.chapters, scene.id).open();
        };
      }
      const beatsWithoutScene = orphanBeats.filter((b) => {
        const scene = this.scenes.find((s) => s.id === b.scene_id);
        return !scene;
      });
      if (beatsWithoutScene.length > 0 || orphanScenes.length === 0 && this.beats.length > 0 && this.scenes.length === 0) {
        const sceneGroup = orphanContent.createDiv({ cls: "story-engine-group" });
        const sceneHeader = sceneGroup.createDiv({ cls: "story-engine-group-header" });
        sceneHeader.createEl("h3", { text: "Without Scene" });
        const sceneItems = sceneGroup.createDiv({ cls: "story-engine-group-items" });
        if (beatsWithoutScene.length > 0) {
          for (const beat of beatsWithoutScene.sort((a, b) => a.order_num - b.order_num)) {
            this.renderBeatItem(sceneItems, beat);
          }
        } else {
          sceneItems.createEl("p", { text: "No beats without scene." });
        }
      }
    }
  }
  renderBeatItem(container, beat) {
    const item = container.createDiv({ cls: "story-engine-item" });
    item.createDiv({
      cls: "story-engine-title",
      text: `Beat ${beat.order_num}: ${beat.type}`
    });
    const meta = item.createDiv({ cls: "story-engine-meta" });
    if (beat.intent) {
      meta.createEl("span", { text: `Intent: ${beat.intent}` });
    }
    if (beat.outcome) {
      meta.createEl("span", { text: `Outcome: ${beat.outcome}` });
    }
    const actions = item.createDiv({ cls: "story-engine-item-actions" });
    actions.createEl("button", { text: "Edit" }).onclick = () => {
      if (!this.currentStory)
        return;
      new BeatModal(this.app, this.currentStory.id, this.scenes, async (updatedBeat) => {
        try {
          await this.plugin.apiClient.updateBeat(beat.id, updatedBeat);
          await this.loadHierarchy();
          this.renderTabContent();
          new import_obsidian16.Notice("Beat updated successfully");
        } catch (err) {
          throw err;
        }
      }, this.beats, beat, this.chapters).open();
    };
    const siblingBeats = this.beats.filter((b) => b.scene_id === beat.scene_id).sort((a, b) => a.order_num - b.order_num);
    const minOrderNum = siblingBeats.length > 0 ? Math.min(...siblingBeats.map((b) => b.order_num)) : beat.order_num;
    const maxOrderNum = siblingBeats.length > 0 ? Math.max(...siblingBeats.map((b) => b.order_num)) : beat.order_num;
    if (beat.order_num > minOrderNum) {
      actions.createEl("button", { text: "Up" }).onclick = () => {
        this.moveBeatUp(beat);
      };
    }
    if (beat.order_num < maxOrderNum) {
      actions.createEl("button", { text: "Down" }).onclick = () => {
        this.moveBeatDown(beat);
      };
    }
    actions.createEl("button", { text: "Relinkar" }).onclick = async () => {
      await this.showMoveBeatModal(beat);
    };
    if (this.currentTab === "contents") {
      const scene = this.scenes.find((s) => s.id === beat.scene_id);
      const chapterId = (scene == null ? void 0 : scene.chapter_id) || (this.chapters.length > 0 ? this.chapters[0].id : "");
      if (chapterId) {
        actions.createEl("button", { text: "+ Content" }).onclick = () => {
          this.createContentForEntity("beat", beat.id, chapterId);
        };
      }
    }
    actions.createEl("button", { text: "Delete" }).onclick = async () => {
      if (confirm("Delete this beat?")) {
        try {
          await this.plugin.apiClient.deleteBeat(beat.id);
          await this.loadHierarchy();
          this.renderTabContent();
          new import_obsidian16.Notice("Beat deleted");
        } catch (err) {
          new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
        }
      }
    };
  }
  showEditStoryNameModal() {
    if (!this.currentStory)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Edit Story Name");
    const content = modal.contentEl;
    let title = this.currentStory.title;
    content.createEl("label", { text: "Story Name *" });
    const titleInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: title });
    titleInput.oninput = () => {
      title = titleInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      if (!title.trim()) {
        new import_obsidian16.Notice("Story name is required", 3e3);
        return;
      }
      try {
        const updatedStory = await this.plugin.apiClient.updateStory(this.currentStory.id, title.trim());
        this.currentStory = updatedStory;
        await this.loadStories();
        this.renderDetailsHeader();
        modal.close();
        new import_obsidian16.Notice("Story name updated");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
    titleInput.focus();
    titleInput.select();
  }
  async cloneStory() {
    var _a;
    if (!this.currentStory)
      return;
    const cloneButton = (_a = this.headerEl) == null ? void 0 : _a.querySelector(".story-engine-clone-btn");
    if (cloneButton) {
      cloneButton.disabled = true;
      cloneButton.setText("Cloning...");
    }
    try {
      if (!this.plugin.settings.tenantId) {
        throw new Error("Tenant ID not configured");
      }
      const clonedStory = await this.plugin.apiClient.cloneStory(
        this.currentStory.id
      );
      new import_obsidian16.Notice(`Story "${clonedStory.title}" cloned successfully!`);
      await this.loadStories();
      await this.showStoryDetails(clonedStory);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Clone failed";
      new import_obsidian16.Notice(`Error: ${errorMessage}`, 5e3);
      if (cloneButton) {
        cloneButton.setText("Clone Story");
        cloneButton.disabled = false;
      }
    }
  }
  showEditWorldModal() {
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Edit World");
    const content = modal.contentEl;
    let name = this.currentWorld.name;
    let description = this.currentWorld.description;
    let genre = this.currentWorld.genre;
    content.createEl("label", { text: "World Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: name });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Genre *" });
    const genreInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: genre });
    genreInput.oninput = () => {
      genre = genreInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.value = description;
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("World name is required", 3e3);
        return;
      }
      if (!genre.trim()) {
        new import_obsidian16.Notice("Genre is required", 3e3);
        return;
      }
      try {
        const updatedWorld = await this.plugin.apiClient.updateWorld(
          this.currentWorld.id,
          name.trim(),
          description.trim(),
          genre.trim()
        );
        this.currentWorld = updatedWorld;
        await this.loadStories();
        this.renderWorldDetails();
        modal.close();
        new import_obsidian16.Notice("World updated");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
    nameInput.focus();
    nameInput.select();
  }
  copyStoryId() {
    if (!this.currentStory)
      return;
    navigator.clipboard.writeText(this.currentStory.id).then(() => {
      new import_obsidian16.Notice("UUID copied to clipboard");
    }).catch(() => {
      const textarea = document.createElement("textarea");
      textarea.value = this.currentStory.id;
      textarea.style.position = "fixed";
      textarea.style.opacity = "0";
      textarea.style.left = "-9999px";
      document.body.appendChild(textarea);
      textarea.select();
      try {
        document.execCommand("copy");
        new import_obsidian16.Notice("UUID copied to clipboard");
      } catch (err) {
        new import_obsidian16.Notice("Failed to copy UUID", 3e3);
      }
      document.body.removeChild(textarea);
    });
  }
  async moveChapterUp(chapter) {
    const sortedChapters = [...this.chapters].sort((a, b) => a.number - b.number);
    const currentIndex = sortedChapters.findIndex((c) => c.id === chapter.id);
    if (currentIndex <= 0)
      return;
    const previousChapter = sortedChapters[currentIndex - 1];
    const tempNumber = chapter.number;
    try {
      await this.plugin.apiClient.updateChapter(chapter.id, { number: previousChapter.number });
      await this.plugin.apiClient.updateChapter(previousChapter.id, { number: tempNumber });
      await this.loadHierarchy();
      this.renderTabContent();
      new import_obsidian16.Notice("Chapter moved up");
    } catch (err) {
      new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
    }
  }
  async moveChapterDown(chapter) {
    const sortedChapters = [...this.chapters].sort((a, b) => a.number - b.number);
    const currentIndex = sortedChapters.findIndex((c) => c.id === chapter.id);
    if (currentIndex < 0 || currentIndex >= sortedChapters.length - 1)
      return;
    const nextChapter = sortedChapters[currentIndex + 1];
    const tempNumber = chapter.number;
    try {
      await this.plugin.apiClient.updateChapter(chapter.id, { number: nextChapter.number });
      await this.plugin.apiClient.updateChapter(nextChapter.id, { number: tempNumber });
      await this.loadHierarchy();
      this.renderTabContent();
      new import_obsidian16.Notice("Chapter moved down");
    } catch (err) {
      new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
    }
  }
  async moveSceneUp(scene) {
    const siblingScenes = this.scenes.filter((s) => s.chapter_id === scene.chapter_id).sort((a, b) => a.order_num - b.order_num);
    const currentIndex = siblingScenes.findIndex((s) => s.id === scene.id);
    if (currentIndex <= 0)
      return;
    const previousScene = siblingScenes[currentIndex - 1];
    const tempOrderNum = scene.order_num;
    try {
      await this.plugin.apiClient.updateScene(scene.id, { order_num: previousScene.order_num });
      await this.plugin.apiClient.updateScene(previousScene.id, { order_num: tempOrderNum });
      await this.loadHierarchy();
      this.renderTabContent();
      new import_obsidian16.Notice("Scene moved up");
    } catch (err) {
      new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
    }
  }
  async moveSceneDown(scene) {
    const siblingScenes = this.scenes.filter((s) => s.chapter_id === scene.chapter_id).sort((a, b) => a.order_num - b.order_num);
    const currentIndex = siblingScenes.findIndex((s) => s.id === scene.id);
    if (currentIndex < 0 || currentIndex >= siblingScenes.length - 1)
      return;
    const nextScene = siblingScenes[currentIndex + 1];
    const tempOrderNum = scene.order_num;
    try {
      await this.plugin.apiClient.updateScene(scene.id, { order_num: nextScene.order_num });
      await this.plugin.apiClient.updateScene(nextScene.id, { order_num: tempOrderNum });
      await this.loadHierarchy();
      this.renderTabContent();
      new import_obsidian16.Notice("Scene moved down");
    } catch (err) {
      new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
    }
  }
  async moveBeatUp(beat) {
    const siblingBeats = this.beats.filter((b) => b.scene_id === beat.scene_id).sort((a, b) => a.order_num - b.order_num);
    const currentIndex = siblingBeats.findIndex((b) => b.id === beat.id);
    if (currentIndex <= 0)
      return;
    const previousBeat = siblingBeats[currentIndex - 1];
    const tempOrderNum = beat.order_num;
    try {
      await this.plugin.apiClient.updateBeat(beat.id, { order_num: previousBeat.order_num });
      await this.plugin.apiClient.updateBeat(previousBeat.id, { order_num: tempOrderNum });
      await this.loadHierarchy();
      this.renderTabContent();
      new import_obsidian16.Notice("Beat moved up");
    } catch (err) {
      new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
    }
  }
  async moveBeatDown(beat) {
    const siblingBeats = this.beats.filter((b) => b.scene_id === beat.scene_id).sort((a, b) => a.order_num - b.order_num);
    const currentIndex = siblingBeats.findIndex((b) => b.id === beat.id);
    if (currentIndex < 0 || currentIndex >= siblingBeats.length - 1)
      return;
    const nextBeat = siblingBeats[currentIndex + 1];
    const tempOrderNum = beat.order_num;
    try {
      await this.plugin.apiClient.updateBeat(beat.id, { order_num: nextBeat.order_num });
      await this.plugin.apiClient.updateBeat(nextBeat.id, { order_num: tempOrderNum });
      await this.loadHierarchy();
      this.renderTabContent();
      new import_obsidian16.Notice("Beat moved down");
    } catch (err) {
      new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
    }
  }
  async showMoveSceneModal(scene) {
    if (!this.currentStory)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Move Scene");
    const content = modal.contentEl;
    content.createEl("p", { text: `Move scene "${scene.goal || `Scene ${scene.order_num}`}" to:` });
    const select = content.createEl("select", { cls: "story-engine-move-select" });
    const noChapterOption = select.createEl("option", { text: "No Chapter", value: "" });
    for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
      const option = select.createEl("option", {
        text: `Chapter ${chapter.number}: ${chapter.title}`,
        value: chapter.id
      });
      if (scene.chapter_id === chapter.id) {
        option.selected = true;
      }
    }
    if (!scene.chapter_id) {
      noChapterOption.selected = true;
    }
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const moveButton = buttonContainer.createEl("button", {
      text: "Move",
      cls: "mod-cta"
    });
    moveButton.onclick = async () => {
      const selectedChapterId = select.value || null;
      try {
        await this.plugin.apiClient.moveScene(scene.id, selectedChapterId);
        await this.loadHierarchy();
        this.renderTabContent();
        modal.close();
        new import_obsidian16.Notice("Scene moved successfully");
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to move scene";
        new import_obsidian16.Notice(`Error: ${errorMessage}`, 5e3);
      }
    };
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.onclick = () => modal.close();
    modal.open();
  }
  async showMoveBeatModal(beat) {
    if (!this.currentStory)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Move Beat");
    const content = modal.contentEl;
    content.createEl("p", { text: `Move beat "${beat.type}" to:` });
    const select = content.createEl("select", { cls: "story-engine-move-select" });
    for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
      const chapterScenes = this.scenes.filter((s) => s.chapter_id === chapter.id).sort((a, b) => a.order_num - b.order_num);
      if (chapterScenes.length > 0) {
        const optgroup = select.createEl("optgroup");
        optgroup.label = `Chapter ${chapter.number}: ${chapter.title}`;
        for (const scene of chapterScenes) {
          const option = optgroup.createEl("option", {
            text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`,
            value: scene.id
          });
          if (beat.scene_id === scene.id) {
            option.selected = true;
          }
        }
      }
    }
    const orphanScenes = this.scenes.filter((s) => !s.chapter_id);
    if (orphanScenes.length > 0) {
      const optgroup = select.createEl("optgroup");
      optgroup.label = "No Chapter";
      for (const scene of orphanScenes.sort((a, b) => a.order_num - b.order_num)) {
        const option = optgroup.createEl("option", {
          text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`,
          value: scene.id
        });
        if (beat.scene_id === scene.id) {
          option.selected = true;
        }
      }
    }
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const moveButton = buttonContainer.createEl("button", {
      text: "Move",
      cls: "mod-cta"
    });
    moveButton.onclick = async () => {
      const selectedSceneId = select.value;
      if (!selectedSceneId) {
        new import_obsidian16.Notice("Please select a scene", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.moveBeat(beat.id, selectedSceneId);
        await this.loadHierarchy();
        this.renderTabContent();
        modal.close();
        new import_obsidian16.Notice("Beat moved successfully");
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to move beat";
        new import_obsidian16.Notice(`Error: ${errorMessage}`, 5e3);
      }
    };
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.onclick = () => modal.close();
    modal.open();
  }
  renderContentsTab(container) {
    container.empty();
    const contentsByChapter = /* @__PURE__ */ new Map();
    const contentsByScene = /* @__PURE__ */ new Map();
    const contentsByBeat = /* @__PURE__ */ new Map();
    const orphanContents = [];
    for (const block of this.contentBlocks) {
      const refs = this.contentBlockRefs.filter((r) => r.content_block_id === block.id);
      if (refs.length === 0) {
        orphanContents.push(block);
        continue;
      }
      for (const ref of refs) {
        if (ref.entity_type === "chapter") {
          if (!contentsByChapter.has(ref.entity_id)) {
            contentsByChapter.set(ref.entity_id, []);
          }
          contentsByChapter.get(ref.entity_id).push(block);
        } else if (ref.entity_type === "scene") {
          if (!contentsByScene.has(ref.entity_id)) {
            contentsByScene.set(ref.entity_id, []);
          }
          contentsByScene.get(ref.entity_id).push(block);
        } else if (ref.entity_type === "beat") {
          if (!contentsByBeat.has(ref.entity_id)) {
            contentsByBeat.set(ref.entity_id, []);
          }
          contentsByBeat.get(ref.entity_id).push(block);
        }
      }
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
      const chapterContents = contentsByChapter.get(chapter.id) || [];
      const chapterScenes = this.scenes.filter((s) => s.chapter_id === chapter.id).sort((a, b) => a.order_num - b.order_num);
      if (chapterContents.length > 0 || chapterScenes.length > 0 || chapterScenes.some((s) => {
        const sceneContents = contentsByScene.get(s.id) || [];
        const sceneBeats = this.beats.filter((b) => b.scene_id === s.id);
        const beatContents = sceneBeats.flatMap((b) => contentsByBeat.get(b.id) || []);
        return sceneContents.length > 0 || beatContents.length > 0;
      })) {
        const chapterGroup = list.createDiv({ cls: "story-engine-chapter-group" });
        const chapterHeader = chapterGroup.createDiv({ cls: "story-engine-chapter-group-header story-engine-hoverable-header" });
        chapterHeader.createEl("h2", {
          text: `Chapter ${chapter.number}: ${chapter.title}`
        });
        const chapterHeaderActions = chapterHeader.createDiv({ cls: "story-engine-hover-header-actions" });
        const textBtn = chapterHeaderActions.createEl("button", {
          cls: "story-engine-add-content-btn story-engine-add-text-btn",
          attr: { "aria-label": "Add text content" }
        });
        textBtn.innerHTML = '<span class="story-engine-icon">\u{1F4DD}</span>';
        textBtn.onclick = () => {
          this.createContentForEntity("chapter", chapter.id, chapter.id, "text");
        };
        const imageBtn = chapterHeaderActions.createEl("button", {
          cls: "story-engine-add-content-btn story-engine-add-image-btn",
          attr: { "aria-label": "Add image content" }
        });
        imageBtn.innerHTML = '<span class="story-engine-icon">\u{1F5BC}\uFE0F</span>';
        imageBtn.onclick = () => {
          this.createContentForEntity("chapter", chapter.id, chapter.id, "image");
        };
        const chapterContent = chapterGroup.createDiv({ cls: "story-engine-chapter-group-content" });
        const chapterContentsGroup = chapterContent.createDiv({ cls: "story-engine-group" });
        const chapterContentsHeader = chapterContentsGroup.createDiv({ cls: "story-engine-group-header" });
        chapterContentsHeader.createEl("h3", { text: "Chapter Contents" });
        const chapterContentsItems = chapterContentsGroup.createDiv({ cls: "story-engine-group-items" });
        if (chapterContents.length > 0) {
          for (const block of chapterContents) {
            this.renderContentItem(chapterContentsItems, block, "chapter", chapter.id);
          }
        } else {
          chapterContentsItems.createEl("p", { text: "No content in this chapter.", cls: "story-engine-empty-content" });
        }
        for (const scene of chapterScenes) {
          const sceneContents = contentsByScene.get(scene.id) || [];
          const sceneBeats = this.beats.filter((b) => b.scene_id === scene.id).sort((a, b) => a.order_num - b.order_num);
          const beatContents = sceneBeats.flatMap((b) => contentsByBeat.get(b.id) || []);
          const sceneGroup = chapterContent.createDiv({ cls: "story-engine-group" });
          const sceneHeader = sceneGroup.createDiv({ cls: "story-engine-group-header story-engine-hoverable-header" });
          sceneHeader.createEl("h3", {
            text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`
          });
          const sceneHeaderActions = sceneHeader.createDiv({ cls: "story-engine-hover-header-actions" });
          const chapterId = scene.chapter_id || (this.chapters.length > 0 ? this.chapters[0].id : "");
          if (chapterId) {
            const textBtn2 = sceneHeaderActions.createEl("button", {
              cls: "story-engine-add-content-btn story-engine-add-text-btn",
              attr: { "aria-label": "Add text content" }
            });
            textBtn2.innerHTML = '<span class="story-engine-icon">\u{1F4DD}</span>';
            textBtn2.onclick = () => {
              this.createContentForEntity("scene", scene.id, chapterId, "text");
            };
            const imageBtn2 = sceneHeaderActions.createEl("button", {
              cls: "story-engine-add-content-btn story-engine-add-image-btn",
              attr: { "aria-label": "Add image content" }
            });
            imageBtn2.innerHTML = '<span class="story-engine-icon">\u{1F5BC}\uFE0F</span>';
            imageBtn2.onclick = () => {
              this.createContentForEntity("scene", scene.id, chapterId, "image");
            };
          }
          const sceneItems = sceneGroup.createDiv({ cls: "story-engine-group-items" });
          if (sceneContents.length > 0) {
            for (const block of sceneContents) {
              this.renderContentItem(sceneItems, block, "scene", scene.id);
            }
          } else {
            sceneItems.createEl("p", { text: "No content in this scene.", cls: "story-engine-empty-content" });
          }
          for (const beat of sceneBeats) {
            const beatContents2 = contentsByBeat.get(beat.id) || [];
            const beatSubGroup = sceneItems.createDiv({ cls: "story-engine-beat-subgroup" });
            const beatSubGroupTitle = beatSubGroup.createDiv({ cls: "story-engine-beat-subgroup-title-container story-engine-hoverable-header" });
            beatSubGroupTitle.createEl("h4", {
              text: `Beat ${beat.order_num}: ${beat.type}`,
              cls: "story-engine-beat-subgroup-title"
            });
            const beatHeaderActions = beatSubGroupTitle.createDiv({ cls: "story-engine-hover-header-actions" });
            const beatChapterId = scene.chapter_id || (this.chapters.length > 0 ? this.chapters[0].id : "");
            if (beatChapterId) {
              const textBtn2 = beatHeaderActions.createEl("button", {
                cls: "story-engine-add-content-btn story-engine-add-text-btn",
                attr: { "aria-label": "Add text content" }
              });
              textBtn2.innerHTML = '<span class="story-engine-icon">\u{1F4DD}</span>';
              textBtn2.onclick = () => {
                this.createContentForEntity("beat", beat.id, beatChapterId, "text");
              };
              const imageBtn2 = beatHeaderActions.createEl("button", {
                cls: "story-engine-add-content-btn story-engine-add-image-btn",
                attr: { "aria-label": "Add image content" }
              });
              imageBtn2.innerHTML = '<span class="story-engine-icon">\u{1F5BC}\uFE0F</span>';
              imageBtn2.onclick = () => {
                this.createContentForEntity("beat", beat.id, beatChapterId, "image");
              };
            }
            if (beatContents2.length > 0) {
              for (const block of beatContents2) {
                this.renderContentItem(beatSubGroup, block, "beat", beat.id);
              }
            } else {
              beatSubGroup.createEl("p", { text: "No content in this beat.", cls: "story-engine-empty-beat-content" });
            }
          }
        }
      }
    }
    if (this.chapters.length === 0 || orphanContents.length > 0 || this.scenes.some((s) => !s.chapter_id)) {
      const orphanGroup = list.createDiv({ cls: "story-engine-chapter-group" });
      const orphanHeader = orphanGroup.createDiv({ cls: "story-engine-chapter-group-header" });
      orphanHeader.createEl("h2", { text: "Without Chapter" });
      const orphanContent = orphanGroup.createDiv({ cls: "story-engine-chapter-group-content" });
      const orphanScenes = this.scenes.filter((s) => !s.chapter_id).sort((a, b) => a.order_num - b.order_num);
      for (const scene of orphanScenes) {
        const sceneContents = contentsByScene.get(scene.id) || [];
        const sceneBeats = this.beats.filter((b) => b.scene_id === scene.id).sort((a, b) => a.order_num - b.order_num);
        const beatContents = sceneBeats.flatMap((b) => contentsByBeat.get(b.id) || []);
        const sceneGroup = orphanContent.createDiv({ cls: "story-engine-group" });
        const sceneHeader = sceneGroup.createDiv({ cls: "story-engine-group-header story-engine-hoverable-header" });
        sceneHeader.createEl("h3", {
          text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`
        });
        const sceneHeaderActions = sceneHeader.createDiv({ cls: "story-engine-header-actions" });
        const chapterId = this.chapters.length > 0 ? this.chapters[0].id : "";
        if (chapterId) {
          sceneHeaderActions.createEl("button", {
            text: "+ Content",
            cls: "story-engine-add-content-btn"
          }).onclick = () => {
            this.createContentForEntity("scene", scene.id, chapterId);
          };
        }
        const sceneItems = sceneGroup.createDiv({ cls: "story-engine-group-items" });
        if (sceneContents.length > 0) {
          for (const block of sceneContents) {
            this.renderContentItem(sceneItems, block, "scene", scene.id);
          }
        } else {
          sceneItems.createEl("p", { text: "No content in this scene." });
        }
        for (const beat of sceneBeats) {
          const beatContents2 = contentsByBeat.get(beat.id) || [];
          const beatSubGroup = sceneItems.createDiv({ cls: "story-engine-beat-subgroup" });
          const beatSubGroupTitle = beatSubGroup.createDiv({ cls: "story-engine-beat-subgroup-title-container story-engine-hoverable-header" });
          beatSubGroupTitle.createEl("h4", {
            text: `Beat ${beat.order_num}: ${beat.type}`,
            cls: "story-engine-beat-subgroup-title"
          });
          const beatHeaderActions = beatSubGroupTitle.createDiv({ cls: "story-engine-hover-header-actions" });
          const beatChapterId = this.chapters.length > 0 ? this.chapters[0].id : "";
          if (beatChapterId) {
            beatHeaderActions.createEl("button", {
              text: "+ Content",
              cls: "story-engine-add-content-btn"
            }).onclick = () => {
              this.createContentForEntity("beat", beat.id, beatChapterId);
            };
          }
          if (beatContents2.length > 0) {
            for (const block of beatContents2) {
              this.renderContentItem(beatSubGroup, block, "beat", beat.id);
            }
          } else {
            beatSubGroup.createEl("p", { text: "No content in this beat.", cls: "story-engine-empty-beat-content" });
          }
        }
      }
      if (orphanContents.length > 0) {
        const orphanContentsGroup = orphanContent.createDiv({ cls: "story-engine-group" });
        const orphanContentsHeader = orphanContentsGroup.createDiv({ cls: "story-engine-group-header" });
        orphanContentsHeader.createEl("h3", { text: "Without Reference" });
        const orphanContentsItems = orphanContentsGroup.createDiv({ cls: "story-engine-group-items" });
        for (const block of orphanContents) {
          this.renderContentItem(orphanContentsItems, block, null, null);
        }
      }
    }
  }
  async loadStoryCharacters() {
    if (!this.currentStory || !this.currentStory.world_id) {
      this.storyCharacters = [];
      return;
    }
    try {
      this.storyCharacters = await this.plugin.apiClient.getCharacters(this.currentStory.world_id);
    } catch (err) {
      console.error("Error loading story characters:", err);
      this.storyCharacters = [];
      new import_obsidian16.Notice(`Error loading characters: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
    }
  }
  renderStoryCharactersTab(container) {
    var _a;
    container.empty();
    if (!((_a = this.currentStory) == null ? void 0 : _a.world_id)) {
      const noWorldMsg = container.createDiv({ cls: "story-engine-empty-state" });
      noWorldMsg.createEl("p", { text: "This story is not linked to a world." });
      noWorldMsg.createEl("p", { text: "Link this story to a world to see its characters.", cls: "story-engine-hint" });
      return;
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    if (this.storyCharacters.length === 0) {
      list.createEl("p", { text: "No characters found in this story's world." });
    } else {
      for (const character of this.storyCharacters.sort((a, b) => a.name.localeCompare(b.name))) {
        const item = list.createDiv({ cls: "story-engine-item" });
        const titleDiv = item.createDiv({ cls: "story-engine-title", text: character.name });
        titleDiv.style.cursor = "pointer";
        titleDiv.onclick = () => {
          this.showCharacterDetails(character);
        };
        const meta = item.createDiv({ cls: "story-engine-meta" });
        if (character.description) {
          meta.createEl("span", {
            text: character.description.substring(0, 80) + (character.description.length > 80 ? "..." : "")
          });
        }
        const actions = item.createDiv({ cls: "story-engine-item-actions" });
        const viewBtn = actions.createEl("button", { text: "View" });
        viewBtn.onclick = () => {
          this.showCharacterDetails(character);
        };
      }
    }
    const footer = container.createDiv({ cls: "story-engine-list-footer" });
    const createButton = footer.createEl("button", {
      text: "Create Character",
      cls: "mod-cta"
    });
    createButton.onclick = () => {
      this.showCreateCharacterModalForStory();
    };
  }
  showCreateCharacterModalForStory() {
    var _a;
    if (!((_a = this.currentStory) == null ? void 0 : _a.world_id)) {
      new import_obsidian16.Notice("This story is not linked to a world");
      return;
    }
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Create Character");
    const content = modal.contentEl;
    let name = "";
    let description = "";
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input" });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Create", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.createCharacter(this.currentStory.world_id, {
          name: name.trim(),
          description: description.trim()
        });
        await this.loadStoryCharacters();
        this.renderTabContent();
        modal.close();
        new import_obsidian16.Notice("Character created");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
    nameInput.focus();
  }
  renderContentItem(container, contentBlock, entityType, entityId) {
    var _a, _b;
    const item = container.createDiv({ cls: "story-engine-item story-engine-content-item" });
    const itemContent = item.createDiv({ cls: "story-engine-content-item-content" });
    const iconContainer = itemContent.createDiv({ cls: "story-engine-content-icon" });
    const iconMap = {
      text: "file-text",
      image: "image",
      video: "video",
      audio: "music",
      embed: "code",
      link: "external-link"
    };
    const iconName = iconMap[contentBlock.type] || "file";
    (0, import_obsidian16.setIcon)(iconContainer, iconName);
    const preview = itemContent.createDiv({ cls: "story-engine-content-preview" });
    if (contentBlock.type === "text") {
      const textPreview = contentBlock.content || "";
      const truncated = textPreview.length > 100 ? textPreview.substring(0, 100) + "..." : textPreview;
      preview.createEl("span", { text: truncated });
    } else if (contentBlock.type === "image") {
      const imgContainer = preview.createDiv({ cls: "story-engine-image-container" });
      const img = imgContainer.createEl("img", {
        attr: { src: contentBlock.content || "", alt: ((_a = contentBlock.metadata) == null ? void 0 : _a.alt_text) || "" },
        cls: "story-engine-content-thumbnail"
      });
      img.style.maxWidth = "100px";
      img.style.maxHeight = "60px";
      img.style.objectFit = "cover";
      img.style.borderRadius = "4px";
      if ((_b = contentBlock.metadata) == null ? void 0 : _b.attribution) {
        const attribution = imgContainer.createDiv({ cls: "story-engine-unsplash-attribution" });
        attribution.createEl("span", {
          text: contentBlock.metadata.attribution,
          cls: "story-engine-attribution-text"
        });
      }
    } else {
      preview.createEl("span", { text: contentBlock.content || "" });
    }
    const actions = item.createDiv({ cls: "story-engine-item-actions" });
    actions.createEl("button", { text: "Edit" }).onclick = () => {
      new ContentBlockModal(this.app, async (updatedContentBlock) => {
        try {
          await this.plugin.apiClient.updateContentBlock(contentBlock.id, updatedContentBlock);
          await this.loadHierarchy();
          this.renderTabContent();
          new import_obsidian16.Notice("Content block updated successfully");
        } catch (err) {
          throw err;
        }
      }, contentBlock, this.plugin).open();
    };
    actions.createEl("button", { text: "Move" }).onclick = async () => {
      await this.showMoveContentModal(contentBlock, entityType, entityId, "move");
    };
    actions.createEl("button", { text: "Link" }).onclick = async () => {
      await this.showMoveContentModal(contentBlock, entityType, entityId, "link");
    };
    actions.createEl("button", { text: "Delete" }).onclick = async () => {
      if (confirm("Delete this content block?")) {
        try {
          await this.plugin.apiClient.deleteContentBlock(contentBlock.id);
          await this.loadHierarchy();
          this.renderTabContent();
          new import_obsidian16.Notice("Content block deleted");
        } catch (err) {
          new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
        }
      }
    };
  }
  async showMoveContentModal(contentBlock, currentEntityType, currentEntityId, mode) {
    if (!this.currentStory)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText(mode === "move" ? "Move Content Block" : "Link Content Block");
    const content = modal.contentEl;
    content.createEl("p", {
      text: mode === "move" ? `Move content block to:` : `Link content block to (will appear in both places):`
    });
    const select = content.createEl("select", { cls: "story-engine-move-select" });
    const noRefOption = select.createEl("option", { text: "No Reference", value: "" });
    for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
      const option = select.createEl("option", {
        text: `Chapter ${chapter.number}: ${chapter.title}`,
        value: `chapter:${chapter.id}`
      });
      if (currentEntityType === "chapter" && currentEntityId === chapter.id) {
        option.selected = true;
      }
    }
    for (const chapter of this.chapters.sort((a, b) => a.number - b.number)) {
      const chapterScenes = this.scenes.filter((s) => s.chapter_id === chapter.id).sort((a, b) => a.order_num - b.order_num);
      if (chapterScenes.length > 0) {
        const optgroup = select.createEl("optgroup");
        optgroup.label = `Chapter ${chapter.number}: ${chapter.title} - Scenes`;
        for (const scene of chapterScenes) {
          const option = optgroup.createEl("option", {
            text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`,
            value: `scene:${scene.id}`
          });
          if (currentEntityType === "scene" && currentEntityId === scene.id) {
            option.selected = true;
          }
        }
      }
    }
    const orphanScenes = this.scenes.filter((s) => !s.chapter_id);
    if (orphanScenes.length > 0) {
      const optgroup = select.createEl("optgroup");
      optgroup.label = "No Chapter - Scenes";
      for (const scene of orphanScenes.sort((a, b) => a.order_num - b.order_num)) {
        const option = optgroup.createEl("option", {
          text: `Scene ${scene.order_num}: ${scene.goal || "Untitled"}`,
          value: `scene:${scene.id}`
        });
        if (currentEntityType === "scene" && currentEntityId === scene.id) {
          option.selected = true;
        }
      }
    }
    for (const scene of this.scenes.sort((a, b) => a.order_num - b.order_num)) {
      const sceneBeats = this.beats.filter((b) => b.scene_id === scene.id).sort((a, b) => a.order_num - b.order_num);
      if (sceneBeats.length > 0) {
        const chapter = this.chapters.find((c) => c.id === scene.chapter_id);
        const chapterLabel = chapter ? `Chapter ${chapter.number}` : "No Chapter";
        const optgroup = select.createEl("optgroup");
        optgroup.label = `${chapterLabel} > Scene ${scene.order_num} - Beats`;
        for (const beat of sceneBeats) {
          const option = optgroup.createEl("option", {
            text: `Beat ${beat.order_num}: ${beat.type}`,
            value: `beat:${beat.id}`
          });
          if (currentEntityType === "beat" && currentEntityId === beat.id) {
            option.selected = true;
          }
        }
      }
    }
    if (!currentEntityType) {
      noRefOption.selected = true;
    }
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const actionButton = buttonContainer.createEl("button", {
      text: mode === "move" ? "Move" : "Link",
      cls: "mod-cta"
    });
    actionButton.onclick = async () => {
      const selectedValue = select.value;
      try {
        if (mode === "move" && currentEntityType && currentEntityId) {
          const currentRef = this.contentBlockRefs.find(
            (r) => r.content_block_id === contentBlock.id && r.entity_type === currentEntityType && r.entity_id === currentEntityId
          );
          if (currentRef) {
            await this.plugin.apiClient.deleteContentAnchor(currentRef.id);
          }
        }
        if (selectedValue) {
          const [entityType, entityId] = selectedValue.split(":");
          await this.plugin.apiClient.createContentAnchor(contentBlock.id, entityType, entityId);
        }
        await this.loadHierarchy();
        this.renderTabContent();
        modal.close();
        new import_obsidian16.Notice(mode === "move" ? "Content block moved successfully" : "Content block linked successfully");
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : `Failed to ${mode} content block`;
        new import_obsidian16.Notice(`Error: ${errorMessage}`, 5e3);
      }
    };
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.onclick = () => modal.close();
    modal.open();
  }
  async createContentForEntity(entityType, entityId, chapterId, contentType = "text") {
    if (!this.currentStory)
      return;
    if (!chapterId) {
      if (this.chapters.length === 0) {
        new import_obsidian16.Notice("No chapter available. Please create a chapter first.", 5e3);
        return;
      }
      chapterId = this.chapters[0].id;
    }
    const chapterBlocks = this.contentBlocks.filter((cb) => {
      const refs = this.contentBlockRefs.filter((r) => r.content_block_id === cb.id && r.entity_type === "chapter" && r.entity_id === chapterId);
      return refs.length > 0 || cb.chapter_id === chapterId;
    });
    const maxOrderNum = chapterBlocks.length > 0 ? Math.max(...chapterBlocks.map((cb) => cb.order_num || 0)) : 0;
    const nextOrderNum = maxOrderNum + 1;
    const initialContentBlock = {
      type: contentType,
      kind: "final",
      content: "",
      metadata: {}
    };
    new ContentBlockModal(this.app, async (contentBlock) => {
      try {
        contentBlock.order_num = nextOrderNum;
        const created = await this.plugin.apiClient.createContentBlock(chapterId, contentBlock);
        await this.plugin.apiClient.createContentAnchor(created.id, entityType, entityId);
        await this.loadHierarchy();
        this.renderTabContent();
        new import_obsidian16.Notice("Content block created successfully");
      } catch (err) {
        throw err;
      }
    }, initialContentBlock, this.plugin).open();
  }
  // ==================== World View Methods ====================
  async showWorldDetails(world) {
    this.currentWorld = world;
    this.viewMode = "world-details";
    this.worldTab = "characters";
    await this.loadWorldData();
    this.renderWorldDetails();
  }
  async loadWorldData() {
    if (!this.currentWorld)
      return;
    this.loadingWorldData = true;
    try {
      this.characters = await this.plugin.apiClient.getCharacters(this.currentWorld.id);
      this.locations = await this.plugin.apiClient.getLocations(this.currentWorld.id);
      this.artifacts = await this.plugin.apiClient.getArtifacts(this.currentWorld.id);
      this.events = await this.plugin.apiClient.getEvents(this.currentWorld.id);
      try {
        this.traits = await this.plugin.apiClient.getTraits();
      } catch (err) {
        console.warn("Traits not available:", err);
        this.traits = [];
      }
      try {
        this.archetypes = await this.plugin.apiClient.getArchetypes();
      } catch (err) {
        console.warn("Archetypes not available:", err);
        this.archetypes = [];
      }
      try {
        this.factions = await this.plugin.apiClient.getFactions(this.currentWorld.id);
      } catch (err) {
        console.warn("Factions not available:", err);
        this.factions = [];
      }
      try {
        this.lores = await this.plugin.apiClient.getLores(this.currentWorld.id);
      } catch (err) {
        console.warn("Lores not available:", err);
        this.lores = [];
      }
      try {
        this.currentWorld = await this.plugin.apiClient.getWorld(this.currentWorld.id);
      } catch (err) {
        console.warn("Failed to reload world:", err);
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to load world data";
      new import_obsidian16.Notice(`Error: ${errorMessage}`, 5e3);
    } finally {
      this.loadingWorldData = false;
    }
  }
  renderWorldDetails() {
    if (!this.contentEl || !this.currentWorld)
      return;
    this.renderWorldDetailsHeader();
    this.contentEl.empty();
    this.renderWorldTabs();
    this.renderWorldTabContent();
  }
  renderWorldDetailsHeader() {
    if (!this.headerEl || !this.currentWorld)
      return;
    this.headerEl.empty();
    const headerLeft = this.headerEl.createDiv({ cls: "story-engine-header-left" });
    const backButton = headerLeft.createEl("button", {
      text: "\u2190 Back",
      cls: "story-engine-back-btn"
    });
    backButton.onclick = () => {
      this.currentWorld = null;
      this.viewMode = "list";
      this.listTab = "worlds";
      this.renderListHeader();
      this.renderListContent();
    };
    const titleContainer = headerLeft.createDiv({ cls: "story-engine-title-container" });
    const titleRow = titleContainer.createDiv({ cls: "story-engine-title-row" });
    titleRow.createEl("h2", {
      text: this.currentWorld.name,
      cls: "story-engine-title-header"
    });
    if (this.currentWorld.genre) {
      const genrePill = titleRow.createSpan({
        cls: "story-engine-status-pill story-engine-status-draft"
      });
      genrePill.textContent = this.currentWorld.genre;
    }
    const uuidRow = titleContainer.createDiv({ cls: "story-engine-uuid-row" });
    const uuidSpan = uuidRow.createSpan({ cls: "story-engine-uuid" });
    uuidSpan.textContent = this.currentWorld.id;
    const copyUuidButton = uuidRow.createEl("button", {
      cls: "story-engine-copy-uuid-btn",
      attr: { "aria-label": "Copy UUID" }
    });
    (0, import_obsidian16.setIcon)(copyUuidButton, "copy");
    copyUuidButton.onclick = () => {
      if (!this.currentWorld)
        return;
      navigator.clipboard.writeText(this.currentWorld.id).then(() => {
        new import_obsidian16.Notice("UUID copied to clipboard");
      }).catch(() => {
        new import_obsidian16.Notice("Failed to copy UUID", 3e3);
      });
    };
    if (this.currentWorld.description) {
      const descRow = titleContainer.createDiv({ cls: "story-engine-world-desc" });
      descRow.textContent = this.currentWorld.description;
    }
    const headerActions = this.headerEl.createDiv({ cls: "story-engine-header-actions" });
    const contextButton = headerActions.createEl("button", {
      cls: "story-engine-context-btn",
      attr: { "aria-label": "World Actions" }
    });
    (0, import_obsidian16.setIcon)(contextButton, "more-vertical");
    const dropdownMenu = headerActions.createDiv({ cls: "story-engine-dropdown-menu" });
    dropdownMenu.style.display = "none";
    const editOption = dropdownMenu.createEl("button", {
      cls: "story-engine-dropdown-item"
    });
    (0, import_obsidian16.setIcon)(editOption, "pencil");
    editOption.createSpan({ text: "Edit World" });
    editOption.onclick = () => {
      dropdownMenu.style.display = "none";
      this.showEditWorldModal();
    };
    dropdownMenu.createDiv({ cls: "story-engine-dropdown-divider" });
    dropdownMenu.createEl("div", {
      cls: "story-engine-dropdown-section",
      text: "Sync"
    });
    const pullWorldOption = dropdownMenu.createEl("button", {
      cls: "story-engine-dropdown-item"
    });
    (0, import_obsidian16.setIcon)(pullWorldOption, "download");
    pullWorldOption.createSpan({ text: "Pull World Files" });
    pullWorldOption.onclick = async () => {
      dropdownMenu.style.display = "none";
      await this.pullCurrentWorld();
    };
    const pushWorldOption = dropdownMenu.createEl("button", {
      cls: "story-engine-dropdown-item"
    });
    (0, import_obsidian16.setIcon)(pushWorldOption, "upload");
    pushWorldOption.createSpan({ text: "Push World Files" });
    pushWorldOption.onclick = async () => {
      dropdownMenu.style.display = "none";
      await this.pushCurrentWorld();
    };
    contextButton.onclick = (e) => {
      e.stopPropagation();
      const isVisible = dropdownMenu.style.display !== "none";
      dropdownMenu.style.display = isVisible ? "none" : "block";
    };
    document.addEventListener("click", () => {
      dropdownMenu.style.display = "none";
    }, { once: true });
  }
  async pullCurrentWorld() {
    var _a;
    if (!this.currentWorld)
      return;
    try {
      new import_obsidian16.Notice(`Pulling world "${this.currentWorld.name}"...`);
      const syncService = this.plugin.syncService;
      if (syncService == null ? void 0 : syncService.pullWorld) {
        await syncService.pullWorld(this.currentWorld.id);
      } else if (syncService == null ? void 0 : syncService.getOrchestrator) {
        const result = await syncService.getOrchestrator().run({
          type: "pull_world",
          payload: { worldId: this.currentWorld.id }
        });
        if (!(result == null ? void 0 : result.success)) {
          throw new Error((_a = result == null ? void 0 : result.message) != null ? _a : "Failed to pull world");
        }
      } else {
        throw new Error("World sync is not available in this sync version");
      }
      await this.loadWorldData();
      this.renderWorldTabContent();
      new import_obsidian16.Notice(`World pulled successfully!`);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to pull world";
      new import_obsidian16.Notice(`Error: ${errorMessage}`, 5e3);
    }
  }
  async pushCurrentWorld() {
    if (!this.currentWorld)
      return;
    try {
      new import_obsidian16.Notice(`Pushing world "${this.currentWorld.name}"...`);
      const syncService = this.plugin.syncService;
      if (syncService == null ? void 0 : syncService.pushWorld) {
        await syncService.pushWorld(this.currentWorld);
      } else if (syncService == null ? void 0 : syncService.getContext) {
        const handler = new WorldHandler();
        await handler.push(this.currentWorld, syncService.getContext());
      } else {
        throw new Error("World sync is not available in this sync version");
      }
      new import_obsidian16.Notice(`World pushed successfully!`);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to push world";
      new import_obsidian16.Notice(`Error: ${errorMessage}`, 5e3);
    }
  }
  renderWorldTabs() {
    if (!this.contentEl)
      return;
    const existingTabs = this.contentEl.querySelector(".story-engine-tabs-container");
    if (existingTabs) {
      existingTabs.remove();
    }
    const tabsWrapper = this.contentEl.createDiv({ cls: "story-engine-tabs-container" });
    const entityTabsContainer = tabsWrapper.createDiv({ cls: "story-engine-tabs" });
    const entityTabs = [
      { key: "characters", label: "Characters" },
      { key: "locations", label: "Locations" },
      { key: "factions", label: "Factions" },
      { key: "artifacts", label: "Artifacts" }
    ];
    for (const tab of entityTabs) {
      const tabButton = entityTabsContainer.createEl("button", {
        text: tab.label,
        cls: `story-engine-tab ${this.worldTab === tab.key ? "is-active" : ""}`
      });
      tabButton.onclick = () => {
        this.worldTab = tab.key;
        this.renderWorldTabs();
        this.renderWorldTabContent();
      };
    }
    const metaTabsContainer = tabsWrapper.createDiv({ cls: "story-engine-tabs" });
    const metaTabs = [
      { key: "traits", label: "Traits" },
      { key: "archetypes", label: "Archetypes" },
      { key: "events", label: "Events" },
      { key: "lore", label: "Lore" }
    ];
    for (const tab of metaTabs) {
      const tabButton = metaTabsContainer.createEl("button", {
        text: tab.label,
        cls: `story-engine-tab ${this.worldTab === tab.key ? "is-active" : ""}`
      });
      tabButton.onclick = () => {
        this.worldTab = tab.key;
        this.renderWorldTabs();
        this.renderWorldTabContent();
      };
    }
  }
  renderWorldTabContent() {
    if (!this.contentEl)
      return;
    const existingContent = this.contentEl.querySelector(".story-engine-tab-content");
    if (existingContent) {
      existingContent.remove();
    }
    const contentContainer = this.contentEl.createDiv({ cls: "story-engine-tab-content" });
    if (this.loadingWorldData) {
      contentContainer.createEl("p", { text: "Loading..." });
      return;
    }
    switch (this.worldTab) {
      case "characters":
        this.renderCharactersTab(contentContainer);
        break;
      case "traits":
        this.renderTraitsTab(contentContainer);
        break;
      case "archetypes":
        this.renderArchetypesTab(contentContainer);
        break;
      case "events":
        this.renderEventsTab(contentContainer);
        break;
      case "lore":
        this.renderLoreTab(contentContainer);
        break;
      case "locations":
        this.renderLocationsTab(contentContainer);
        break;
      case "factions":
        this.renderFactionsTab(contentContainer);
        break;
      case "artifacts":
        this.renderArtifactsTab(contentContainer);
        break;
    }
    this.renderWorldActionsBar(contentContainer);
  }
  renderWorldActionsBar(container) {
    const actionsBar = container.createDiv({ cls: "story-engine-actions-bar" });
    let createButtonText = "Create Character";
    let createButtonAction = () => {
      this.showCreateCharacterModal();
    };
    switch (this.worldTab) {
      case "traits":
        createButtonText = "Create Trait";
        createButtonAction = () => this.showCreateTraitModal();
        break;
      case "archetypes":
        createButtonText = "Create Archetype";
        createButtonAction = () => this.showCreateArchetypeModal();
        break;
      case "events":
        createButtonText = "Create Event";
        createButtonAction = () => this.showCreateEventModal();
        break;
      case "lore":
        createButtonText = "Create Lore";
        createButtonAction = () => this.showCreateLoreModal();
        break;
      case "locations":
        createButtonText = "Create Location";
        createButtonAction = () => this.showCreateLocationModal();
        break;
      case "factions":
        createButtonText = "Create Faction";
        createButtonAction = () => this.showCreateFactionModal();
        break;
      case "artifacts":
        createButtonText = "Create Artifact";
        createButtonAction = () => this.showCreateArtifactModal();
        break;
    }
    const createButton = actionsBar.createEl("button", {
      text: createButtonText,
      cls: "mod-cta story-engine-create-btn"
    });
    createButton.onclick = createButtonAction;
  }
  renderCharactersTab(container) {
    if (this.characters.length === 0) {
      container.createEl("p", { text: "No characters found. Create your first character!" });
      return;
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const character of this.characters) {
      const item = list.createDiv({ cls: "story-engine-item" });
      const titleDiv = item.createDiv({ cls: "story-engine-title", text: character.name });
      titleDiv.style.cursor = "pointer";
      titleDiv.onclick = () => {
        this.showCharacterDetails(character);
      };
      const meta = item.createDiv({ cls: "story-engine-meta" });
      if (character.description) {
        meta.createEl("span", { text: character.description.substring(0, 50) + (character.description.length > 50 ? "..." : "") });
      }
      const actions = item.createDiv({ cls: "story-engine-item-actions" });
      const relBtn = actions.createEl("button");
      (0, import_obsidian16.setIcon)(relBtn, "users");
      relBtn.title = "Add Relationship";
      relBtn.onclick = () => this.showAddCharacterRelationshipModal(character);
      actions.createEl("button", { text: "Edit" }).onclick = () => {
        this.showEditCharacterModal(character);
      };
      actions.createEl("button", { text: "Delete" }).onclick = async () => {
        if (confirm(`Delete character "${character.name}"?`)) {
          try {
            await this.plugin.apiClient.deleteCharacter(character.id);
            await this.loadWorldData();
            this.renderWorldTabContent();
            new import_obsidian16.Notice("Character deleted");
          } catch (err) {
            new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
          }
        }
      };
    }
  }
  renderLocationsTab(container) {
    if (this.locations.length === 0) {
      container.createEl("p", { text: "No locations found. Create your first location!" });
      return;
    }
    const rootLocations = this.locations.filter((l) => !l.parent_id);
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const location of rootLocations.sort((a, b) => a.name.localeCompare(b.name))) {
      this.renderLocationItem(list, location, 0);
    }
  }
  renderLocationItem(container, location, level) {
    const item = container.createDiv({ cls: "story-engine-item" });
    item.style.marginLeft = `${level * 1}rem`;
    const titleRow = item.createDiv({ cls: "story-engine-title" });
    titleRow.textContent = location.name;
    if (location.type) {
      const typeBadge = titleRow.createSpan({ cls: "story-engine-badge" });
      typeBadge.textContent = location.type;
    }
    const meta = item.createDiv({ cls: "story-engine-meta" });
    if (location.description) {
      meta.createEl("span", { text: location.description.substring(0, 50) + (location.description.length > 50 ? "..." : "") });
    }
    const actions = item.createDiv({ cls: "story-engine-item-actions" });
    actions.createEl("button", { text: "Edit" }).onclick = () => {
      this.showEditLocationModal(location);
    };
    actions.createEl("button", { text: "Delete" }).onclick = async () => {
      if (confirm(`Delete location "${location.name}"?`)) {
        try {
          await this.plugin.apiClient.deleteLocation(location.id);
          await this.loadWorldData();
          this.renderWorldTabContent();
          new import_obsidian16.Notice("Location deleted");
        } catch (err) {
          new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
        }
      }
    };
    const children2 = this.locations.filter((l) => l.parent_id === location.id);
    for (const child of children2.sort((a, b) => a.name.localeCompare(b.name))) {
      this.renderLocationItem(container, child, level + 1);
    }
  }
  renderArtifactsTab(container) {
    if (this.artifacts.length === 0) {
      container.createEl("p", { text: "No artifacts found. Create your first artifact!" });
      return;
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const artifact of this.artifacts) {
      const item = list.createDiv({ cls: "story-engine-item" });
      const titleRow = item.createDiv({ cls: "story-engine-title" });
      titleRow.textContent = artifact.name;
      if (artifact.rarity) {
        const rarityBadge = titleRow.createSpan({ cls: `story-engine-badge story-engine-rarity-${artifact.rarity.toLowerCase()}` });
        rarityBadge.textContent = artifact.rarity;
      }
      const meta = item.createDiv({ cls: "story-engine-meta" });
      if (artifact.description) {
        meta.createEl("span", { text: artifact.description.substring(0, 50) + (artifact.description.length > 50 ? "..." : "") });
      }
      const actions = item.createDiv({ cls: "story-engine-item-actions" });
      actions.createEl("button", { text: "Edit" }).onclick = () => {
        this.showEditArtifactModal(artifact);
      };
      actions.createEl("button", { text: "Delete" }).onclick = async () => {
        if (confirm(`Delete artifact "${artifact.name}"?`)) {
          try {
            await this.plugin.apiClient.deleteArtifact(artifact.id);
            await this.loadWorldData();
            this.renderWorldTabContent();
            new import_obsidian16.Notice("Artifact deleted");
          } catch (err) {
            new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
          }
        }
      };
    }
  }
  renderEventsTab(container) {
    var _a;
    const timeConfigSection = container.createDiv({ cls: "story-engine-time-config-section" });
    if ((_a = this.currentWorld) == null ? void 0 : _a.time_config) {
      this.renderTimeConfigDisplay(timeConfigSection, this.currentWorld.time_config);
      const editBtn = timeConfigSection.createEl("button", {
        text: "Edit Time Config",
        cls: "story-engine-btn-secondary"
      });
      editBtn.onclick = () => this.showTimeConfigModal(this.currentWorld.time_config);
    } else {
      const addBtn = timeConfigSection.createEl("button", {
        text: "Add Time Configuration",
        cls: "story-engine-btn-primary"
      });
      addBtn.onclick = () => this.showTimeConfigModal(null);
    }
    const timelineSection = container.createDiv({ cls: "story-engine-timeline-section" });
    const timelineBtn = timelineSection.createEl("button", {
      text: "View Timeline",
      cls: "story-engine-btn-secondary"
    });
    timelineBtn.onclick = () => this.showTimelineModal();
    const epochSection = container.createDiv({ cls: "story-engine-epoch-section" });
    epochSection.createEl("h4", { text: "\u23F0 Epoch Event (Year Zero)", cls: "story-engine-section-title" });
    const epochEvent = this.events.find((e) => e.is_epoch && e.timeline_position === 0);
    if (epochEvent) {
      const epochItem = epochSection.createDiv({ cls: "story-engine-item story-engine-epoch-item" });
      const epochTitle = epochItem.createDiv({ cls: "story-engine-title" });
      epochTitle.createSpan({ text: epochEvent.name });
      epochTitle.createSpan({ cls: "story-engine-badge story-engine-badge-epoch", text: "EPOCH" });
      const epochMeta = epochItem.createDiv({ cls: "story-engine-meta" });
      epochMeta.createEl("span", { text: "Position: 0 (Year Zero)" });
      if (epochEvent.description) {
        epochMeta.createEl("span", { text: epochEvent.description.substring(0, 80) + (epochEvent.description.length > 80 ? "..." : "") });
      }
      const epochActions = epochItem.createDiv({ cls: "story-engine-item-actions" });
      epochActions.createEl("button", { text: "Edit Epoch" }).onclick = () => {
        this.showEditEventModal(epochEvent);
      };
    } else {
      const createEpochBtn = epochSection.createEl("button", {
        text: "\u{1F31F} Create Epoch Event (Year Zero)",
        cls: "mod-cta story-engine-create-epoch-btn"
      });
      createEpochBtn.onclick = () => this.showCreateEpochEventModal();
      epochSection.createEl("p", {
        text: "The Epoch Event marks Year Zero - all other events are dated relative to this point.",
        cls: "story-engine-hint"
      });
    }
    const eventsSection = container.createDiv({ cls: "story-engine-events-list-section" });
    eventsSection.createEl("h4", { text: "\u{1F4DC} Events", cls: "story-engine-section-title" });
    const regularEvents = this.events.filter((e) => !(e.is_epoch && e.timeline_position === 0));
    if (regularEvents.length === 0) {
      eventsSection.createEl("p", { text: "No events yet. Create your first event!", cls: "story-engine-empty-hint" });
      return;
    }
    const list = eventsSection.createDiv({ cls: "story-engine-list" });
    const sortedEvents = regularEvents.sort((a, b) => {
      var _a2, _b;
      const posA = (_a2 = a.timeline_position) != null ? _a2 : Number.MAX_SAFE_INTEGER;
      const posB = (_b = b.timeline_position) != null ? _b : Number.MAX_SAFE_INTEGER;
      if (posA !== posB)
        return posA - posB;
      return b.importance - a.importance;
    });
    for (const event of sortedEvents) {
      const item = list.createDiv({ cls: "story-engine-item" });
      const titleRow = item.createDiv({ cls: "story-engine-title" });
      titleRow.createSpan({ text: event.name });
      const importanceBadge = titleRow.createSpan({ cls: "story-engine-badge" });
      importanceBadge.textContent = `\u2605${event.importance}`;
      if (event.type) {
        titleRow.createSpan({ cls: "story-engine-badge", text: event.type });
      }
      if (event.is_epoch) {
        titleRow.createSpan({ cls: "story-engine-badge story-engine-badge-epoch", text: "EPOCH" });
      }
      const meta = item.createDiv({ cls: "story-engine-meta" });
      if (event.timeline_position !== void 0 && event.timeline_position !== null) {
        const posText = event.timeline_position >= 0 ? `Year ${event.timeline_position}` : `${Math.abs(event.timeline_position)} years before Year Zero`;
        meta.createEl("span", { text: `\u{1F4C5} ${posText}`, cls: "story-engine-event-position" });
      }
      if (event.parent_id) {
        const parentEvent = this.events.find((e) => e.id === event.parent_id);
        if (parentEvent) {
          meta.createEl("span", { text: `\u21B3 Related to: ${parentEvent.name}`, cls: "story-engine-event-parent" });
        }
      }
      if (event.description) {
        meta.createEl("span", {
          text: event.description.substring(0, 60) + (event.description.length > 60 ? "..." : ""),
          cls: "story-engine-event-description"
        });
      }
      const actions = item.createDiv({ cls: "story-engine-item-actions" });
      const linkBtn = actions.createEl("button");
      (0, import_obsidian16.setIcon)(linkBtn, "link");
      linkBtn.title = "Link to Entity";
      linkBtn.onclick = () => this.showLinkEventToEntityModal(event);
      const eventLinkBtn = actions.createEl("button");
      (0, import_obsidian16.setIcon)(eventLinkBtn, "git-branch");
      eventLinkBtn.title = "Set Parent Event";
      eventLinkBtn.onclick = () => this.showSetEventParentModal(event);
      actions.createEl("button", { text: "Edit" }).onclick = () => {
        this.showEditEventModal(event);
      };
      actions.createEl("button", { text: "Delete" }).onclick = async () => {
        if (confirm(`Delete event "${event.name}"?`)) {
          try {
            await this.plugin.apiClient.deleteEvent(event.id);
            await this.loadWorldData();
            this.renderWorldTabContent();
            new import_obsidian16.Notice("Event deleted");
          } catch (err) {
            new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
          }
        }
      };
    }
  }
  showCreateEpochEventModal() {
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Create Epoch Event (Year Zero)");
    const content = modal.contentEl;
    let name = "";
    let description = "";
    content.createEl("p", {
      text: "The Epoch Event defines Year Zero in your world's timeline. All other events will be dated relative to this moment.",
      cls: "story-engine-modal-hint"
    });
    content.createEl("label", { text: "Event Name *" });
    const nameInput = content.createEl("input", {
      type: "text",
      cls: "story-engine-input",
      placeholder: "e.g., The Great Cataclysm, The Founding, Year of the Dragon"
    });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", {
      cls: "story-engine-textarea",
      placeholder: "Describe what happened at this pivotal moment..."
    });
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Create Epoch", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required");
        return;
      }
      try {
        await this.plugin.apiClient.createEvent(this.currentWorld.id, {
          name: name.trim(),
          description: description.trim() || void 0,
          timeline_position: 0,
          is_epoch: true,
          importance: 10,
          // Max importance for epoch
          type: "Epoch"
        });
        modal.close();
        await this.loadWorldData();
        this.renderWorldTabContent();
        new import_obsidian16.Notice("Epoch event created!");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => modal.close();
    modal.open();
  }
  renderTraitsTab(container) {
    if (this.traits.length === 0) {
      container.createEl("p", { text: "No traits found. Create your first trait!" });
      return;
    }
    const traitsByCategory = /* @__PURE__ */ new Map();
    for (const trait of this.traits) {
      const category = trait.category || "Uncategorized";
      if (!traitsByCategory.has(category)) {
        traitsByCategory.set(category, []);
      }
      traitsByCategory.get(category).push(trait);
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const [category, categoryTraits] of traitsByCategory.entries()) {
      const group = list.createDiv({ cls: "story-engine-group" });
      const groupHeader = group.createDiv({ cls: "story-engine-group-header" });
      groupHeader.createEl("h3", { text: category });
      const groupItems = group.createDiv({ cls: "story-engine-group-items" });
      for (const trait of categoryTraits.sort((a, b) => a.name.localeCompare(b.name))) {
        const item = groupItems.createDiv({ cls: "story-engine-item" });
        item.createDiv({ cls: "story-engine-title", text: trait.name });
        const meta = item.createDiv({ cls: "story-engine-meta" });
        if (trait.description) {
          meta.createEl("span", { text: trait.description.substring(0, 50) + (trait.description.length > 50 ? "..." : "") });
        }
        const actions = item.createDiv({ cls: "story-engine-item-actions" });
        actions.createEl("button", { text: "Edit" }).onclick = () => {
          this.showEditTraitModal(trait);
        };
        actions.createEl("button", { text: "Delete" }).onclick = async () => {
          if (confirm(`Delete trait "${trait.name}"?`)) {
            try {
              await this.plugin.apiClient.deleteTrait(trait.id);
              await this.loadWorldData();
              this.renderWorldTabContent();
              new import_obsidian16.Notice("Trait deleted");
            } catch (err) {
              new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
            }
          }
        };
      }
    }
  }
  renderArchetypesTab(container) {
    if (this.archetypes.length === 0) {
      container.createEl("p", { text: "No archetypes found. Create your first archetype!" });
      return;
    }
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const archetype of this.archetypes.sort((a, b) => a.name.localeCompare(b.name))) {
      const item = list.createDiv({ cls: "story-engine-item" });
      item.createDiv({ cls: "story-engine-title", text: archetype.name });
      const meta = item.createDiv({ cls: "story-engine-meta" });
      if (archetype.description) {
        meta.createEl("span", { text: archetype.description.substring(0, 50) + (archetype.description.length > 50 ? "..." : "") });
      }
      const actions = item.createDiv({ cls: "story-engine-item-actions" });
      actions.createEl("button", { text: "View Traits" }).onclick = async () => {
        try {
          const traits = await this.plugin.apiClient.getArchetypeTraits(archetype.id);
          this.showArchetypeTraitsModal(archetype, traits);
        } catch (err) {
          new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
        }
      };
      actions.createEl("button", { text: "Edit" }).onclick = () => {
        this.showEditArchetypeModal(archetype);
      };
      actions.createEl("button", { text: "Delete" }).onclick = async () => {
        if (confirm(`Delete archetype "${archetype.name}"?`)) {
          try {
            await this.plugin.apiClient.deleteArchetype(archetype.id);
            await this.loadWorldData();
            this.renderWorldTabContent();
            new import_obsidian16.Notice("Archetype deleted");
          } catch (err) {
            new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
          }
        }
      };
    }
  }
  renderLoreTab(container) {
    if (this.lores.length === 0) {
      container.createEl("p", { text: "No lore found. Create your first lore!" });
      return;
    }
    const rootLores = this.lores.filter((l) => !l.parent_id);
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const lore of rootLores.sort((a, b) => a.name.localeCompare(b.name))) {
      this.renderLoreItem(list, lore, 0);
    }
  }
  renderLoreItem(container, lore, level) {
    const item = container.createDiv({ cls: "story-engine-item" });
    item.style.marginLeft = `${level * 1}rem`;
    const titleRow = item.createDiv({ cls: "story-engine-title" });
    titleRow.textContent = lore.name;
    if (lore.category) {
      const categoryBadge = titleRow.createSpan({ cls: "story-engine-badge" });
      categoryBadge.textContent = lore.category;
    }
    const meta = item.createDiv({ cls: "story-engine-meta" });
    if (lore.description) {
      meta.createEl("span", { text: lore.description.substring(0, 50) + (lore.description.length > 50 ? "..." : "") });
    }
    const actions = item.createDiv({ cls: "story-engine-item-actions" });
    const linkBtn = actions.createEl("button");
    (0, import_obsidian16.setIcon)(linkBtn, "link");
    linkBtn.title = "Link to Entity";
    linkBtn.onclick = () => this.showAddLoreReferenceModal(lore);
    const subBtn = actions.createEl("button");
    (0, import_obsidian16.setIcon)(subBtn, "folder-plus");
    subBtn.title = "Create Sub-Lore";
    subBtn.onclick = () => this.showCreateLoreModal(lore.id);
    actions.createEl("button", { text: "Edit" }).onclick = () => {
      this.showEditLoreModal(lore);
    };
    actions.createEl("button", { text: "Delete" }).onclick = async () => {
      if (confirm(`Delete lore "${lore.name}"?`)) {
        try {
          await this.plugin.apiClient.deleteLore(lore.id);
          await this.loadWorldData();
          this.renderWorldTabContent();
          new import_obsidian16.Notice("Lore deleted");
        } catch (err) {
          new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
        }
      }
    };
    const children2 = this.lores.filter((l) => l.parent_id === lore.id);
    for (const child of children2.sort((a, b) => a.name.localeCompare(b.name))) {
      this.renderLoreItem(container, child, level + 1);
    }
  }
  renderFactionsTab(container) {
    if (this.factions.length === 0) {
      container.createEl("p", { text: "No factions found. Create your first faction!" });
      return;
    }
    const rootFactions = this.factions.filter((f) => !f.parent_id);
    const list = container.createDiv({ cls: "story-engine-list" });
    for (const faction of rootFactions.sort((a, b) => a.name.localeCompare(b.name))) {
      this.renderFactionItem(list, faction, 0);
    }
  }
  renderFactionItem(container, faction, level) {
    const item = container.createDiv({ cls: "story-engine-item" });
    item.style.marginLeft = `${level * 1}rem`;
    const titleRow = item.createDiv({ cls: "story-engine-title" });
    titleRow.textContent = faction.name;
    if (faction.type) {
      const typeBadge = titleRow.createSpan({ cls: "story-engine-badge" });
      typeBadge.textContent = faction.type;
    }
    const meta = item.createDiv({ cls: "story-engine-meta" });
    if (faction.description) {
      meta.createEl("span", { text: faction.description.substring(0, 50) + (faction.description.length > 50 ? "..." : "") });
    }
    const actions = item.createDiv({ cls: "story-engine-item-actions" });
    const linkBtn = actions.createEl("button");
    (0, import_obsidian16.setIcon)(linkBtn, "link");
    linkBtn.title = "Link to Entity";
    linkBtn.onclick = () => this.showAddFactionReferenceModal(faction);
    const subBtn = actions.createEl("button");
    (0, import_obsidian16.setIcon)(subBtn, "folder-plus");
    subBtn.title = "Create Sub-Faction";
    subBtn.onclick = () => this.showCreateFactionModal(faction.id);
    actions.createEl("button", { text: "View Details" }).onclick = () => {
      this.showFactionDetailsModal(faction);
    };
    actions.createEl("button", { text: "Edit" }).onclick = () => {
      this.showEditFactionModal(faction);
    };
    actions.createEl("button", { text: "Delete" }).onclick = async () => {
      if (confirm(`Delete faction "${faction.name}"?`)) {
        try {
          await this.plugin.apiClient.deleteFaction(faction.id);
          await this.loadWorldData();
          this.renderWorldTabContent();
          new import_obsidian16.Notice("Faction deleted");
        } catch (err) {
          new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
        }
      }
    };
    const children2 = this.factions.filter((f) => f.parent_id === faction.id);
    for (const child of children2.sort((a, b) => a.name.localeCompare(b.name))) {
      this.renderFactionItem(container, child, level + 1);
    }
  }
  // Modal methods for World entities
  showCreateCharacterModal() {
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Create Character");
    const content = modal.contentEl;
    let name = "";
    let description = "";
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input" });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Create", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.createCharacter(this.currentWorld.id, { name: name.trim(), description: description.trim() });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Character created");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
    nameInput.focus();
  }
  showEditCharacterModal(character) {
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Edit Character");
    const content = modal.contentEl;
    let name = character.name;
    let description = character.description;
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: name });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.value = description;
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        const updated = await this.plugin.apiClient.updateCharacter(character.id, { name: name.trim(), description: description.trim() });
        if (this.viewMode === "character-details" && this.characterDetailsView && this.characterDetailsView["character"].id === character.id) {
          this.characterDetailsView.updateCharacter(updated);
        } else {
          await this.loadWorldData();
          this.renderWorldTabContent();
        }
        modal.close();
        new import_obsidian16.Notice("Character updated");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  showCreateLocationModal() {
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Create Location");
    const content = modal.contentEl;
    let name = "";
    let type2 = "";
    let description = "";
    let parentId = null;
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input" });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Type" });
    const typeInput = content.createEl("input", { type: "text", cls: "story-engine-input", placeholder: "e.g., City, Forest, Building" });
    typeInput.oninput = () => {
      type2 = typeInput.value;
    };
    content.createEl("label", { text: "Parent Location" });
    const parentSelect = content.createEl("select", { cls: "story-engine-select" });
    parentSelect.createEl("option", { value: "", text: "None (Root Location)" });
    for (const loc of this.locations.sort((a, b) => a.name.localeCompare(b.name))) {
      parentSelect.createEl("option", { value: loc.id, text: loc.name });
    }
    parentSelect.onchange = () => {
      parentId = parentSelect.value || null;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Create", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.createLocation(this.currentWorld.id, {
          name: name.trim(),
          type: type2.trim(),
          description: description.trim(),
          parent_id: parentId
        });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Location created");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
    nameInput.focus();
  }
  showEditLocationModal(location) {
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Edit Location");
    const content = modal.contentEl;
    let name = location.name;
    let type2 = location.type;
    let description = location.description;
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: name });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Type" });
    const typeInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: type2 });
    typeInput.oninput = () => {
      type2 = typeInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.value = description;
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.updateLocation(location.id, { name: name.trim(), type: type2.trim(), description: description.trim() });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Location updated");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  showCreateArtifactModal() {
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Create Artifact");
    const content = modal.contentEl;
    let name = "";
    let description = "";
    let rarity = "";
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input" });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Rarity" });
    const raritySelect = content.createEl("select", { cls: "story-engine-select" });
    raritySelect.createEl("option", { value: "", text: "Select Rarity" });
    ["Common", "Uncommon", "Rare", "Epic", "Legendary", "Unique"].forEach((r) => {
      raritySelect.createEl("option", { value: r.toLowerCase(), text: r });
    });
    raritySelect.onchange = () => {
      rarity = raritySelect.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Create", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.createArtifact(this.currentWorld.id, {
          name: name.trim(),
          description: description.trim(),
          rarity
        });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Artifact created");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
    nameInput.focus();
  }
  showEditArtifactModal(artifact) {
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Edit Artifact");
    const content = modal.contentEl;
    let name = artifact.name;
    let description = artifact.description;
    let rarity = artifact.rarity;
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: name });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Rarity" });
    const raritySelect = content.createEl("select", { cls: "story-engine-select" });
    raritySelect.createEl("option", { value: "", text: "Select Rarity" });
    ["Common", "Uncommon", "Rare", "Epic", "Legendary", "Unique"].forEach((r) => {
      const opt = raritySelect.createEl("option", { value: r.toLowerCase(), text: r });
      if (rarity.toLowerCase() === r.toLowerCase())
        opt.selected = true;
    });
    raritySelect.onchange = () => {
      rarity = raritySelect.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.value = description;
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.updateArtifact(artifact.id, { name: name.trim(), description: description.trim(), rarity });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Artifact updated");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  showCreateEventModal() {
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Create Event");
    const content = modal.contentEl;
    let name = "";
    let type2 = "";
    let description = "";
    let importance = 5;
    let timelinePosition = void 0;
    content.createEl("h4", { text: "Basic Info", cls: "story-engine-modal-section" });
    content.createEl("label", { text: "Event Name *" });
    const nameInput = content.createEl("input", {
      type: "text",
      cls: "story-engine-input",
      placeholder: "e.g., The Battle of Crimson Fields"
    });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Event Type" });
    const typeSelect = content.createEl("select", { cls: "story-engine-select" });
    typeSelect.createEl("option", { value: "", text: "Select type..." });
    ["Battle", "Treaty", "Discovery", "Birth", "Death", "Coronation", "Disaster", "Migration", "Founding", "Other"].forEach((t) => {
      typeSelect.createEl("option", { value: t, text: t });
    });
    typeSelect.onchange = () => {
      type2 = typeSelect.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", {
      cls: "story-engine-textarea",
      placeholder: "What happened during this event?"
    });
    descInput.oninput = () => {
      description = descInput.value;
    };
    content.createEl("h4", { text: "\u{1F4C5} Timeline Position", cls: "story-engine-modal-section" });
    content.createEl("label", { text: "Year (relative to Epoch/Year Zero)" });
    content.createEl("p", {
      text: "Use positive numbers for years after Year Zero, negative for years before.",
      cls: "story-engine-hint"
    });
    const timelinePosInput = content.createEl("input", {
      type: "number",
      cls: "story-engine-input",
      placeholder: "e.g., 100 (Year 100) or -50 (50 years before Year Zero)"
    });
    timelinePosInput.oninput = () => {
      const val = timelinePosInput.value;
      timelinePosition = val ? parseInt(val) : void 0;
    };
    content.createEl("h4", { text: "\u2B50 Importance", cls: "story-engine-modal-section" });
    content.createEl("label", { text: "Importance Level (1-10)" });
    const importanceInput = content.createEl("input", {
      type: "range",
      cls: "story-engine-range",
      value: "5",
      attr: { min: "1", max: "10" }
    });
    const importanceValue = content.createEl("span", { text: " 5", cls: "story-engine-range-value" });
    importanceInput.oninput = () => {
      importance = parseInt(importanceInput.value) || 5;
      importanceValue.textContent = ` ${importance}`;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Create Event", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.createEvent(this.currentWorld.id, {
          name: name.trim(),
          type: type2.trim() || void 0,
          description: description.trim() || void 0,
          importance: Math.max(1, Math.min(10, importance)),
          timeline_position: timelinePosition
        });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Event created");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
    nameInput.focus();
  }
  showEditEventModal(event) {
    var _a, _b;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Edit Event");
    const content = modal.contentEl;
    let name = event.name;
    let type2 = event.type || "";
    let description = event.description || "";
    let importance = event.importance;
    let timelinePosition = (_a = event.timeline_position) != null ? _a : void 0;
    content.createEl("h4", { text: "Basic Info", cls: "story-engine-modal-section" });
    content.createEl("label", { text: "Event Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: name });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Event Type" });
    const typeSelect = content.createEl("select", { cls: "story-engine-select" });
    typeSelect.createEl("option", { value: "", text: "Select type..." });
    ["Battle", "Treaty", "Discovery", "Birth", "Death", "Coronation", "Disaster", "Migration", "Founding", "Epoch", "Other"].forEach((t) => {
      const opt = typeSelect.createEl("option", { value: t, text: t });
      if (type2.toLowerCase() === t.toLowerCase())
        opt.selected = true;
    });
    typeSelect.onchange = () => {
      type2 = typeSelect.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.value = description;
    descInput.oninput = () => {
      description = descInput.value;
    };
    content.createEl("h4", { text: "\u{1F4C5} Timeline Position", cls: "story-engine-modal-section" });
    content.createEl("label", { text: "Year (relative to Epoch/Year Zero)" });
    content.createEl("p", {
      text: "Use positive numbers for years after Year Zero, negative for years before.",
      cls: "story-engine-hint"
    });
    const timelinePosInput = content.createEl("input", {
      type: "number",
      cls: "story-engine-input",
      value: (_b = timelinePosition == null ? void 0 : timelinePosition.toString()) != null ? _b : ""
    });
    timelinePosInput.placeholder = "e.g., 100 or -50";
    timelinePosInput.oninput = () => {
      const val = timelinePosInput.value;
      timelinePosition = val ? parseInt(val) : void 0;
    };
    content.createEl("h4", { text: "\u2B50 Importance", cls: "story-engine-modal-section" });
    content.createEl("label", { text: "Importance Level (1-10)" });
    const importanceInput = content.createEl("input", {
      type: "range",
      cls: "story-engine-range",
      value: importance.toString(),
      attr: { min: "1", max: "10" }
    });
    const importanceValue = content.createEl("span", { text: ` ${importance}`, cls: "story-engine-range-value" });
    importanceInput.oninput = () => {
      importance = parseInt(importanceInput.value) || 5;
      importanceValue.textContent = ` ${importance}`;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.updateEvent(event.id, {
          name: name.trim(),
          type: type2.trim() || void 0,
          description: description.trim() || void 0,
          importance: Math.max(1, Math.min(10, importance)),
          timeline_position: timelinePosition
        });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Event updated");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  showCreateTraitModal() {
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Create Trait");
    const content = modal.contentEl;
    let name = "";
    let category = "";
    let description = "";
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input" });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Category" });
    const categoryInput = content.createEl("input", { type: "text", cls: "story-engine-input", placeholder: "e.g., Personality, Physical, Background" });
    categoryInput.oninput = () => {
      category = categoryInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Create", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.createTrait({
          name: name.trim(),
          category: category.trim(),
          description: description.trim()
        });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Trait created");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
    nameInput.focus();
  }
  showEditTraitModal(trait) {
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Edit Trait");
    const content = modal.contentEl;
    let name = trait.name;
    let category = trait.category;
    let description = trait.description;
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: name });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Category" });
    const categoryInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: category });
    categoryInput.oninput = () => {
      category = categoryInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.value = description;
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.updateTrait(trait.id, { name: name.trim(), category: category.trim(), description: description.trim() });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Trait updated");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  renderTimeConfigDisplay(container, config) {
    var _a;
    container.createEl("h4", { text: "Time Configuration" });
    const grid = container.createDiv({ cls: "story-engine-time-config-grid" });
    grid.createDiv().setText(`Base Unit: ${config.base_unit}`);
    grid.createDiv().setText(`Hours/Day: ${config.hours_per_day}`);
    grid.createDiv().setText(`Days/Week: ${config.days_per_week}`);
    grid.createDiv().setText(`Days/Year: ${config.days_per_year}`);
    grid.createDiv().setText(`Months/Year: ${config.months_per_year}`);
    if (config.era_name) {
      grid.createDiv().setText(`Era: ${config.era_name}`);
    }
    if ((_a = config.month_names) == null ? void 0 : _a.length) {
      grid.createDiv().setText(`Months: ${config.month_names.join(", ")}`);
    }
    if (config.year_zero !== void 0) {
      grid.createDiv().setText(`Year Zero: ${config.year_zero}`);
    }
  }
  showTimeConfigModal(existingConfig) {
    var _a;
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText(existingConfig ? "Edit Time Configuration" : "Create Time Configuration");
    const content = modal.contentEl;
    let baseUnit = (existingConfig == null ? void 0 : existingConfig.base_unit) || "year";
    let hoursPerDay = (existingConfig == null ? void 0 : existingConfig.hours_per_day) || 24;
    let daysPerWeek = (existingConfig == null ? void 0 : existingConfig.days_per_week) || 7;
    let daysPerYear = (existingConfig == null ? void 0 : existingConfig.days_per_year) || 365;
    let monthsPerYear = (existingConfig == null ? void 0 : existingConfig.months_per_year) || 12;
    let eraName = (existingConfig == null ? void 0 : existingConfig.era_name) || "";
    let yearZero = ((_a = existingConfig == null ? void 0 : existingConfig.year_zero) == null ? void 0 : _a.toString()) || "";
    content.createEl("label", { text: "Base Unit *" });
    const baseUnitSelect = content.createEl("select", { cls: "story-engine-select" });
    ["year", "day", "hour", "custom"].forEach((unit2) => {
      const opt = baseUnitSelect.createEl("option", { value: unit2, text: unit2 });
      if (baseUnit === unit2)
        opt.selected = true;
    });
    baseUnitSelect.onchange = () => {
      baseUnit = baseUnitSelect.value;
    };
    content.createEl("label", { text: "Hours per Day" });
    const hoursPerDayInput = content.createEl("input", {
      type: "number",
      cls: "story-engine-input",
      value: hoursPerDay.toString()
    });
    hoursPerDayInput.oninput = () => {
      hoursPerDay = parseFloat(hoursPerDayInput.value) || 24;
    };
    content.createEl("label", { text: "Days per Week" });
    const daysPerWeekInput = content.createEl("input", {
      type: "number",
      cls: "story-engine-input",
      value: daysPerWeek.toString()
    });
    daysPerWeekInput.oninput = () => {
      daysPerWeek = parseInt(daysPerWeekInput.value) || 7;
    };
    content.createEl("label", { text: "Days per Year" });
    const daysPerYearInput = content.createEl("input", {
      type: "number",
      cls: "story-engine-input",
      value: daysPerYear.toString()
    });
    daysPerYearInput.oninput = () => {
      daysPerYear = parseInt(daysPerYearInput.value) || 365;
    };
    content.createEl("label", { text: "Months per Year" });
    const monthsPerYearInput = content.createEl("input", {
      type: "number",
      cls: "story-engine-input",
      value: monthsPerYear.toString()
    });
    monthsPerYearInput.oninput = () => {
      monthsPerYear = parseInt(monthsPerYearInput.value) || 12;
    };
    content.createEl("label", { text: "Era Name (optional)" });
    const eraNameInput = content.createEl("input", {
      type: "text",
      cls: "story-engine-input",
      value: eraName
    });
    eraNameInput.oninput = () => {
      eraName = eraNameInput.value;
    };
    content.createEl("label", { text: "Year Zero (optional)" });
    const yearZeroInput = content.createEl("input", {
      type: "number",
      cls: "story-engine-input",
      value: yearZero
    });
    yearZeroInput.oninput = () => {
      yearZero = yearZeroInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      try {
        const timeConfig = {
          base_unit: baseUnit,
          hours_per_day: hoursPerDay,
          days_per_week: daysPerWeek,
          days_per_year: daysPerYear,
          months_per_year: monthsPerYear,
          era_name: eraName.trim() || void 0,
          year_zero: yearZero ? parseInt(yearZero) : void 0
        };
        await this.plugin.apiClient.updateWorldTimeConfig(this.currentWorld.id, timeConfig);
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Time configuration saved");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  async showTimelineModal() {
    if (!this.currentWorld)
      return;
    try {
      const events = await this.plugin.apiClient.getTimeline(this.currentWorld.id);
      const modal = new TimelineModal(this.app, events, this.currentWorld.time_config || null);
      modal.open();
    } catch (err) {
      new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed to load timeline"}`, 5e3);
    }
  }
  // Placeholder methods for modals that will be implemented later
  showArchetypeTraitsModal(archetype, traits) {
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText(`Traits for ${archetype.name}`);
    const content = modal.contentEl;
    if (traits.length === 0) {
      content.createEl("p", { text: "No traits assigned to this archetype." });
    } else {
      const list = content.createDiv({ cls: "story-engine-list" });
      for (const trait of traits) {
        const item = list.createDiv({ cls: "story-engine-item" });
        item.createDiv({ cls: "story-engine-title", text: trait.trait_name || "Unknown" });
      }
    }
    modal.open();
  }
  showCreateArchetypeModal() {
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Create Archetype");
    const content = modal.contentEl;
    let name = "";
    let description = "";
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input" });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Create", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.createArchetype({ name: name.trim(), description: description.trim() });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Archetype created");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
    nameInput.focus();
  }
  showEditArchetypeModal(archetype) {
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Edit Archetype");
    const content = modal.contentEl;
    let name = archetype.name;
    let description = archetype.description;
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: name });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.value = description;
    descInput.oninput = () => {
      description = descInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.updateArchetype(archetype.id, { name: name.trim(), description: description.trim() });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Archetype updated");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  showLoreDetailsModal(lore) {
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText(lore.name);
    const content = modal.contentEl;
    content.createEl("h4", { text: "Description" });
    content.createEl("p", { text: lore.description || "No description" });
    if (lore.rules) {
      content.createEl("h4", { text: "Rules" });
      content.createEl("p", { text: lore.rules });
    }
    if (lore.limitations) {
      content.createEl("h4", { text: "Limitations" });
      content.createEl("p", { text: lore.limitations });
    }
    if (lore.requirements) {
      content.createEl("h4", { text: "Requirements" });
      content.createEl("p", { text: lore.requirements });
    }
    modal.open();
  }
  showCreateLoreModal(parentId) {
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Create Lore");
    const content = modal.contentEl;
    let name = "";
    let category = "";
    let description = "";
    let rules = "";
    let limitations = "";
    let requirements = "";
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input" });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Category" });
    const categoryInput = content.createEl("input", { type: "text", cls: "story-engine-input" });
    categoryInput.oninput = () => {
      category = categoryInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.oninput = () => {
      description = descInput.value;
    };
    content.createEl("label", { text: "Rules" });
    const rulesInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    rulesInput.oninput = () => {
      rules = rulesInput.value;
    };
    content.createEl("label", { text: "Limitations" });
    const limitationsInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    limitationsInput.oninput = () => {
      limitations = limitationsInput.value;
    };
    content.createEl("label", { text: "Requirements" });
    const requirementsInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    requirementsInput.oninput = () => {
      requirements = requirementsInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Create", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.createLore(this.currentWorld.id, {
          name: name.trim(),
          category: category.trim() || void 0,
          description: description.trim(),
          rules: rules.trim(),
          limitations: limitations.trim(),
          requirements: requirements.trim(),
          parent_id: parentId || void 0
        });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Lore created");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
    nameInput.focus();
  }
  showEditLoreModal(lore) {
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Edit Lore");
    const content = modal.contentEl;
    let name = lore.name;
    let category = lore.category || "";
    let description = lore.description;
    let rules = lore.rules;
    let limitations = lore.limitations;
    let requirements = lore.requirements;
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: name });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Category" });
    const categoryInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: category });
    categoryInput.oninput = () => {
      category = categoryInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.value = description;
    descInput.oninput = () => {
      description = descInput.value;
    };
    content.createEl("label", { text: "Rules" });
    const rulesInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    rulesInput.value = rules;
    rulesInput.oninput = () => {
      rules = rulesInput.value;
    };
    content.createEl("label", { text: "Limitations" });
    const limitationsInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    limitationsInput.value = limitations;
    limitationsInput.oninput = () => {
      limitations = limitationsInput.value;
    };
    content.createEl("label", { text: "Requirements" });
    const requirementsInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    requirementsInput.value = requirements;
    requirementsInput.oninput = () => {
      requirements = requirementsInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.updateLore(lore.id, {
          name: name.trim(),
          category: category.trim() || void 0,
          description: description.trim(),
          rules: rules.trim(),
          limitations: limitations.trim(),
          requirements: requirements.trim()
        });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Lore updated");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  showFactionDetailsModal(faction) {
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText(faction.name);
    const content = modal.contentEl;
    content.createEl("h4", { text: "Description" });
    content.createEl("p", { text: faction.description || "No description" });
    if (faction.beliefs) {
      content.createEl("h4", { text: "Beliefs" });
      content.createEl("p", { text: faction.beliefs });
    }
    if (faction.structure) {
      content.createEl("h4", { text: "Structure" });
      content.createEl("p", { text: faction.structure });
    }
    if (faction.symbols) {
      content.createEl("h4", { text: "Symbols" });
      content.createEl("p", { text: faction.symbols });
    }
    modal.open();
  }
  showCreateFactionModal(parentId) {
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Create Faction");
    const content = modal.contentEl;
    let name = "";
    let type2 = "";
    let description = "";
    let beliefs = "";
    let structure = "";
    let symbols = "";
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input" });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Type" });
    const typeInput = content.createEl("input", { type: "text", cls: "story-engine-input" });
    typeInput.oninput = () => {
      type2 = typeInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.oninput = () => {
      description = descInput.value;
    };
    content.createEl("label", { text: "Beliefs" });
    const beliefsInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    beliefsInput.oninput = () => {
      beliefs = beliefsInput.value;
    };
    content.createEl("label", { text: "Structure" });
    const structureInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    structureInput.oninput = () => {
      structure = structureInput.value;
    };
    content.createEl("label", { text: "Symbols" });
    const symbolsInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    symbolsInput.oninput = () => {
      symbols = symbolsInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Create", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.createFaction(this.currentWorld.id, {
          name: name.trim(),
          type: type2.trim() || void 0,
          description: description.trim(),
          beliefs: beliefs.trim(),
          structure: structure.trim(),
          symbols: symbols.trim(),
          parent_id: parentId || void 0
        });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Faction created");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
    nameInput.focus();
  }
  showEditFactionModal(faction) {
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Edit Faction");
    const content = modal.contentEl;
    let name = faction.name;
    let type2 = faction.type || "";
    let description = faction.description;
    let beliefs = faction.beliefs;
    let structure = faction.structure;
    let symbols = faction.symbols;
    content.createEl("label", { text: "Name *" });
    const nameInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: name });
    nameInput.oninput = () => {
      name = nameInput.value;
    };
    content.createEl("label", { text: "Type" });
    const typeInput = content.createEl("input", { type: "text", cls: "story-engine-input", value: type2 });
    typeInput.oninput = () => {
      type2 = typeInput.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.value = description;
    descInput.oninput = () => {
      description = descInput.value;
    };
    content.createEl("label", { text: "Beliefs" });
    const beliefsInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    beliefsInput.value = beliefs;
    beliefsInput.oninput = () => {
      beliefs = beliefsInput.value;
    };
    content.createEl("label", { text: "Structure" });
    const structureInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    structureInput.value = structure;
    structureInput.oninput = () => {
      structure = structureInput.value;
    };
    content.createEl("label", { text: "Symbols" });
    const symbolsInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    symbolsInput.value = symbols;
    symbolsInput.oninput = () => {
      symbols = symbolsInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      if (!name.trim()) {
        new import_obsidian16.Notice("Name is required", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.updateFaction(faction.id, {
          name: name.trim(),
          type: type2.trim() || void 0,
          description: description.trim(),
          beliefs: beliefs.trim(),
          structure: structure.trim(),
          symbols: symbols.trim()
        });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Faction updated");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  // ==================== Relationship Modals ====================
  showAddCharacterRelationshipModal(character) {
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Add Character Relationship");
    const content = modal.contentEl;
    let otherCharacterId = "";
    let relationshipType = "ally";
    let description = "";
    let bidirectional = true;
    content.createEl("label", { text: "Other Character *" });
    const characterSelect = content.createEl("select", { cls: "story-engine-select" });
    characterSelect.createEl("option", { value: "", text: "Select a character..." });
    for (const char of this.characters.filter((c) => c.id !== character.id).sort((a, b) => a.name.localeCompare(b.name))) {
      characterSelect.createEl("option", { value: char.id, text: char.name });
    }
    characterSelect.onchange = () => {
      otherCharacterId = characterSelect.value;
    };
    content.createEl("label", { text: "Relationship Type *" });
    const typeSelect = content.createEl("select", { cls: "story-engine-select" });
    const relationshipTypes = ["ally", "enemy", "family", "lover", "rival", "mentor", "student"];
    for (const type2 of relationshipTypes) {
      typeSelect.createEl("option", { value: type2, text: type2.charAt(0).toUpperCase() + type2.slice(1) });
    }
    typeSelect.onchange = () => {
      relationshipType = typeSelect.value;
    };
    content.createEl("label", { text: "Description" });
    const descInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    descInput.oninput = () => {
      description = descInput.value;
    };
    content.createEl("label", { text: "Bidirectional" });
    const bidirectionalCheckbox = content.createEl("input", { type: "checkbox" });
    bidirectionalCheckbox.checked = true;
    bidirectionalCheckbox.onchange = () => {
      bidirectional = bidirectionalCheckbox.checked;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Create", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!otherCharacterId) {
        new import_obsidian16.Notice("Please select a character", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.createCharacterRelationship(character.id, {
          character2_id: otherCharacterId,
          relationship_type: relationshipType,
          description: description.trim(),
          bidirectional
        });
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Relationship created");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  showLinkEventToEntityModal(event) {
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText(`Link Event: ${event.name}`);
    const content = modal.contentEl;
    let entityType = "character";
    let entityId = "";
    let relationshipType = "";
    let notes = "";
    content.createEl("label", { text: "Entity Type *" });
    const typeSelect = content.createEl("select", { cls: "story-engine-select" });
    typeSelect.createEl("option", { value: "character", text: "\u{1F464} Character" });
    typeSelect.createEl("option", { value: "location", text: "\u{1F4CD} Location" });
    typeSelect.createEl("option", { value: "faction", text: "\u{1F3F4} Faction" });
    typeSelect.createEl("option", { value: "artifact", text: "\u2694\uFE0F Artifact" });
    typeSelect.createEl("option", { value: "lore", text: "\u{1F4DC} Lore" });
    content.createEl("label", { text: "Entity *" });
    const entitySelect = content.createEl("select", { cls: "story-engine-select" });
    const populateEntitySelect = () => {
      entitySelect.empty();
      entitySelect.createEl("option", { value: "", text: `Select a ${entityType}...` });
      entityId = "";
      if (entityType === "character") {
        for (const char of this.characters.sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: char.id, text: char.name });
        }
      } else if (entityType === "location") {
        for (const loc of this.locations.sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: loc.id, text: loc.name });
        }
      } else if (entityType === "faction") {
        for (const faction of this.factions.sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: faction.id, text: faction.name });
        }
      } else if (entityType === "artifact") {
        for (const art of this.artifacts.sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: art.id, text: art.name });
        }
      } else if (entityType === "lore") {
        for (const lore of this.lores.sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: lore.id, text: lore.name });
        }
      }
    };
    populateEntitySelect();
    typeSelect.onchange = () => {
      entityType = typeSelect.value;
      populateEntitySelect();
    };
    entitySelect.onchange = () => {
      entityId = entitySelect.value;
    };
    content.createEl("label", { text: "Relationship Type" });
    const relTypeSelect = content.createEl("select", { cls: "story-engine-select" });
    relTypeSelect.createEl("option", { value: "", text: "Select relationship..." });
    ["involved", "caused", "affected", "witnessed", "created", "destroyed", "participated", "led", "opposed"].forEach((rel) => {
      relTypeSelect.createEl("option", { value: rel, text: rel.charAt(0).toUpperCase() + rel.slice(1) });
    });
    relTypeSelect.onchange = () => {
      relationshipType = relTypeSelect.value;
    };
    content.createEl("label", { text: "Notes" });
    const notesInput = content.createEl("textarea", {
      cls: "story-engine-textarea",
      placeholder: "Additional details about this relationship..."
    });
    notesInput.oninput = () => {
      notes = notesInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Link Entity", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!entityId) {
        new import_obsidian16.Notice(`Please select a ${entityType}`, 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.addEventReference(event.id, entityType, entityId, relationshipType.trim() || void 0, notes.trim() || void 0);
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Entity linked to event");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  showSetEventParentModal(event) {
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Set Parent Event (Cause)");
    const content = modal.contentEl;
    let parentId = event.parent_id || null;
    content.createEl("p", {
      text: "Link this event to its cause or parent event in the timeline hierarchy.",
      cls: "story-engine-hint"
    });
    content.createEl("label", { text: "Parent Event (Cause)" });
    const parentSelect = content.createEl("select", { cls: "story-engine-select" });
    parentSelect.createEl("option", { value: "", text: "None (Root Event)" });
    const sortedEvents = this.events.filter((e) => e.id !== event.id).sort((a, b) => {
      var _a, _b;
      const posA = (_a = a.timeline_position) != null ? _a : Number.MAX_SAFE_INTEGER;
      const posB = (_b = b.timeline_position) != null ? _b : Number.MAX_SAFE_INTEGER;
      if (posA !== posB)
        return posA - posB;
      return a.name.localeCompare(b.name);
    });
    for (const evt of sortedEvents) {
      const posLabel = evt.timeline_position !== void 0 ? ` (Year ${evt.timeline_position})` : "";
      const opt = parentSelect.createEl("option", { value: evt.id, text: `${evt.name}${posLabel}` });
      if (event.parent_id === evt.id) {
        opt.selected = true;
      }
    }
    parentSelect.onchange = () => {
      parentId = parentSelect.value || null;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      try {
        await this.plugin.apiClient.moveEvent(event.id, parentId);
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Event parent updated");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  showAddFactionReferenceModal(faction) {
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Link Faction to Entity");
    const content = modal.contentEl;
    let entityType = "character";
    let entityId = "";
    let role = "";
    let notes = "";
    content.createEl("label", { text: "Entity Type *" });
    const typeSelect = content.createEl("select", { cls: "story-engine-select" });
    typeSelect.createEl("option", { value: "character", text: "Character" });
    typeSelect.createEl("option", { value: "location", text: "Location" });
    typeSelect.createEl("option", { value: "artifact", text: "Artifact" });
    typeSelect.createEl("option", { value: "event", text: "Event" });
    typeSelect.createEl("option", { value: "faction", text: "Faction" });
    typeSelect.onchange = () => {
      entityType = typeSelect.value;
      entitySelect.empty();
      entitySelect.createEl("option", { value: "", text: `Select a ${entityType}...` });
      loadEntitiesForType(entityType);
    };
    content.createEl("label", { text: "Entity *" });
    const entitySelect = content.createEl("select", { cls: "story-engine-select" });
    entitySelect.createEl("option", { value: "", text: "Select an entity..." });
    const loadEntitiesForType = (type2) => {
      if (type2 === "character") {
        for (const char of this.characters.sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: char.id, text: char.name });
        }
      } else if (type2 === "location") {
        for (const loc of this.locations.sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: loc.id, text: loc.name });
        }
      } else if (type2 === "artifact") {
        for (const art of this.artifacts.sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: art.id, text: art.name });
        }
      } else if (type2 === "event") {
        for (const evt of this.events.sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: evt.id, text: evt.name });
        }
      } else if (type2 === "faction") {
        for (const fac of this.factions.filter((f) => f.id !== faction.id).sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: fac.id, text: fac.name });
        }
      }
    };
    loadEntitiesForType(entityType);
    entitySelect.onchange = () => {
      entityId = entitySelect.value;
    };
    content.createEl("label", { text: "Role" });
    const roleInput = content.createEl("input", { type: "text", cls: "story-engine-input", placeholder: "e.g., leader, member, ally, rival" });
    roleInput.oninput = () => {
      role = roleInput.value;
    };
    content.createEl("label", { text: "Notes" });
    const notesInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    notesInput.oninput = () => {
      notes = notesInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Create", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!entityId) {
        new import_obsidian16.Notice("Please select an entity", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.addFactionReference(faction.id, entityType, entityId, role.trim() || void 0, notes.trim() || void 0);
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Reference created");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  showAddLoreReferenceModal(lore) {
    if (!this.currentWorld)
      return;
    const modal = new import_obsidian16.Modal(this.app);
    modal.titleEl.setText("Link Lore to Entity");
    const content = modal.contentEl;
    let entityType = "character";
    let entityId = "";
    let relationshipType = "";
    let notes = "";
    content.createEl("label", { text: "Entity Type *" });
    const typeSelect = content.createEl("select", { cls: "story-engine-select" });
    typeSelect.createEl("option", { value: "character", text: "Character" });
    typeSelect.createEl("option", { value: "location", text: "Location" });
    typeSelect.createEl("option", { value: "artifact", text: "Artifact" });
    typeSelect.createEl("option", { value: "event", text: "Event" });
    typeSelect.createEl("option", { value: "faction", text: "Faction" });
    typeSelect.createEl("option", { value: "lore", text: "Lore" });
    typeSelect.onchange = () => {
      entityType = typeSelect.value;
      entitySelect.empty();
      entitySelect.createEl("option", { value: "", text: `Select a ${entityType}...` });
      loadEntitiesForType(entityType);
    };
    content.createEl("label", { text: "Entity *" });
    const entitySelect = content.createEl("select", { cls: "story-engine-select" });
    entitySelect.createEl("option", { value: "", text: "Select an entity..." });
    const loadEntitiesForType = (type2) => {
      if (type2 === "character") {
        for (const char of this.characters.sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: char.id, text: char.name });
        }
      } else if (type2 === "location") {
        for (const loc of this.locations.sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: loc.id, text: loc.name });
        }
      } else if (type2 === "artifact") {
        for (const art of this.artifacts.sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: art.id, text: art.name });
        }
      } else if (type2 === "event") {
        for (const evt of this.events.sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: evt.id, text: evt.name });
        }
      } else if (type2 === "faction") {
        for (const fac of this.factions.sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: fac.id, text: fac.name });
        }
      } else if (type2 === "lore") {
        for (const l of this.lores.filter((l2) => l2.id !== lore.id).sort((a, b) => a.name.localeCompare(b.name))) {
          entitySelect.createEl("option", { value: l.id, text: l.name });
        }
      }
    };
    loadEntitiesForType(entityType);
    entitySelect.onchange = () => {
      entityId = entitySelect.value;
    };
    content.createEl("label", { text: "Relationship Type" });
    const relTypeInput = content.createEl("input", { type: "text", cls: "story-engine-input", placeholder: "e.g., practitioner, origin, forbidden" });
    relTypeInput.oninput = () => {
      relationshipType = relTypeInput.value;
    };
    content.createEl("label", { text: "Notes" });
    const notesInput = content.createEl("textarea", { cls: "story-engine-textarea" });
    notesInput.oninput = () => {
      notes = notesInput.value;
    };
    const buttonContainer = content.createDiv({ cls: "modal-button-container" });
    const createBtn = buttonContainer.createEl("button", { text: "Create", cls: "mod-cta" });
    createBtn.onclick = async () => {
      if (!entityId) {
        new import_obsidian16.Notice("Please select an entity", 3e3);
        return;
      }
      try {
        await this.plugin.apiClient.addLoreReference(lore.id, entityType, entityId, relationshipType.trim() || void 0, notes.trim() || void 0);
        await this.loadWorldData();
        this.renderWorldTabContent();
        modal.close();
        new import_obsidian16.Notice("Reference created");
      } catch (err) {
        new import_obsidian16.Notice(`Error: ${err instanceof Error ? err.message : "Failed"}`, 5e3);
      }
    };
    buttonContainer.createEl("button", { text: "Cancel" }).onclick = () => modal.close();
    modal.open();
  }
  // ==================== Character Details View Methods ====================
  async showCharacterDetails(character) {
    this.viewMode = "character-details";
    const world = character.world_id ? await this.plugin.apiClient.getWorld(character.world_id).catch(() => null) : null;
    const characters = world ? await this.plugin.apiClient.getCharacters(world.id).catch(() => []) : [];
    let traits = this.traits;
    let archetypes = this.archetypes;
    let events = world ? this.events : [];
    if (!traits || traits.length === 0) {
      try {
        traits = await this.plugin.apiClient.getTraits();
        this.traits = traits;
      } catch (err) {
        console.warn("Failed to load traits:", err);
        traits = [];
      }
    }
    if (!archetypes || archetypes.length === 0) {
      try {
        archetypes = await this.plugin.apiClient.getArchetypes();
        this.archetypes = archetypes;
      } catch (err) {
        console.warn("Failed to load archetypes:", err);
        archetypes = [];
      }
    }
    if (world && (!events || events.length === 0)) {
      try {
        events = await this.plugin.apiClient.getEvents(world.id);
        this.events = events;
      } catch (err) {
        console.warn("Failed to load events:", err);
        events = [];
      }
    }
    this.characterDetailsView = new CharacterDetailsView(
      this.plugin,
      character,
      this.headerEl,
      this.contentEl,
      () => {
        this.characterDetailsView = null;
        if (this.currentWorld) {
          this.viewMode = "world-details";
          this.renderWorldDetails();
        } else if (this.currentStory) {
          this.viewMode = "details";
          this.renderDetails();
        } else {
          this.viewMode = "list";
          this.renderListHeader();
          this.renderListContent();
        }
      },
      (character2) => {
        this.showEditCharacterModal(character2);
      },
      world,
      characters,
      archetypes,
      traits,
      events
    );
    await this.characterDetailsView.render();
  }
};

// src/views/StoryEngineExtractView.ts
var import_obsidian17 = require("obsidian");
var STORY_ENGINE_EXTRACT_VIEW_TYPE = "story-engine-extract-view";
var StoryEngineExtractView = class extends import_obsidian17.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.result = null;
    this.logs = [];
    this.status = "idle";
    this.activeTab = "progress";
    this.expandedLogs = /* @__PURE__ */ new Set();
    this.expandedRelationIndex = null;
    this.pendingRelationScrollIndex = null;
    this.pendingTabScroll = false;
    this.entitySearch = "";
    this.entityFilterType = "all";
    this.entitySort = "name";
    this.relationSearch = "";
    this.relationFilterType = "all";
    this.relationSort = "type";
    this.plugin = plugin;
    this.logs = plugin.extractLogs;
    this.status = plugin.extractStatus;
  }
  getViewType() {
    return STORY_ENGINE_EXTRACT_VIEW_TYPE;
  }
  getDisplayText() {
    return "Extract";
  }
  getIcon() {
    return "search";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("story-engine-extract-container");
    this.contentRoot = container;
    this.setResult(this.plugin.extractResult);
    this.setLogs(this.plugin.extractLogs, this.plugin.extractStatus);
  }
  setResult(result) {
    this.result = result;
    this.render();
  }
  setLogs(logs, status) {
    this.logs = logs;
    this.status = status;
    this.render();
  }
  render() {
    if (!this.contentRoot)
      return;
    this.contentRoot.empty();
    const header = this.contentRoot.createDiv({
      cls: "story-engine-extract-header"
    });
    header.createEl("h2", { text: "Extract" });
    const headerActions = header.createDiv({
      cls: "story-engine-extract-header-actions"
    });
    const backButton = headerActions.createEl("button", {
      text: "Back to Stories",
      cls: "story-engine-extract-back"
    });
    backButton.onclick = () => {
      this.plugin.activateView();
    };
    if (this.status === "running") {
      const cancelButton = headerActions.createEl("button", {
        text: "Cancel",
        cls: "story-engine-extract-cancel"
      });
      cancelButton.onclick = () => {
        this.plugin.cancelExtractStream();
      };
    }
    if (!this.result) {
      this.renderLogs();
      this.contentRoot.createEl("p", {
        text: "No extraction results yet.",
        cls: "story-engine-extract-empty"
      });
      return;
    }
    const queryBlock = this.contentRoot.createDiv({
      cls: "story-engine-extract-query"
    });
    queryBlock.createEl("div", {
      text: "Text",
      cls: "story-engine-extract-label"
    });
    queryBlock.createEl("div", {
      text: this.result.text,
      cls: "story-engine-extract-query-text"
    });
    const headerMeta = this.contentRoot.createDiv({
      cls: "story-engine-extract-meta"
    });
    headerMeta.createEl("div", {
      text: `Status: ${this.status}`
    });
    if (this.result) {
      const foundCount = this.result.entities.filter((entity) => entity.found).length;
      headerMeta.createEl("div", {
        text: `Entities found: ${foundCount}/${this.result.entities.length}`
      });
      headerMeta.createEl("div", {
        text: `Relations found: ${this.result.relations.length}`
      });
      headerMeta.createEl("div", {
        text: `Text length: ${this.result.text.length}`
      });
    }
    const tabs = this.contentRoot.createDiv({
      cls: "story-engine-extract-tabs"
    });
    const hasEntities = this.result.entities.length > 0;
    const hasRelations = this.result.relations.length > 0;
    const includeRelations = this.result.include_relations !== false;
    const entitiesDisabled = !hasEntities && this.status === "idle";
    const relationsDisabled = !hasRelations && this.status === "idle" || !includeRelations;
    const progressTab = tabs.createEl("button", {
      text: "Progress",
      cls: `story-engine-extract-tab ${this.activeTab === "progress" ? "is-active" : ""}`
    });
    progressTab.onclick = () => {
      this.setActiveTab("progress");
    };
    const entitiesTab = tabs.createEl("button", {
      text: "Entities",
      cls: `story-engine-extract-tab ${this.activeTab === "entities" ? "is-active" : ""}`
    });
    if (entitiesDisabled) {
      entitiesTab.disabled = true;
      entitiesTab.addClass("is-disabled");
    }
    entitiesTab.onclick = () => {
      if (entitiesDisabled)
        return;
      this.setActiveTab("entities");
    };
    const relationsTab = tabs.createEl("button", {
      text: "Relations",
      cls: `story-engine-extract-tab ${this.activeTab === "relations" ? "is-active" : ""}`
    });
    if (relationsDisabled) {
      relationsTab.disabled = true;
      relationsTab.addClass("is-disabled");
    }
    relationsTab.onclick = () => {
      if (relationsDisabled)
        return;
      this.setActiveTab("relations");
    };
    const panels = this.contentRoot.createDiv({
      cls: "story-engine-extract-panels"
    });
    const entitiesPanel = panels.createDiv({
      cls: `story-engine-extract-panel ${this.activeTab === "entities" ? "is-active" : ""}`
    });
    const relationsPanel = panels.createDiv({
      cls: `story-engine-extract-panel ${this.activeTab === "relations" ? "is-active" : ""}`
    });
    const progressPanel = panels.createDiv({
      cls: `story-engine-extract-panel ${this.activeTab === "progress" ? "is-active" : ""}`
    });
    const actions = this.contentRoot.createDiv({
      cls: "story-engine-extract-actions"
    });
    const clearButton = actions.createEl("button", {
      text: "Clear Results",
      cls: "story-engine-extract-clear"
    });
    clearButton.onclick = () => {
      this.plugin.extractResult = null;
      this.setResult(null);
      this.plugin.updateExtractViews();
    };
    this.renderLogs(progressPanel);
    if (hasEntities) {
      this.renderEntityControls(entitiesPanel);
      const list = entitiesPanel.createDiv({
        cls: "story-engine-extract-list"
      });
      const filteredEntities = this.filterAndSortEntities(this.result.entities);
      filteredEntities.forEach((entity, index) => {
        this.renderEntity(list, entity, index);
      });
    } else {
      const emptyText = this.status === "running" ? "Extracting entities..." : "No entities returned from extraction.";
      entitiesPanel.createEl("p", {
        text: emptyText,
        cls: "story-engine-extract-empty"
      });
    }
    if (hasRelations) {
      this.renderRelationControls(relationsPanel);
      const list = relationsPanel.createDiv({
        cls: "story-engine-extract-list"
      });
      const filteredRelations = this.filterAndSortRelations(this.result.relations);
      filteredRelations.forEach((relation, index) => {
        this.renderRelation(list, relation, index);
      });
    } else {
      let emptyText = "No relations returned from extraction.";
      if (!includeRelations) {
        emptyText = "Relations not requested.";
      } else if (!hasEntities) {
        emptyText = "Waiting for entity extraction.";
      } else if (this.status === "running") {
        emptyText = "Extracting relations...";
      }
      relationsPanel.createEl("p", {
        text: emptyText,
        cls: "story-engine-extract-empty"
      });
    }
    this.applyPendingScroll();
  }
  renderLogs(container) {
    const root2 = container != null ? container : this.contentRoot;
    const logBlock = root2.createDiv({
      cls: "story-engine-extract-logs"
    });
    logBlock.createEl("div", {
      text: "Progress",
      cls: "story-engine-extract-label"
    });
    if (!this.logs.length) {
      logBlock.createEl("p", {
        text: "No events yet.",
        cls: "story-engine-extract-empty"
      });
      return;
    }
    const list = logBlock.createDiv({ cls: "story-engine-extract-log-list" });
    const lastIndex = this.logs.length - 1;
    this.logs.forEach((entry, index) => {
      const eventLabel = entry.phase ? `${entry.phase} \xB7 ${entry.eventType}` : entry.eventType;
      const item = list.createDiv({
        cls: `story-engine-extract-log-item ${index === lastIndex ? "is-latest" : ""}`
      });
      const header = item.createDiv({
        cls: "story-engine-extract-log-header"
      });
      header.createSpan({
        text: `${entry.timestamp} | ${eventLabel}`,
        cls: "story-engine-extract-log-title"
      });
      const label = item.createDiv({
        cls: "story-engine-extract-log-label"
      });
      label.createSpan({ text: entry.message });
      const toggle = label.createSpan({
        text: index === lastIndex ? "..." : this.expandedLogs.has(entry.id) ? "\u2212" : "+",
        cls: "story-engine-extract-log-toggle"
      });
      label.onclick = () => {
        if (this.expandedLogs.has(entry.id)) {
          this.expandedLogs.delete(entry.id);
        } else {
          this.expandedLogs.add(entry.id);
        }
        this.render();
      };
      if (index === lastIndex) {
        toggle.addClass("is-typing");
      }
      if (this.expandedLogs.has(entry.id) && entry.data) {
        item.createEl("pre", {
          text: JSON.stringify(entry.data, null, 2),
          cls: "story-engine-extract-log-data"
        });
      }
    });
    list.scrollTop = list.scrollHeight;
  }
  renderEntity(container, entity, index) {
    this.renderEntityCard(container, entity, index);
  }
  renderEntityCard(container, entity, index, onCreated) {
    const item = container.createDiv({ cls: "story-engine-extract-item" });
    item.dataset.relationIndex = String(index);
    const header = item.createDiv({ cls: "story-engine-extract-item-header" });
    header.createEl("div", {
      text: `#${index + 1}`,
      cls: "story-engine-extract-rank"
    });
    const statusText = entity.created ? "Created" : entity.found ? "Found" : "New";
    const statusClass = entity.created ? "is-created" : entity.found ? "is-found" : "is-new";
    header.createEl("div", {
      text: statusText,
      cls: `story-engine-extract-status ${statusClass}`
    });
    const title = item.createDiv({ cls: "story-engine-extract-item-title" });
    title.createEl("div", {
      text: entity.name,
      cls: "story-engine-extract-entity-name"
    });
    title.createEl("div", {
      text: entity.type,
      cls: "story-engine-extract-entity-type"
    });
    if (entity.summary) {
      item.createEl("div", {
        text: entity.summary,
        cls: "story-engine-extract-content"
      });
    }
    if (entity.match) {
      item.appendChild(this.renderMatch("Match", entity.match));
    }
    if (entity.candidates && entity.candidates.length) {
      const list = item.createDiv({ cls: "story-engine-extract-candidates" });
      list.createEl("div", {
        text: "Candidates",
        cls: "story-engine-extract-label"
      });
      entity.candidates.forEach((candidate) => {
        list.appendChild(this.renderMatch("", candidate));
      });
    }
    if (!entity.created) {
      const actions = item.createDiv({ cls: "story-engine-extract-actions" });
      const actionButton = actions.createEl("button", {
        text: entity.found ? "Update Entity" : "Create Entity",
        cls: "story-engine-extract-action"
      });
      actionButton.onclick = async () => {
        actionButton.disabled = true;
        try {
          if (entity.found) {
            await this.updateEntity(entity);
          } else {
            const createdId = await this.createEntity(entity);
            if (createdId && onCreated) {
              onCreated(createdId);
            }
          }
        } finally {
          actionButton.disabled = false;
        }
      };
    }
  }
  renderMatch(label, match) {
    const wrapper = document.createElement("div");
    wrapper.className = "story-engine-extract-match";
    const parts = [];
    if (label) {
      parts.push(label);
    }
    parts.push(`${match.source_type}:${match.source_id}`);
    if (match.entity_name) {
      parts.push(match.entity_name);
    }
    parts.push(`sim ${match.similarity.toFixed(3)}`);
    if (match.reason) {
      parts.push(match.reason);
    }
    wrapper.textContent = parts.join(" \xB7 ");
    return wrapper;
  }
  async createEntity(entity) {
    var _a, _b;
    if (!((_a = this.result) == null ? void 0 : _a.world_id)) {
      new import_obsidian17.Notice("World ID missing. Select a story or world first.", 4e3);
      return "";
    }
    const description = ((_b = entity.summary) == null ? void 0 : _b.trim()) || entity.name;
    let createdId = "";
    switch (entity.type) {
      case "character": {
        const created = await this.plugin.apiClient.createCharacter(
          this.result.world_id,
          { name: entity.name, description }
        );
        createdId = created.id;
        break;
      }
      case "location": {
        const created = await this.plugin.apiClient.createLocation(
          this.result.world_id,
          { name: entity.name, description }
        );
        createdId = created.id;
        break;
      }
      case "artefact": {
        const created = await this.plugin.apiClient.createArtifact(
          this.result.world_id,
          { name: entity.name, description }
        );
        createdId = created.id;
        break;
      }
      case "faction": {
        const created = await this.plugin.apiClient.createFaction(
          this.result.world_id,
          { name: entity.name, description }
        );
        createdId = created.id;
        break;
      }
      case "event": {
        const created = await this.plugin.apiClient.createEvent(
          this.result.world_id,
          { name: entity.name, description }
        );
        createdId = created.id;
        break;
      }
      default:
        new import_obsidian17.Notice(`Unsupported type: ${entity.type}`, 4e3);
        return "";
    }
    entity.found = false;
    entity.created = true;
    entity.match = {
      source_type: entity.type,
      source_id: createdId,
      entity_name: entity.name,
      similarity: 1,
      reason: "Created from extract"
    };
    this.render();
    new import_obsidian17.Notice(`Created ${entity.type}: ${entity.name}`, 3e3);
    return createdId;
  }
  async updateEntity(entity) {
    var _a, _b;
    if (!((_a = entity.match) == null ? void 0 : _a.source_id)) {
      new import_obsidian17.Notice("No match available to update.", 4e3);
      return;
    }
    const description = (_b = entity.summary) != null ? _b : "";
    switch (entity.type) {
      case "character":
        await this.plugin.apiClient.updateCharacter(entity.match.source_id, {
          name: entity.name,
          description
        });
        break;
      case "location":
        await this.plugin.apiClient.updateLocation(entity.match.source_id, {
          name: entity.name,
          description
        });
        break;
      case "artefact":
        await this.plugin.apiClient.updateArtifact(entity.match.source_id, {
          name: entity.name,
          description
        });
        break;
      case "faction":
        await this.plugin.apiClient.updateFaction(entity.match.source_id, {
          name: entity.name,
          description
        });
        break;
      case "event":
        await this.plugin.apiClient.updateEvent(entity.match.source_id, {
          name: entity.name,
          description
        });
        break;
      default:
        new import_obsidian17.Notice(`Unsupported type: ${entity.type}`, 4e3);
        return;
    }
    new import_obsidian17.Notice(`Updated ${entity.type}: ${entity.name}`, 3e3);
  }
  renderRelation(container, relation, index) {
    const item = container.createDiv({ cls: "story-engine-extract-item" });
    const header = item.createDiv({ cls: "story-engine-extract-item-header" });
    header.createEl("div", {
      text: `#${index + 1}`,
      cls: "story-engine-extract-rank"
    });
    const statusText = relation.status === "pending_entities" ? "Pending" : relation.status;
    const statusClass = relation.status === "pending_entities" ? "is-new" : "is-found";
    const relationType = relation.relation_type || "relation";
    const typeLabel = `${relationType} | ${relation.source.type} -> ${relation.target.type}`;
    const typeLine = header.createEl("div", {
      text: typeLabel,
      cls: "story-engine-extract-entity-type"
    });
    typeLine.addClass("story-engine-extract-relation-types");
    header.createEl("div", {
      text: statusText,
      cls: `story-engine-extract-status ${statusClass}`
    });
    const title = item.createDiv({ cls: "story-engine-extract-item-title" });
    const sourceLabel = relation.source.name || relation.source.ref;
    const targetLabel = relation.target.name || relation.target.ref;
    title.createEl("div", {
      text: `${sourceLabel} \u2192 ${targetLabel}`,
      cls: "story-engine-extract-entity-type"
    });
    if (relation.summary) {
      item.createEl("div", {
        text: relation.summary,
        cls: "story-engine-extract-content"
      });
    }
    const hasPending = this.hasTempNode(relation.source) || this.hasTempNode(relation.target);
    const relationCreated = relation.status === "created";
    const actions = item.createDiv({ cls: "story-engine-extract-actions" });
    const createRelationButton = actions.createEl("button", {
      text: relationCreated ? "Relation Created" : "Create Relation",
      cls: "story-engine-extract-action"
    });
    if (relationCreated) {
      createRelationButton.disabled = true;
      createRelationButton.addClass("is-disabled");
      createRelationButton.title = "Relation already created.";
    } else if (hasPending) {
      createRelationButton.disabled = true;
      createRelationButton.addClass("is-disabled");
      createRelationButton.title = "Create pending entities first.";
    } else {
      createRelationButton.onclick = async () => {
        createRelationButton.disabled = true;
        try {
          await this.createRelation(relation);
        } finally {
          createRelationButton.disabled = false;
        }
      };
    }
    if (hasPending) {
      const createButton = actions.createEl("button", {
        text: "Create Pending",
        cls: "story-engine-extract-action"
      });
      createButton.onclick = async () => {
        createButton.disabled = true;
        try {
          await this.createPendingEntities(relation);
        } finally {
          createButton.disabled = false;
        }
      };
    }
    const accordionButton = actions.createEl("button", {
      text: "See Entities",
      cls: "story-engine-extract-action"
    });
    accordionButton.onclick = () => {
      const shouldExpand = this.expandedRelationIndex !== index;
      this.expandedRelationIndex = shouldExpand ? index : null;
      this.pendingRelationScrollIndex = shouldExpand ? index : null;
      this.render();
    };
    if (this.expandedRelationIndex === index) {
      const entitiesWrap = item.createDiv({
        cls: "story-engine-extract-relations-entities"
      });
      entitiesWrap.dataset.relationIndex = String(index);
      const entities = [
        this.resolveRelationEntity(relation.source),
        this.resolveRelationEntity(relation.target)
      ];
      entities.forEach((entity, entityIndex) => {
        this.renderEntityCard(entitiesWrap, entity, entityIndex, (createdId) => {
          this.applyCreatedIdToRelation(relation, entity, createdId);
        });
      });
    }
  }
  renderEntityControls(container) {
    if (!this.result)
      return;
    const controls = container.createDiv({ cls: "story-engine-extract-controls" });
    const search = controls.createEl("input", {
      type: "search",
      placeholder: "Search entities",
      cls: "story-engine-extract-search"
    });
    search.value = this.entitySearch;
    search.oninput = () => {
      this.entitySearch = search.value.trim();
      this.render();
    };
    const typeSelect = controls.createEl("select", {
      cls: "story-engine-extract-select"
    });
    typeSelect.createEl("option", { value: "all", text: "All types" });
    this.getEntityTypes(this.result.entities).forEach((type2) => {
      typeSelect.createEl("option", { value: type2, text: type2 });
    });
    typeSelect.value = this.entityFilterType;
    typeSelect.onchange = () => {
      this.entityFilterType = typeSelect.value;
      this.render();
    };
    const sortSelect = controls.createEl("select", {
      cls: "story-engine-extract-select"
    });
    sortSelect.createEl("option", { value: "name", text: "Sort: Name" });
    sortSelect.createEl("option", { value: "type", text: "Sort: Type" });
    sortSelect.createEl("option", { value: "status", text: "Sort: Status" });
    sortSelect.value = this.entitySort;
    sortSelect.onchange = () => {
      this.entitySort = sortSelect.value;
      this.render();
    };
  }
  renderRelationControls(container) {
    if (!this.result)
      return;
    const controls = container.createDiv({ cls: "story-engine-extract-controls" });
    const search = controls.createEl("input", {
      type: "search",
      placeholder: "Search relations",
      cls: "story-engine-extract-search"
    });
    search.value = this.relationSearch;
    search.oninput = () => {
      this.relationSearch = search.value.trim();
      this.render();
    };
    const typeSelect = controls.createEl("select", {
      cls: "story-engine-extract-select"
    });
    typeSelect.createEl("option", { value: "all", text: "All types" });
    this.getRelationTypes(this.result.relations).forEach((type2) => {
      typeSelect.createEl("option", { value: type2, text: type2 });
    });
    typeSelect.value = this.relationFilterType;
    typeSelect.onchange = () => {
      this.relationFilterType = typeSelect.value;
      this.render();
    };
    const sortSelect = controls.createEl("select", {
      cls: "story-engine-extract-select"
    });
    sortSelect.createEl("option", { value: "type", text: "Sort: Type" });
    sortSelect.createEl("option", { value: "status", text: "Sort: Status" });
    sortSelect.createEl("option", { value: "source", text: "Sort: Source" });
    sortSelect.createEl("option", { value: "target", text: "Sort: Target" });
    sortSelect.value = this.relationSort;
    sortSelect.onchange = () => {
      this.relationSort = sortSelect.value;
      this.render();
    };
  }
  getEntityTypes(entities) {
    const set3 = /* @__PURE__ */ new Set();
    entities.forEach((entity) => {
      if (entity.type) {
        set3.add(entity.type);
      }
    });
    return Array.from(set3).sort((a, b) => a.localeCompare(b));
  }
  getRelationTypes(relations) {
    const set3 = /* @__PURE__ */ new Set();
    relations.forEach((relation) => {
      if (relation.relation_type) {
        set3.add(relation.relation_type);
      }
    });
    return Array.from(set3).sort((a, b) => a.localeCompare(b));
  }
  filterAndSortEntities(entities) {
    const search = this.entitySearch.toLowerCase();
    let filtered = entities.filter((entity) => {
      var _a;
      if (this.entityFilterType !== "all" && entity.type !== this.entityFilterType) {
        return false;
      }
      if (!search)
        return true;
      return entity.name.toLowerCase().includes(search) || entity.type.toLowerCase().includes(search) || ((_a = entity.summary) != null ? _a : "").toLowerCase().includes(search);
    });
    const statusRank = (entity) => {
      if (entity.created)
        return 0;
      if (entity.found)
        return 1;
      return 2;
    };
    filtered = [...filtered].sort((a, b) => {
      switch (this.entitySort) {
        case "type":
          return a.type.localeCompare(b.type) || a.name.localeCompare(b.name);
        case "status":
          return statusRank(a) - statusRank(b) || a.name.localeCompare(b.name);
        default:
          return a.name.localeCompare(b.name);
      }
    });
    return filtered;
  }
  filterAndSortRelations(relations) {
    const search = this.relationSearch.toLowerCase();
    let filtered = relations.filter((relation) => {
      var _a, _b, _c, _d, _e;
      if (this.relationFilterType !== "all" && relation.relation_type !== this.relationFilterType) {
        return false;
      }
      if (!search)
        return true;
      const sourceLabel = ((_b = (_a = relation.source.name) != null ? _a : relation.source.ref) != null ? _b : "").toLowerCase();
      const targetLabel = ((_d = (_c = relation.target.name) != null ? _c : relation.target.ref) != null ? _d : "").toLowerCase();
      return relation.relation_type.toLowerCase().includes(search) || sourceLabel.includes(search) || targetLabel.includes(search) || relation.source.type.toLowerCase().includes(search) || relation.target.type.toLowerCase().includes(search) || ((_e = relation.summary) != null ? _e : "").toLowerCase().includes(search);
    });
    const statusRank = (relation) => {
      if (relation.status === "created")
        return 0;
      if (relation.status === "ready")
        return 1;
      if (relation.status === "pending_entities")
        return 2;
      return 3;
    };
    filtered = [...filtered].sort((a, b) => {
      switch (this.relationSort) {
        case "status":
          return statusRank(a) - statusRank(b) || a.relation_type.localeCompare(b.relation_type);
        case "source": {
          const aSource = a.source.name || a.source.ref;
          const bSource = b.source.name || b.source.ref;
          return aSource.localeCompare(bSource) || a.relation_type.localeCompare(b.relation_type);
        }
        case "target": {
          const aTarget = a.target.name || a.target.ref;
          const bTarget = b.target.name || b.target.ref;
          return aTarget.localeCompare(bTarget) || a.relation_type.localeCompare(b.relation_type);
        }
        default:
          return a.relation_type.localeCompare(b.relation_type);
      }
    });
    return filtered;
  }
  resolveRelationEntity(node) {
    if (!this.result) {
      return this.buildRelationEntity(node);
    }
    const existing = this.result.entities.find((entity) => {
      var _a;
      if (node.id && ((_a = entity.match) == null ? void 0 : _a.source_id) === node.id) {
        return true;
      }
      return entity.type === node.type && entity.name === node.name;
    });
    return existing != null ? existing : this.buildRelationEntity(node);
  }
  buildRelationEntity(node) {
    const hasId = !!(node.id && node.id.trim());
    return {
      type: node.type,
      name: node.name || node.ref,
      found: hasId,
      match: hasId ? {
        source_type: node.type,
        source_id: node.id,
        entity_name: node.name,
        similarity: 1,
        reason: "Relation match"
      } : void 0
    };
  }
  hasTempNode(node) {
    if (!node.id || !node.id.trim()) {
      return true;
    }
    if (node.id.startsWith("temp")) {
      return true;
    }
    return node.ref.startsWith("finding:");
  }
  async createPendingEntities(relation) {
    const nodes = [relation.source, relation.target];
    for (const node of nodes) {
      if (!this.hasTempNode(node)) {
        continue;
      }
      const entity = this.buildRelationEntity(node);
      const createdId = await this.createEntity(entity);
      if (createdId) {
        this.applyCreatedIdToRelation(relation, entity, createdId);
      }
    }
    this.render();
  }
  async createRelation(relation) {
    var _a, _b;
    if (!((_a = this.result) == null ? void 0 : _a.world_id)) {
      new import_obsidian17.Notice("World ID missing. Select a story or world first.", 4e3);
      return;
    }
    if (!relation.source.id || !relation.target.id) {
      new import_obsidian17.Notice("Create the related entities before creating the relation.", 4e3);
      return;
    }
    const created = await this.plugin.apiClient.createEntityRelation({
      world_id: this.result.world_id,
      source_type: relation.source.type,
      source_id: relation.source.id,
      target_type: relation.target.type,
      target_id: relation.target.id,
      relation_type: relation.relation_type,
      summary: relation.summary,
      create_mirror: (_b = relation.create_mirror) != null ? _b : false
    });
    relation.status = "created";
    relation.created_id = created.id;
    this.render();
    new import_obsidian17.Notice(`Relation created: ${relation.relation_type}`, 3e3);
  }
  applyCreatedIdToRelation(relation, entity, createdId) {
    const updateNode = (node) => {
      if (node.type !== entity.type)
        return false;
      if (entity.name && node.name && node.name !== entity.name)
        return false;
      node.id = createdId;
      node.name = entity.name;
      return true;
    };
    if (!updateNode(relation.source)) {
      updateNode(relation.target);
    }
    if (!this.hasTempNode(relation.source) && !this.hasTempNode(relation.target)) {
      relation.status = "ready";
    }
  }
  setActiveTab(tab) {
    this.activeTab = tab;
    this.pendingTabScroll = true;
    this.render();
  }
  applyPendingScroll() {
    if (!this.pendingTabScroll && this.pendingRelationScrollIndex === null) {
      return;
    }
    requestAnimationFrame(() => {
      if (this.pendingTabScroll) {
        const panel = this.contentRoot.querySelector(
          ".story-engine-extract-panel.is-active"
        );
        if (panel) {
          panel.scrollTop = 0;
          panel.scrollIntoView({ block: "start" });
        }
        this.pendingTabScroll = false;
      }
      if (this.pendingRelationScrollIndex !== null) {
        const selector = `.story-engine-extract-relations-entities[data-relation-index="${this.pendingRelationScrollIndex}"]`;
        const entityBlock = this.contentRoot.querySelector(selector);
        if (entityBlock) {
          entityBlock.scrollIntoView({ block: "start" });
        }
        this.pendingRelationScrollIndex = null;
      }
    });
  }
};

// src/sync/syncService.ts
var import_obsidian19 = require("obsidian");

// src/sync/contentBlockParser.ts
function parseHierarchicalProse(chapterContent) {
  const sections = [];
  const frontmatterMatch = chapterContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = chapterContent.substring(contentStart).trim();
  const chapterSectionMatch = bodyContent.match(/##\s+Chapter\s+\d+:\s+[^\n]+\s*\n+([\s\S]*?)(?=\n##\s+Chapter\s+\d+:|$)/);
  if (!chapterSectionMatch) {
    const chapterSectionMatchSameLine = bodyContent.match(/##\s+Chapter\s+\d+:\s+[^\n]+\s+([^\n]+)/);
    if (chapterSectionMatchSameLine) {
      const proseContent2 = chapterSectionMatchSameLine[1].trim();
      if (proseContent2.length > 0 && !proseContent2.startsWith("#")) {
        const paragraph = {
          content: proseContent2,
          linkName: null,
          originalOrder: 0
        };
        sections.push({
          type: "prose",
          prose: paragraph,
          originalOrder: 0
        });
      }
      return { sections };
    }
    return { sections: [] };
  }
  const proseContent = chapterSectionMatch[1].trim();
  const lines = proseContent.split(/\n/);
  let currentScene = null;
  let currentBeat = null;
  let order = 0;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line) {
      continue;
    }
    const sceneMatch = line.match(/^##\s+Scene:\s*(.+)$/);
    if (sceneMatch) {
      const sceneText = sceneMatch[1].trim();
      const parsedScene = parseSceneHeader(sceneText);
      parsedScene.originalOrder = order++;
      currentScene = parsedScene;
      currentBeat = null;
      sections.push({
        type: "scene",
        scene: parsedScene,
        originalOrder: parsedScene.originalOrder
      });
      continue;
    }
    const beatMatch = line.match(/^###\s+Beat:\s*(.+)$/);
    if (beatMatch) {
      const beatText = beatMatch[1].trim();
      const parsedBeat = parseBeatHeader(beatText);
      parsedBeat.originalOrder = order++;
      currentBeat = parsedBeat;
      sections.push({
        type: "beat",
        beat: parsedBeat,
        originalOrder: parsedBeat.originalOrder
      });
      continue;
    }
    if (line.startsWith("#") && !line.match(/^##\s+Scene:/) && !line.match(/^###\s+Beat:/)) {
      continue;
    }
    const proseMatch = line.match(/^\s*\[\[([^\|]+)\|([^\]]+)\]\]\s*$/);
    if (proseMatch) {
      const linkName = proseMatch[1].trim();
      const content = proseMatch[2].trim();
      const paragraph = {
        content,
        linkName,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
      continue;
    }
    if (line.length > 0 && !line.startsWith("#")) {
      const paragraph = {
        content: line,
        linkName: null,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
    }
  }
  return { sections };
}
function parseSceneHeader(text) {
  const linkMatch = text.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
  if (linkMatch) {
    const linkName = linkMatch[1].trim();
    const displayText = linkMatch[2].trim();
    const { goal: goal2, timeRef: timeRef2 } = parseSceneText(displayText);
    return {
      linkName,
      goal: goal2,
      timeRef: timeRef2,
      originalOrder: 0
      // Will be set by caller
    };
  }
  const simpleLinkMatch = text.match(/^\[\[([^\]]+)\]\]$/);
  if (simpleLinkMatch) {
    return {
      linkName: simpleLinkMatch[1].trim(),
      goal: "",
      timeRef: "",
      originalOrder: 0
    };
  }
  const { goal, timeRef } = parseSceneText(text);
  return {
    linkName: null,
    goal,
    timeRef,
    originalOrder: 0
  };
}
function parseSceneText(text) {
  const parts = text.split(/\s*-\s*/);
  if (parts.length >= 2) {
    return {
      goal: parts[0].trim(),
      timeRef: parts.slice(1).join(" - ").trim()
      // Join in case there are multiple "-"
    };
  }
  return {
    goal: text.trim(),
    timeRef: ""
  };
}
function parseBeatHeader(text) {
  const linkMatch = text.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
  if (linkMatch) {
    const linkName = linkMatch[1].trim();
    const displayText = linkMatch[2].trim();
    const { intent: intent2, outcome: outcome2 } = parseBeatText(displayText);
    return {
      linkName,
      intent: intent2,
      outcome: outcome2,
      originalOrder: 0
      // Will be set by caller
    };
  }
  const simpleLinkMatch = text.match(/^\[\[([^\]]+)\]\]$/);
  if (simpleLinkMatch) {
    return {
      linkName: simpleLinkMatch[1].trim(),
      intent: "",
      outcome: "",
      originalOrder: 0
    };
  }
  const { intent, outcome } = parseBeatText(text);
  return {
    linkName: null,
    intent,
    outcome,
    originalOrder: 0
  };
}
function parseBeatText(text) {
  const parts = text.split(/\s*->\s*/);
  if (parts.length >= 2) {
    return {
      intent: parts[0].trim(),
      outcome: parts.slice(1).join(" -> ").trim()
      // Join in case there are multiple "->"
    };
  }
  return {
    intent: text.trim(),
    outcome: ""
  };
}
function compareContentBlocks(paragraph, localContentBlock, remoteContentBlock) {
  const paragraphContent = paragraph.content.trim();
  if (!paragraph.linkName) {
    if (remoteContentBlock && remoteContentBlock.content.trim() === paragraphContent) {
      if (localContentBlock && localContentBlock.id === remoteContentBlock.id) {
        return "unchanged";
      }
      return "unchanged";
    }
    return "new";
  }
  if (!localContentBlock) {
    if (remoteContentBlock && remoteContentBlock.content.trim() === paragraphContent) {
      return "remote_modified";
    }
    return "new";
  }
  if (!remoteContentBlock) {
    return "local_modified";
  }
  const localContent = localContentBlock.content.trim();
  const remoteContent = remoteContentBlock.content.trim();
  if (localContent === paragraphContent && remoteContent === paragraphContent) {
    return "unchanged";
  }
  if (paragraphContent !== localContent && paragraphContent !== remoteContent && localContent === remoteContent) {
    return "local_modified";
  }
  if (localContent === paragraphContent && remoteContent !== paragraphContent) {
    return "remote_modified";
  }
  if (paragraphContent !== localContent && paragraphContent !== remoteContent && localContent !== remoteContent) {
    return "conflict";
  }
  if (paragraphContent === remoteContent && localContent !== remoteContent) {
    return "remote_modified";
  }
  return "conflict";
}
function parseSceneBeatList(chapterContent) {
  const items = [];
  const frontmatterMatch = chapterContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = chapterContent.substring(contentStart).trim();
  const listSectionMatch = bodyContent.match(/##\s+Scenes\s+&\s+Beats\s*\n+([\s\S]*?)(?=\n##|$)/);
  if (!listSectionMatch) {
    return { items: [] };
  }
  const listContent = listSectionMatch[1].trim();
  const lines = listContent.split(/\n/);
  let order = 0;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    const itemMatch = trimmedLine.match(/^([+-])\s+(.+)$/);
    if (!itemMatch) {
      continue;
    }
    const hasProse = itemMatch[1] === "+";
    const itemText = itemMatch[2].trim();
    const tabMatch = line.match(/^(\t*)/);
    const indentLevel = tabMatch ? tabMatch[1].length : 0;
    const isBeat = indentLevel > 0;
    const linkMatch = itemText.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
    let linkName = null;
    let displayText;
    if (linkMatch) {
      linkName = linkMatch[1].trim();
      displayText = linkMatch[2].trim();
    } else {
      displayText = itemText;
    }
    items.push({
      type: isBeat ? "beat" : "scene",
      linkName,
      displayText,
      hasProse,
      indentLevel: isBeat ? 1 : 0,
      originalOrder: order++
    });
  }
  return { items };
}
function parseChapterList(storyContent) {
  const items = [];
  const frontmatterMatch = storyContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = storyContent.substring(contentStart).trim();
  const listSectionMatch = bodyContent.match(/##\s+Chapters(?:,\s*Scenes\s*&\s*Beats)?\s*\n+([\s\S]*?)(?=\n##|$)/);
  if (!listSectionMatch) {
    return { items: [] };
  }
  const listContent = listSectionMatch[1].trim();
  const lines = listContent.split(/\n/);
  let order = 0;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    const itemMatch = trimmedLine.match(/^([+-])\s+(.+)$/);
    if (!itemMatch) {
      continue;
    }
    const hasProse = itemMatch[1] === "+";
    const itemText = itemMatch[2].trim();
    const tabMatch = line.match(/^(\t*)/);
    const indentLevel = tabMatch ? tabMatch[1].length : 0;
    let type2;
    if (indentLevel === 0) {
      type2 = "chapter";
    } else if (indentLevel === 1) {
      type2 = "scene";
    } else if (indentLevel === 2) {
      type2 = "beat";
    } else {
      continue;
    }
    const linkMatch = itemText.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
    let linkName = null;
    let displayText;
    if (linkMatch) {
      linkName = linkMatch[1].trim();
      displayText = linkMatch[2].trim();
    } else {
      displayText = itemText;
    }
    items.push({
      type: type2,
      linkName,
      displayText,
      hasProse,
      indentLevel: indentLevel / 2,
      // Normalize to 0, 1, 2
      originalOrder: order++
    });
  }
  return { items };
}
function parseBeatList(sceneContent) {
  const items = [];
  const frontmatterMatch = sceneContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = sceneContent.substring(contentStart).trim();
  const listSectionMatch = bodyContent.match(/##\s+Beats\s*\n+([\s\S]*?)(?=\n##|$)/);
  if (!listSectionMatch) {
    return { items: [] };
  }
  const listContent = listSectionMatch[1].trim();
  const lines = listContent.split(/\n/);
  let order = 0;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    if (trimmedLine.startsWith(">")) {
      continue;
    }
    const itemMatch = trimmedLine.match(/^([+-])\s+(.+)$/);
    if (!itemMatch) {
      continue;
    }
    const hasProse = itemMatch[1] === "+";
    const itemText = itemMatch[2].trim();
    const linkMatch = itemText.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
    let linkName = null;
    let displayText;
    if (linkMatch) {
      linkName = linkMatch[1].trim();
      displayText = linkMatch[2].trim();
    } else {
      displayText = itemText;
    }
    items.push({
      linkName,
      displayText,
      hasProse,
      originalOrder: order++
    });
  }
  return { items };
}
function parseOrphanScenesList(storyContent) {
  const items = [];
  const frontmatterMatch = storyContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = storyContent.substring(contentStart).trim();
  const listSectionMatch = bodyContent.match(/##\s+Orphan\s+Scenes\s*\n+([\s\S]*?)(?=\n##|$)/);
  if (!listSectionMatch) {
    return { items: [] };
  }
  const listContent = listSectionMatch[1].trim();
  const lines = listContent.split(/\n/);
  let order = 0;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    if (trimmedLine.startsWith(">")) {
      continue;
    }
    const itemMatch = trimmedLine.match(/^([+-])\s+(.+)$/);
    if (!itemMatch) {
      continue;
    }
    const hasProse = itemMatch[1] === "+";
    const itemText = itemMatch[2].trim();
    const tabMatch = line.match(/^(\t*)/);
    const indentLevel = tabMatch ? tabMatch[1].length : 0;
    const isBeat = indentLevel > 0;
    const linkMatch = itemText.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
    let linkName = null;
    let displayText;
    if (linkMatch) {
      linkName = linkMatch[1].trim();
      displayText = linkMatch[2].trim();
    } else {
      displayText = itemText;
    }
    items.push({
      type: isBeat ? "beat" : "scene",
      linkName,
      displayText,
      hasProse,
      indentLevel: isBeat ? 1 : 0,
      originalOrder: order++
    });
  }
  return { items };
}
function parseOrphanBeatsList(storyContent) {
  const items = [];
  const frontmatterMatch = storyContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = storyContent.substring(contentStart).trim();
  const listSectionMatch = bodyContent.match(/##\s+Orphan\s+Beats\s*\n+([\s\S]*?)(?=\n##|$)/);
  if (!listSectionMatch) {
    return { items: [] };
  }
  const listContent = listSectionMatch[1].trim();
  const lines = listContent.split(/\n/);
  let order = 0;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    if (trimmedLine.startsWith(">")) {
      continue;
    }
    const itemMatch = trimmedLine.match(/^([+-])\s+(.+)$/);
    if (!itemMatch) {
      continue;
    }
    const hasProse = itemMatch[1] === "+";
    const itemText = itemMatch[2].trim();
    const linkMatch = itemText.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
    let linkName = null;
    let displayText;
    if (linkMatch) {
      linkName = linkMatch[1].trim();
      displayText = linkMatch[2].trim();
    } else {
      displayText = itemText;
    }
    items.push({
      linkName,
      displayText,
      hasProse,
      originalOrder: order++
    });
  }
  return { items };
}
function parseStoryProse(storyContent) {
  const sections = [];
  const frontmatterMatch = storyContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = storyContent.substring(contentStart).trim();
  const storyHeaderMatch = bodyContent.match(/^(#\s+Story:\s*.+)$/m);
  const chapterHeaderMatch = bodyContent.match(/^(##\s+Chapter\s*\d*:\s*.+)$/m);
  let proseStartIndex = -1;
  if (storyHeaderMatch) {
    proseStartIndex = bodyContent.indexOf(storyHeaderMatch[0]);
  } else if (chapterHeaderMatch) {
    proseStartIndex = bodyContent.indexOf(chapterHeaderMatch[0]);
  }
  if (proseStartIndex === -1) {
    return { sections: [] };
  }
  const proseContent = bodyContent.substring(proseStartIndex);
  const lines = proseContent.split(/\n/);
  let order = 0;
  let currentChapter = null;
  let currentScene = null;
  let currentBeat = null;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    if (trimmedLine.startsWith(">")) {
      continue;
    }
    const storyMatch = trimmedLine.match(/^#\s+Story:\s*(.+)$/i);
    if (storyMatch) {
      continue;
    }
    const chapterMatch = trimmedLine.match(/^##\s+Chapter\s*\d*:\s*(.+)$/i);
    if (chapterMatch) {
      const chapterText = chapterMatch[1].trim();
      const linkMatch = chapterText.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
      if (linkMatch) {
        currentChapter = {
          linkName: linkMatch[1].trim(),
          title: linkMatch[2].trim()
        };
      } else {
        currentChapter = {
          linkName: null,
          title: chapterText
        };
      }
      currentScene = null;
      currentBeat = null;
      continue;
    }
    const sceneMatch = trimmedLine.match(/^###\s+Scene:\s*(.+)$/i);
    if (sceneMatch) {
      const sceneText = sceneMatch[1].trim();
      currentScene = parseSceneHeaderText(sceneText);
      currentScene.originalOrder = order++;
      sections.push({
        type: "scene",
        scene: currentScene,
        originalOrder: currentScene.originalOrder
      });
      currentBeat = null;
      continue;
    }
    const beatMatch = trimmedLine.match(/^####\s+Beat:\s*(.+)$/i);
    if (beatMatch) {
      const beatText = beatMatch[1].trim();
      currentBeat = parseBeatHeaderText(beatText);
      currentBeat.originalOrder = order++;
      sections.push({
        type: "beat",
        beat: currentBeat,
        originalOrder: currentBeat.originalOrder
      });
      continue;
    }
    if (trimmedLine.startsWith("#")) {
      continue;
    }
    if (trimmedLine.match(/^[+-]\s+/)) {
      continue;
    }
    const proseMatch = trimmedLine.match(/^\s*\[\[([^\|]+)\|([^\]]+)\]\]\s*$/);
    if (proseMatch) {
      const linkName = proseMatch[1].trim();
      const content = proseMatch[2].trim();
      const paragraph = {
        content,
        linkName,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
      continue;
    }
    if (trimmedLine.length > 0) {
      const paragraph = {
        content: trimmedLine,
        linkName: null,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
    }
  }
  return { sections };
}
function parseSceneHeaderText(text) {
  const linkMatch = text.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
  if (linkMatch) {
    const linkName = linkMatch[1].trim();
    const displayText = linkMatch[2].trim();
    const parts2 = displayText.split(/\s*-\s*/);
    return {
      linkName,
      goal: parts2[0].trim(),
      timeRef: parts2.length > 1 ? parts2.slice(1).join(" - ").trim() : "",
      originalOrder: 0
    };
  }
  const simpleLinkMatch = text.match(/^\[\[([^\]]+)\]\]$/);
  if (simpleLinkMatch) {
    return {
      linkName: simpleLinkMatch[1].trim(),
      goal: "",
      timeRef: "",
      originalOrder: 0
    };
  }
  const parts = text.split(/\s*-\s*/);
  return {
    linkName: null,
    goal: parts[0].trim(),
    timeRef: parts.length > 1 ? parts.slice(1).join(" - ").trim() : "",
    originalOrder: 0
  };
}
function parseBeatHeaderText(text) {
  const linkMatch = text.match(/^\[\[([^\|]+)\|([^\]]+)\]\]$/);
  if (linkMatch) {
    const linkName = linkMatch[1].trim();
    const displayText = linkMatch[2].trim();
    const parts2 = displayText.split(/\s*->\s*/);
    return {
      linkName,
      intent: parts2[0].trim(),
      outcome: parts2.length > 1 ? parts2.slice(1).join(" -> ").trim() : "",
      originalOrder: 0
    };
  }
  const simpleLinkMatch = text.match(/^\[\[([^\]]+)\]\]$/);
  if (simpleLinkMatch) {
    return {
      linkName: simpleLinkMatch[1].trim(),
      intent: "",
      outcome: "",
      originalOrder: 0
    };
  }
  const parts = text.split(/\s*->\s*/);
  return {
    linkName: null,
    intent: parts[0].trim(),
    outcome: parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "",
    originalOrder: 0
  };
}
function parseSceneProse(sceneContent) {
  const sections = [];
  const frontmatterMatch = sceneContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = sceneContent.substring(contentStart).trim();
  const sceneHeaderMatch = bodyContent.match(/^(###\s+Scene:\s*.+)$/m);
  const beatHeaderMatch = bodyContent.match(/^(#{3,4}\s+Beat:\s*.+)$/m);
  let proseStartIndex = -1;
  if (sceneHeaderMatch) {
    proseStartIndex = bodyContent.indexOf(sceneHeaderMatch[0]);
  } else if (beatHeaderMatch) {
    proseStartIndex = bodyContent.indexOf(beatHeaderMatch[0]);
  } else {
    const beatsListEnd = bodyContent.match(/##\s+Beats\s*\n+[\s\S]*?(?=\n###|\n####|\n[^#\-\+>\s]|$)/);
    if (beatsListEnd) {
      proseStartIndex = bodyContent.indexOf(beatsListEnd[0]) + beatsListEnd[0].length;
    } else {
      const firstNonListContent = bodyContent.match(/(?:^|\n)([^#\-\+>\s\n].+)/);
      if (firstNonListContent) {
        proseStartIndex = bodyContent.indexOf(firstNonListContent[1]);
      }
    }
  }
  if (proseStartIndex === -1) {
    return { sections: [] };
  }
  const proseContent = bodyContent.substring(proseStartIndex);
  const lines = proseContent.split(/\n/);
  let order = 0;
  let currentBeat = null;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    if (trimmedLine.startsWith(">")) {
      continue;
    }
    const sceneMatch = trimmedLine.match(/^###\s+Scene:\s*(.+)$/i);
    if (sceneMatch) {
      const sceneText = sceneMatch[1].trim();
      const parsedScene = parseSceneHeaderText(sceneText);
      parsedScene.originalOrder = order++;
      sections.push({
        type: "scene",
        scene: parsedScene,
        originalOrder: parsedScene.originalOrder
      });
      currentBeat = null;
      continue;
    }
    const beatMatch = trimmedLine.match(/^#{3,4}\s+Beat:\s*(.+)$/i);
    if (beatMatch) {
      const beatText = beatMatch[1].trim();
      currentBeat = parseBeatHeaderText(beatText);
      currentBeat.originalOrder = order++;
      sections.push({
        type: "beat",
        beat: currentBeat,
        originalOrder: currentBeat.originalOrder
      });
      continue;
    }
    if (trimmedLine.startsWith("#")) {
      continue;
    }
    if (trimmedLine.match(/^[+-]\s+/)) {
      continue;
    }
    const proseMatch = trimmedLine.match(/^\s*\[\[([^\|]+)\|([^\]]+)\]\]\s*$/);
    if (proseMatch) {
      const linkName = proseMatch[1].trim();
      const content = proseMatch[2].trim();
      const paragraph = {
        content,
        linkName,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
      continue;
    }
    if (trimmedLine.length > 0) {
      const paragraph = {
        content: trimmedLine,
        linkName: null,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
    }
  }
  return { sections };
}
function parseBeatProse(beatContent) {
  const sections = [];
  const frontmatterMatch = beatContent.match(/^---\n([\s\S]*?)\n---/);
  const contentStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
  const bodyContent = beatContent.substring(contentStart).trim();
  const beatHeaderMatch = bodyContent.match(/^(##\s+Beat:\s*.+)$/m);
  let proseStartIndex = -1;
  if (beatHeaderMatch) {
    proseStartIndex = bodyContent.indexOf(beatHeaderMatch[0]);
  }
  if (proseStartIndex === -1) {
    return { sections: [] };
  }
  const proseContent = bodyContent.substring(proseStartIndex);
  const lines = proseContent.split(/\n/);
  let order = 0;
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      continue;
    }
    if (trimmedLine.startsWith(">")) {
      continue;
    }
    const beatMatch = trimmedLine.match(/^##\s+Beat:\s*(.+)$/i);
    if (beatMatch) {
      continue;
    }
    if (trimmedLine.startsWith("#")) {
      continue;
    }
    if (trimmedLine.match(/^[+-]\s+/)) {
      continue;
    }
    const proseMatch = trimmedLine.match(/^\s*\[\[([^\|]+)\|([^\]]+)\]\]\s*$/);
    if (proseMatch) {
      const linkName = proseMatch[1].trim();
      const content = proseMatch[2].trim();
      const paragraph = {
        content,
        linkName,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
      continue;
    }
    if (trimmedLine.length > 0) {
      const paragraph = {
        content: trimmedLine,
        linkName: null,
        originalOrder: order++
      };
      sections.push({
        type: "prose",
        prose: paragraph,
        originalOrder: paragraph.originalOrder
      });
    }
  }
  return { sections };
}

// src/views/modals/ConflictModal.ts
var import_obsidian18 = require("obsidian");
var ConflictModal = class extends import_obsidian18.Modal {
  constructor(app, localContentBlock, remoteContentBlock, onResolve) {
    super(app);
    this.resolution = null;
    this.localContentBlock = localContentBlock;
    this.remoteContentBlock = remoteContentBlock;
    this.onResolve = onResolve;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", {
      text: "Content Block Conflict"
    });
    contentEl.createEl("p", {
      text: "This content block has been modified both locally and remotely. Choose how to resolve the conflict:"
    });
    const diffContainer = contentEl.createDiv("conflict-diff-container");
    const localDiv = diffContainer.createDiv("conflict-local");
    localDiv.createEl("h3", { text: "Local Version" });
    const localContent = localDiv.createEl("pre", {
      text: this.localContentBlock.content,
      cls: "conflict-content"
    });
    localContent.style.whiteSpace = "pre-wrap";
    localContent.style.maxHeight = "200px";
    localContent.style.overflow = "auto";
    localContent.style.border = "1px solid var(--background-modifier-border)";
    localContent.style.padding = "10px";
    localContent.style.borderRadius = "4px";
    const remoteDiv = diffContainer.createDiv("conflict-remote");
    remoteDiv.createEl("h3", { text: "Remote Version" });
    const remoteContent = remoteDiv.createEl("pre", {
      text: this.remoteContentBlock.content,
      cls: "conflict-content"
    });
    remoteContent.style.whiteSpace = "pre-wrap";
    remoteContent.style.maxHeight = "200px";
    remoteContent.style.overflow = "auto";
    remoteContent.style.border = "1px solid var(--background-modifier-border)";
    remoteContent.style.padding = "10px";
    remoteContent.style.borderRadius = "4px";
    const manualDiv = contentEl.createDiv("conflict-manual");
    manualDiv.createEl("h3", { text: "Manual Merge (Optional)" });
    const manualTextarea = manualDiv.createEl("textarea", {
      text: this.localContentBlock.content,
      cls: "conflict-manual-input"
    });
    manualTextarea.style.width = "100%";
    manualTextarea.style.minHeight = "150px";
    manualTextarea.style.padding = "10px";
    manualTextarea.style.border = "1px solid var(--background-modifier-border)";
    manualTextarea.style.borderRadius = "4px";
    manualTextarea.style.fontFamily = "var(--font-monospace)";
    const buttonContainer = contentEl.createDiv("conflict-buttons");
    buttonContainer.style.marginTop = "20px";
    buttonContainer.style.display = "flex";
    buttonContainer.style.gap = "10px";
    const useLocalBtn = buttonContainer.createEl("button", {
      text: "Use Local",
      cls: "mod-cta"
    });
    useLocalBtn.onclick = async () => {
      this.resolution = { resolution: "local" };
      await this.onResolve(this.resolution);
      this.close();
    };
    const useRemoteBtn = buttonContainer.createEl("button", {
      text: "Use Remote"
    });
    useRemoteBtn.onclick = async () => {
      this.resolution = { resolution: "remote" };
      await this.onResolve(this.resolution);
      this.close();
    };
    const useManualBtn = buttonContainer.createEl("button", {
      text: "Use Manual Merge",
      cls: "mod-primary"
    });
    useManualBtn.onclick = async () => {
      this.resolution = {
        resolution: "manual",
        mergedContent: manualTextarea.value
      };
      await this.onResolve(this.resolution);
      this.close();
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/sync/syncService.ts
var SyncService = class {
  constructor(apiClient, fileManager, settings, app) {
    this.apiClient = apiClient;
    this.fileManager = fileManager;
    this.settings = settings;
    this.app = app;
    if (this.settings.autoSyncOnApiUpdates) {
      this.unsubscribeFromNotifier = apiUpdateNotifier.subscribe(async (payload) => {
        try {
          await this.applyEntityData(payload);
        } catch (err) {
          console.error("Failed to auto-sync entity data", err);
        }
      });
    }
  }
  dispose() {
    if (this.unsubscribeFromNotifier) {
      this.unsubscribeFromNotifier();
      this.unsubscribeFromNotifier = void 0;
    }
  }
  // Pull story from service to Obsidian (Service  Obsidian)
  async pullStory(storyId, target) {
    try {
      if (target) {
        await this.pullSingleEntity(storyId, target);
        return;
      }
      const storyData = await this.apiClient.getStoryWithHierarchy(storyId);
      const folderPath = this.fileManager.getStoryFolderPath(
        storyData.story.title
      );
      const existingMetadata = await this.fileManager.readStoryMetadata(folderPath).catch(() => null);
      const allScenes = await this.apiClient.getScenesByStory(storyId);
      const orphanScenes = [];
      for (const scene of allScenes) {
        if (!scene.chapter_id) {
          const beats = await this.apiClient.getBeats(scene.id);
          orphanScenes.push({ scene, beats });
        }
      }
      orphanScenes.sort((a, b) => a.scene.order_num - b.scene.order_num);
      const allBeats = await this.apiClient.getBeatsByStory(storyId);
      const orphanBeats = [];
      const sceneIdSet = new Set(allScenes.map((s) => s.id));
      for (const beat of allBeats) {
        if (!beat.scene_id || !sceneIdSet.has(beat.scene_id)) {
          orphanBeats.push(beat);
        }
      }
      orphanBeats.sort((a, b) => a.order_num - b.order_num);
      const chapterContentData = /* @__PURE__ */ new Map();
      for (const chapterWithContent of storyData.chapters) {
        const contentBlocks = await this.apiClient.getContentBlocks(chapterWithContent.chapter.id);
        const contentBlockRefs = [];
        for (const contentBlock of contentBlocks) {
          const refs = await this.apiClient.getContentAnchors(contentBlock.id);
          contentBlockRefs.push(...refs);
        }
        chapterContentData.set(chapterWithContent.chapter.id, { contentBlocks, contentBlockRefs });
      }
      await this.fileManager.writeStoryMetadata(
        storyData.story,
        folderPath,
        storyData.chapters,
        orphanScenes,
        orphanBeats,
        chapterContentData
      );
      const contentsFolderPath = `${folderPath}/03-contents`;
      await this.fileManager.ensureFolderExists(contentsFolderPath);
      for (const typeFolder of ["00-texts", "01-images", "02-videos", "03-audios", "04-embeds", "05-links"]) {
        await this.fileManager.ensureFolderExists(`${contentsFolderPath}/${typeFolder}`);
      }
      const chaptersFolderPath = `${folderPath}/00-chapters`;
      await this.fileManager.ensureFolderExists(chaptersFolderPath);
      for (const chapterWithContent of storyData.chapters) {
        const contentData = chapterContentData.get(chapterWithContent.chapter.id);
        const contentBlocks = (contentData == null ? void 0 : contentData.contentBlocks) || [];
        const contentBlockRefs = (contentData == null ? void 0 : contentData.contentBlockRefs) || [];
        for (const contentBlock of contentBlocks) {
          const contentBlockFileName = this.fileManager.generateContentBlockFileName(contentBlock);
          const typeFolderPath = this.fileManager.getContentBlockFolderPath(folderPath, contentBlock.type || "text");
          await this.fileManager.ensureFolderExists(typeFolderPath);
          const contentBlockFilePath = `${typeFolderPath}/${contentBlockFileName}`;
          await this.fileManager.writeContentBlockFile(
            contentBlock,
            contentBlockFilePath,
            storyData.story.title
          );
        }
        const chapterFileName = `Chapter-${chapterWithContent.chapter.number}.md`;
        const chapterFilePath = `${chaptersFolderPath}/${chapterFileName}`;
        await this.fileManager.writeChapterFile(
          chapterWithContent,
          chapterFilePath,
          storyData.story.title,
          contentBlocks,
          contentBlockRefs,
          orphanScenes
          // Include orphan scenes for easy association
        );
        const scenesFolderPath2 = `${folderPath}/01-scenes`;
        await this.fileManager.ensureFolderExists(scenesFolderPath2);
        for (const { scene, beats } of chapterWithContent.scenes) {
          const sceneContentBlocks = await this.apiClient.getContentBlocksByScene(scene.id);
          const sceneFileName = this.fileManager.generateSceneFileName(scene);
          const sceneFilePath = `${scenesFolderPath2}/${sceneFileName}`;
          await this.fileManager.writeSceneFile(
            { scene, beats },
            sceneFilePath,
            storyData.story.title,
            sceneContentBlocks,
            orphanBeats
            // Include orphan beats for easy association
          );
          const beatsFolderPath2 = `${folderPath}/02-beats`;
          await this.fileManager.ensureFolderExists(beatsFolderPath2);
          for (const beat of beats) {
            const beatContentBlocks = await this.apiClient.getContentBlocksByBeat(beat.id);
            const beatFileName = this.fileManager.generateBeatFileName(beat);
            const beatFilePath = `${beatsFolderPath2}/${beatFileName}`;
            await this.fileManager.writeBeatFile(beat, beatFilePath, storyData.story.title, beatContentBlocks);
          }
        }
      }
      const scenesFolderPath = `${folderPath}/01-scenes`;
      await this.fileManager.ensureFolderExists(scenesFolderPath);
      for (const { scene, beats } of orphanScenes) {
        const sceneContentBlocks = await this.apiClient.getContentBlocksByScene(scene.id);
        const sceneFileName = this.fileManager.generateSceneFileName(scene);
        const sceneFilePath = `${scenesFolderPath}/${sceneFileName}`;
        await this.fileManager.writeSceneFile(
          { scene, beats },
          sceneFilePath,
          storyData.story.title,
          sceneContentBlocks,
          orphanBeats
          // Include orphan beats for easy association
        );
        const beatsFolderPath2 = `${folderPath}/02-beats`;
        await this.fileManager.ensureFolderExists(beatsFolderPath2);
        for (const beat of beats) {
          const beatContentBlocks = await this.apiClient.getContentBlocksByBeat(beat.id);
          const beatFileName = this.fileManager.generateBeatFileName(beat);
          const beatFilePath = `${beatsFolderPath2}/${beatFileName}`;
          await this.fileManager.writeBeatFile(beat, beatFilePath, storyData.story.title, beatContentBlocks);
        }
      }
      const beatsFolderPath = `${folderPath}/02-beats`;
      await this.fileManager.ensureFolderExists(beatsFolderPath);
      for (const beat of orphanBeats) {
        const beatContentBlocks = await this.apiClient.getContentBlocksByBeat(beat.id);
        const beatFileName = this.fileManager.generateBeatFileName(beat);
        const beatFilePath = `${beatsFolderPath}/${beatFileName}`;
        await this.fileManager.writeBeatFile(beat, beatFilePath, storyData.story.title, beatContentBlocks);
      }
      if (existingMetadata && existingMetadata.frontmatter.version !== void 0 && existingMetadata.frontmatter.version !== storyData.story.version_number) {
        await this.fileManager.createVersionSnapshot(
          folderPath,
          existingMetadata.frontmatter.version
        );
      }
      await this.syncVersionHistory(storyData.story.root_story_id, folderPath);
      new import_obsidian19.Notice(`Story "${storyData.story.title}" synced successfully`);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to sync story";
      new import_obsidian19.Notice(`Error syncing story: ${errorMessage}`, 5e3);
      throw err;
    }
  }
  // Sync all previous versions of a story
  async syncVersionHistory(rootStoryId, storyFolderPath) {
    try {
      const allStories = await this.apiClient.listStories();
      const versions = allStories.filter((s) => s.root_story_id === rootStoryId);
      versions.sort((a, b) => a.version_number - b.version_number);
      const versionsPath = `${storyFolderPath}/versions`;
      await this.fileManager.ensureFolderExists(versionsPath);
      for (const versionStory of versions) {
        const currentVersion = versions[versions.length - 1].version_number;
        if (versionStory.version_number === currentVersion) {
          continue;
        }
        const versionFolderPath = `${versionsPath}/v${versionStory.version_number}`;
        const existingVersionFolder = this.fileManager.getVault().getAbstractFileByPath(
          versionFolderPath
        );
        if (existingVersionFolder) {
          console.log(`Version v${versionStory.version_number} already exists, skipping`);
          continue;
        }
        const versionData = await this.apiClient.getStoryWithHierarchy(
          versionStory.id
        );
        await this.fileManager.ensureFolderExists(versionFolderPath);
        await this.fileManager.writeStoryMetadata(
          versionData.story,
          versionFolderPath
        );
        const versionContentsFolderPath = `${versionFolderPath}/03-contents`;
        await this.fileManager.ensureFolderExists(versionContentsFolderPath);
        for (const typeFolder of ["00-texts", "01-images", "02-videos", "03-audios", "04-embeds", "05-links"]) {
          await this.fileManager.ensureFolderExists(`${versionContentsFolderPath}/${typeFolder}`);
        }
        const versionChaptersPath = `${versionFolderPath}/00-chapters`;
        await this.fileManager.ensureFolderExists(versionChaptersPath);
        for (const chapterWithContent of versionData.chapters) {
          const contentBlocks = await this.apiClient.getContentBlocks(chapterWithContent.chapter.id);
          const contentBlockRefs = [];
          for (const contentBlock of contentBlocks) {
            const refs = await this.apiClient.getContentAnchors(contentBlock.id);
            contentBlockRefs.push(...refs);
          }
          for (const contentBlock of contentBlocks) {
            const contentBlockFileName = this.fileManager.generateContentBlockFileName(contentBlock);
            const typeFolderPath = this.fileManager.getContentBlockFolderPath(versionFolderPath, contentBlock.type || "text");
            await this.fileManager.ensureFolderExists(typeFolderPath);
            const contentBlockFilePath = `${typeFolderPath}/${contentBlockFileName}`;
            await this.fileManager.writeContentBlockFile(
              contentBlock,
              contentBlockFilePath,
              versionData.story.title
            );
          }
          const chapterFileName = `Chapter-${chapterWithContent.chapter.number}.md`;
          const chapterFilePath = `${versionChaptersPath}/${chapterFileName}`;
          await this.fileManager.writeChapterFile(
            chapterWithContent,
            chapterFilePath,
            versionData.story.title,
            contentBlocks,
            contentBlockRefs
          );
          const versionScenesPath = `${versionFolderPath}/01-scenes`;
          await this.fileManager.ensureFolderExists(versionScenesPath);
          for (const { scene, beats } of chapterWithContent.scenes) {
            const sceneContentBlocks = await this.apiClient.getContentBlocksByScene(scene.id);
            const sceneFileName = this.fileManager.generateSceneFileName(scene);
            const sceneFilePath = `${versionScenesPath}/${sceneFileName}`;
            await this.fileManager.writeSceneFile(
              { scene, beats },
              sceneFilePath,
              versionData.story.title,
              sceneContentBlocks
            );
            const versionBeatsPath = `${versionFolderPath}/02-beats`;
            await this.fileManager.ensureFolderExists(versionBeatsPath);
            for (const beat of beats) {
              const beatContentBlocks = await this.apiClient.getContentBlocksByBeat(beat.id);
              const beatFileName = this.fileManager.generateBeatFileName(beat);
              const beatFilePath = `${versionBeatsPath}/${beatFileName}`;
              await this.fileManager.writeBeatFile(beat, beatFilePath, versionData.story.title, beatContentBlocks);
            }
          }
        }
        console.log(`Synced version v${versionStory.version_number}`);
      }
    } catch (err) {
      console.error("Error syncing version history:", err);
    }
  }
  // Pull all stories
  async pullAllStories() {
    if (this.settings.mode === "remote" && !this.settings.tenantId) {
      throw new Error("Tenant ID is required");
    }
    try {
      await this.apiClient.getWorlds();
    } catch (err) {
      console.error("Failed to load worlds:", err);
    }
    const stories = await this.apiClient.listStories();
    for (const story of stories) {
      try {
        await this.pullStory(story.id);
      } catch (err) {
        console.error(`Failed to sync story ${story.id}:`, err);
      }
    }
    new import_obsidian19.Notice(`Synced ${stories.length} stories`);
  }
  // Apply entity data received from API without fetching
  async applyEntityData(payload) {
    switch (payload.type) {
      case "chapter": {
        await this.writeChapterBundle({
          story: payload.story,
          chapter: payload.chapter,
          scenes: payload.scenes,
          contentBlocks: payload.contentBlocks,
          contentBlockRefs: payload.contentBlockRefs
        });
        new import_obsidian19.Notice(`Chapter "${payload.chapter.title}" synced successfully`);
        break;
      }
      case "scene": {
        const beatContentBlockMap = /* @__PURE__ */ new Map();
        if (payload.beatContentBlocks) {
          for (const [beatId, blocks] of Object.entries(payload.beatContentBlocks)) {
            beatContentBlockMap.set(beatId, blocks);
          }
        }
        const folderPath = this.fileManager.getStoryFolderPath(payload.story.title);
        await this.ensureStoryFolders(folderPath);
        await this.writeSceneBundle({
          storyTitle: payload.story.title,
          folderPath,
          scene: payload.scene,
          beats: payload.beats,
          sceneContentBlocks: payload.sceneContentBlocks,
          beatContentBlockMap,
          skipRemoteContentFetch: true
        });
        if (payload.sceneContentBlocks) {
          for (const contentBlock of payload.sceneContentBlocks) {
            await this.writeContentBlockToFolder(folderPath, payload.story.title, contentBlock);
          }
        }
        for (const blocks of beatContentBlockMap.values()) {
          for (const contentBlock of blocks) {
            await this.writeContentBlockToFolder(folderPath, payload.story.title, contentBlock);
          }
        }
        new import_obsidian19.Notice(`Scene "${payload.scene.goal}" synced successfully`);
        break;
      }
      case "content": {
        const folderPath = this.fileManager.getStoryFolderPath(payload.story.title);
        await this.ensureContentFolders(folderPath);
        await this.writeContentBlockToFolder(
          folderPath,
          payload.story.title,
          payload.contentBlock
        );
        new import_obsidian19.Notice("Content block synced successfully");
        break;
      }
    }
  }
  // Push story from Obsidian to service (Obsidian  Service)
  async pushStory(folderPath, target) {
    try {
      const { frontmatter: storyFrontmatter } = await this.fileManager.readStoryMetadata(folderPath);
      if (!storyFrontmatter.id) {
        throw new Error("Story metadata missing ID");
      }
      const storyId = storyFrontmatter.id;
      if (target) {
        await this.pushSingleEntity(folderPath, target, storyId, storyFrontmatter.title);
        return;
      }
      const storyFilePath = `${folderPath}/story.md`;
      const storyFile = this.fileManager.getVault().getAbstractFileByPath(storyFilePath);
      if (storyFile instanceof import_obsidian19.TFile) {
        const storyContent = await this.fileManager.getVault().read(storyFile);
        const chapterList = parseChapterList(storyContent);
        if (chapterList.items.length > 0) {
          await this.processChapterList(chapterList, storyId);
        }
        const orphanScenesList = parseOrphanScenesList(storyContent);
        if (orphanScenesList.items.length > 0) {
          await this.processOrphanScenesList(orphanScenesList, storyId);
        }
        const orphanBeatsList = parseOrphanBeatsList(storyContent);
        if (orphanBeatsList.items.length > 0) {
          await this.processOrphanBeatsList(orphanBeatsList, storyId);
        }
        const storyProse = parseStoryProse(storyContent);
        if (storyProse.sections.length > 0) {
          await this.pushStoryContentBlocks(storyFilePath, folderPath, storyId);
        }
      }
      await this.apiClient.updateStory(
        storyId,
        storyFrontmatter.title,
        storyFrontmatter.status
      );
      const chapterFiles = await this.fileManager.listChapterFiles(folderPath);
      for (const chapterFilePath of chapterFiles) {
        console.log(`Would update chapter: ${chapterFilePath}`);
      }
      for (const chapterFilePath of chapterFiles) {
        await this.pushChapterContentBlocks(chapterFilePath, folderPath);
      }
      const sceneFiles = await this.fileManager.listStorySceneFiles(folderPath);
      for (const sceneFilePath of sceneFiles) {
        await this.pushSceneBeats(sceneFilePath, storyId);
        await this.pushSceneContentBlocks(sceneFilePath, folderPath);
      }
      const beatFiles = await this.fileManager.listStoryBeatFiles(folderPath);
      for (const beatFilePath of beatFiles) {
        await this.pushBeatContentBlocks(beatFilePath, folderPath);
      }
      new import_obsidian19.Notice(`Story "${storyFrontmatter.title}" pushed successfully`);
      try {
        new import_obsidian19.Notice(`Syncing story "${storyFrontmatter.title}" from service...`);
        await this.pullStory(storyId);
        new import_obsidian19.Notice(`Story "${storyFrontmatter.title}" synced successfully`);
      } catch (pullErr) {
        const pullErrorMessage = pullErr instanceof Error ? pullErr.message : "Failed to sync story after push";
        new import_obsidian19.Notice(`Warning: ${pullErrorMessage}`, 5e3);
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to push story";
      new import_obsidian19.Notice(`Error pushing story: ${errorMessage}`, 5e3);
      throw err;
    }
  }
  // Push prose blocks from a chapter file (hierarchical structure)
  async pushChapterContentBlocks(chapterFilePath, storyFolderPath) {
    const file = this.fileManager.getVault().getAbstractFileByPath(chapterFilePath);
    if (!(file instanceof import_obsidian19.TFile)) {
      throw new Error(`Chapter file not found: ${chapterFilePath}`);
    }
    const chapterContent = await this.fileManager.getVault().read(file);
    const frontmatter = this.fileManager.parseFrontmatter(chapterContent);
    if (!frontmatter.id || !frontmatter.story_id) {
      throw new Error("Chapter metadata missing ID or story_id");
    }
    const chapterId = frontmatter.id;
    const storyId = frontmatter.story_id;
    const contentsFolderPath = `${storyFolderPath}/03-contents`;
    const sceneBeatList = parseSceneBeatList(chapterContent);
    await this.processSceneBeatList(sceneBeatList, chapterId, storyId);
    const remoteContentBlocks = await this.apiClient.getContentBlocks(chapterId);
    const remoteContentBlocksMap = /* @__PURE__ */ new Map();
    for (const pb of remoteContentBlocks) {
      remoteContentBlocksMap.set(pb.id, pb);
    }
    const existingScenes = await this.apiClient.getScenes(chapterId);
    const sceneMap = /* @__PURE__ */ new Map();
    const sceneIdMap = /* @__PURE__ */ new Map();
    for (const scene of existingScenes) {
      const fileName = this.fileManager.generateSceneFileName(scene);
      const linkName = fileName.replace(/\.md$/, "");
      sceneMap.set(linkName, scene);
      sceneIdMap.set(scene.id, scene);
    }
    const beatMap = /* @__PURE__ */ new Map();
    const beatIdMap = /* @__PURE__ */ new Map();
    for (const scene of existingScenes) {
      const beats = await this.apiClient.getBeats(scene.id);
      for (const beat of beats) {
        const fileName = this.fileManager.generateBeatFileName(beat);
        const linkName = fileName.replace(/\.md$/, "");
        beatMap.set(linkName, beat);
        beatIdMap.set(beat.id, beat);
      }
    }
    const hierarchical = parseHierarchicalProse(chapterContent);
    const updatedSections = [];
    let currentScene = null;
    let currentBeat = null;
    let proseOrderNum = 1;
    let sceneOrderNum = existingScenes.length > 0 ? Math.max(...existingScenes.map((s) => s.order_num)) + 1 : 1;
    for (const section of hierarchical.sections) {
      if (section.type === "scene" && section.scene) {
        const { scene: parsedScene } = section;
        if (parsedScene.linkName) {
          currentScene = sceneMap.get(parsedScene.linkName) || null;
          if (!currentScene) {
            currentScene = sceneIdMap.get(parsedScene.linkName) || null;
          }
          if (currentScene) {
            if (parsedScene.goal !== currentScene.goal || parsedScene.timeRef !== currentScene.time_ref) {
              currentScene = await this.apiClient.updateScene(currentScene.id, {
                goal: parsedScene.goal,
                time_ref: parsedScene.timeRef
              });
            }
          }
        } else {
          currentScene = await this.apiClient.createScene({
            story_id: storyId,
            chapter_id: chapterId,
            order_num: sceneOrderNum++,
            goal: parsedScene.goal,
            time_ref: parsedScene.timeRef
          });
          const sceneFileName = this.fileManager.generateSceneFileName(currentScene);
          const sceneLinkName = sceneFileName.replace(/\.md$/, "");
          sceneMap.set(sceneLinkName, currentScene);
          sceneIdMap.set(currentScene.id, currentScene);
        }
        if (currentScene) {
          const sceneFileName = this.fileManager.generateSceneFileName(currentScene);
          const sceneLinkName = sceneFileName.replace(/\.md$/, "");
          const sceneDisplayText = currentScene.time_ref ? `${currentScene.goal} - ${currentScene.time_ref}` : currentScene.goal;
          updatedSections.push(`## Scene: [[${sceneLinkName}|${sceneDisplayText}]]`);
        }
        currentBeat = null;
      } else if (section.type === "beat" && section.beat) {
        const { beat: parsedBeat } = section;
        if (!currentScene) {
          throw new Error("Beat found without a parent scene");
        }
        if (parsedBeat.linkName) {
          currentBeat = beatMap.get(parsedBeat.linkName) || null;
          if (!currentBeat) {
            currentBeat = beatIdMap.get(parsedBeat.linkName) || null;
          }
          if (currentBeat) {
            if (parsedBeat.intent !== currentBeat.intent || parsedBeat.outcome !== currentBeat.outcome) {
              currentBeat = await this.apiClient.updateBeat(currentBeat.id, {
                intent: parsedBeat.intent,
                outcome: parsedBeat.outcome
              });
            }
          }
        } else {
          const existingBeats = await this.apiClient.getBeats(currentScene.id);
          const beatOrderNum = existingBeats.length > 0 ? Math.max(...existingBeats.map((b) => b.order_num)) + 1 : 1;
          currentBeat = await this.apiClient.createBeat({
            scene_id: currentScene.id,
            order_num: beatOrderNum,
            type: "setup",
            // Default type
            intent: parsedBeat.intent,
            outcome: parsedBeat.outcome
          });
          const beatFileName = this.fileManager.generateBeatFileName(currentBeat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          beatMap.set(beatLinkName, currentBeat);
          beatIdMap.set(currentBeat.id, currentBeat);
        }
        if (currentBeat) {
          const beatFileName = this.fileManager.generateBeatFileName(currentBeat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          const beatDisplayText = currentBeat.outcome ? `${currentBeat.intent} -> ${currentBeat.outcome}` : currentBeat.intent;
          updatedSections.push(`### Beat: [[${beatLinkName}|${beatDisplayText}]]`);
        }
      } else if (section.type === "prose" && section.prose) {
        const { prose: paragraph } = section;
        let localContentBlock = null;
        let remoteContentBlock = null;
        if (paragraph.linkName) {
          const contentBlockFilePath = await this.findContentBlockFileByLinkName(contentsFolderPath, paragraph.linkName);
          if (contentBlockFilePath) {
            localContentBlock = await this.fileManager.readContentBlockFromFile(contentBlockFilePath);
          }
          if (!localContentBlock) {
            localContentBlock = await this.findContentBlockByContent(contentsFolderPath, paragraph.content);
          }
          if (localContentBlock) {
            remoteContentBlock = remoteContentBlocksMap.get(localContentBlock.id) || null;
          } else {
            const normalizedContent = paragraph.content.trim();
            for (const [id2, remotePB] of remoteContentBlocksMap.entries()) {
              if (remotePB.content.trim() === normalizedContent) {
                remoteContentBlock = remotePB;
                break;
              }
            }
          }
        } else {
          localContentBlock = await this.findContentBlockByContent(contentsFolderPath, paragraph.content);
          const normalizedContent = paragraph.content.trim();
          for (const [id2, remotePB] of remoteContentBlocksMap.entries()) {
            if (remotePB.content.trim() === normalizedContent) {
              remoteContentBlock = remotePB;
              if (!localContentBlock) {
                localContentBlock = await this.findContentBlockById(contentsFolderPath, remotePB.id);
              }
              break;
            }
          }
        }
        const status = compareContentBlocks(paragraph, localContentBlock, remoteContentBlock);
        let finalContentBlock;
        switch (status) {
          case "new": {
            finalContentBlock = await this.apiClient.createContentBlock(chapterId, {
              order_num: proseOrderNum++,
              kind: "final",
              content: paragraph.content
            });
            const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            if (currentScene) {
              await this.apiClient.createContentAnchor(finalContentBlock.id, "scene", currentScene.id);
            }
            if (currentBeat) {
              await this.apiClient.createContentAnchor(finalContentBlock.id, "beat", currentBeat.id);
            }
            const linkName = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
            break;
          }
          case "unchanged": {
            if (!localContentBlock && remoteContentBlock) {
              finalContentBlock = remoteContentBlock;
              const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
              await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            } else if (localContentBlock) {
              if (localContentBlock.order_num !== proseOrderNum) {
                finalContentBlock = await this.apiClient.updateContentBlock(localContentBlock.id, {
                  order_num: proseOrderNum++
                });
                const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
                await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
              } else {
                finalContentBlock = localContentBlock;
                proseOrderNum++;
              }
            } else {
              finalContentBlock = remoteContentBlock;
              proseOrderNum++;
            }
            if (finalContentBlock) {
              const existingRefs = await this.apiClient.getContentAnchors(finalContentBlock.id);
              const hasSceneRef = existingRefs.some((r) => r.entity_type === "scene" && r.entity_id === (currentScene == null ? void 0 : currentScene.id));
              const hasBeatRef = existingRefs.some((r) => r.entity_type === "beat" && r.entity_id === (currentBeat == null ? void 0 : currentBeat.id));
              if (currentScene && !hasSceneRef) {
                await this.apiClient.createContentAnchor(finalContentBlock.id, "scene", currentScene.id);
              }
              if (currentBeat && !hasBeatRef) {
                await this.apiClient.createContentAnchor(finalContentBlock.id, "beat", currentBeat.id);
              }
            }
            if (paragraph.linkName) {
              updatedSections.push(`[[${paragraph.linkName}|${paragraph.content}]]`);
            } else {
              const linkName = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
              updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
            }
            break;
          }
          case "local_modified": {
            finalContentBlock = await this.apiClient.updateContentBlock(localContentBlock.id, {
              content: paragraph.content,
              order_num: proseOrderNum++
            });
            const filePathLocalMod = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePathLocalMod, void 0);
            if (finalContentBlock) {
              const existingRefs = await this.apiClient.getContentAnchors(finalContentBlock.id);
              const hasSceneRef = existingRefs.some((r) => r.entity_type === "scene" && r.entity_id === (currentScene == null ? void 0 : currentScene.id));
              const hasBeatRef = existingRefs.some((r) => r.entity_type === "beat" && r.entity_id === (currentBeat == null ? void 0 : currentBeat.id));
              if (currentScene && !hasSceneRef) {
                await this.apiClient.createContentAnchor(finalContentBlock.id, "scene", currentScene.id);
              }
              if (currentBeat && !hasBeatRef) {
                await this.apiClient.createContentAnchor(finalContentBlock.id, "beat", currentBeat.id);
              }
            }
            const linkNameLocalMod = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
            updatedSections.push(`[[${linkNameLocalMod}|${paragraph.content}]]`);
            break;
          }
          case "remote_modified": {
            finalContentBlock = remoteContentBlock;
            const filePathRemoteMod = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePathRemoteMod, void 0);
            if (finalContentBlock) {
              const existingRefs = await this.apiClient.getContentAnchors(finalContentBlock.id);
              const hasSceneRef = existingRefs.some((r) => r.entity_type === "scene" && r.entity_id === (currentScene == null ? void 0 : currentScene.id));
              const hasBeatRef = existingRefs.some((r) => r.entity_type === "beat" && r.entity_id === (currentBeat == null ? void 0 : currentBeat.id));
              if (currentScene && !hasSceneRef) {
                await this.apiClient.createContentAnchor(finalContentBlock.id, "scene", currentScene.id);
              }
              if (currentBeat && !hasBeatRef) {
                await this.apiClient.createContentAnchor(finalContentBlock.id, "beat", currentBeat.id);
              }
            }
            const linkNameRemoteMod = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
            updatedSections.push(`[[${linkNameRemoteMod}|${finalContentBlock.content}]]`);
            new import_obsidian19.Notice(`Prose block updated from remote: ${linkNameRemoteMod}`, 3e3);
            proseOrderNum++;
            break;
          }
          case "conflict": {
            const resolution = await this.resolveConflict(localContentBlock, remoteContentBlock);
            let resolvedContent;
            if (resolution.resolution === "local") {
              resolvedContent = paragraph.content;
            } else if (resolution.resolution === "remote") {
              resolvedContent = remoteContentBlock.content;
            } else {
              resolvedContent = resolution.mergedContent || paragraph.content;
            }
            finalContentBlock = await this.apiClient.updateContentBlock(localContentBlock.id, {
              content: resolvedContent,
              order_num: proseOrderNum++
            });
            const filePathConflict = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePathConflict, void 0);
            if (finalContentBlock) {
              const existingRefs = await this.apiClient.getContentAnchors(finalContentBlock.id);
              const hasSceneRef = existingRefs.some((r) => r.entity_type === "scene" && r.entity_id === (currentScene == null ? void 0 : currentScene.id));
              const hasBeatRef = existingRefs.some((r) => r.entity_type === "beat" && r.entity_id === (currentBeat == null ? void 0 : currentBeat.id));
              if (currentScene && !hasSceneRef) {
                await this.apiClient.createContentAnchor(finalContentBlock.id, "scene", currentScene.id);
              }
              if (currentBeat && !hasBeatRef) {
                await this.apiClient.createContentAnchor(finalContentBlock.id, "beat", currentBeat.id);
              }
            }
            const linkNameConflict = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
            updatedSections.push(`[[${linkNameConflict}|${resolvedContent}]]`);
            break;
          }
        }
      }
    }
    await this.updateChapterFile(chapterContent, updatedSections, file, frontmatter, existingScenes, beatMap, remoteContentBlocks, chapterId);
  }
  // Update chapter file with both scene/beat list and chapter content
  async updateChapterFile(originalContent, updatedSections, file, frontmatter, scenes, beatMap, contentBlocks, chapterId) {
    const allContentAnchors = [];
    for (const contentBlock of contentBlocks) {
      const refs = await this.apiClient.getContentAnchors(contentBlock.id);
      allContentAnchors.push(...refs);
    }
    const proseRefsByScene = /* @__PURE__ */ new Map();
    const proseRefsByBeat = /* @__PURE__ */ new Map();
    for (const ref of allContentAnchors) {
      if (ref.entity_type === "scene") {
        if (!proseRefsByScene.has(ref.entity_id)) {
          proseRefsByScene.set(ref.entity_id, []);
        }
        proseRefsByScene.get(ref.entity_id).push(ref);
      } else if (ref.entity_type === "beat") {
        if (!proseRefsByBeat.has(ref.entity_id)) {
          proseRefsByBeat.set(ref.entity_id, []);
        }
        proseRefsByBeat.get(ref.entity_id).push(ref);
      }
    }
    const sceneBeatListItems = [];
    for (const scene of scenes.sort((a, b) => a.order_num - b.order_num)) {
      const sceneFileName = this.fileManager.generateSceneFileName(scene);
      const sceneLinkName = sceneFileName.replace(/\.md$/, "");
      const sceneDisplayText = scene.time_ref ? `${scene.goal} - ${scene.time_ref}` : scene.goal;
      const sceneProseRefs = proseRefsByScene.get(scene.id) || [];
      const sceneContentBlockIds = new Set(sceneProseRefs.map((r) => r.content_block_id));
      const hasSceneProse = Array.from(sceneContentBlockIds).some((contentBlockId) => {
        const blockRefs = allContentAnchors.filter((r) => r.content_block_id === contentBlockId);
        return !blockRefs.some((r) => r.entity_type === "beat");
      });
      const sceneMarker = hasSceneProse ? "+" : "-";
      sceneBeatListItems.push(`${sceneMarker} [[${sceneLinkName}|Scene ${scene.order_num}: ${sceneDisplayText}]]`);
      const sceneBeats = [];
      for (const [linkName, beat] of beatMap.entries()) {
        if (beat.scene_id === scene.id) {
          sceneBeats.push(beat);
        }
      }
      for (const beat of sceneBeats.sort((a, b) => a.order_num - b.order_num)) {
        const beatFileName = this.fileManager.generateBeatFileName(beat);
        const beatLinkName = beatFileName.replace(/\.md$/, "");
        const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
        const beatProseRefs = proseRefsByBeat.get(beat.id) || [];
        const hasBeatProse = beatProseRefs.length > 0;
        const beatMarker = hasBeatProse ? "+" : "-";
        sceneBeatListItems.push(`	${beatMarker} [[${beatLinkName}|Beat ${beat.order_num}: ${beatDisplayText}]]`);
      }
    }
    const frontmatterMatch = originalContent.match(/^---\n([\s\S]*?)\n---/);
    const frontmatterText = frontmatterMatch ? frontmatterMatch[0] : "";
    const bodyStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
    const bodyContent = originalContent.substring(bodyStart).trim();
    const chapterNumber = frontmatter.number || "1";
    const chapterTitle = frontmatter.title || "Untitled";
    const listSectionMatch = bodyContent.match(/([\s\S]*?##\s+Scenes\s+&\s+Beats\s*\n+)([\s\S]*?)(?=\n##|$)/);
    const updatedListSection = `## Scenes & Beats

${sceneBeatListItems.join("\n")}

`;
    let updatedBody;
    if (listSectionMatch) {
      const beforeList = listSectionMatch[1];
      const afterList = bodyContent.substring(listSectionMatch.index + listSectionMatch[0].length);
      updatedBody = `${beforeList}${updatedListSection}${afterList}`;
    } else {
      const titleMatch = bodyContent.match(/(#\s+[^\n]+\n+)([\s\S]*)/);
      if (titleMatch) {
        updatedBody = `${titleMatch[1]}${updatedListSection}${titleMatch[2]}`;
      } else {
        updatedBody = `${updatedListSection}${bodyContent}`;
      }
    }
    const chapterHeaderPattern = `##\\s+Chapter\\s+${chapterNumber}:\\s+[^\\n]+`;
    const chapterSectionMatch = updatedBody.match(new RegExp(`([\\s\\S]*?${chapterHeaderPattern}\\s*\\n+)([\\s\\S]*?)(?=\\n##\\s+Chapter\\s+\\d+:|$)`, "i"));
    if (!chapterSectionMatch) {
      const newChapterSection = `

## Chapter ${chapterNumber}: ${chapterTitle}

${updatedSections.join("\n\n")}

`;
      updatedBody = `${updatedBody}${newChapterSection}`;
    } else {
      const beforeChapter = chapterSectionMatch[1];
      const afterChapter = updatedBody.substring(chapterSectionMatch.index + chapterSectionMatch[0].length);
      const newChapterContent = updatedSections.join("\n\n");
      updatedBody = `${beforeChapter}${newChapterContent}

${afterChapter}`;
    }
    const updatedContent = `${frontmatterText}
${updatedBody}`;
    await this.fileManager.getVault().modify(file, updatedContent);
  }
  // Process the "## Chapters, Scenes & Beats" list and update order
  async processChapterList(list, storyId) {
    const existingChapters = await this.apiClient.getChapters(storyId);
    const chapterMap = /* @__PURE__ */ new Map();
    const chapterIdMap = /* @__PURE__ */ new Map();
    for (const chapter of existingChapters) {
      const fileName = `Chapter-${chapter.number}.md`;
      const linkName = fileName.replace(/\.md$/, "");
      chapterMap.set(linkName, chapter);
      chapterIdMap.set(chapter.id, chapter);
    }
    let currentChapter = null;
    let currentScene = null;
    let chapterOrderNum = 1;
    const sceneOrderNums = /* @__PURE__ */ new Map();
    const beatOrderNums = /* @__PURE__ */ new Map();
    for (const item of list.items) {
      if (item.type === "chapter") {
        let title;
        let chapterNumber = null;
        const chapterMatch = item.displayText.match(/Chapter\s+(\d+):\s*(.+)/);
        if (chapterMatch) {
          chapterNumber = parseInt(chapterMatch[1], 10);
          title = chapterMatch[2].trim();
        } else {
          title = item.displayText.trim();
        }
        currentScene = null;
        sceneOrderNums.set("current", 1);
        if (item.linkName) {
          currentChapter = chapterMap.get(item.linkName) || null;
          if (!currentChapter) {
            currentChapter = chapterIdMap.get(item.linkName) || null;
          }
          if (currentChapter) {
            const needsOrderUpdate = currentChapter.number !== chapterOrderNum;
            const needsTitleUpdate = title !== currentChapter.title;
            if (needsOrderUpdate || needsTitleUpdate) {
              currentChapter = await this.apiClient.updateChapter(currentChapter.id, {
                number: chapterOrderNum,
                title: needsTitleUpdate ? title : void 0
              });
              const fileName = `Chapter-${currentChapter.number}.md`;
              const linkName = fileName.replace(/\.md$/, "");
              chapterMap.set(linkName, currentChapter);
              chapterIdMap.set(currentChapter.id, currentChapter);
            }
          }
        } else {
          if (title) {
            currentChapter = await this.apiClient.createChapter(storyId, {
              number: chapterOrderNum,
              title,
              status: "draft"
            });
            const fileName = `Chapter-${currentChapter.number}.md`;
            const linkName = fileName.replace(/\.md$/, "");
            chapterMap.set(linkName, currentChapter);
            chapterIdMap.set(currentChapter.id, currentChapter);
          }
        }
        if (currentChapter) {
          sceneOrderNums.set(currentChapter.id, 1);
        }
        chapterOrderNum++;
      } else if (item.type === "scene" && currentChapter) {
        let goal;
        let timeRef = "";
        const sceneMatch = item.displayText.match(/Scene\s+\d+:\s*(.+)/);
        if (sceneMatch) {
          const sceneText = sceneMatch[1].trim();
          const parts = sceneText.split(/\s*-\s*/);
          goal = parts[0].trim();
          timeRef = parts.length > 1 ? parts.slice(1).join(" - ").trim() : "";
        } else {
          const parts = item.displayText.split(/\s*-\s*/);
          goal = parts[0].trim();
          timeRef = parts.length > 1 ? parts.slice(1).join(" - ").trim() : "";
        }
        const currentSceneOrderNum = sceneOrderNums.get(currentChapter.id) || 1;
        currentScene = null;
        if (item.linkName) {
          const existingScenes = await this.apiClient.getScenes(currentChapter.id);
          const sceneMap = /* @__PURE__ */ new Map();
          const sceneIdMap = /* @__PURE__ */ new Map();
          for (const scene of existingScenes) {
            const fileName = this.fileManager.generateSceneFileName(scene);
            const linkName = fileName.replace(/\.md$/, "");
            sceneMap.set(linkName, scene);
            sceneIdMap.set(scene.id, scene);
          }
          currentScene = sceneMap.get(item.linkName) || null;
          if (!currentScene) {
            currentScene = sceneIdMap.get(item.linkName) || null;
          }
          if (currentScene) {
            const needsOrderUpdate = currentScene.order_num !== currentSceneOrderNum;
            const needsContentUpdate = goal !== currentScene.goal || timeRef !== currentScene.time_ref;
            const needsChapterUpdate = currentScene.chapter_id !== currentChapter.id;
            if (needsOrderUpdate || needsContentUpdate || needsChapterUpdate) {
              currentScene = await this.apiClient.updateScene(currentScene.id, {
                goal,
                time_ref: timeRef,
                order_num: currentSceneOrderNum,
                chapter_id: currentChapter.id
              });
            }
            const existingBeats = await this.apiClient.getBeats(currentScene.id);
            if (existingBeats.length === 0) {
              beatOrderNums.set(currentScene.id, 1);
            } else {
              const maxOrderNum = Math.max(...existingBeats.map((b) => b.order_num));
              beatOrderNums.set(currentScene.id, maxOrderNum + 1);
            }
          }
        } else {
          currentScene = await this.apiClient.createScene({
            story_id: storyId,
            chapter_id: currentChapter.id,
            order_num: currentSceneOrderNum,
            goal,
            time_ref: timeRef
          });
          beatOrderNums.set(currentScene.id, 1);
        }
        sceneOrderNums.set(currentChapter.id, currentSceneOrderNum + 1);
      } else if (item.type === "beat" && currentScene) {
        let intent;
        let outcome = "";
        const beatMatch = item.displayText.match(/Beat\s+\d+:\s*(.+)/);
        if (beatMatch) {
          const beatText = beatMatch[1].trim();
          const parts = beatText.split(/\s*->\s*/);
          intent = parts[0].trim();
          outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
        } else {
          const parts = item.displayText.split(/\s*->\s*/);
          intent = parts[0].trim();
          outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
        }
        const currentBeatOrderNum = beatOrderNums.get(currentScene.id) || 1;
        if (item.linkName) {
          const existingBeats = await this.apiClient.getBeats(currentScene.id);
          const beatMap = /* @__PURE__ */ new Map();
          const beatIdMap = /* @__PURE__ */ new Map();
          for (const beat of existingBeats) {
            const fileName = this.fileManager.generateBeatFileName(beat);
            const linkName = fileName.replace(/\.md$/, "");
            beatMap.set(linkName, beat);
            beatIdMap.set(beat.id, beat);
          }
          let currentBeat = beatMap.get(item.linkName) || null;
          if (!currentBeat) {
            currentBeat = beatIdMap.get(item.linkName) || null;
          }
          if (currentBeat) {
            const needsOrderUpdate = currentBeat.order_num !== currentBeatOrderNum;
            const needsContentUpdate = intent !== currentBeat.intent || outcome !== currentBeat.outcome;
            const needsSceneUpdate = currentBeat.scene_id !== currentScene.id;
            if (needsOrderUpdate || needsContentUpdate || needsSceneUpdate) {
              currentBeat = await this.apiClient.updateBeat(currentBeat.id, {
                intent,
                outcome,
                order_num: currentBeatOrderNum,
                scene_id: currentScene.id
              });
            }
          }
        } else {
          await this.apiClient.createBeat({
            scene_id: currentScene.id,
            order_num: currentBeatOrderNum,
            type: "setup",
            // Default type
            intent,
            outcome
          });
        }
        beatOrderNums.set(currentScene.id, currentBeatOrderNum + 1);
      }
    }
  }
  // Process the "## Beats" list from a scene file and update beat order
  async pushSceneBeats(sceneFilePath, storyId) {
    const file = this.fileManager.getVault().getAbstractFileByPath(sceneFilePath);
    if (!(file instanceof import_obsidian19.TFile)) {
      return;
    }
    const sceneContent = await this.fileManager.getVault().read(file);
    const frontmatter = this.fileManager.parseFrontmatter(sceneContent);
    if (!frontmatter.id) {
      return;
    }
    const sceneId = frontmatter.id;
    const beatList = parseBeatList(sceneContent);
    if (beatList.items.length === 0) {
      return;
    }
    const existingBeats = await this.apiClient.getBeats(sceneId);
    const beatMap = /* @__PURE__ */ new Map();
    const beatIdMap = /* @__PURE__ */ new Map();
    for (const beat of existingBeats) {
      const fileName = this.fileManager.generateBeatFileName(beat);
      const linkName = fileName.replace(/\.md$/, "");
      beatMap.set(linkName, beat);
      beatIdMap.set(beat.id, beat);
    }
    let beatOrderNum = 1;
    for (const item of beatList.items) {
      let intent;
      let outcome = "";
      const beatMatch = item.displayText.match(/Beat\s+\d+:\s*(.+)/);
      if (beatMatch) {
        const beatText = beatMatch[1].trim();
        const parts = beatText.split(/\s*->\s*/);
        intent = parts[0].trim();
        outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
      } else {
        const parts = item.displayText.split(/\s*->\s*/);
        intent = parts[0].trim();
        outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
      }
      if (item.linkName) {
        let currentBeat = beatMap.get(item.linkName) || null;
        if (!currentBeat) {
          currentBeat = beatIdMap.get(item.linkName) || null;
        }
        if (currentBeat) {
          const needsOrderUpdate = currentBeat.order_num !== beatOrderNum;
          const needsContentUpdate = intent !== currentBeat.intent || outcome !== currentBeat.outcome;
          if (needsOrderUpdate || needsContentUpdate) {
            currentBeat = await this.apiClient.updateBeat(currentBeat.id, {
              intent,
              outcome,
              order_num: beatOrderNum
            });
          }
        }
      } else {
        await this.apiClient.createBeat({
          scene_id: sceneId,
          order_num: beatOrderNum,
          type: "setup",
          // Default type
          intent,
          outcome
        });
      }
      beatOrderNum++;
    }
  }
  // Push prose blocks from a story file with hierarchical structure
  // Format: # Story: title, ## Chapter: title, ### Scene: title, #### Beat: title
  async pushStoryContentBlocks(storyFilePath, storyFolderPath, storyId) {
    const file = this.fileManager.getVault().getAbstractFileByPath(storyFilePath);
    if (!(file instanceof import_obsidian19.TFile)) {
      throw new Error(`Story file not found: ${storyFilePath}`);
    }
    const storyContent = await this.fileManager.getVault().read(file);
    const contentsFolderPath = `${storyFolderPath}/03-contents`;
    const storyProse = parseStoryProse(storyContent);
    if (storyProse.sections.length === 0) {
      return;
    }
    const existingChapters = await this.apiClient.getChapters(storyId);
    const chapterByTitle = /* @__PURE__ */ new Map();
    for (const ch of existingChapters) {
      chapterByTitle.set(ch.title.toLowerCase(), ch);
    }
    let currentChapter = null;
    let currentScene = null;
    let currentBeat = null;
    let proseOrderNum = 1;
    const sceneMap = /* @__PURE__ */ new Map();
    const beatMap = /* @__PURE__ */ new Map();
    const remoteContentBlocksCache = /* @__PURE__ */ new Map();
    const getRemoteContentBlocksMap = async (chapterId) => {
      if (!remoteContentBlocksCache.has(chapterId)) {
        const blocks = await this.apiClient.getContentBlocks(chapterId);
        const map2 = /* @__PURE__ */ new Map();
        for (const pb of blocks) {
          map2.set(pb.id, pb);
        }
        remoteContentBlocksCache.set(chapterId, map2);
      }
      return remoteContentBlocksCache.get(chapterId);
    };
    for (const section of storyProse.sections) {
      if (section.type === "scene" && section.scene) {
        const { scene: parsedScene } = section;
        if (!currentChapter) {
          currentChapter = chapterByTitle.get("story prose") || null;
          if (!currentChapter) {
            currentChapter = await this.apiClient.createChapter(storyId, {
              number: 9999,
              title: "Story Prose",
              status: "draft"
            });
            chapterByTitle.set("story prose", currentChapter);
          }
        }
        if (parsedScene.linkName) {
          currentScene = sceneMap.get(parsedScene.linkName) || null;
        }
        if (!currentScene && parsedScene.goal) {
          const allScenes = await this.apiClient.getScenes(currentChapter.id);
          currentScene = allScenes.find((s) => s.goal === parsedScene.goal) || null;
        }
        if (!currentScene) {
          const existingScenes = await this.apiClient.getScenes(currentChapter.id);
          const sceneOrderNum = existingScenes.length > 0 ? Math.max(...existingScenes.map((s) => s.order_num)) + 1 : 1;
          currentScene = await this.apiClient.createScene({
            story_id: storyId,
            chapter_id: currentChapter.id,
            order_num: sceneOrderNum,
            goal: parsedScene.goal,
            time_ref: parsedScene.timeRef
          });
        }
        if (currentScene) {
          const sceneFileName = this.fileManager.generateSceneFileName(currentScene);
          const sceneLinkName = sceneFileName.replace(/\.md$/, "");
          sceneMap.set(sceneLinkName, currentScene);
        }
        currentBeat = null;
        proseOrderNum = 1;
      } else if (section.type === "beat" && section.beat) {
        const { beat: parsedBeat } = section;
        if (!currentScene) {
          continue;
        }
        if (parsedBeat.linkName) {
          currentBeat = beatMap.get(parsedBeat.linkName) || null;
        }
        if (!currentBeat && parsedBeat.intent) {
          const allBeats = await this.apiClient.getBeats(currentScene.id);
          currentBeat = allBeats.find((b) => b.intent === parsedBeat.intent) || null;
        }
        if (!currentBeat) {
          const existingBeats = await this.apiClient.getBeats(currentScene.id);
          const beatOrderNum = existingBeats.length > 0 ? Math.max(...existingBeats.map((b) => b.order_num)) + 1 : 1;
          currentBeat = await this.apiClient.createBeat({
            scene_id: currentScene.id,
            order_num: beatOrderNum,
            type: "setup",
            intent: parsedBeat.intent,
            outcome: parsedBeat.outcome
          });
        }
        if (currentBeat) {
          const beatFileName = this.fileManager.generateBeatFileName(currentBeat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          beatMap.set(beatLinkName, currentBeat);
        }
      } else if (section.type === "prose" && section.prose) {
        const { prose: paragraph } = section;
        if (!currentChapter) {
          currentChapter = chapterByTitle.get("story prose") || null;
          if (!currentChapter) {
            currentChapter = await this.apiClient.createChapter(storyId, {
              number: 9999,
              title: "Story Prose",
              status: "draft"
            });
            chapterByTitle.set("story prose", currentChapter);
          }
        }
        const remoteContentBlocksMap = await getRemoteContentBlocksMap(currentChapter.id);
        let localContentBlock = null;
        let remoteContentBlock = null;
        if (paragraph.linkName) {
          const contentBlockFilePath = await this.findContentBlockFileByLinkName(contentsFolderPath, paragraph.linkName);
          if (contentBlockFilePath) {
            localContentBlock = await this.fileManager.readContentBlockFromFile(contentBlockFilePath);
          }
          if (!localContentBlock) {
            localContentBlock = await this.findContentBlockByContent(contentsFolderPath, paragraph.content);
          }
          if (localContentBlock) {
            remoteContentBlock = remoteContentBlocksMap.get(localContentBlock.id) || null;
          } else {
            const normalizedContent = paragraph.content.trim();
            for (const [, remotePB] of remoteContentBlocksMap.entries()) {
              if (remotePB.content.trim() === normalizedContent) {
                remoteContentBlock = remotePB;
                break;
              }
            }
          }
        } else {
          localContentBlock = await this.findContentBlockByContent(contentsFolderPath, paragraph.content);
          const normalizedContent = paragraph.content.trim();
          for (const [, remotePB] of remoteContentBlocksMap.entries()) {
            if (remotePB.content.trim() === normalizedContent) {
              remoteContentBlock = remotePB;
              if (!localContentBlock) {
                localContentBlock = await this.findContentBlockById(contentsFolderPath, remotePB.id);
              }
              break;
            }
          }
        }
        const status = compareContentBlocks(paragraph, localContentBlock, remoteContentBlock);
        let finalContentBlock;
        switch (status) {
          case "new": {
            finalContentBlock = await this.apiClient.createContentBlock(currentChapter.id, {
              order_num: proseOrderNum++,
              kind: "final",
              content: paragraph.content
            });
            const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            if (currentScene) {
              await this.apiClient.createContentAnchor(finalContentBlock.id, "scene", currentScene.id);
            }
            if (currentBeat) {
              await this.apiClient.createContentAnchor(finalContentBlock.id, "beat", currentBeat.id);
            }
            break;
          }
          case "unchanged": {
            if (!localContentBlock && remoteContentBlock) {
              finalContentBlock = remoteContentBlock;
              const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
              await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            } else if (localContentBlock) {
              finalContentBlock = localContentBlock;
              proseOrderNum++;
            } else {
              finalContentBlock = remoteContentBlock;
              proseOrderNum++;
            }
            break;
          }
          case "local_modified": {
            finalContentBlock = await this.apiClient.updateContentBlock(localContentBlock.id, {
              content: paragraph.content,
              order_num: proseOrderNum++
            });
            const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            break;
          }
          case "remote_modified": {
            finalContentBlock = remoteContentBlock;
            const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            proseOrderNum++;
            break;
          }
          case "conflict": {
            const resolution = await this.resolveConflict(localContentBlock, remoteContentBlock);
            let resolvedContent = resolution.resolution === "local" ? paragraph.content : resolution.resolution === "remote" ? remoteContentBlock.content : resolution.mergedContent || paragraph.content;
            finalContentBlock = await this.apiClient.updateContentBlock(localContentBlock.id, {
              content: resolvedContent,
              order_num: proseOrderNum++
            });
            const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            break;
          }
        }
      }
    }
  }
  // Push prose blocks from a scene file (scene-level prose, not inside chapters)
  async pushSceneContentBlocks(sceneFilePath, storyFolderPath) {
    const file = this.fileManager.getVault().getAbstractFileByPath(sceneFilePath);
    if (!(file instanceof import_obsidian19.TFile)) {
      return;
    }
    const sceneContent = await this.fileManager.getVault().read(file);
    const frontmatter = this.fileManager.parseFrontmatter(sceneContent);
    if (!frontmatter.id || !frontmatter.story_id) {
      return;
    }
    const sceneId = frontmatter.id;
    const storyId = frontmatter.story_id;
    const contentsFolderPath = `${storyFolderPath}/03-contents`;
    const sceneProse = parseSceneProse(sceneContent);
    if (sceneProse.sections.length === 0) {
      return;
    }
    const chapters = await this.apiClient.getChapters(storyId);
    let tempChapter = chapters.find((c) => c.title === "Scene-Level Prose");
    if (!tempChapter) {
      tempChapter = await this.apiClient.createChapter(storyId, {
        number: 9998,
        // High number to keep it at the end
        title: "Scene-Level Prose",
        status: "draft"
      });
    }
    const remoteContentBlocks = await this.apiClient.getContentBlocks(tempChapter.id);
    const remoteContentBlocksMap = /* @__PURE__ */ new Map();
    for (const pb of remoteContentBlocks) {
      remoteContentBlocksMap.set(pb.id, pb);
    }
    const existingBeats = await this.apiClient.getBeats(sceneId);
    const beatMap = /* @__PURE__ */ new Map();
    const beatIdMap = /* @__PURE__ */ new Map();
    for (const beat of existingBeats) {
      const fileName = this.fileManager.generateBeatFileName(beat);
      const linkName = fileName.replace(/\.md$/, "");
      beatMap.set(linkName, beat);
      beatIdMap.set(beat.id, beat);
    }
    let proseOrderNum = 1;
    let currentBeat = null;
    const updatedSections = [];
    for (const section of sceneProse.sections) {
      if (section.type === "beat" && section.beat) {
        const { beat: parsedBeat } = section;
        if (parsedBeat.linkName) {
          currentBeat = beatMap.get(parsedBeat.linkName) || null;
          if (!currentBeat) {
            currentBeat = beatIdMap.get(parsedBeat.linkName) || null;
          }
        }
        if (currentBeat) {
          const beatFileName = this.fileManager.generateBeatFileName(currentBeat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          const beatDisplayText = currentBeat.outcome ? `${currentBeat.intent} -> ${currentBeat.outcome}` : currentBeat.intent;
          updatedSections.push(`### Beat: [[${beatLinkName}|${beatDisplayText}]]`);
        }
      } else if (section.type === "prose" && section.prose) {
        const { prose: paragraph } = section;
        let localContentBlock = null;
        let remoteContentBlock = null;
        if (paragraph.linkName) {
          const contentBlockFilePath = await this.findContentBlockFileByLinkName(contentsFolderPath, paragraph.linkName);
          if (contentBlockFilePath) {
            localContentBlock = await this.fileManager.readContentBlockFromFile(contentBlockFilePath);
          }
          if (!localContentBlock) {
            localContentBlock = await this.findContentBlockByContent(contentsFolderPath, paragraph.content);
          }
          if (localContentBlock) {
            remoteContentBlock = remoteContentBlocksMap.get(localContentBlock.id) || null;
          } else {
            const normalizedContent = paragraph.content.trim();
            for (const [id2, remotePB] of remoteContentBlocksMap.entries()) {
              if (remotePB.content.trim() === normalizedContent) {
                remoteContentBlock = remotePB;
                break;
              }
            }
          }
        } else {
          localContentBlock = await this.findContentBlockByContent(contentsFolderPath, paragraph.content);
          const normalizedContent = paragraph.content.trim();
          for (const [id2, remotePB] of remoteContentBlocksMap.entries()) {
            if (remotePB.content.trim() === normalizedContent) {
              remoteContentBlock = remotePB;
              if (!localContentBlock) {
                localContentBlock = await this.findContentBlockById(contentsFolderPath, remotePB.id);
              }
              break;
            }
          }
        }
        const status = compareContentBlocks(paragraph, localContentBlock, remoteContentBlock);
        let finalContentBlock;
        switch (status) {
          case "new": {
            finalContentBlock = await this.apiClient.createContentBlock(tempChapter.id, {
              order_num: proseOrderNum++,
              kind: "final",
              content: paragraph.content
            });
            const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            await this.apiClient.createContentAnchor(finalContentBlock.id, "scene", sceneId);
            if (currentBeat) {
              await this.apiClient.createContentAnchor(finalContentBlock.id, "beat", currentBeat.id);
            }
            const linkName = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
            break;
          }
          case "unchanged": {
            if (!localContentBlock && remoteContentBlock) {
              finalContentBlock = remoteContentBlock;
              const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
              await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            } else if (localContentBlock) {
              if (localContentBlock.order_num !== proseOrderNum) {
                finalContentBlock = await this.apiClient.updateContentBlock(localContentBlock.id, {
                  order_num: proseOrderNum++
                });
                const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
                await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
              } else {
                finalContentBlock = localContentBlock;
                proseOrderNum++;
              }
            } else {
              finalContentBlock = remoteContentBlock;
              proseOrderNum++;
            }
            if (paragraph.linkName) {
              updatedSections.push(`[[${paragraph.linkName}|${paragraph.content}]]`);
            } else {
              const linkName = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
              updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
            }
            break;
          }
          case "local_modified": {
            finalContentBlock = await this.apiClient.updateContentBlock(localContentBlock.id, {
              content: paragraph.content,
              order_num: proseOrderNum++
            });
            const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            const linkName = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
            break;
          }
          case "remote_modified": {
            finalContentBlock = remoteContentBlock;
            const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            const linkName = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${finalContentBlock.content}]]`);
            new import_obsidian19.Notice(`Scene prose block updated from remote: ${linkName}`, 3e3);
            proseOrderNum++;
            break;
          }
          case "conflict": {
            const resolution = await this.resolveConflict(localContentBlock, remoteContentBlock);
            let resolvedContent;
            if (resolution.resolution === "local") {
              resolvedContent = paragraph.content;
            } else if (resolution.resolution === "remote") {
              resolvedContent = remoteContentBlock.content;
            } else {
              resolvedContent = resolution.mergedContent || paragraph.content;
            }
            finalContentBlock = await this.apiClient.updateContentBlock(localContentBlock.id, {
              content: resolvedContent,
              order_num: proseOrderNum++
            });
            const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            const linkName = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${resolvedContent}]]`);
            break;
          }
        }
      }
    }
    if (updatedSections.length > 0) {
      const frontmatterMatch = sceneContent.match(/^---\n([\s\S]*?)\n---/);
      const frontmatterEnd = frontmatterMatch ? frontmatterMatch[0].length : 0;
      const afterFrontmatter = sceneContent.substring(frontmatterEnd).trim();
      const beatsSectionMatch = afterFrontmatter.match(/\n##\s+Beats\s*\n/);
      const insertionPoint = beatsSectionMatch ? frontmatterEnd + afterFrontmatter.indexOf(beatsSectionMatch[0]) : sceneContent.length;
      const beforeProse = sceneContent.substring(0, insertionPoint).trimEnd();
      const afterProse = sceneContent.substring(insertionPoint);
      const updatedContent = `${beforeProse}

${updatedSections.join("\n\n")}
${afterProse}`;
      await this.fileManager.getVault().modify(file, updatedContent);
    }
  }
  // Push prose blocks from a beat file
  async pushBeatContentBlocks(beatFilePath, storyFolderPath) {
    const file = this.fileManager.getVault().getAbstractFileByPath(beatFilePath);
    if (!(file instanceof import_obsidian19.TFile)) {
      return;
    }
    const beatContent = await this.fileManager.getVault().read(file);
    const frontmatter = this.fileManager.parseFrontmatter(beatContent);
    if (!frontmatter.id || !frontmatter.scene_id) {
      return;
    }
    const beatId = frontmatter.id;
    const sceneId = frontmatter.scene_id;
    const contentsFolderPath = `${storyFolderPath}/03-contents`;
    const beatProse = parseBeatProse(beatContent);
    if (beatProse.sections.length === 0) {
      return;
    }
    const scene = await this.apiClient.getScene(sceneId);
    if (!scene) {
      return;
    }
    const storyId = scene.story_id;
    const chapters = await this.apiClient.getChapters(storyId);
    let tempChapter = chapters.find((c) => c.title === "Beat-Level Prose");
    if (!tempChapter) {
      tempChapter = await this.apiClient.createChapter(storyId, {
        number: 9997,
        // High number to keep it at the end
        title: "Beat-Level Prose",
        status: "draft"
      });
    }
    const remoteContentBlocks = await this.apiClient.getContentBlocks(tempChapter.id);
    const remoteContentBlocksMap = /* @__PURE__ */ new Map();
    for (const pb of remoteContentBlocks) {
      remoteContentBlocksMap.set(pb.id, pb);
    }
    let proseOrderNum = 1;
    const updatedSections = [];
    const beat = await this.apiClient.getBeat(beatId);
    if (beat) {
      const beatFileName = this.fileManager.generateBeatFileName(beat);
      const beatLinkName = beatFileName.replace(/\.md$/, "");
      const beatDisplayText = beat.outcome ? `${beat.intent} -> ${beat.outcome}` : beat.intent;
      updatedSections.push(`## Beat: [[${beatLinkName}|${beatDisplayText}]]`);
    }
    for (const section of beatProse.sections) {
      if (section.type === "prose" && section.prose) {
        const { prose: paragraph } = section;
        let localContentBlock = null;
        let remoteContentBlock = null;
        if (paragraph.linkName) {
          const contentBlockFilePath = await this.findContentBlockFileByLinkName(contentsFolderPath, paragraph.linkName);
          if (contentBlockFilePath) {
            localContentBlock = await this.fileManager.readContentBlockFromFile(contentBlockFilePath);
          }
          if (!localContentBlock) {
            localContentBlock = await this.findContentBlockByContent(contentsFolderPath, paragraph.content);
          }
          if (localContentBlock) {
            remoteContentBlock = remoteContentBlocksMap.get(localContentBlock.id) || null;
          } else {
            const normalizedContent = paragraph.content.trim();
            for (const [, remotePB] of remoteContentBlocksMap.entries()) {
              if (remotePB.content.trim() === normalizedContent) {
                remoteContentBlock = remotePB;
                break;
              }
            }
          }
        } else {
          localContentBlock = await this.findContentBlockByContent(contentsFolderPath, paragraph.content);
          const normalizedContent = paragraph.content.trim();
          for (const [, remotePB] of remoteContentBlocksMap.entries()) {
            if (remotePB.content.trim() === normalizedContent) {
              remoteContentBlock = remotePB;
              if (!localContentBlock) {
                localContentBlock = await this.findContentBlockById(contentsFolderPath, remotePB.id);
              }
              break;
            }
          }
        }
        const status = compareContentBlocks(paragraph, localContentBlock, remoteContentBlock);
        let finalContentBlock;
        switch (status) {
          case "new": {
            finalContentBlock = await this.apiClient.createContentBlock(tempChapter.id, {
              order_num: proseOrderNum++,
              kind: "final",
              content: paragraph.content
            });
            const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            await this.apiClient.createContentAnchor(finalContentBlock.id, "scene", sceneId);
            await this.apiClient.createContentAnchor(finalContentBlock.id, "beat", beatId);
            const linkName = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
            break;
          }
          case "unchanged": {
            if (!localContentBlock && remoteContentBlock) {
              finalContentBlock = remoteContentBlock;
              const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
              await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
              const linkName = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
              updatedSections.push(`[[${linkName}|${remoteContentBlock.content}]]`);
            } else if (localContentBlock) {
              finalContentBlock = localContentBlock;
              const linkName = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
              updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
              proseOrderNum++;
            } else {
              proseOrderNum++;
              continue;
            }
            break;
          }
          case "local_modified": {
            finalContentBlock = await this.apiClient.updateContentBlock(localContentBlock.id, {
              content: paragraph.content,
              order_num: proseOrderNum++
            });
            const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            const linkName = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${paragraph.content}]]`);
            break;
          }
          case "remote_modified": {
            finalContentBlock = remoteContentBlock;
            const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            proseOrderNum++;
            const linkName = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${remoteContentBlock.content}]]`);
            break;
          }
          case "conflict": {
            const resolution = await this.resolveConflict(localContentBlock, remoteContentBlock);
            let resolvedContent;
            if (resolution.resolution === "local") {
              resolvedContent = paragraph.content;
            } else if (resolution.resolution === "remote") {
              resolvedContent = remoteContentBlock.content;
            } else {
              resolvedContent = resolution.mergedContent || paragraph.content;
            }
            finalContentBlock = await this.apiClient.updateContentBlock(localContentBlock.id, {
              content: resolvedContent,
              order_num: proseOrderNum++
            });
            const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, finalContentBlock);
            await this.fileManager.writeContentBlockFile(finalContentBlock, filePath, void 0);
            const linkName = this.fileManager.generateContentBlockFileName(finalContentBlock).replace(/\.md$/, "");
            updatedSections.push(`[[${linkName}|${resolvedContent}]]`);
            break;
          }
        }
      }
    }
    if (updatedSections.length > 1) {
      const frontmatterMatch = beatContent.match(/^---\n([\s\S]*?)\n---/);
      const frontmatterEnd = frontmatterMatch ? frontmatterMatch[0].length : 0;
      const afterFrontmatter = beatContent.substring(frontmatterEnd).trim();
      const beatSectionMatch = afterFrontmatter.match(/##\s+Beat:\s*.+[\s\S]*/);
      if (beatSectionMatch) {
        const beforeBeatSection = beatContent.substring(0, frontmatterEnd + afterFrontmatter.indexOf(beatSectionMatch[0]));
        const updatedContent = `${beforeBeatSection.trimEnd()}

${updatedSections.join("\n\n")}
`;
        await this.fileManager.getVault().modify(file, updatedContent);
      } else {
        const updatedContent = `${beatContent.trimEnd()}

${updatedSections.join("\n\n")}
`;
        await this.fileManager.getVault().modify(file, updatedContent);
      }
    }
  }
  // Process the "## Orphan Scenes" list and update orphan scenes order
  async processOrphanScenesList(list, storyId) {
    const allScenes = await this.apiClient.getScenesByStory(storyId);
    const sceneMap = /* @__PURE__ */ new Map();
    const sceneIdMap = /* @__PURE__ */ new Map();
    const orphanScenes = allScenes.filter((s) => !s.chapter_id);
    for (const scene of orphanScenes) {
      const fileName = this.fileManager.generateSceneFileName(scene);
      const linkName = fileName.replace(/\.md$/, "");
      sceneMap.set(linkName, scene);
      sceneIdMap.set(scene.id, scene);
    }
    const beatMap = /* @__PURE__ */ new Map();
    const beatIdMap = /* @__PURE__ */ new Map();
    for (const scene of orphanScenes) {
      const beats = await this.apiClient.getBeats(scene.id);
      for (const beat of beats) {
        const fileName = this.fileManager.generateBeatFileName(beat);
        const linkName = fileName.replace(/\.md$/, "");
        beatMap.set(linkName, beat);
        beatIdMap.set(beat.id, beat);
      }
    }
    let currentScene = null;
    let sceneOrderNum = 1;
    const beatOrderNums = /* @__PURE__ */ new Map();
    for (const item of list.items) {
      if (item.type === "scene") {
        let goal;
        let timeRef = "";
        const sceneMatch = item.displayText.match(/Scene\s+\d+:\s*(.+)/);
        if (sceneMatch) {
          const sceneText = sceneMatch[1].trim();
          const parts = sceneText.split(/\s*-\s*/);
          goal = parts[0].trim();
          timeRef = parts.length > 1 ? parts.slice(1).join(" - ").trim() : "";
        } else {
          const parts = item.displayText.split(/\s*-\s*/);
          goal = parts[0].trim();
          timeRef = parts.length > 1 ? parts.slice(1).join(" - ").trim() : "";
        }
        if (item.linkName) {
          currentScene = sceneMap.get(item.linkName) || null;
          if (!currentScene) {
            currentScene = sceneIdMap.get(item.linkName) || null;
          }
          if (currentScene) {
            const needsOrderUpdate = currentScene.order_num !== sceneOrderNum;
            const needsContentUpdate = goal !== currentScene.goal || timeRef !== currentScene.time_ref;
            if (needsOrderUpdate || needsContentUpdate) {
              currentScene = await this.apiClient.updateScene(currentScene.id, {
                goal,
                time_ref: timeRef,
                order_num: sceneOrderNum
              });
            }
            const existingBeats = await this.apiClient.getBeats(currentScene.id);
            if (existingBeats.length === 0) {
              beatOrderNums.set(currentScene.id, 1);
            } else {
              const maxOrderNum = Math.max(...existingBeats.map((b) => b.order_num));
              beatOrderNums.set(currentScene.id, maxOrderNum + 1);
            }
          }
        } else {
          currentScene = await this.apiClient.createScene({
            story_id: storyId,
            chapter_id: null,
            // Orphan scene
            order_num: sceneOrderNum,
            goal,
            time_ref: timeRef
          });
          const sceneFileName = this.fileManager.generateSceneFileName(currentScene);
          const sceneLinkName = sceneFileName.replace(/\.md$/, "");
          sceneMap.set(sceneLinkName, currentScene);
          sceneIdMap.set(currentScene.id, currentScene);
          beatOrderNums.set(currentScene.id, 1);
        }
        sceneOrderNum++;
      } else if (item.type === "beat" && currentScene) {
        let intent;
        let outcome = "";
        const beatMatch = item.displayText.match(/Beat\s+\d+:\s*(.+)/);
        if (beatMatch) {
          const beatText = beatMatch[1].trim();
          const parts = beatText.split(/\s*->\s*/);
          intent = parts[0].trim();
          outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
        } else {
          const parts = item.displayText.split(/\s*->\s*/);
          intent = parts[0].trim();
          outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
        }
        const currentBeatOrderNum = beatOrderNums.get(currentScene.id) || 1;
        if (item.linkName) {
          let currentBeat = beatMap.get(item.linkName) || null;
          if (!currentBeat) {
            currentBeat = beatIdMap.get(item.linkName) || null;
          }
          if (currentBeat) {
            const needsOrderUpdate = currentBeat.order_num !== currentBeatOrderNum;
            const needsContentUpdate = intent !== currentBeat.intent || outcome !== currentBeat.outcome;
            const needsSceneUpdate = currentBeat.scene_id !== currentScene.id;
            if (needsOrderUpdate || needsContentUpdate || needsSceneUpdate) {
              currentBeat = await this.apiClient.updateBeat(currentBeat.id, {
                intent,
                outcome,
                order_num: currentBeatOrderNum,
                scene_id: currentScene.id
              });
            }
          }
        } else {
          await this.apiClient.createBeat({
            scene_id: currentScene.id,
            order_num: currentBeatOrderNum,
            type: "setup",
            // Default type
            intent,
            outcome
          });
        }
        beatOrderNums.set(currentScene.id, currentBeatOrderNum + 1);
      }
    }
  }
  // Process the "## Orphan Beats" list and update orphan beats order
  async processOrphanBeatsList(list, storyId) {
    const allBeats = await this.apiClient.getBeatsByStory(storyId);
    const allScenes = await this.apiClient.getScenesByStory(storyId);
    const sceneIdSet = new Set(allScenes.map((s) => s.id));
    const orphanBeats = allBeats.filter((b) => !b.scene_id || !sceneIdSet.has(b.scene_id));
    const beatMap = /* @__PURE__ */ new Map();
    const beatIdMap = /* @__PURE__ */ new Map();
    for (const beat of orphanBeats) {
      const fileName = this.fileManager.generateBeatFileName(beat);
      const linkName = fileName.replace(/\.md$/, "");
      beatMap.set(linkName, beat);
      beatIdMap.set(beat.id, beat);
    }
    let beatOrderNum = 1;
    for (const item of list.items) {
      let intent;
      let outcome = "";
      const beatMatch = item.displayText.match(/Beat\s+\d+:\s*(.+)/);
      if (beatMatch) {
        const beatText = beatMatch[1].trim();
        const parts = beatText.split(/\s*->\s*/);
        intent = parts[0].trim();
        outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
      } else {
        const parts = item.displayText.split(/\s*->\s*/);
        intent = parts[0].trim();
        outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
      }
      if (item.linkName) {
        let currentBeat = beatMap.get(item.linkName) || null;
        if (!currentBeat) {
          currentBeat = beatIdMap.get(item.linkName) || null;
        }
        if (currentBeat) {
          const needsOrderUpdate = currentBeat.order_num !== beatOrderNum;
          const needsContentUpdate = intent !== currentBeat.intent || outcome !== currentBeat.outcome;
          if (needsOrderUpdate || needsContentUpdate) {
            currentBeat = await this.apiClient.updateBeat(currentBeat.id, {
              intent,
              outcome,
              order_num: beatOrderNum
              // Keep scene_id as null or invalid (orphan) - don't update it
            });
          }
        }
      } else {
        const allScenes2 = await this.apiClient.getScenesByStory(storyId);
        let orphanBeatScene = allScenes2.find((s) => !s.chapter_id && s.goal.startsWith("Orphan Beats Container"));
        if (!orphanBeatScene) {
          orphanBeatScene = await this.apiClient.createScene({
            story_id: storyId,
            chapter_id: null,
            order_num: 9999,
            // High number to keep it at the end
            goal: "Orphan Beats Container",
            time_ref: ""
          });
        }
        await this.apiClient.createBeat({
          scene_id: orphanBeatScene.id,
          order_num: beatOrderNum,
          type: "setup",
          // Default type
          intent,
          outcome
        });
      }
      beatOrderNum++;
    }
  }
  // Process the "## Scenes & Beats" list and create/update/delete scenes and beats
  async processSceneBeatList(list, chapterId, storyId) {
    const existingScenes = await this.apiClient.getScenes(chapterId);
    const sceneMap = /* @__PURE__ */ new Map();
    const sceneIdMap = /* @__PURE__ */ new Map();
    for (const scene of existingScenes) {
      const fileName = this.fileManager.generateSceneFileName(scene);
      const linkName = fileName.replace(/\.md$/, "");
      sceneMap.set(linkName, scene);
      sceneIdMap.set(scene.id, scene);
    }
    const beatMap = /* @__PURE__ */ new Map();
    const beatIdMap = /* @__PURE__ */ new Map();
    for (const scene of existingScenes) {
      const beats = await this.apiClient.getBeats(scene.id);
      for (const beat of beats) {
        const fileName = this.fileManager.generateBeatFileName(beat);
        const linkName = fileName.replace(/\.md$/, "");
        beatMap.set(linkName, beat);
        beatIdMap.set(beat.id, beat);
      }
    }
    let currentScene = null;
    let sceneOrderNum = 1;
    const beatOrderNums = /* @__PURE__ */ new Map();
    for (const item of list.items) {
      if (item.type === "scene") {
        currentScene = null;
        let goal;
        let timeRef = "";
        const sceneMatch = item.displayText.match(/Scene\s+\d+:\s*(.+)/);
        if (sceneMatch) {
          const sceneText = sceneMatch[1].trim();
          const parts = sceneText.split(/\s*-\s*/);
          goal = parts[0].trim();
          timeRef = parts.length > 1 ? parts.slice(1).join(" - ").trim() : "";
        } else {
          const parts = item.displayText.split(/\s*-\s*/);
          goal = parts[0].trim();
          timeRef = parts.length > 1 ? parts.slice(1).join(" - ").trim() : "";
        }
        currentScene = null;
        if (item.linkName) {
          currentScene = sceneMap.get(item.linkName) || null;
          if (!currentScene) {
            currentScene = sceneIdMap.get(item.linkName) || null;
          }
          if (currentScene) {
            const needsOrderUpdate = currentScene.order_num !== sceneOrderNum;
            const needsContentUpdate = goal !== currentScene.goal || timeRef !== currentScene.time_ref;
            if (needsOrderUpdate || needsContentUpdate) {
              currentScene = await this.apiClient.updateScene(currentScene.id, {
                goal,
                time_ref: timeRef,
                order_num: sceneOrderNum
              });
            }
            const existingBeats = await this.apiClient.getBeats(currentScene.id);
            if (existingBeats.length === 0) {
              beatOrderNums.set(currentScene.id, 1);
            } else {
              const maxOrderNum = Math.max(...existingBeats.map((b) => b.order_num));
              beatOrderNums.set(currentScene.id, maxOrderNum + 1);
            }
          }
        } else {
          currentScene = await this.apiClient.createScene({
            story_id: storyId,
            chapter_id: chapterId,
            order_num: sceneOrderNum,
            goal,
            time_ref: timeRef
          });
          const sceneFileName = this.fileManager.generateSceneFileName(currentScene);
          const sceneLinkName = sceneFileName.replace(/\.md$/, "");
          sceneMap.set(sceneLinkName, currentScene);
          sceneIdMap.set(currentScene.id, currentScene);
          beatOrderNums.set(currentScene.id, 1);
        }
        sceneOrderNum++;
      } else if (item.type === "beat" && currentScene) {
        let intent;
        let outcome = "";
        const beatMatch = item.displayText.match(/Beat\s+\d+:\s*(.+)/);
        if (beatMatch) {
          const beatText = beatMatch[1].trim();
          const parts = beatText.split(/\s*->\s*/);
          intent = parts[0].trim();
          outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
        } else {
          const parts = item.displayText.split(/\s*->\s*/);
          intent = parts[0].trim();
          outcome = parts.length > 1 ? parts.slice(1).join(" -> ").trim() : "";
        }
        const currentBeatOrderNum = beatOrderNums.get(currentScene.id) || 1;
        if (item.linkName) {
          let currentBeat = beatMap.get(item.linkName) || null;
          if (!currentBeat) {
            currentBeat = beatIdMap.get(item.linkName) || null;
          }
          if (currentBeat) {
            const needsOrderUpdate = currentBeat.order_num !== currentBeatOrderNum;
            const needsContentUpdate = intent !== currentBeat.intent || outcome !== currentBeat.outcome;
            const needsSceneUpdate = currentBeat.scene_id !== currentScene.id;
            if (needsOrderUpdate || needsContentUpdate || needsSceneUpdate) {
              currentBeat = await this.apiClient.updateBeat(currentBeat.id, {
                intent,
                outcome,
                order_num: currentBeatOrderNum,
                scene_id: currentScene.id
              });
              if (needsSceneUpdate) {
                const beatFileName = this.fileManager.generateBeatFileName(currentBeat);
                const beatLinkName = beatFileName.replace(/\.md$/, "");
                beatMap.set(beatLinkName, currentBeat);
                beatIdMap.set(currentBeat.id, currentBeat);
              }
            }
          }
        } else {
          const newBeat = await this.apiClient.createBeat({
            scene_id: currentScene.id,
            order_num: currentBeatOrderNum,
            type: "setup",
            // Default type
            intent,
            outcome
          });
          const beatFileName = this.fileManager.generateBeatFileName(newBeat);
          const beatLinkName = beatFileName.replace(/\.md$/, "");
          beatMap.set(beatLinkName, newBeat);
          beatIdMap.set(newBeat.id, newBeat);
        }
        beatOrderNums.set(currentScene.id, currentBeatOrderNum + 1);
      }
    }
  }
  // Find content block file by link name (searches recursively in all type subfolders)
  async findContentBlockFileByLinkName(contentsRoot, linkName) {
    const root2 = this.fileManager.getVault().getAbstractFileByPath(contentsRoot);
    if (!(root2 instanceof import_obsidian19.TFolder))
      return null;
    const target = `${linkName}.md`;
    const stack = [root2];
    while (stack.length) {
      const folder = stack.pop();
      for (const child of folder.children) {
        if (child instanceof import_obsidian19.TFolder) {
          stack.push(child);
        } else if (child instanceof import_obsidian19.TFile && child.name === target) {
          return child.path;
        }
      }
    }
    return null;
  }
  // Find prose block by content when file name doesn't match (searches recursively in all type subfolders)
  async findContentBlockByContent(contentsFolderPath, content) {
    try {
      const folder = this.fileManager.getVault().getAbstractFileByPath(contentsFolderPath);
      if (!(folder instanceof import_obsidian19.TFolder)) {
        return null;
      }
      const normalizedContent = content.trim();
      const stack = [folder];
      while (stack.length) {
        const currentFolder = stack.pop();
        for (const child of currentFolder.children) {
          if (child instanceof import_obsidian19.TFolder) {
            stack.push(child);
          } else if (child instanceof import_obsidian19.TFile && child.extension === "md") {
            const contentBlock = await this.fileManager.readContentBlockFromFile(child.path);
            if (contentBlock && contentBlock.content.trim() === normalizedContent) {
              return contentBlock;
            }
          }
        }
      }
    } catch (err) {
      console.error("Error searching for prose block by content:", err);
    }
    return null;
  }
  // Find prose block by ID when we have remote ID but need local file (searches recursively in all type subfolders)
  async findContentBlockById(contentsFolderPath, id2) {
    try {
      const folder = this.fileManager.getVault().getAbstractFileByPath(contentsFolderPath);
      if (!(folder instanceof import_obsidian19.TFolder)) {
        return null;
      }
      const stack = [folder];
      while (stack.length) {
        const currentFolder = stack.pop();
        for (const child of currentFolder.children) {
          if (child instanceof import_obsidian19.TFolder) {
            stack.push(child);
          } else if (child instanceof import_obsidian19.TFile && child.extension === "md") {
            const contentBlock = await this.fileManager.readContentBlockFromFile(child.path);
            if (contentBlock && contentBlock.id === id2) {
              return contentBlock;
            }
          }
        }
      }
    } catch (err) {
      console.error("Error searching for prose block by ID:", err);
    }
    return null;
  }
  // Get the correct file path for a content block (always uses type subfolders)
  getContentBlockFilePath(storyFolderPath, contentBlock) {
    const fileName = this.fileManager.generateContentBlockFileName(contentBlock);
    const typeFolderPath = this.fileManager.getContentBlockFolderPath(storyFolderPath, contentBlock.type || "text");
    return `${typeFolderPath}/${fileName}`;
  }
  // Get content block file path from contents folder path (03-contents)
  async getContentBlockFilePathFromContents(contentsFolderPath, contentBlock) {
    const typeFolder = this.fileManager.getContentTypeFolder(contentBlock.type || "text");
    const typeFolderPath = `${contentsFolderPath}/${typeFolder}`;
    await this.fileManager.ensureFolderExists(typeFolderPath);
    const fileName = this.fileManager.generateContentBlockFileName(contentBlock);
    return `${typeFolderPath}/${fileName}`;
  }
  // Resolve conflict using modal or auto-resolve based on mode
  async resolveConflict(localContentBlock, remoteContentBlock) {
    if (this.settings.mode === "local") {
      return { resolution: "local" };
    }
    return new Promise((resolve) => {
      const modal = new ConflictModal(
        this.app,
        localContentBlock,
        remoteContentBlock,
        async (result) => {
          resolve(result);
        }
      );
      modal.open();
    });
  }
  // Update the Chapter section in chapter file (hierarchical structure)
  async updateChapterProseSectionHierarchical(originalContent, updatedSections, file, frontmatter) {
    const frontmatterMatch = originalContent.match(/^---\n([\s\S]*?)\n---/);
    const frontmatterText = frontmatterMatch ? frontmatterMatch[0] : "";
    const bodyStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
    const bodyContent = originalContent.substring(bodyStart).trim();
    const chapterNumber = frontmatter.number || "1";
    const chapterTitle = frontmatter.title || "Untitled";
    const chapterHeaderPattern = `##\\s+Chapter\\s+${chapterNumber}:\\s+[^\\n]+`;
    const chapterSectionMatch = bodyContent.match(new RegExp(`([\\s\\S]*?${chapterHeaderPattern}\\s*\\n+)([\\s\\S]*?)(?=\\n##\\s+Chapter\\s+\\d+:|$)`, "i"));
    if (!chapterSectionMatch) {
      const newChapterSection = `

## Chapter ${chapterNumber}: ${chapterTitle}

${updatedSections.join("\n\n")}

`;
      const updatedContent2 = `${frontmatterText}
${bodyContent}${newChapterSection}`;
      await this.fileManager.getVault().modify(file, updatedContent2);
      return;
    }
    const beforeChapter = chapterSectionMatch[1];
    const afterChapter = bodyContent.substring(chapterSectionMatch.index + chapterSectionMatch[0].length);
    const newChapterContent = updatedSections.join("\n\n");
    const updatedBody = `${beforeChapter}${newChapterContent}

${afterChapter}`;
    const updatedContent = `${frontmatterText}
${updatedBody}`;
    await this.fileManager.getVault().modify(file, updatedContent);
  }
  // Update the Prose section in chapter file
  async updateChapterProseSection(originalContent, updatedParagraphs, file) {
    const frontmatterMatch = originalContent.match(/^---\n([\s\S]*?)\n---/);
    const frontmatter = frontmatterMatch ? frontmatterMatch[0] : "";
    const bodyStart = frontmatterMatch ? frontmatterMatch[0].length : 0;
    const bodyContent = originalContent.substring(bodyStart).trim();
    const proseSectionMatch = bodyContent.match(/([\s\S]*?##\s+Prose\s*\n\n)([\s\S]*?)(?=\n##|\n*$)/);
    if (!proseSectionMatch) {
      const newProseSection = `

## Prose

${updatedParagraphs.join("\n\n")}

`;
      const updatedContent2 = `${frontmatter}
${bodyContent}${newProseSection}`;
      await this.fileManager.getVault().modify(file, updatedContent2);
      return;
    }
    const beforeProse = proseSectionMatch[1];
    const newProseContent = updatedParagraphs.join("\n\n");
    const afterProse = bodyContent.substring(proseSectionMatch.index + proseSectionMatch[0].length);
    const updatedBody = `${beforeProse}${newProseContent}

${afterProse}`;
    const updatedContent = `${frontmatter}
${updatedBody}`;
    await this.fileManager.getVault().modify(file, updatedContent);
  }
  async writeChapterBundle(data) {
    const folderPath = this.fileManager.getStoryFolderPath(data.story.title);
    await this.ensureStoryFolders(folderPath);
    for (const contentBlock of data.contentBlocks) {
      await this.writeContentBlockToFolder(folderPath, data.story.title, contentBlock);
    }
    const chaptersFolderPath = `${folderPath}/00-chapters`;
    const chapterFileName = `Chapter-${data.chapter.number}.md`;
    const chapterFilePath = `${chaptersFolderPath}/${chapterFileName}`;
    await this.fileManager.writeChapterFile(
      { chapter: data.chapter, scenes: data.scenes },
      chapterFilePath,
      data.story.title,
      data.contentBlocks,
      data.contentBlockRefs,
      []
    );
    const { byScene, byBeat } = this.buildContentBlockAssociationMaps(
      data.contentBlocks,
      data.contentBlockRefs
    );
    await this.syncScenesToFilesystem(
      data.scenes,
      folderPath,
      data.story.title,
      byScene,
      byBeat
    );
  }
  async writeSceneBundle(data) {
    var _a, _b;
    await this.fileManager.ensureFolderExists(`${data.folderPath}/01-scenes`);
    await this.fileManager.ensureFolderExists(`${data.folderPath}/02-beats`);
    const sceneContentBlocks = (_a = data.sceneContentBlocks) != null ? _a : data.skipRemoteContentFetch ? [] : await this.apiClient.getContentBlocksByScene(data.scene.id);
    const sceneFileName = this.fileManager.generateSceneFileName(data.scene);
    const sceneFilePath = `${data.folderPath}/01-scenes/${sceneFileName}`;
    await this.fileManager.writeSceneFile(
      { scene: data.scene, beats: data.beats },
      sceneFilePath,
      data.storyTitle,
      sceneContentBlocks,
      []
    );
    for (const beat of data.beats) {
      const provided = (_b = data.beatContentBlockMap) == null ? void 0 : _b.get(beat.id);
      const beatContentBlocks = provided != null ? provided : data.skipRemoteContentFetch ? [] : await this.apiClient.getContentBlocksByBeat(beat.id);
      const beatFileName = this.fileManager.generateBeatFileName(beat);
      const beatFilePath = `${data.folderPath}/02-beats/${beatFileName}`;
      await this.fileManager.writeBeatFile(
        beat,
        beatFilePath,
        data.storyTitle,
        beatContentBlocks
      );
    }
  }
  buildContentBlockAssociationMaps(contentBlocks, contentBlockRefs) {
    const byScene = /* @__PURE__ */ new Map();
    const byBeat = /* @__PURE__ */ new Map();
    const blockById = new Map(contentBlocks.map((block) => [block.id, block]));
    for (const ref of contentBlockRefs) {
      const block = blockById.get(ref.content_block_id);
      if (!block) {
        continue;
      }
      if (ref.entity_type === "scene") {
        if (!byScene.has(ref.entity_id)) {
          byScene.set(ref.entity_id, []);
        }
        byScene.get(ref.entity_id).push(block);
      } else if (ref.entity_type === "beat") {
        if (!byBeat.has(ref.entity_id)) {
          byBeat.set(ref.entity_id, []);
        }
        byBeat.get(ref.entity_id).push(block);
      }
    }
    return { byScene, byBeat };
  }
  async pullSingleEntity(storyId, target) {
    switch (target.type) {
      case "chapter":
        await this.pullChapterEntity(storyId, target.id);
        break;
      case "scene":
        await this.pullSceneEntity(storyId, target.id);
        break;
      case "content":
        await this.pullContentBlockEntity(storyId, target.id);
        break;
      default:
        throw new Error(`Unsupported entity type: ${target.type}`);
    }
  }
  async pullChapterEntity(storyId, chapterId) {
    const story = await this.apiClient.getStory(storyId);
    const chapter = await this.apiClient.getChapter(chapterId);
    if (chapter.story_id !== storyId) {
      throw new Error("Chapter does not belong to the selected story");
    }
    const scenes = await this.apiClient.getScenes(chapterId);
    const scenesWithBeats = await Promise.all(
      scenes.map(async (scene) => {
        const beats = await this.apiClient.getBeats(scene.id);
        return { scene, beats };
      })
    );
    const contentBlocks = await this.apiClient.getContentBlocks(chapterId);
    const contentBlockRefs = [];
    for (const contentBlock of contentBlocks) {
      const refs = await this.apiClient.getContentAnchors(contentBlock.id);
      contentBlockRefs.push(...refs);
    }
    await this.writeChapterBundle({
      story,
      chapter,
      scenes: scenesWithBeats,
      contentBlocks,
      contentBlockRefs
    });
    new import_obsidian19.Notice(`Chapter "${chapter.title}" synced successfully`);
  }
  async pullSceneEntity(storyId, sceneId) {
    const scene = await this.apiClient.getScene(sceneId);
    if (scene.story_id !== storyId) {
      throw new Error("Scene does not belong to the selected story");
    }
    const story = await this.apiClient.getStory(storyId);
    const folderPath = this.fileManager.getStoryFolderPath(story.title);
    await this.ensureStoryFolders(folderPath);
    const beats = await this.apiClient.getBeats(scene.id);
    const sceneContentBlocks = await this.apiClient.getContentBlocksByScene(scene.id);
    const beatContentBlockMap = /* @__PURE__ */ new Map();
    for (const beat of beats) {
      const beatContentBlocks = await this.apiClient.getContentBlocksByBeat(beat.id);
      beatContentBlockMap.set(beat.id, beatContentBlocks);
    }
    await this.writeSceneBundle({
      storyTitle: story.title,
      folderPath,
      scene,
      beats,
      sceneContentBlocks,
      beatContentBlockMap
    });
    await this.syncSceneContentBlocks(scene, beats, folderPath, story.title);
    new import_obsidian19.Notice(`Scene "${scene.goal}" synced successfully`);
  }
  async pullContentBlockEntity(storyId, contentBlockId) {
    const story = await this.apiClient.getStory(storyId);
    const contentBlock = await this.apiClient.getContentBlock(contentBlockId);
    if (contentBlock.chapter_id) {
      const chapter = await this.apiClient.getChapter(contentBlock.chapter_id);
      if (chapter.story_id !== storyId) {
        throw new Error("Content block does not belong to the selected story");
      }
    }
    const folderPath = this.fileManager.getStoryFolderPath(story.title);
    await this.ensureContentFolders(folderPath);
    await this.writeContentBlockToFolder(folderPath, story.title, contentBlock);
    new import_obsidian19.Notice("Content block synced successfully");
  }
  async pushSingleEntity(folderPath, target, storyId, storyTitle) {
    let entityLabel;
    switch (target.type) {
      case "chapter":
        entityLabel = await this.pushChapterEntity(folderPath, target.id);
        break;
      case "scene":
        entityLabel = await this.pushSceneEntity(folderPath, storyId, target.id);
        break;
      case "content":
        entityLabel = await this.pushContentBlockEntity(folderPath, target.id, storyTitle);
        break;
      default:
        throw new Error(`Unsupported entity type: ${target.type}`);
    }
    new import_obsidian19.Notice(`${entityLabel} pushed successfully`);
    try {
      await this.pullSingleEntity(storyId, target);
    } catch (pullErr) {
      const pullErrorMessage = pullErr instanceof Error ? pullErr.message : "Failed to sync entity after push";
      new import_obsidian19.Notice(`Warning: ${pullErrorMessage}`, 5e3);
    }
  }
  async pushChapterEntity(folderPath, chapterId) {
    var _a, _b;
    const chapterFile = await this.findChapterFileById(folderPath, chapterId);
    if (!chapterFile) {
      throw new Error("Chapter file not found locally");
    }
    await this.pushChapterContentBlocks(chapterFile.path, folderPath);
    const label = ((_a = chapterFile.frontmatter) == null ? void 0 : _a.title) || (((_b = chapterFile.frontmatter) == null ? void 0 : _b.number) ? `Chapter ${chapterFile.frontmatter.number}` : "Chapter");
    return label;
  }
  async pushSceneEntity(folderPath, storyId, sceneId) {
    var _a;
    const sceneFile = await this.findSceneFileById(folderPath, sceneId);
    if (!sceneFile) {
      throw new Error("Scene file not found locally");
    }
    await this.pushSceneBeats(sceneFile.path, storyId);
    await this.pushSceneContentBlocks(sceneFile.path, folderPath);
    const label = ((_a = sceneFile.frontmatter) == null ? void 0 : _a.goal) ? `Scene: ${sceneFile.frontmatter.goal}` : "Scene";
    return label;
  }
  async pushContentBlockEntity(folderPath, contentBlockId, storyTitle) {
    var _a;
    const contentsFolderPath = `${folderPath}/03-contents`;
    await this.fileManager.ensureFolderExists(contentsFolderPath);
    const localContentBlock = await this.findContentBlockById(contentsFolderPath, contentBlockId);
    if (!localContentBlock) {
      throw new Error("Content block file not found locally");
    }
    const updatedBlock = await this.apiClient.updateContentBlock(contentBlockId, {
      content: localContentBlock.content,
      metadata: localContentBlock.metadata,
      type: localContentBlock.type,
      kind: localContentBlock.kind,
      order_num: (_a = localContentBlock.order_num) != null ? _a : void 0
    });
    const filePath = await this.getContentBlockFilePathFromContents(contentsFolderPath, updatedBlock);
    await this.fileManager.writeContentBlockFile(updatedBlock, filePath, storyTitle);
    return "Content block";
  }
  async ensureStoryFolders(folderPath) {
    await this.fileManager.ensureFolderExists(folderPath);
    await this.ensureContentFolders(folderPath);
    await this.fileManager.ensureFolderExists(`${folderPath}/00-chapters`);
    await this.fileManager.ensureFolderExists(`${folderPath}/01-scenes`);
    await this.fileManager.ensureFolderExists(`${folderPath}/02-beats`);
  }
  async ensureContentFolders(folderPath) {
    const contentsFolderPath = `${folderPath}/03-contents`;
    await this.fileManager.ensureFolderExists(contentsFolderPath);
    for (const typeFolder of ["00-texts", "01-images", "02-videos", "03-audios", "04-embeds", "05-links"]) {
      await this.fileManager.ensureFolderExists(`${contentsFolderPath}/${typeFolder}`);
    }
  }
  async writeContentBlockToFolder(storyFolderPath, storyTitle, contentBlock) {
    const typeFolderPath = this.fileManager.getContentBlockFolderPath(
      storyFolderPath,
      contentBlock.type || "text"
    );
    await this.fileManager.ensureFolderExists(typeFolderPath);
    const contentBlockFileName = this.fileManager.generateContentBlockFileName(contentBlock);
    const contentBlockFilePath = `${typeFolderPath}/${contentBlockFileName}`;
    await this.fileManager.writeContentBlockFile(contentBlock, contentBlockFilePath, storyTitle);
  }
  async syncScenesToFilesystem(scenesWithBeats, folderPath, storyTitle, contentBlocksByScene, contentBlocksByBeat) {
    const skipRemoteFetch = Boolean(contentBlocksByScene || contentBlocksByBeat);
    for (const { scene, beats } of scenesWithBeats) {
      await this.writeSceneBundle({
        storyTitle,
        folderPath,
        scene,
        beats,
        sceneContentBlocks: contentBlocksByScene == null ? void 0 : contentBlocksByScene.get(scene.id),
        beatContentBlockMap: contentBlocksByBeat,
        skipRemoteContentFetch: skipRemoteFetch
      });
    }
  }
  async syncSceneContentBlocks(scene, beats, folderPath, storyTitle) {
    if (!scene.chapter_id) {
      return;
    }
    const contentBlocks = await this.apiClient.getContentBlocks(scene.chapter_id);
    for (const contentBlock of contentBlocks) {
      const refs = await this.apiClient.getContentAnchors(contentBlock.id);
      const hasSceneRef = refs.some(
        (ref) => ref.entity_type === "scene" && ref.entity_id === scene.id
      );
      const beatIds = beats.map((beat) => beat.id);
      const hasBeatRef = refs.some(
        (ref) => ref.entity_type === "beat" && beatIds.includes(ref.entity_id)
      );
      if (hasSceneRef || hasBeatRef) {
        await this.writeContentBlockToFolder(folderPath, storyTitle, contentBlock);
      }
    }
  }
  async findChapterFileById(folderPath, chapterId) {
    const chapterFiles = await this.fileManager.listChapterFiles(folderPath);
    for (const chapterFilePath of chapterFiles) {
      const file = this.fileManager.getVault().getAbstractFileByPath(chapterFilePath);
      if (!(file instanceof import_obsidian19.TFile)) {
        continue;
      }
      const content = await this.fileManager.getVault().read(file);
      const frontmatter = this.fileManager.parseFrontmatter(content);
      if (frontmatter.id === chapterId) {
        return { path: chapterFilePath, frontmatter };
      }
    }
    return null;
  }
  async findSceneFileById(folderPath, sceneId) {
    const sceneFiles = await this.fileManager.listStorySceneFiles(folderPath);
    for (const sceneFilePath of sceneFiles) {
      const file = this.fileManager.getVault().getAbstractFileByPath(sceneFilePath);
      if (!(file instanceof import_obsidian19.TFile)) {
        continue;
      }
      const content = await this.fileManager.getVault().read(file);
      const frontmatter = this.fileManager.parseFrontmatter(content);
      if (frontmatter.id === sceneId) {
        return { path: sceneFilePath, frontmatter };
      }
    }
    return null;
  }
};

// src/sync-v2/core/ModularSyncEngine.ts
var import_obsidian21 = require("obsidian");

// src/sync-v2/core/EntityRegistry.ts
var EntityRegistry = class {
  constructor() {
    this.handlers = /* @__PURE__ */ new Map();
  }
  register(key, handler) {
    this.handlers.set(key, handler);
  }
  get(key) {
    return this.handlers.get(key);
  }
};

// src/sync-v2/generators/OutlineGenerator.ts
var OutlineGenerator = class {
  constructor(now2 = () => (/* @__PURE__ */ new Date()).toISOString()) {
    this.now = now2;
  }
  generateStoryOutline(story, options = {}) {
    var _a;
    const lines = [];
    const enableHelpBox = options.showHelpBox !== false;
    const idField = getIdFieldName(options.idField);
    lines.push(
      "---",
      `${idField}: ${story.story.id}`,
      "type: story-outline",
      `synced_at: ${(_a = options.syncedAt) != null ? _a : this.now()}`,
      "---",
      "",
      `# ${story.story.title}`,
      "",
      "## Hierarchy",
      ""
    );
    if (enableHelpBox) {
      lines.push(
        "> [!tip] Como editar esta lista",
        "> - **Reordenar**: Arraste itens para mudar a ordem",
        "> - **Criar novo**: Edite a linha `_New..._` no final de cada se\xE7\xE3o",
        "> - **Indenta\xE7\xE3o**: Tab define hierarquia (chapter \u2192 scene \u2192 beat)",
        "> - **Marcadores**: `+` tem conte\xFAdo, `-` est\xE1 vazio",
        ""
      );
    }
    const sections = this.buildSections(
      story.chapters,
      options.includePlaceholders !== false,
      options.storyFolderPath
    );
    sections.forEach((section) => {
      const indent = "	".repeat(section.depth);
      lines.push(`${indent}- ${section.link} ${section.status}`.trimEnd());
    });
    if (options.includePlaceholders !== false) {
      lines.push("- _New chapter: title_");
    }
    return lines.join("\n").trimEnd() + "\n";
  }
  buildSections(chapters, includePlaceholders, storyFolderPath) {
    const sections = [];
    chapters.forEach((chapter, chapterIdx) => {
      var _a;
      const chapterLink = this.buildLink(
        "chapter",
        (_a = chapter.chapter.number) != null ? _a : chapterIdx + 1,
        chapter.chapter.title,
        `Chapter ${chapterIdx + 1}: ${chapter.chapter.title}`,
        storyFolderPath
      );
      sections.push({
        type: "chapter",
        link: chapterLink,
        label: chapter.chapter.title,
        status: this.hasScenesWithContent(chapter.scenes) ? "+" : "-",
        depth: 0
      });
      chapter.scenes.forEach((sceneWrapper, sceneIdx) => {
        var _a2, _b;
        const sceneLabel = this.composeSceneLabel(sceneWrapper);
        const sceneLink = this.buildLink(
          "scene",
          (_a2 = sceneWrapper.scene.order_num) != null ? _a2 : sceneIdx + 1,
          sceneWrapper.scene.goal || `Scene ${sceneIdx + 1}`,
          `Scene ${sceneIdx + 1}: ${sceneLabel}`,
          storyFolderPath,
          { chapterOrder: (_b = chapter.chapter.number) != null ? _b : chapterIdx + 1 }
        );
        sections.push({
          type: "scene",
          link: sceneLink,
          label: sceneLabel,
          status: sceneWrapper.beats.length ? "+" : "-",
          depth: 1
        });
        sceneWrapper.beats.forEach((beat, beatIdx) => {
          var _a3, _b2, _c;
          sections.push({
            type: "beat",
            link: this.buildLink(
              "beat",
              (_a3 = beat.order_num) != null ? _a3 : beatIdx + 1,
              beat.intent || `Beat ${beatIdx + 1}`,
              `Beat ${beatIdx + 1}: ${beat.intent || ""}`,
              storyFolderPath,
              {
                chapterOrder: (_b2 = chapter.chapter.number) != null ? _b2 : chapterIdx + 1,
                sceneOrder: (_c = sceneWrapper.scene.order_num) != null ? _c : sceneIdx + 1
              }
            ),
            label: beat.intent,
            status: beat.outcome ? "+" : "-",
            depth: 2
          });
        });
        if (includePlaceholders) {
          sections.push({
            type: "beat",
            link: "_New beat: intent here..._",
            label: "",
            status: "-",
            depth: 2
          });
        }
      });
      if (includePlaceholders) {
        sections.push({
          type: "scene",
          link: "_New scene: goal - time_",
          label: "",
          status: "-",
          depth: 1
        });
      }
    });
    return sections;
  }
  buildLink(type2, order, title, display, storyFolderPath, overrides) {
    const label = display != null ? display : title;
    if (storyFolderPath) {
      const path = buildStoryEntityPath(storyFolderPath, type2, order, title, overrides);
      return buildWikiLink(path, label);
    }
    const slug = this.slugify(title);
    const prefix = type2 === "chapter" ? "ch" : type2 === "scene" ? "sc" : "bt";
    return `[[${prefix}-${order.toString().padStart(2, "0")}-${slug}|${label}]]`;
  }
  composeSceneLabel(scene) {
    const goal = scene.scene.goal || "Scene";
    const time = scene.scene.time_ref ? ` - ${scene.scene.time_ref}` : "";
    return `${goal}${time}`;
  }
  hasScenesWithContent(scenes) {
    return scenes.some((scene) => scene.beats.length > 0);
  }
  generateChapterOutline(chapter, options = {}) {
    var _a, _b;
    const lines = [];
    const enableHelpBox = options.showHelpBox !== false;
    const idField = getIdFieldName(options.idField);
    lines.push(
      "---",
      `${idField}: ${chapter.chapter.id}`,
      "type: chapter-outline",
      `synced_at: ${(_a = options.syncedAt) != null ? _a : this.now()}`,
      "---",
      "",
      `# ${chapter.chapter.title}`,
      "",
      "## Hierarchy",
      ""
    );
    if (enableHelpBox) {
      lines.push(
        "> [!tip] Como editar esta lista",
        "> - **Reordenar**: Arraste itens para mudar a ordem",
        "> - **Criar novo**: Edite a linha `_New..._` no final de cada se\xE7\xE3o",
        "> - **Indenta\xE7\xE3o**: Tab define hierarquia (scene \u2192 beat)",
        "> - **Marcadores**: `+` tem conte\xFAdo, `-` est\xE1 vazio",
        ""
      );
    }
    const sections = this.buildChapterSections(
      chapter.scenes,
      options.includePlaceholders !== false,
      options.storyFolderPath,
      (_b = chapter.chapter.number) != null ? _b : 0
    );
    sections.forEach((section) => {
      const indent = "	".repeat(section.depth);
      lines.push(`${indent}- ${section.link} ${section.status}`.trimEnd());
    });
    if (options.includePlaceholders !== false) {
      lines.push("- _New scene: goal - time_");
    }
    return lines.join("\n").trimEnd() + "\n";
  }
  buildChapterSections(scenes, includePlaceholders, storyFolderPath, chapterOrder = 0) {
    const sections = [];
    scenes.forEach((sceneWrapper, sceneIdx) => {
      var _a;
      const sceneLabel = this.composeSceneLabel(sceneWrapper);
      const sceneLink = this.buildLink(
        "scene",
        (_a = sceneWrapper.scene.order_num) != null ? _a : sceneIdx + 1,
        sceneWrapper.scene.goal || `Scene ${sceneIdx + 1}`,
        `Scene ${sceneIdx + 1}: ${sceneLabel}`,
        storyFolderPath,
        { chapterOrder }
      );
      sections.push({
        type: "scene",
        link: sceneLink,
        label: sceneLabel,
        status: sceneWrapper.beats.length ? "+" : "-",
        depth: 0
      });
      sceneWrapper.beats.forEach((beat, beatIdx) => {
        var _a2, _b;
        sections.push({
          type: "beat",
          link: this.buildLink(
            "beat",
            (_a2 = beat.order_num) != null ? _a2 : beatIdx + 1,
            beat.intent || `Beat ${beatIdx + 1}`,
            `Beat ${beatIdx + 1}: ${beat.intent || ""}`,
            storyFolderPath,
            {
              chapterOrder,
              sceneOrder: (_b = sceneWrapper.scene.order_num) != null ? _b : sceneIdx + 1
            }
          ),
          label: beat.intent,
          status: beat.outcome ? "+" : "-",
          depth: 1
        });
      });
      if (includePlaceholders) {
        sections.push({
          type: "beat",
          link: "_New beat: intent here..._",
          label: "",
          status: "-",
          depth: 1
        });
      }
    });
    return sections;
  }
  generateSceneOutline(scene, options = {}) {
    var _a;
    const lines = [];
    const enableHelpBox = options.showHelpBox !== false;
    const idField = getIdFieldName(options.idField);
    lines.push(
      "---",
      `${idField}: ${scene.scene.id}`,
      "type: scene-outline",
      `synced_at: ${(_a = options.syncedAt) != null ? _a : this.now()}`,
      "---",
      "",
      `# ${scene.scene.goal || "Untitled Scene"}`,
      "",
      "## Hierarchy",
      ""
    );
    if (enableHelpBox) {
      lines.push(
        "> [!tip] Como editar esta lista",
        "> - **Reordenar**: Arraste itens para mudar a ordem",
        "> - **Criar novo**: Edite a linha `_New..._` no final",
        "> - **Marcadores**: `+` tem conte\xFAdo, `-` est\xE1 vazio",
        ""
      );
    }
    scene.beats.forEach((beat, beatIdx) => {
      var _a2, _b, _c;
      const beatLink = this.buildLink(
        "beat",
        (_a2 = beat.order_num) != null ? _a2 : beatIdx + 1,
        beat.intent || `Beat ${beatIdx + 1}`,
        `Beat ${(_b = beat.order_num) != null ? _b : beatIdx + 1}: ${beat.intent || ""}`,
        options.storyFolderPath,
        { chapterOrder: 0, sceneOrder: (_c = scene.scene.order_num) != null ? _c : 0 }
      );
      lines.push(`- ${beatLink} ${beat.outcome ? "+" : "-"}`);
    });
    if (options.includePlaceholders !== false) {
      lines.push("- _New beat: intent here..._");
    }
    return lines.join("\n").trimEnd() + "\n";
  }
  slugify(value) {
    return value.toLowerCase().normalize("NFKD").replace(/[^a-z0-9\s-]/g, "").trim().replace(/\s+/g, "-").slice(0, 40);
  }
};

// src/sync-v2/parsers/contentsParser.ts
var FENCE_PATTERN = /<!--(chapter|scene|beat|content)-(start|end):(\d{4}):([a-z0-9-]+):([a-zA-Z0-9-]+)-->/gi;
var PLACEHOLDER_DEFAULTS = {
  chapter: "## _New Chapter Title_",
  scene: "### _New Scene Title_\n\n_Describe what happens in this scene..._",
  beat: "#### _New Beat Intent_",
  content: "_Write your content here..._"
};
var ContentsParser = class {
  parseHierarchy(content) {
    const internal = this.parseInternal(content);
    return {
      chapters: internal.chapters.map((f) => this.stripInternalProps(f)),
      orphanScenes: internal.orphanScenes.map((f) => this.stripInternalProps(f)),
      orphanBeats: internal.orphanBeats.map((f) => this.stripInternalProps(f)),
      orphanContents: internal.orphanContents.map((f) => this.stripInternalProps(f))
    };
  }
  parseFencesByType(content, type2) {
    return this.flattenInternal(this.parseInternal(content)).filter((f) => f.type === type2).map((f) => this.stripInternalProps(f));
  }
  detectChanges(oldContent, newContent) {
    const oldMap = new Map(
      this.flattenInternal(this.parseInternal(oldContent)).map((f) => [f.id, f])
    );
    const newMap = new Map(
      this.flattenInternal(this.parseInternal(newContent)).map((f) => [f.id, f])
    );
    const changes = [];
    for (const [id2, newFence] of newMap.entries()) {
      if (!oldMap.has(id2)) {
        changes.push({
          id: id2,
          type: newFence.type,
          changeType: "created",
          newOrder: newFence.order,
          newParentId: newFence.parentId
        });
        continue;
      }
      const oldFence = oldMap.get(id2);
      if (oldFence.parentId !== newFence.parentId) {
        changes.push({
          id: id2,
          type: newFence.type,
          changeType: "moved",
          oldParentId: oldFence.parentId,
          newParentId: newFence.parentId
        });
      } else if (oldFence.order !== newFence.order) {
        changes.push({
          id: id2,
          type: newFence.type,
          changeType: "reordered",
          oldOrder: oldFence.order,
          newOrder: newFence.order
        });
      } else if (oldFence.innerText !== newFence.innerText) {
        changes.push({
          id: id2,
          type: newFence.type,
          changeType: "updated"
        });
      }
    }
    for (const [id2, oldFence] of oldMap.entries()) {
      if (!newMap.has(id2)) {
        changes.push({
          id: id2,
          type: oldFence.type,
          changeType: "deleted",
          oldOrder: oldFence.order,
          oldParentId: oldFence.parentId
        });
      }
    }
    return changes;
  }
  generateFenceStart(type2, order, name, id2) {
    return `<!--${type2}-start:${order.toString().padStart(4, "0")}:${name}:${id2}-->`;
  }
  generateFenceEnd(type2, order, name, id2) {
    return `<!--${type2}-end:${order.toString().padStart(4, "0")}:${name}:${id2}-->`;
  }
  generateFence(type2, order, name, id2, innerContent) {
    return `${this.generateFenceStart(type2, order, name, id2)}
${innerContent}
${this.generateFenceEnd(
      type2,
      order,
      name,
      id2
    )}`;
  }
  updateFenceContent(content, id2, newInnerContent) {
    const target = this.flattenInternal(this.parseInternal(content)).find((f) => f.id === id2);
    if (!target) {
      return content;
    }
    const before = content.slice(0, target.contentStart);
    const after = content.slice(target.contentEnd);
    return `${before}${newInnerContent}${after}`;
  }
  updateFenceMeta(content, id2, newOrder, newName) {
    return content.replace(
      new RegExp(`(<!--(chapter|scene|beat|content)-(start|end):)\\d{4}:([a-z0-9-]+):(${id2})-->`, "gi"),
      (_, prefix) => `${prefix}${newOrder.toString().padStart(4, "0")}:${newName}:${id2}-->`
    );
  }
  removeFence(content, id2) {
    var _a, _b;
    const matches = [...content.matchAll(FENCE_PATTERN)].filter((match) => match[5] === id2);
    if (matches.length < 2) {
      return content;
    }
    const start2 = (_a = matches[0].index) != null ? _a : 0;
    const end = ((_b = matches[matches.length - 1].index) != null ? _b : 0) + matches[matches.length - 1][0].length;
    return content.slice(0, start2) + content.slice(end);
  }
  recalculateOrders(content, type2) {
    const fences = this.flattenInternal(this.parseInternal(content)).filter((f) => f.type === type2).sort((a, b) => a.positionInFile - b.positionInFile);
    let updated = content;
    fences.forEach((fence, index) => {
      const desiredOrder = index + 1;
      if (fence.order !== desiredOrder) {
        updated = this.updateFenceMeta(updated, fence.id, desiredOrder, fence.name);
      }
    });
    return updated;
  }
  sanitizeName(title) {
    return title.toLowerCase().replace(/[^a-z0-9\s-]/g, "").trim().replace(/\s+/g, "-").slice(0, 30);
  }
  isPlaceholder(fence) {
    return fence.order === 0 || fence.name.startsWith("new-") || fence.id === "placeholder";
  }
  isModifiedPlaceholder(fence) {
    if (!this.isPlaceholder(fence)) {
      return false;
    }
    const defaultContent = PLACEHOLDER_DEFAULTS[fence.type];
    return fence.innerText !== defaultContent.trim();
  }
  generatePlaceholder(type2, parentId) {
    const name = `new-${type2}${parentId ? `-${parentId.slice(0, 6)}` : ""}`;
    return this.generateFence(type2, 0, name, "placeholder", PLACEHOLDER_DEFAULTS[type2]);
  }
  ensurePlaceholders(content) {
    let updated = content;
    for (const type2 of ["chapter", "scene", "beat", "content"]) {
      const hasPlaceholder = this.parseFencesByType(updated, type2).some((f) => this.isPlaceholder(f));
      if (!hasPlaceholder) {
        updated = `${updated.trimEnd()}
${this.generatePlaceholder(type2)}
`;
      }
    }
    return updated;
  }
  replacePlaceholder(content, placeholderPosition, realFence) {
    const internal = this.parseInternal(content);
    const target = this.flattenInternal(internal).find(
      (f) => f.id === "placeholder" && placeholderPosition >= f.startIndex && placeholderPosition <= f.endIndex
    );
    if (!target) {
      return content;
    }
    const replacement = this.generateFence(
      realFence.type,
      realFence.order,
      realFence.name,
      realFence.id,
      realFence.content
    );
    return content.slice(0, target.startIndex) + replacement + content.slice(target.endIndex);
  }
  parseInternal(content) {
    var _a, _b, _c, _d, _e;
    const normalizedContent = this.normalizeLegacyPlaceholders(content);
    const stack = [];
    const chapters = [];
    const orphanScenes = [];
    const orphanBeats = [];
    const orphanContents = [];
    const finalize = (fence) => {
      if (fence.type === "scene" && !fence.parentId) {
        orphanScenes.push(fence);
      } else if (fence.type === "beat" && !fence.parentId) {
        orphanBeats.push(fence);
      } else if (fence.type === "content" && !fence.parentId) {
        orphanContents.push(fence);
      } else if (fence.type === "chapter") {
        chapters.push(fence);
      }
    };
    for (const match of normalizedContent.matchAll(FENCE_PATTERN)) {
      const full = match[0];
      const type2 = (_a = match[1]) == null ? void 0 : _a.toLowerCase();
      const action = match[2];
      const order = parseInt(match[3], 10);
      const name = match[4];
      const id2 = match[5];
      const index = (_b = match.index) != null ? _b : 0;
      if (action === "start") {
        const fence = {
          type: type2,
          id: id2,
          order,
          name,
          content: "",
          innerText: "",
          startLine: this.getLineNumber(normalizedContent, index),
          endLine: this.getLineNumber(normalizedContent, index),
          positionInFile: index,
          children: [],
          contentStart: index + full.length,
          contentEnd: index + full.length,
          startIndex: index,
          endIndex: index + full.length,
          parentId: void 0
        };
        if (stack.length > 0) {
          const parent = stack[stack.length - 1];
          parent.children.push(fence);
          fence.parentId = parent.id;
        }
        stack.push(fence);
      } else {
        const fence = stack.pop();
        if (!fence || fence.id !== id2) {
          throw new Error(`Unmatched fence end for id "${id2}".`);
        }
        fence.contentEnd = (_c = match.index) != null ? _c : fence.contentStart;
        fence.endIndex = ((_d = match.index) != null ? _d : 0) + full.length;
        fence.endLine = this.getLineNumber(normalizedContent, fence.endIndex);
        fence.content = normalizedContent.slice(fence.contentStart, (_e = match.index) != null ? _e : 0);
        fence.innerText = this.stripFences(fence.content).trim();
        if (stack.length === 0) {
          finalize(fence);
        }
      }
    }
    return { chapters, orphanScenes, orphanBeats, orphanContents };
  }
  flattenInternal(hierarchy) {
    const result = [];
    const visit = (fence) => {
      result.push(fence);
      fence.children.forEach((child) => visit(child));
    };
    hierarchy.chapters.forEach(visit);
    hierarchy.orphanScenes.forEach(visit);
    hierarchy.orphanBeats.forEach(visit);
    hierarchy.orphanContents.forEach(visit);
    return result;
  }
  stripInternalProps(fence) {
    const { contentStart: _cS, contentEnd: _cE, startIndex: _sI, endIndex: _eI, ...rest } = fence;
    return {
      ...rest,
      children: fence.children.map((child) => this.stripInternalProps(child))
    };
  }
  stripFences(innerContent) {
    return innerContent.replace(FENCE_PATTERN, "").trim();
  }
  getLineNumber(content, index) {
    return content.slice(0, index).split("\n").length;
  }
  normalizeLegacyPlaceholders(content) {
    return content.replace(/<!--\s*new-(chapter|scene|beat|content)\s*-->/gi, (_match, type2) => {
      const fenceType = type2.toLowerCase();
      return `
${this.generatePlaceholder(fenceType)}
`;
    });
  }
};

// src/sync-v2/generators/ContentsGenerator.ts
var ContentsGenerator = class {
  constructor(now2 = () => (/* @__PURE__ */ new Date()).toISOString()) {
    this.now = now2;
    this.parser = new ContentsParser();
  }
  generateStoryContents(input) {
    var _a, _b, _c;
    const { story, chapters } = input;
    const lines = [];
    const idField = getIdFieldName((_a = input.options) == null ? void 0 : _a.idField);
    lines.push(
      "---",
      `${idField}: ${story.id}`,
      "type: story-contents",
      `synced_at: ${(_c = (_b = input.options) == null ? void 0 : _b.syncedAt) != null ? _c : this.now()}`,
      "---",
      "",
      `# ${story.title} - Contents`,
      ""
    );
    chapters.forEach((chapter, chapterIdx) => {
      const chapterContent = this.buildChapterContent(chapter, chapterIdx, input);
      lines.push(chapterContent);
    });
    return lines.join("\n").trimEnd() + "\n";
  }
  buildChapterContent(chapter, index, input) {
    var _a, _b;
    const chapterName = this.slugify(chapter.chapter.title);
    const order = index + 1;
    const contentLines = [];
    contentLines.push(`## Chapter ${order}: ${chapter.chapter.title}`, "");
    const chapterBlocks = (_b = (_a = input.chapterContentBlocks) == null ? void 0 : _a.get(chapter.chapter.id)) != null ? _b : [];
    chapterBlocks.sort((a, b) => {
      var _a2, _b2;
      return ((_a2 = a.order_num) != null ? _a2 : 0) - ((_b2 = b.order_num) != null ? _b2 : 0);
    }).forEach((block) => {
      contentLines.push(this.renderContentBlock(block));
    });
    chapter.scenes.forEach((scene, sceneIdx) => {
      contentLines.push(
        this.buildSceneSection(scene, sceneIdx, chapter.chapter.id, input)
      );
    });
    contentLines.push(this.parser.generatePlaceholder("scene"));
    return this.parser.generateFence(
      "chapter",
      order,
      chapterName,
      chapter.chapter.id,
      contentLines.join("\n").trimEnd()
    );
  }
  buildSceneSection(scene, index, chapterId, input) {
    var _a, _b;
    const lines = [];
    const order = index + 1;
    const sceneName = this.slugify(scene.scene.goal || `scene-${order}`);
    lines.push(`### Scene ${order}: ${scene.scene.goal || "Untitled"}`, "");
    const sceneBlocks = (_b = (_a = input.sceneContentBlocks) == null ? void 0 : _a.get(scene.scene.id)) != null ? _b : [];
    if (sceneBlocks.length === 0) {
      lines.push(this.parser.generatePlaceholder("content"));
    } else {
      sceneBlocks.sort((a, b) => {
        var _a2, _b2;
        return ((_a2 = a.order_num) != null ? _a2 : 0) - ((_b2 = b.order_num) != null ? _b2 : 0);
      }).forEach((block) => {
        lines.push(this.renderContentBlock(block));
      });
    }
    scene.beats.forEach((beat, beatIdx) => {
      lines.push(this.buildBeatSection(beat, beatIdx, input));
    });
    lines.push(this.parser.generatePlaceholder("beat"));
    return this.parser.generateFence(
      "scene",
      order,
      sceneName,
      scene.scene.id,
      lines.join("\n").trimEnd()
    );
  }
  buildBeatSection(beat, index, input) {
    var _a, _b;
    const lines = [];
    const order = index + 1;
    const beatName = this.slugify(beat.intent || `beat-${order}`);
    lines.push(`#### Beat ${order}: ${beat.intent || "Untitled"}`, "");
    const beatBlocks = (_b = (_a = input.beatContentBlocks) == null ? void 0 : _a.get(beat.id)) != null ? _b : [];
    if (beatBlocks.length === 0) {
      lines.push(this.parser.generatePlaceholder("content"));
    } else {
      beatBlocks.sort((a, b) => {
        var _a2, _b2;
        return ((_a2 = a.order_num) != null ? _a2 : 0) - ((_b2 = b.order_num) != null ? _b2 : 0);
      }).forEach((block) => {
        lines.push(this.renderContentBlock(block));
      });
    }
    return this.parser.generateFence(
      "beat",
      order,
      beatName,
      beat.id,
      lines.join("\n").trimEnd()
    );
  }
  generateSceneContents(scene, sceneContentBlocks, beatContentBlocks, options = {}) {
    var _a, _b;
    const lines = [];
    const idField = getIdFieldName(options.idField);
    lines.push(
      "---",
      `${idField}: ${scene.scene.id}`,
      "type: scene-contents",
      `synced_at: ${(_a = options.syncedAt) != null ? _a : this.now()}`,
      "---",
      "",
      `# ${scene.scene.goal || "Untitled Scene"} - Contents`,
      ""
    );
    const sceneBlocks = (_b = sceneContentBlocks.get(scene.scene.id)) != null ? _b : [];
    if (sceneBlocks.length === 0) {
      lines.push(this.parser.generatePlaceholder("content"));
    } else {
      sceneBlocks.sort((a, b) => {
        var _a2, _b2;
        return ((_a2 = a.order_num) != null ? _a2 : 0) - ((_b2 = b.order_num) != null ? _b2 : 0);
      }).forEach((block) => {
        lines.push(this.renderContentBlock(block));
      });
    }
    scene.beats.forEach((beat, beatIdx) => {
      lines.push(this.buildBeatSection(beat, beatIdx, {
        story: {
          id: scene.scene.story_id,
          tenant_id: "",
          title: "",
          status: "draft",
          version_number: 1,
          root_story_id: scene.scene.story_id,
          previous_story_id: null,
          created_by_user_id: "",
          world_id: null,
          created_at: "",
          updated_at: ""
        },
        chapters: [],
        chapterContentBlocks: /* @__PURE__ */ new Map(),
        sceneContentBlocks,
        beatContentBlocks,
        options
      }));
    });
    lines.push(this.parser.generatePlaceholder("beat"));
    return lines.join("\n").trimEnd() + "\n";
  }
  generateBeatContents(beat, beatContentBlocks, options = {}) {
    var _a, _b, _c;
    const lines = [];
    const idField = getIdFieldName(options.idField);
    lines.push(
      "---",
      `${idField}: ${beat.id}`,
      "type: beat-contents",
      `synced_at: ${(_a = options.syncedAt) != null ? _a : this.now()}`,
      "---",
      "",
      `# Beat ${(_b = beat.order_num) != null ? _b : 0}: ${beat.intent || "Untitled"} - Contents`,
      ""
    );
    const beatBlocks = (_c = beatContentBlocks.get(beat.id)) != null ? _c : [];
    if (beatBlocks.length === 0) {
      lines.push(this.parser.generatePlaceholder("content"));
    } else {
      beatBlocks.sort((a, b) => {
        var _a2, _b2;
        return ((_a2 = a.order_num) != null ? _a2 : 0) - ((_b2 = b.order_num) != null ? _b2 : 0);
      }).forEach((block) => {
        lines.push(this.renderContentBlock(block));
      });
    }
    return lines.join("\n").trimEnd() + "\n";
  }
  renderContentBlock(block) {
    var _a, _b;
    const name = this.slugify(((_a = block.metadata) == null ? void 0 : _a.title) || block.kind || `content-${block.id}`);
    const fence = this.parser.generateFence(
      "content",
      (_b = block.order_num) != null ? _b : 0,
      name,
      block.id,
      block.content.trim() || "*No content yet*"
    );
    return fence;
  }
  generateChapterContents(chapter, chapterContentBlocks, sceneContentBlocks, beatContentBlocks, options = {}) {
    var _a, _b;
    const lines = [];
    const idField = getIdFieldName(options.idField);
    lines.push(
      "---",
      `${idField}: ${chapter.chapter.id}`,
      "type: chapter-contents",
      `synced_at: ${(_a = options.syncedAt) != null ? _a : this.now()}`,
      "---",
      "",
      `# ${chapter.chapter.title} - Contents`,
      ""
    );
    const chapterBlocks = (_b = chapterContentBlocks.get(chapter.chapter.id)) != null ? _b : [];
    chapterBlocks.sort((a, b) => {
      var _a2, _b2;
      return ((_a2 = a.order_num) != null ? _a2 : 0) - ((_b2 = b.order_num) != null ? _b2 : 0);
    }).forEach((block) => {
      lines.push(this.renderContentBlock(block));
    });
    chapter.scenes.forEach((scene, sceneIdx) => {
      lines.push(
        this.buildSceneSection(scene, sceneIdx, chapter.chapter.id, {
          story: {
            id: chapter.chapter.story_id,
            tenant_id: "",
            title: "",
            status: "draft",
            version_number: 1,
            root_story_id: chapter.chapter.story_id,
            previous_story_id: null,
            created_by_user_id: "",
            world_id: null,
            created_at: "",
            updated_at: ""
          },
          chapters: [],
          chapterContentBlocks,
          sceneContentBlocks,
          beatContentBlocks,
          options
        })
      );
    });
    lines.push(this.parser.generatePlaceholder("scene"));
    return lines.join("\n").trimEnd() + "\n";
  }
  slugify(value) {
    return value.toLowerCase().normalize("NFKD").replace(/[^a-z0-9\s-]/g, "").trim().replace(/\s+/g, "-").slice(0, 40);
  }
};

// src/sync-v2/diff/DiffEngine.ts
var FENCE_PATTERN2 = /<!--(chapter|scene|beat|content)-(start|end):(\d{4}):([a-z0-9-]+):([a-zA-Z0-9-]+)-->/gi;
var DiffEngine = class {
  constructor() {
    this.contentsParser = new ContentsParser();
  }
  diffContents(local, generated) {
    const changes = this.contentsParser.detectChanges(local, generated);
    return {
      operations: changes.map((change) => this.toDiffOperation(change)),
      untrackedSegments: this.findUntrackedSegments(local)
    };
  }
  toDiffOperation(change) {
    let kind = "updated";
    if (change.changeType === "created")
      kind = "created";
    else if (change.changeType === "deleted")
      kind = "deleted";
    else if (change.changeType === "moved")
      kind = "moved";
    else if (change.changeType === "reordered")
      kind = "reordered";
    return {
      kind,
      fenceId: change.id,
      fenceType: change.type,
      metadata: {
        oldOrder: change.oldOrder,
        newOrder: change.newOrder,
        oldParentId: change.oldParentId,
        newParentId: change.newParentId
      }
    };
  }
  findUntrackedSegments(content) {
    const trimmedContent = this.stripFrontmatter(content);
    const ranges = this.getFenceRanges(trimmedContent);
    const segments = [];
    let cursor = 0;
    for (const range of ranges) {
      if (range.start > cursor) {
        const snippet = trimmedContent.slice(cursor, range.start).trim();
        if (snippet.length > 0) {
          segments.push(snippet);
        }
      }
      cursor = Math.max(cursor, range.end);
    }
    if (cursor < trimmedContent.length) {
      const snippet = trimmedContent.slice(cursor).trim();
      if (snippet.length > 0) {
        segments.push(snippet);
      }
    }
    return segments;
  }
  getFenceRanges(content) {
    var _a;
    const stack = [];
    const ranges = [];
    for (const match of content.matchAll(FENCE_PATTERN2)) {
      const action = match[2];
      const id2 = match[5];
      const index = (_a = match.index) != null ? _a : 0;
      if (action === "start") {
        stack.push({ id: id2, start: index });
      } else {
        const startEntryIndex = stack.findLastIndex((entry) => entry.id === id2);
        if (startEntryIndex === -1) {
          continue;
        }
        const startEntry = stack[startEntryIndex];
        stack.splice(startEntryIndex, 1);
        const end = index + match[0].length;
        ranges.push({ start: startEntry.start, end });
      }
    }
    return ranges.sort((a, b) => a.start - b.start);
  }
  stripFrontmatter(content) {
    const match = content.match(/^---\n[\s\S]*?\n---\n?/);
    return match ? content.slice(match[0].length) : content;
  }
};

// src/sync-v2/diff/ContentsReconciler.ts
var ContentsReconciler = class {
  constructor(diffEngine = new DiffEngine()) {
    this.diffEngine = diffEngine;
  }
  reconcile(localContent, generatedContent) {
    if (!localContent) {
      return {
        mergedContent: generatedContent,
        diff: { operations: [], untrackedSegments: [] },
        warnings: []
      };
    }
    const diff = this.diffEngine.diffContents(localContent, generatedContent);
    let mergedContent = generatedContent;
    const warnings = [];
    if (diff.untrackedSegments.length > 0) {
      const untrackedBlock = [
        "",
        "<!-- story-engine/untracked-start -->",
        "> [!warning] Texto preservado",
        "> Estas linhas n\xE3o foram reconhecidas pelo sync. Revise e mova para a se\xE7\xE3o correta.",
        "",
        diff.untrackedSegments.join("\n\n"),
        "",
        "<!-- story-engine/untracked-end -->",
        ""
      ].join("\n");
      mergedContent = `${generatedContent.trimEnd()}
${untrackedBlock}`;
      warnings.push({
        code: "contents_untracked_segments",
        message: `Preservamos ${diff.untrackedSegments.length} trechos n\xE3o reconhecidos em story.contents.`,
        details: diff.untrackedSegments,
        severity: "warning"
      });
    }
    return {
      mergedContent,
      diff,
      warnings
    };
  }
};

// src/sync-v2/parsers/outlineParser.ts
var PLACEHOLDER_PATTERN = /^_(.+)_$/;
var LINK_PATTERN = /\[\[([^[\]|]+)(?:\|([^[\]]+))?\]\]/;
var OutlineParser = class {
  parse(markdown) {
    const entries = [];
    const counters = {
      chapter: 0,
      scene: 0,
      beat: 0
    };
    for (const rawLine of markdown.split("\n")) {
      const line = rawLine.replace(/\r$/, "");
      if (!line.trim() || line.trimStart().startsWith(">")) {
        continue;
      }
      const entry = this.parseLine(line, counters);
      if (entry) {
        entries.push(entry);
      }
    }
    return entries;
  }
  sanitizeTitle(title) {
    return title.normalize("NFKD").replace(/[^\w\s-]/g, "").replace(/\s+/g, " ").trim();
  }
  formatEntry(entry) {
    const indent = "	".repeat(entry.depth);
    const marker = entry.status === "has_content" ? "+" : "-";
    const display = entry.status === "placeholder" && entry.placeholderLabel ? `_${entry.placeholderLabel}_` : entry.link ? `[[${entry.link}|${entry.title}]]` : entry.title;
    return `${indent}- ${display} ${marker}`.trimEnd();
  }
  parseLine(line, counters) {
    var _a;
    const match = line.match(/^([\t ]*)([-+])\s+(.+)$/);
    if (!match) {
      return null;
    }
    const [, indent, , restRaw] = match;
    const depth = this.computeDepth(indent);
    const type2 = this.depthToType(depth);
    if (!type2) {
      return null;
    }
    let rest = restRaw.trim();
    let status = "empty";
    const trailingStatus = rest.match(/([+-])\s*$/);
    if (trailingStatus) {
      status = trailingStatus[1] === "+" ? "has_content" : "empty";
      rest = rest.slice(0, trailingStatus.index).trim();
    }
    const placeholder = rest.match(PLACEHOLDER_PATTERN);
    let placeholderLabel;
    if (placeholder) {
      status = "placeholder";
      placeholderLabel = placeholder[1];
    }
    const linkMatch = rest.match(LINK_PATTERN);
    let link;
    let title = rest;
    if (linkMatch) {
      link = linkMatch[1].trim();
      title = ((_a = linkMatch[2]) != null ? _a : linkMatch[1]).trim();
    } else if (placeholderLabel) {
      title = placeholderLabel.replace(/^_+|_+$/g, "").trim();
    }
    counters[type2] += 1;
    return {
      type: type2,
      title: this.sanitizeTitle(title),
      link,
      raw: line,
      status,
      depth,
      order: counters[type2],
      placeholderLabel
    };
  }
  computeDepth(indent) {
    const tabs = (indent.match(/\t/g) || []).length;
    const spaces = indent.replace(/\t/g, "").length;
    return tabs + Math.floor(spaces / 2);
  }
  depthToType(depth) {
    if (depth <= 0)
      return "chapter";
    if (depth === 1)
      return "scene";
    if (depth >= 2)
      return "beat";
    return null;
  }
};

// src/sync-v2/diff/OutlineReconciler.ts
var OutlineReconciler = class {
  constructor() {
    this.outlineParser = new OutlineParser();
  }
  reconcile(localContent, generatedContent) {
    var _a;
    if (!localContent) {
      return generatedContent;
    }
    const localEntries = this.outlineParser.parse(localContent);
    const generatedEntries = this.outlineParser.parse(generatedContent);
    const localEntryMap = new Map(localEntries.map((entry) => [this.buildEntryKey(entry), entry.raw]));
    const generatedLines = generatedContent.split("\n");
    const entryQueueByRaw = this.buildEntryQueues(generatedEntries);
    const mergedLines = [];
    for (const line of generatedLines) {
      const queue = entryQueueByRaw.get(line);
      if (queue && queue.length > 0) {
        const entry = queue.shift();
        const key = this.buildEntryKey(entry);
        mergedLines.push((_a = localEntryMap.get(key)) != null ? _a : line);
      } else {
        mergedLines.push(line);
      }
    }
    const untracked = this.collectUntrackedSegments(localContent, new Set(localEntries.map((entry) => entry.raw)));
    if (untracked.length > 0) {
      mergedLines.push(
        "",
        "<!-- story-engine/untracked-start -->",
        "> [!warning] Texto preservado",
        "> Estas linhas n\xE3o foram reconhecidas pelo sync. Revise e mova para a se\xE7\xE3o correta.",
        "",
        untracked.join("\n"),
        "",
        "<!-- story-engine/untracked-end -->",
        ""
      );
    }
    return mergedLines.join("\n");
  }
  buildEntryQueues(entries) {
    var _a;
    const queues = /* @__PURE__ */ new Map();
    for (const entry of entries) {
      const bucket = (_a = queues.get(entry.raw)) != null ? _a : [];
      bucket.push(entry);
      queues.set(entry.raw, bucket);
    }
    return queues;
  }
  buildEntryKey(entry) {
    if (entry.link) {
      return `${entry.type}:${entry.link}`;
    }
    if (entry.placeholderLabel) {
      return `${entry.type}:placeholder:${entry.placeholderLabel.toLowerCase()}:${entry.depth}`;
    }
    return `${entry.type}:${entry.title.toLowerCase()}:${entry.depth}`;
  }
  collectUntrackedSegments(localContent, trackedLines) {
    const untracked = [];
    let insideBlock = false;
    for (const line of localContent.split("\n")) {
      if (line.includes("<!-- story-engine/untracked-start -->")) {
        insideBlock = true;
        continue;
      }
      if (line.includes("<!-- story-engine/untracked-end -->")) {
        insideBlock = false;
        continue;
      }
      if (insideBlock) {
        continue;
      }
      if (!trackedLines.has(line) && line.trim().length > 0) {
        untracked.push(line);
      }
    }
    return untracked;
  }
};

// src/sync-v2/fileRenamer/FileRenamer.ts
var FileRenamer = class {
  constructor(context) {
    this.context = context;
  }
  async rename(request) {
    var _a;
    await this.context.fileManager.renameFile(request.oldPath, request.newPath);
    const updatedReferences = await this.updateReferences((_a = request.references) != null ? _a : []);
    return {
      oldPath: request.oldPath,
      newPath: request.newPath,
      updatedReferences
    };
  }
  async updateReferences(updates) {
    let updatedFiles = 0;
    for (const update of updates) {
      const original = await this.context.fileManager.readFile(update.filePath);
      let modified = original;
      for (const replacement of update.replacements) {
        modified = modified.replace(replacement.pattern, replacement.replacement);
      }
      if (modified !== original) {
        await this.context.fileManager.writeFile(update.filePath, modified);
        updatedFiles += 1;
      }
    }
    return updatedFiles;
  }
};

// src/sync-v2/push/OutlinePushHandler.ts
var OutlinePushHandler = class {
  constructor(parser = new OutlineParser()) {
    this.parser = parser;
  }
  async analyzeOutline(outlineFilePath, storyId, context) {
    const warnings = [];
    const actions = [];
    let outlineContent;
    try {
      outlineContent = await context.fileManager.readFile(outlineFilePath);
    } catch (e) {
      warnings.push("Outline file not found");
      return { actions, warnings };
    }
    const entries = this.parser.parse(outlineContent).filter(
      (entry) => entry.type === "chapter" && entry.link
    );
    const story = await context.apiClient.getStory(storyId);
    const hierarchy = await context.apiClient.getStoryWithHierarchy(storyId);
    const storyFolder = context.fileManager.getStoryFolderPath(story.title);
    const localOrderByChapterId = /* @__PURE__ */ new Map();
    for (const entry of entries) {
      const chapterId = await this.resolveChapterId(storyFolder, entry.link, context);
      if (chapterId) {
        localOrderByChapterId.set(chapterId, entry.order);
      } else {
        warnings.push(`Could not resolve chapter ID for link: ${entry.link}`);
      }
    }
    for (const chapterWithContent of hierarchy.chapters) {
      const remoteChapter = chapterWithContent.chapter;
      const localOrder = localOrderByChapterId.get(remoteChapter.id);
      if (localOrder !== void 0 && localOrder !== remoteChapter.number) {
        actions.push({
          type: "chapter_reorder",
          chapterId: remoteChapter.id,
          oldOrder: remoteChapter.number,
          newOrder: localOrder
        });
      }
    }
    return { actions, warnings };
  }
  /**
   * Resolve a chapter link to its ID by reading the chapter file's frontmatter.
   * Tries both `00-chapters/` and `chapters/` folder conventions.
   */
  async resolveChapterId(storyFolder, link, context) {
    const isFullPath = link.includes("/") || link.endsWith(".md");
    if (isFullPath) {
      const path = link.endsWith(".md") ? link : `${link}.md`;
      try {
        const content = await context.fileManager.readFile(path);
        const frontmatter = parseFrontmatter(content);
        const id2 = getFrontmatterId(frontmatter, context.settings.frontmatterIdField);
        if (id2)
          return id2;
      } catch (e) {
      }
    }
    const possiblePaths = [
      `${storyFolder}/00-chapters/${link}.md`,
      `${storyFolder}/chapters/${link}.md`
    ];
    for (const path of possiblePaths) {
      try {
        const content = await context.fileManager.readFile(path);
        const frontmatter = parseFrontmatter(content);
        const id2 = getFrontmatterId(frontmatter, context.settings.frontmatterIdField);
        if (id2)
          return id2;
      } catch (e) {
      }
    }
    return null;
  }
};

// src/sync-v2/push/PushPlanner.ts
var PushPlanner = class {
  constructor(diffEngine = new DiffEngine(), contentsParser = new ContentsParser()) {
    this.diffEngine = diffEngine;
    this.contentsParser = contentsParser;
  }
  buildPlan(remoteContents, localContents) {
    const diffRemoteVsLocal = this.diffEngine.diffContents(remoteContents, localContents);
    const diffLocalVsRemote = this.diffEngine.diffContents(localContents, remoteContents);
    const localMap = this.buildFenceMap(localContents);
    const actions = [];
    const unsupported = [];
    const warnings = [];
    for (const op of diffRemoteVsLocal.operations) {
      switch (op.fenceType) {
        case "chapter":
          this.handleChapterOperation(op, actions, unsupported);
          break;
        case "scene":
          this.handleSceneOperation(op, actions, unsupported, localMap);
          break;
        case "beat":
          this.handleBeatOperation(op, actions, unsupported, localMap);
          break;
        case "content":
          this.handleContentOperation(op, actions, unsupported, localMap);
          break;
        default:
          unsupported.push(op);
          break;
      }
    }
    if (unsupported.length > 0) {
      warnings.push({
        code: "push_unsupported_operations",
        message: `Detectamos ${unsupported.length} mudan\xE7as locais ainda n\xE3o suportadas pelo push autom\xE1tico.`,
        details: unsupported,
        severity: "warning"
      });
    }
    if (diffLocalVsRemote.untrackedSegments.length > 0) {
      warnings.push({
        code: "push_untracked_segments",
        message: `H\xE1 ${diffLocalVsRemote.untrackedSegments.length} trechos fora das fences; revise antes de tentar enviar.`,
        details: diffLocalVsRemote.untrackedSegments,
        severity: "warning"
      });
    }
    return {
      actions,
      unsupportedOperations: unsupported,
      untrackedSegments: diffLocalVsRemote.untrackedSegments,
      warnings
    };
  }
  handleChapterOperation(op, actions, unsupported) {
    var _a;
    if (op.kind === "reordered" && ((_a = op.metadata) == null ? void 0 : _a.newOrder)) {
      actions.push({
        type: "chapter_reorder",
        chapterId: op.fenceId,
        oldOrder: op.metadata.oldOrder,
        newOrder: op.metadata.newOrder
      });
      return;
    }
    unsupported.push(op);
  }
  handleSceneOperation(op, actions, unsupported, localMap) {
    var _a, _b, _c, _d, _e;
    if (op.kind === "reordered" && ((_a = op.metadata) == null ? void 0 : _a.newOrder)) {
      const scene = localMap.get(op.fenceId);
      actions.push({
        type: "scene_reorder",
        sceneId: op.fenceId,
        chapterId: scene == null ? void 0 : scene.parentId,
        oldOrder: op.metadata.oldOrder,
        newOrder: op.metadata.newOrder
      });
      return;
    }
    if (op.kind === "moved") {
      actions.push({
        type: "scene_move",
        sceneId: op.fenceId,
        fromChapterId: (_c = (_b = op.metadata) == null ? void 0 : _b.oldParentId) != null ? _c : null,
        toChapterId: (_e = (_d = op.metadata) == null ? void 0 : _d.newParentId) != null ? _e : null
      });
      return;
    }
    unsupported.push(op);
  }
  handleBeatOperation(op, actions, unsupported, localMap) {
    var _a, _b, _c;
    if (op.kind === "reordered" && ((_a = op.metadata) == null ? void 0 : _a.newOrder)) {
      const beat = localMap.get(op.fenceId);
      actions.push({
        type: "beat_reorder",
        beatId: op.fenceId,
        sceneId: beat == null ? void 0 : beat.parentId,
        oldOrder: op.metadata.oldOrder,
        newOrder: op.metadata.newOrder
      });
      return;
    }
    if (op.kind === "moved" && ((_b = op.metadata) == null ? void 0 : _b.newParentId)) {
      actions.push({
        type: "beat_move",
        beatId: op.fenceId,
        fromSceneId: (_c = op.metadata.oldParentId) != null ? _c : null,
        toSceneId: op.metadata.newParentId
      });
      return;
    }
    unsupported.push(op);
  }
  handleContentOperation(op, actions, unsupported, localMap) {
    if (op.kind === "updated") {
      const fence = localMap.get(op.fenceId);
      if (fence && fence.innerText.trim().length > 0) {
        actions.push({
          type: "content_update",
          contentBlockId: op.fenceId,
          newContent: fence.innerText.trim()
        });
        return;
      }
    }
    unsupported.push(op);
  }
  buildFenceMap(content) {
    const hierarchy = this.contentsParser.parseHierarchy(content);
    const flattened = this.flattenHierarchy(hierarchy);
    return new Map(flattened.map((fence) => [fence.id, fence]));
  }
  flattenHierarchy(hierarchy) {
    const result = [];
    const visit = (fence) => {
      result.push(fence);
      fence.children.forEach(visit);
    };
    const buckets = [
      hierarchy.chapters,
      hierarchy.orphanScenes,
      hierarchy.orphanBeats,
      hierarchy.orphanContents
    ];
    buckets.forEach((bucket) => bucket.forEach(visit));
    return result;
  }
};

// src/sync-v2/push/PushExecutor.ts
var PushExecutor = class {
  constructor(apiClient, citationService) {
    this.apiClient = apiClient;
    this.citationService = citationService;
  }
  async execute(actions, options) {
    const summary = {
      applied: 0,
      errors: []
    };
    for (const action of actions) {
      try {
        await this.applyAction(action, options == null ? void 0 : options.worldId);
        summary.applied += 1;
      } catch (error) {
        summary.errors.push({
          code: `push_${action.type}`,
          message: error instanceof Error ? error.message : "Unknown error while executing push action.",
          details: action,
          recoverable: true
        });
      }
    }
    return summary;
  }
  async applyAction(action, worldId) {
    var _a, _b;
    switch (action.type) {
      case "chapter_reorder":
        await this.apiClient.updateChapter(action.chapterId, {
          number: action.newOrder
        });
        return;
      case "scene_reorder":
        await this.apiClient.updateScene(action.sceneId, {
          order_num: action.newOrder
        });
        return;
      case "scene_move":
        await this.apiClient.moveScene(action.sceneId, (_a = action.toChapterId) != null ? _a : null);
        return;
      case "beat_reorder":
        await this.apiClient.updateBeat(action.beatId, {
          order_num: action.newOrder
        });
        return;
      case "beat_move":
        await this.apiClient.moveBeat(action.beatId, action.toSceneId);
        return;
      case "content_update":
        await this.apiClient.updateContentBlock(action.contentBlockId, {
          content: action.newContent
        });
        await ((_b = this.citationService) == null ? void 0 : _b.syncCitations(action.contentBlockId, action.newContent, worldId));
        return;
    }
  }
};

// src/sync-v2/push/ContentCitationService.ts
var ContentCitationService = class {
  constructor(context) {
    this.context = context;
  }
  async syncCitations(contentBlockId, content, worldId) {
    var _a, _b, _c, _d, _e, _f;
    const mentions = detectEntityMentions(content);
    const created = /* @__PURE__ */ new Set();
    for (const mention of mentions) {
      const resolved = await resolveEntityMention(mention, this.context);
      if (!resolved) {
        (_b = (_a = this.context).emitWarning) == null ? void 0 : _b.call(_a, {
          code: "citation_resolution_failed",
          message: `N\xE3o consegui resolver a men\xE7\xE3o ${mention.linkText}`,
          details: { mention },
          severity: "info"
        });
        continue;
      }
      const resolvedWorldId = worldId != null ? worldId : resolved.worldId;
      if (!resolvedWorldId) {
        (_d = (_c = this.context).emitWarning) == null ? void 0 : _d.call(_c, {
          code: "citation_world_missing",
          message: `N\xE3o foi poss\xEDvel determinar o world_id para ${mention.linkText}`,
          details: { mention },
          severity: "warning"
        });
        continue;
      }
      const targetKey = `${resolved.entityType}:${resolved.entityId}`;
      if (created.has(targetKey)) {
        continue;
      }
      created.add(targetKey);
      const payload = {
        world_id: resolvedWorldId,
        source_type: "content_block",
        source_id: contentBlockId,
        target_type: resolved.entityType,
        target_id: resolved.entityId,
        relation_type: "citation",
        summary: mention.displayLabel ? `Referenciado como ${mention.displayLabel}` : void 0,
        create_mirror: true
      };
      try {
        await this.context.apiClient.createEntityRelation(payload);
      } catch (error) {
        (_f = (_e = this.context).emitWarning) == null ? void 0 : _f.call(_e, {
          code: "citation_push_failed",
          message: `N\xE3o foi poss\xEDvel criar a citation para ${mention.linkText}`,
          details: error,
          severity: "warning"
        });
      }
    }
  }
};

// src/sync-v2/handlers/story/services/StoryRelationsService.ts
var StoryRelationsService = class {
  constructor(relationsGenerator = new RelationsGenerator(), relationsPushHandler = new RelationsPushHandler()) {
    this.relationsGenerator = relationsGenerator;
    this.relationsPushHandler = relationsPushHandler;
  }
  /**
   * Generate the story.relations.md file by fetching relations from API
   * and resolving entity names.
   */
  async generateRelationsFile(story, folderPath, context) {
    var _a;
    try {
      let worldFolderPath;
      if (story.story.world_id) {
        try {
          const world = await context.apiClient.getWorld(story.story.world_id);
          if (world == null ? void 0 : world.name) {
            worldFolderPath = context.fileManager.getWorldFolderPath(world.name);
          }
        } catch (e) {
        }
      }
      const relationsResponse = await context.apiClient.listRelationsByTarget({
        targetType: "story",
        targetId: story.story.id
      });
      const entityCache = /* @__PURE__ */ new Map();
      const resolvedRelations = await Promise.all(
        relationsResponse.data.map(async (relation) => {
          return this.resolveRelationTarget(relation, entityCache, context);
        })
      );
      const entityMap = new Map(
        resolvedRelations.map((r) => [`${r.targetType}:${r.targetId}`, r])
      );
      const resolveTarget = (relation) => {
        const key = `${relation.source_type}:${relation.source_id}`;
        const resolved = entityMap.get(key);
        if (!resolved)
          return null;
        return {
          targetId: resolved.targetId,
          targetName: resolved.targetName,
          summary: resolved.summary
        };
      };
      const mappedRelations = relationsResponse.data.map((rel) => ({
        ...rel,
        target_type: rel.source_type,
        target_id: rel.source_id
      }));
      const input = mapRelationsToGeneratorInput({
        entity: {
          id: story.story.id,
          name: story.story.title,
          type: "story",
          worldId: (_a = story.story.world_id) != null ? _a : void 0
        },
        relations: mappedRelations,
        resolveTarget,
        options: {
          syncedAt: context.timestamp(),
          showHelpBox: context.settings.showHelpBox,
          idField: context.settings.frontmatterIdField,
          worldFolderPath
        }
      });
      const relationsContent = this.relationsGenerator.generate(input);
      await context.fileManager.writeFile(`${folderPath}/story.relations.md`, relationsContent);
    } catch (error) {
      console.warn("[Sync V2] Failed to generate story relations file", {
        storyId: story.story.id,
        error
      });
      await context.fileManager.writeFile(
        `${folderPath}/story.relations.md`,
        this.renderRelationsPlaceholder(story)
      );
    }
  }
  /**
   * Push local relations changes to the API.
   */
  async pushRelations(entity, folderPath, context) {
    var _a, _b, _c;
    const relationsFilePath = `${folderPath}/story.relations.md`;
    try {
      await context.fileManager.readFile(relationsFilePath);
      const result = await this.relationsPushHandler.pushRelations(
        relationsFilePath,
        "story",
        entity.story.id,
        context,
        (_a = entity.story.world_id) != null ? _a : void 0
      );
      if (result.warnings.length > 0) {
        result.warnings.forEach(
          (warning) => {
            var _a2;
            return (_a2 = context.emitWarning) == null ? void 0 : _a2.call(context, {
              code: "relations_push_warning",
              message: warning,
              filePath: relationsFilePath
            });
          }
        );
      }
    } catch (error) {
      if (!((_b = error == null ? void 0 : error.message) == null ? void 0 : _b.includes("missing")) && (error == null ? void 0 : error.code) !== "ENOENT") {
        (_c = context.emitWarning) == null ? void 0 : _c.call(context, {
          code: "relations_push_error",
          message: `Failed to push relations: ${error}`,
          filePath: relationsFilePath
        });
      }
    }
  }
  async resolveRelationTarget(relation, entityCache, context) {
    try {
      let targetName = relation.source_id;
      let targetId = relation.source_id;
      let targetType = relation.source_type;
      const cacheKey = `${relation.source_type}:${relation.source_id}`;
      if (entityCache.has(cacheKey)) {
        const cached = entityCache.get(cacheKey);
        targetName = cached.name;
        targetType = cached.type;
      } else {
        const resolved = await this.fetchEntityName(relation.source_type, relation.source_id, context);
        if (resolved) {
          targetName = resolved.name;
          targetId = resolved.id;
          entityCache.set(cacheKey, { name: resolved.name, type: relation.source_type });
        }
      }
      return {
        targetType,
        targetId,
        targetName,
        relationType: relation.relation_type,
        summary: relation.context
      };
    } catch (error) {
      console.warn("[Sync V2] Failed to resolve target for story relation", {
        relation,
        error
      });
      return {
        targetType: relation.source_type,
        targetId: relation.source_id,
        targetName: relation.source_id,
        relationType: relation.relation_type,
        summary: relation.context
      };
    }
  }
  async fetchEntityName(entityType, entityId, context) {
    switch (entityType) {
      case "character": {
        const char = await context.apiClient.getCharacter(entityId);
        return { id: char.id, name: char.name };
      }
      case "location": {
        const loc = await context.apiClient.getLocation(entityId);
        return { id: loc.id, name: loc.name };
      }
      case "faction": {
        const faction = await context.apiClient.getFaction(entityId);
        return { id: faction.id, name: faction.name };
      }
      case "artifact": {
        const artifact = await context.apiClient.getArtifact(entityId);
        return { id: artifact.id, name: artifact.name };
      }
      case "event": {
        const event = await context.apiClient.getEvent(entityId);
        return { id: event.id, name: event.name };
      }
      case "lore": {
        const lore = await context.apiClient.getLore(entityId);
        return { id: lore.id, name: lore.name };
      }
      case "world": {
        const world = await context.apiClient.getWorld(entityId);
        return { id: world.id, name: world.name };
      }
      default:
        return null;
    }
  }
  renderRelationsPlaceholder(story) {
    return [
      `# ${story.story.title} - Relations`,
      "",
      "_Relations will be populated when synced with the server._",
      ""
    ].join("\n");
  }
};

// src/sync-v2/conflict/ConflictModal.ts
var _ConflictModal = class _ConflictModal {
  constructor(app, conflict) {
    this.app = app;
    this.conflict = conflict;
    void this.app;
    void this.conflict;
  }
  static setNextChoice(choice) {
    _ConflictModal.nextChoice = choice;
  }
  async open() {
    if (_ConflictModal.nextChoice) {
      const choice = _ConflictModal.nextChoice;
      _ConflictModal.nextChoice = null;
      return choice;
    }
    return "local";
  }
};
_ConflictModal.nextChoice = null;
var ConflictModal2 = _ConflictModal;

// src/sync-v2/conflict/ConflictResolver.ts
var ConflictResolver = class {
  constructor(app, context) {
    this.app = app;
    this.context = context;
  }
  /**
   * Detect if there's a conflict between local and remote versions
   * 
   * @param entityType Type of entity (story, chapter, scene, etc.)
   * @param entityId ID of the entity
   * @param localData Local version (from file)
   * @param remoteData Remote version (from API)
   * @param localTimestamp Local modification timestamp (if available)
   * @param remoteTimestamp Remote modification timestamp (from API)
   * @returns Conflict object if conflict detected, null otherwise
   */
  detectConflict(entityType, entityId, filePath, localData, remoteData, localTimestamp, remoteTimestamp) {
    if (this.isSimultaneousEdit(localData, remoteData, localTimestamp, remoteTimestamp)) {
      return {
        type: "simultaneous_edit",
        entityId,
        entityType,
        filePath,
        localTimestamp,
        remoteTimestamp,
        localData,
        remoteData,
        context: {
          message: "Entity was modified both locally and remotely"
        }
      };
    }
    return null;
  }
  /**
   * Resolve a conflict using the configured strategy
   * 
   * @param conflict Conflict to resolve
   * @returns Resolution result
   */
  async resolve(conflict) {
    const strategy = this.getResolutionStrategy();
    try {
      let resolution;
      switch (strategy) {
        case "local":
          resolution = this.resolveLocal(conflict);
          break;
        case "remote":
          resolution = this.resolveRemote(conflict);
          break;
        case "last_write_wins":
          resolution = this.resolveLastWriteWins(conflict);
          break;
        case "merge":
          resolution = await this.resolveMerge(conflict);
          break;
        case "manual":
        default:
          resolution = await this.resolveManual(conflict);
          break;
      }
      return {
        success: true,
        resolution
      };
    } catch (error) {
      return {
        success: false,
        resolution: {
          strategy,
          autoResolved: false
        },
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
  /**
   * Get the resolution strategy from settings
   */
  getResolutionStrategy() {
    const setting = this.context.settings.conflictResolution;
    switch (setting) {
      case "local":
        return "local";
      case "manual":
        return "manual";
      case "service":
        return "remote";
      default:
        return "manual";
    }
  }
  /**
   * Check if there's a simultaneous edit conflict
   */
  isSimultaneousEdit(localData, remoteData, localTimestamp, remoteTimestamp) {
    if (localTimestamp && remoteTimestamp) {
      const localTs = new Date(localTimestamp).getTime();
      const remoteTs = new Date(remoteTimestamp).getTime();
      if (remoteTs > localTs && !this.isDataEqual(localData, remoteData)) {
        return true;
      }
    }
    if (!localTimestamp && !remoteTimestamp) {
      return !this.isDataEqual(localData, remoteData);
    }
    return false;
  }
  /**
   * Check if two data objects are equal (deep comparison for objects, simple for primitives)
   */
  isDataEqual(a, b) {
    if (a === b) {
      return true;
    }
    if (typeof a !== typeof b) {
      return false;
    }
    if (typeof a === "object" && a !== null && b !== null) {
      const aObj = a;
      const bObj = b;
      const aKeys = Object.keys(aObj);
      const bKeys = Object.keys(bObj);
      if (aKeys.length !== bKeys.length) {
        return false;
      }
      for (const key of aKeys) {
        if (!bKeys.includes(key)) {
          return false;
        }
        if (!this.isDataEqual(aObj[key], bObj[key])) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  /**
   * Resolve conflict by using local version
   */
  resolveLocal(conflict) {
    return {
      strategy: "local",
      resolvedData: conflict.localData,
      autoResolved: true
    };
  }
  /**
   * Resolve conflict by using remote version
   */
  resolveRemote(conflict) {
    return {
      strategy: "remote",
      resolvedData: conflict.remoteData,
      autoResolved: true
    };
  }
  /**
   * Resolve conflict using last-write-wins strategy (latest timestamp wins)
   */
  resolveLastWriteWins(conflict) {
    if (conflict.localTimestamp && conflict.remoteTimestamp) {
      const localTs = new Date(conflict.localTimestamp).getTime();
      const remoteTs = new Date(conflict.remoteTimestamp).getTime();
      if (remoteTs >= localTs) {
        return {
          strategy: "last_write_wins",
          resolvedData: conflict.remoteData,
          autoResolved: true
        };
      }
    }
    return {
      strategy: "last_write_wins",
      resolvedData: conflict.localData,
      autoResolved: true
    };
  }
  /**
   * Resolve conflict using merge strategy (attempt intelligent merge)
   * For now, falls back to manual resolution
   */
  async resolveMerge(conflict) {
    return this.resolveManual(conflict);
  }
  /**
   * Resolve conflict manually (show UI modal to user)
   */
  async resolveManual(conflict) {
    var _a, _b;
    const choice = await new ConflictModal2(this.app, conflict).open();
    const resolvedData = choice === "remote" ? conflict.remoteData : conflict.localData;
    (_b = (_a = this.context).emitWarning) == null ? void 0 : _b.call(_a, {
      code: "conflict_detected",
      message: `Conflict detected for ${conflict.entityType} ${conflict.entityId}. Manual resolution selected (${choice}).`,
      filePath: conflict.filePath,
      severity: "warning"
    });
    return {
      strategy: "manual",
      resolvedData,
      autoResolved: false
    };
  }
};

// src/sync-v2/handlers/story/services/StoryConflictService.ts
var StoryConflictService = class {
  constructor(resolverFactory = (app, ctx) => new ConflictResolver(app, ctx)) {
    this.resolverFactory = resolverFactory;
  }
  /**
   * Check for conflicts between local and remote versions of a file.
   * Emits warnings through context.emitWarning when conflicts are detected.
   */
  async checkConflicts(path, story, context, opts) {
    var _a, _b, _c, _d;
    const local = (opts == null ? void 0 : opts.localContentPath) ? await this.readFileSilently(context, opts.localContentPath) : await this.readFileSilently(context, path);
    if (!local) {
      return;
    }
    const parsed = parseFrontmatter(local);
    const localTimestamp = (_a = parsed.updated_at) != null ? _a : parsed.synced_at;
    if (!localTimestamp) {
      return;
    }
    const remoteTimestamp = story.updated_at;
    const entityType = (_b = opts == null ? void 0 : opts.entityType) != null ? _b : "story";
    const resolver = this.resolverFactory(context.app, context);
    const conflict = resolver.detectConflict(
      entityType,
      story.id,
      path,
      { updated_at: localTimestamp },
      { updated_at: remoteTimestamp },
      localTimestamp,
      remoteTimestamp
    );
    if (!conflict) {
      return;
    }
    const resolution = await resolver.resolve(conflict);
    if (!resolution.success) {
      (_c = context.emitWarning) == null ? void 0 : _c.call(context, {
        code: "conflict_resolution_failed",
        message: `Failed to resolve conflict for ${entityType.replace("-", " ")}: ${resolution.error}`,
        filePath: path,
        severity: "warning"
      });
      return;
    }
    if (!resolution.resolution.autoResolved && resolution.resolution.strategy === "manual") {
      (_d = context.emitWarning) == null ? void 0 : _d.call(context, {
        code: "conflict_requires_manual_resolution",
        message: `Conflict detected for ${entityType.replace("-", " ")}. Manual resolution required.`,
        filePath: path,
        severity: "warning",
        details: conflict
      });
    }
  }
  async readFileSilently(context, path) {
    try {
      return await context.fileManager.readFile(path);
    } catch (e) {
      return null;
    }
  }
};

// src/sync-v2/handlers/story/services/StoryRenameService.ts
var StoryRenameService = class {
  constructor(fileRenamerFactory = (ctx) => new FileRenamer(ctx)) {
    this.fileRenamerFactory = fileRenamerFactory;
  }
  /**
   * Handle file renames based on reorder operations from the diff.
   */
  async handleReorders(operations, story, folderPath, context) {
    const renamer = this.fileRenamerFactory(context);
    const pathResolver = new PathResolver(folderPath);
    const sceneMap = new Map(
      story.chapters.flatMap(
        (chapter) => chapter.scenes.map((scene) => {
          var _a;
          return [
            scene.scene.id,
            { scene: scene.scene, chapterOrder: (_a = chapter.chapter.number) != null ? _a : 0 }
          ];
        })
      )
    );
    const beatMap = new Map(
      story.chapters.flatMap(
        (chapter) => chapter.scenes.flatMap(
          (scene) => scene.beats.map((beat) => {
            var _a, _b;
            return [
              beat.id,
              {
                beat,
                chapterOrder: (_a = chapter.chapter.number) != null ? _a : 0,
                sceneOrder: (_b = scene.scene.order_num) != null ? _b : 0
              }
            ];
          })
        )
      )
    );
    const chapterMap = new Map(
      story.chapters.map((chapter) => [chapter.chapter.id, chapter.chapter])
    );
    for (const op of operations) {
      if (op.kind !== "reordered")
        continue;
      if (op.fenceType === "chapter") {
        await this.handleChapterReorder(op, chapterMap, pathResolver, renamer);
      } else if (op.fenceType === "scene") {
        await this.handleSceneReorder(op, sceneMap, pathResolver, renamer);
      } else if (op.fenceType === "beat") {
        await this.handleBeatReorder(op, beatMap, pathResolver, renamer);
      } else if (op.fenceType === "content") {
        await this.handleContentReorder(op, pathResolver, renamer, context);
      }
    }
  }
  async handleChapterReorder(op, chapterMap, pathResolver, renamer) {
    var _a;
    const chapter = chapterMap.get(op.fenceId);
    if (!chapter || ((_a = op.metadata) == null ? void 0 : _a.newOrder) === void 0 || op.metadata.oldOrder === void 0) {
      return;
    }
    const oldPath = pathResolver.getChapterPath(chapter, { order: op.metadata.oldOrder });
    const newPath = pathResolver.getChapterPath(chapter, { order: op.metadata.newOrder });
    if (oldPath === newPath)
      return;
    await this.renameSafely(renamer, oldPath, newPath, "chapter");
  }
  async handleSceneReorder(op, sceneMap, pathResolver, renamer) {
    var _a;
    const sceneEntry = sceneMap.get(op.fenceId);
    if (!sceneEntry || ((_a = op.metadata) == null ? void 0 : _a.newOrder) === void 0 || op.metadata.oldOrder === void 0) {
      return;
    }
    const oldPath = pathResolver.getScenePath(sceneEntry.scene, {
      order: op.metadata.oldOrder,
      chapterOrder: sceneEntry.chapterOrder
    });
    const newPath = pathResolver.getScenePath(sceneEntry.scene, {
      order: op.metadata.newOrder,
      chapterOrder: sceneEntry.chapterOrder
    });
    if (oldPath === newPath)
      return;
    await this.renameSafely(renamer, oldPath, newPath, "scene");
  }
  async handleBeatReorder(op, beatMap, pathResolver, renamer) {
    var _a;
    const beatEntry = beatMap.get(op.fenceId);
    if (!beatEntry || ((_a = op.metadata) == null ? void 0 : _a.newOrder) === void 0 || op.metadata.oldOrder === void 0) {
      return;
    }
    const oldPath = pathResolver.getBeatPath(beatEntry.beat, {
      order: op.metadata.oldOrder,
      chapterOrder: beatEntry.chapterOrder,
      sceneOrder: beatEntry.sceneOrder
    });
    const newPath = pathResolver.getBeatPath(beatEntry.beat, {
      order: op.metadata.newOrder,
      chapterOrder: beatEntry.chapterOrder,
      sceneOrder: beatEntry.sceneOrder
    });
    if (oldPath === newPath)
      return;
    await this.renameSafely(renamer, oldPath, newPath, "beat");
  }
  async handleContentReorder(op, pathResolver, renamer, context) {
    var _a;
    if (((_a = op.metadata) == null ? void 0 : _a.newOrder) === void 0 || op.metadata.oldOrder === void 0) {
      return;
    }
    try {
      const contentBlock = await context.apiClient.getContentBlock(op.fenceId);
      if (!contentBlock)
        return;
      const oldPath = pathResolver.getContentBlockPath(contentBlock, {
        order: op.metadata.oldOrder
      });
      const newPath = pathResolver.getContentBlockPath(contentBlock, {
        order: op.metadata.newOrder
      });
      if (oldPath === newPath)
        return;
      await this.renameSafely(renamer, oldPath, newPath, "content block");
    } catch (err) {
      console.warn(`[Sync V2] Failed to get content block for rename`, err);
    }
  }
  async renameSafely(renamer, oldPath, newPath, entity) {
    try {
      await renamer.rename({ oldPath, newPath });
    } catch (err) {
      console.warn(`[Sync V2] Failed to rename ${entity} file`, err);
    }
  }
};

// src/sync-v2/relations/relationsFileWriter.ts
async function writeRelationsFile({
  entity,
  outputPath,
  context,
  worldFolderPath
}) {
  const relationsGenerator = new RelationsGenerator();
  try {
    const relationsResponse = await context.apiClient.listRelationsByTarget({
      targetType: entity.type,
      targetId: entity.id
    });
    const entityCache = /* @__PURE__ */ new Map();
    const resolvedRelations = await Promise.all(
      relationsResponse.data.map(async (relation) => {
        return resolveRelationTarget(relation, entityCache, context);
      })
    );
    const entityMap = new Map(
      resolvedRelations.map((r) => [`${r.targetType}:${r.targetId}`, r])
    );
    const resolveTarget = (relation) => {
      const key = `${relation.source_type}:${relation.source_id}`;
      const resolved = entityMap.get(key);
      if (!resolved)
        return null;
      return {
        targetId: resolved.targetId,
        targetName: resolved.targetName,
        summary: resolved.summary
      };
    };
    const mappedRelations = relationsResponse.data.map((rel) => ({
      ...rel,
      target_type: rel.source_type,
      target_id: rel.source_id
    }));
    const input = mapRelationsToGeneratorInput({
      entity,
      relations: mappedRelations,
      resolveTarget,
      options: {
        syncedAt: context.timestamp(),
        showHelpBox: context.settings.showHelpBox,
        idField: context.settings.frontmatterIdField,
        worldFolderPath
      }
    });
    const relationsContent = relationsGenerator.generate(input);
    await context.fileManager.writeFile(outputPath, relationsContent);
  } catch (error) {
    console.warn("[Sync V2] Failed to generate relations file", {
      entity,
      error
    });
    await context.fileManager.writeFile(outputPath, renderRelationsPlaceholder(entity.name));
  }
}
async function resolveRelationTarget(relation, entityCache, context) {
  try {
    let targetName = relation.source_id;
    let targetId = relation.source_id;
    let targetType = relation.source_type;
    const cacheKey = `${relation.source_type}:${relation.source_id}`;
    if (entityCache.has(cacheKey)) {
      const cached = entityCache.get(cacheKey);
      targetName = cached.name;
      targetId = cached.id;
      targetType = cached.type;
    } else {
      const resolved = await fetchEntityName(relation.source_type, relation.source_id, context);
      if (resolved) {
        targetName = resolved.name;
        targetId = resolved.id;
        entityCache.set(cacheKey, { name: resolved.name, type: relation.source_type, id: resolved.id });
      }
    }
    return {
      targetType,
      targetId,
      targetName,
      relationType: relation.relation_type,
      summary: relation.context
    };
  } catch (error) {
    console.warn("[Sync V2] Failed to resolve relation target", {
      relation,
      error
    });
    return {
      targetType: relation.source_type,
      targetId: relation.source_id,
      targetName: relation.source_id,
      relationType: relation.relation_type,
      summary: relation.context
    };
  }
}
async function fetchEntityName(entityType, entityId, context) {
  var _a, _b, _c, _d;
  switch (entityType) {
    case "character": {
      const char = await context.apiClient.getCharacter(entityId);
      return { id: char.id, name: char.name };
    }
    case "location": {
      const loc = await context.apiClient.getLocation(entityId);
      return { id: loc.id, name: loc.name };
    }
    case "faction": {
      const faction = await context.apiClient.getFaction(entityId);
      return { id: faction.id, name: faction.name };
    }
    case "artifact": {
      const artifact = await context.apiClient.getArtifact(entityId);
      return { id: artifact.id, name: artifact.name };
    }
    case "event": {
      const event = await context.apiClient.getEvent(entityId);
      return { id: event.id, name: event.name };
    }
    case "lore": {
      const lore = await context.apiClient.getLore(entityId);
      return { id: lore.id, name: lore.name };
    }
    case "world": {
      const world = await context.apiClient.getWorld(entityId);
      return { id: world.id, name: world.name };
    }
    case "chapter": {
      const chapter = await context.apiClient.getChapter(entityId);
      return { id: chapter.id, name: `Chapter ${chapter.number}: ${chapter.title}` };
    }
    case "scene": {
      const scene = await context.apiClient.getScene(entityId);
      return { id: scene.id, name: `Scene ${(_a = scene.order_num) != null ? _a : 0}: ${scene.goal || "Untitled"}` };
    }
    case "beat": {
      const beat = await context.apiClient.getBeat(entityId);
      return { id: beat.id, name: `Beat ${(_b = beat.order_num) != null ? _b : 0}: ${beat.intent || "Untitled"}` };
    }
    case "content_block": {
      const block = await context.apiClient.getContentBlock(entityId);
      const name = ((_c = block.metadata) == null ? void 0 : _c.title) || block.kind || block.type || ((_d = block.content) == null ? void 0 : _d.slice(0, 40)) || "Content Block";
      return { id: block.id, name };
    }
    default:
      return null;
  }
}
function renderRelationsPlaceholder(name) {
  return [`# ${name} - Relations`, "", "_Relations will be populated when synced._", ""].join("\n");
}

// src/sync-v2/handlers/story/services/StoryFileService.ts
var StoryFileService = class {
  constructor() {
    this.contentsGenerator = new ContentsGenerator();
    this.outlineGenerator = new OutlineGenerator();
  }
  /**
   * Read a file silently, returning null if it doesn't exist or on error.
   */
  async readFileSilently(context, path) {
    try {
      return await context.fileManager.readFile(path);
    } catch (e) {
      return null;
    }
  }
  /**
   * Write individual entity files (chapters, scenes, beats) as placeholders.
   */
  async writeIndividualEntityFiles(story, folderPath, context) {
    var _a, _b, _c, _d, _e, _f, _g;
    const pathResolver = new PathResolver(folderPath);
    let worldFolderPath;
    if (story.story.world_id) {
      try {
        const world = await context.apiClient.getWorld(story.story.world_id);
        if (world == null ? void 0 : world.name) {
          worldFolderPath = context.fileManager.getWorldFolderPath(world.name);
        }
      } catch (e) {
      }
    }
    const chaptersFolderPath = `${folderPath}/00-chapters`;
    const scenesFolderPath = `${folderPath}/01-scenes`;
    const beatsFolderPath = `${folderPath}/02-beats`;
    await context.fileManager.ensureFolderExists(chaptersFolderPath);
    await context.fileManager.ensureFolderExists(scenesFolderPath);
    await context.fileManager.ensureFolderExists(beatsFolderPath);
    const contentBlocksByScene = /* @__PURE__ */ new Map();
    const contentBlocksByBeat = /* @__PURE__ */ new Map();
    for (const chapterWithContent of story.chapters) {
      const chapter = chapterWithContent.chapter;
      const chapterOrder = (_a = chapter.number) != null ? _a : 0;
      const chapterBasePath = pathResolver.getChapterPath(chapter);
      await context.fileManager.ensureFolderExists(chapterBasePath.replace(/\/[^/]+$/, ""));
      await context.fileManager.writeChapterFile(
        chapterWithContent,
        chapterBasePath,
        story.story.title,
        void 0,
        void 0,
        void 0,
        { linkMode: "full_path", storyFolderPath: folderPath }
      );
      const chapterOutlinePath = chapterBasePath.replace(/\.md$/, ".outline.md");
      const chapterContentsPath = chapterBasePath.replace(/\.md$/, ".contents.md");
      const chapterRelationsPath = chapterBasePath.replace(/\.md$/, ".relations.md");
      const chapterOutline = this.outlineGenerator.generateChapterOutline(chapterWithContent, {
        syncedAt: context.timestamp(),
        showHelpBox: context.settings.showHelpBox,
        idField: context.settings.frontmatterIdField,
        storyFolderPath: folderPath
      });
      await context.fileManager.writeFile(chapterOutlinePath, chapterOutline);
      const sceneContentBlocks = /* @__PURE__ */ new Map();
      const beatContentBlocks = /* @__PURE__ */ new Map();
      for (const sceneWrapper of chapterWithContent.scenes) {
        const scene = sceneWrapper.scene;
        const sceneOrder = (_b = scene.order_num) != null ? _b : 0;
        const scenePath = pathResolver.getScenePath(scene, { chapterOrder });
        const sceneBlocks = await context.apiClient.getContentBlocksByScene(scene.id);
        contentBlocksByScene.set(scene.id, sceneBlocks);
        sceneContentBlocks.set(scene.id, sceneBlocks);
        await context.fileManager.writeSceneFile(
          sceneWrapper,
          scenePath,
          story.story.title,
          sceneBlocks,
          [],
          {
            linkMode: "full_path",
            storyFolderPath: folderPath,
            chapterOrder
          }
        );
        for (const beat of sceneWrapper.beats) {
          const beatPath = pathResolver.getBeatPath(beat, {
            chapterOrder,
            sceneOrder
          });
          const beatBlocks = await context.apiClient.getContentBlocksByBeat(beat.id);
          contentBlocksByBeat.set(beat.id, beatBlocks);
          beatContentBlocks.set(beat.id, beatBlocks);
          await context.fileManager.writeBeatFile(
            beat,
            beatPath,
            story.story.title,
            beatBlocks,
            {
              linkMode: "full_path",
              storyFolderPath: folderPath,
              chapterOrder,
              sceneOrder
            }
          );
          const beatContentsPath = beatPath.replace(/\.md$/, ".contents.md");
          const beatRelationsPath = beatPath.replace(/\.md$/, ".relations.md");
          const beatContents = this.contentsGenerator.generateBeatContents(
            beat,
            beatContentBlocks,
            { syncedAt: context.timestamp(), idField: context.settings.frontmatterIdField }
          );
          await context.fileManager.writeFile(beatContentsPath, beatContents);
          await writeRelationsFile({
            entity: {
              id: beat.id,
              name: `Beat ${(_c = beat.order_num) != null ? _c : 0}: ${beat.intent || "Untitled"}`,
              type: "beat",
              worldId: (_d = story.story.world_id) != null ? _d : void 0
            },
            outputPath: beatRelationsPath,
            context,
            worldFolderPath
          });
        }
        const sceneOutlinePath = scenePath.replace(/\.md$/, ".outline.md");
        const sceneContentsPath = scenePath.replace(/\.md$/, ".contents.md");
        const sceneRelationsPath = scenePath.replace(/\.md$/, ".relations.md");
        const sceneOutline = this.outlineGenerator.generateSceneOutline(sceneWrapper, {
          syncedAt: context.timestamp(),
          showHelpBox: context.settings.showHelpBox,
          idField: context.settings.frontmatterIdField,
          storyFolderPath: folderPath
        });
        await context.fileManager.writeFile(sceneOutlinePath, sceneOutline);
        const sceneContents = this.contentsGenerator.generateSceneContents(
          sceneWrapper,
          sceneContentBlocks,
          beatContentBlocks,
          { syncedAt: context.timestamp(), idField: context.settings.frontmatterIdField }
        );
        await context.fileManager.writeFile(sceneContentsPath, sceneContents);
        await writeRelationsFile({
          entity: {
            id: scene.id,
            name: `Scene ${(_e = scene.order_num) != null ? _e : 0}: ${scene.goal || "Untitled"}`,
            type: "scene",
            worldId: (_f = story.story.world_id) != null ? _f : void 0
          },
          outputPath: sceneRelationsPath,
          context,
          worldFolderPath
        });
      }
      const chapterContents = this.contentsGenerator.generateChapterContents(
        chapterWithContent,
        /* @__PURE__ */ new Map(),
        sceneContentBlocks,
        beatContentBlocks,
        { syncedAt: context.timestamp(), idField: context.settings.frontmatterIdField }
      );
      await context.fileManager.writeFile(chapterContentsPath, chapterContents);
      await writeRelationsFile({
        entity: {
          id: chapter.id,
          name: `Chapter ${chapter.number}: ${chapter.title}`,
          type: "chapter",
          worldId: (_g = story.story.world_id) != null ? _g : void 0
        },
        outputPath: chapterRelationsPath,
        context,
        worldFolderPath
      });
    }
    const writtenBlocks = /* @__PURE__ */ new Set();
    const allBlocks = [...contentBlocksByScene.values(), ...contentBlocksByBeat.values()].flat();
    for (const block of allBlocks) {
      if (writtenBlocks.has(block.id)) {
        continue;
      }
      writtenBlocks.add(block.id);
      const blockPath = pathResolver.getContentBlockPath(block);
      const blockFolder = blockPath.replace(/\/[^/]+$/, "");
      await context.fileManager.ensureFolderExists(blockFolder);
      await context.fileManager.writeContentBlockFile(block, blockPath, story.story.title);
    }
  }
};

// src/sync-v2/handlers/story/StoryHandler.ts
var StoryHandler = class {
  constructor(outlineGenerator = new OutlineGenerator(), contentsGenerator = new ContentsGenerator(), contentsReconciler = new ContentsReconciler(), outlineReconciler = new OutlineReconciler(), relationsGenerator = new RelationsGenerator(), relationsPushHandler = new RelationsPushHandler(), fileRenamerFactory = (ctx) => new FileRenamer(ctx)) {
    this.outlineGenerator = outlineGenerator;
    this.contentsGenerator = contentsGenerator;
    this.contentsReconciler = contentsReconciler;
    this.outlineReconciler = outlineReconciler;
    this.relationsGenerator = relationsGenerator;
    this.relationsPushHandler = relationsPushHandler;
    this.fileRenamerFactory = fileRenamerFactory;
    this.entityType = "story";
    this.relationsService = new StoryRelationsService(relationsGenerator, relationsPushHandler);
    this.conflictService = new StoryConflictService();
    this.renameService = new StoryRenameService(fileRenamerFactory);
    this.fileService = new StoryFileService();
  }
  async pull(id2, context) {
    const story = await context.apiClient.getStoryWithHierarchy(id2);
    const folderPath = context.fileManager.getStoryFolderPath(story.story.title);
    await context.fileManager.ensureFolderExists(folderPath);
    await context.fileManager.writeStoryMetadata(story.story, folderPath, story.chapters, void 0, void 0, void 0, {
      linkMode: "full_path"
    });
    await this.conflictService.checkConflicts(
      `${folderPath}/story.md`,
      story.story,
      context
    );
    const outlinePath = `${folderPath}/story.outline.md`;
    const contentsPath = `${folderPath}/story.contents.md`;
    const outlineGenerated = this.outlineGenerator.generateStoryOutline(story, {
      syncedAt: context.timestamp(),
      showHelpBox: context.settings.showHelpBox,
      idField: context.settings.frontmatterIdField,
      storyFolderPath: folderPath
    });
    const contentsGenerated = this.contentsGenerator.generateStoryContents({
      story: story.story,
      chapters: story.chapters,
      options: {
        syncedAt: context.timestamp(),
        idField: context.settings.frontmatterIdField
      }
    });
    await this.conflictService.checkConflicts(outlinePath, story.story, context, {
      localContentPath: outlinePath,
      remoteContent: outlineGenerated,
      entityType: "story-outline"
    });
    await this.conflictService.checkConflicts(contentsPath, story.story, context, {
      localContentPath: contentsPath,
      remoteContent: contentsGenerated,
      entityType: "story-contents"
    });
    const existingOutline = await this.fileService.readFileSilently(context, outlinePath);
    const existingContents = await this.fileService.readFileSilently(context, contentsPath);
    const outlineMerged = this.outlineReconciler.reconcile(existingOutline, outlineGenerated);
    const contentsReconciled = this.contentsReconciler.reconcile(existingContents, contentsGenerated);
    if (contentsReconciled.warnings.length) {
      contentsReconciled.warnings.forEach(
        (warning) => {
          var _a;
          return (_a = context.emitWarning) == null ? void 0 : _a.call(context, {
            ...warning,
            filePath: contentsPath
          });
        }
      );
    }
    await context.fileManager.writeFile(outlinePath, outlineMerged);
    await context.fileManager.writeFile(contentsPath, contentsReconciled.mergedContent);
    await this.renameService.handleReorders(contentsReconciled.diff.operations, story, folderPath, context);
    await this.relationsService.generateRelationsFile(story, folderPath, context);
    await this.fileService.writeIndividualEntityFiles(story, folderPath, context);
    return story;
  }
  async push(entity, context) {
    var _a, _b, _c, _d, _e;
    const folderPath = context.fileManager.getStoryFolderPath(entity.story.title);
    await this.relationsService.pushRelations(entity, folderPath, context);
    const outlineFilePath = `${folderPath}/story.outline.md`;
    try {
      const outlinePushHandler = new OutlinePushHandler();
      const outlineResult = await outlinePushHandler.analyzeOutline(
        outlineFilePath,
        entity.story.id,
        context
      );
      for (const action of outlineResult.actions) {
        if (action.type === "chapter_reorder") {
          await context.apiClient.updateChapter(action.chapterId, {
            number: action.newOrder
          });
        }
      }
      if (outlineResult.warnings.length > 0) {
        outlineResult.warnings.forEach(
          (warning) => {
            var _a2;
            return (_a2 = context.emitWarning) == null ? void 0 : _a2.call(context, {
              code: "outline_push_warning",
              message: warning,
              filePath: outlineFilePath
            });
          }
        );
      }
    } catch (error) {
      if (!((_a = error == null ? void 0 : error.message) == null ? void 0 : _a.includes("missing")) && (error == null ? void 0 : error.code) !== "ENOENT") {
        (_b = context.emitWarning) == null ? void 0 : _b.call(context, {
          code: "outline_push_error",
          message: `Failed to push outline: ${error}`,
          filePath: outlineFilePath
        });
      }
    }
    const contentsFilePath = `${folderPath}/story.contents.md`;
    try {
      const localContents = await context.fileManager.readFile(contentsFilePath);
      const remoteContents = this.contentsGenerator.generateStoryContents({
        story: entity.story,
        chapters: entity.chapters,
        options: {
          syncedAt: context.timestamp(),
          idField: context.settings.frontmatterIdField
        }
      });
      const planner = new PushPlanner();
      const plan = planner.buildPlan(remoteContents, localContents);
      if (plan.actions.length > 0) {
        const citationService = new ContentCitationService(context);
        const executor = new PushExecutor(context.apiClient, citationService);
        const result = await executor.execute(plan.actions, {
          worldId: (_c = entity.story.world_id) != null ? _c : void 0
        });
        if (result.errors.length > 0) {
          result.errors.forEach(
            (error) => {
              var _a2;
              return (_a2 = context.emitWarning) == null ? void 0 : _a2.call(context, {
                ...error,
                filePath: contentsFilePath
              });
            }
          );
        }
      }
      if (plan.warnings.length > 0) {
        plan.warnings.forEach(
          (warning) => {
            var _a2;
            return (_a2 = context.emitWarning) == null ? void 0 : _a2.call(context, {
              ...warning,
              filePath: contentsFilePath
            });
          }
        );
      }
    } catch (error) {
      if (!((_d = error == null ? void 0 : error.message) == null ? void 0 : _d.includes("missing")) && (error == null ? void 0 : error.code) !== "ENOENT") {
        (_e = context.emitWarning) == null ? void 0 : _e.call(context, {
          code: "contents_push_error",
          message: `Failed to push contents: ${error}`,
          filePath: contentsFilePath
        });
      }
    }
  }
  async delete(_id, _context) {
  }
};

// src/sync-v2/handlers/chapter/ChapterHandler.ts
var ChapterHandler = class {
  constructor() {
    this.entityType = "chapter";
    this.contentsGenerator = new ContentsGenerator();
    this.outlineGenerator = new OutlineGenerator();
  }
  async pull(id2, context) {
    var _a;
    const chapter = await context.apiClient.getChapter(id2);
    const scenes = await context.apiClient.getScenes(chapter.id);
    const scenesWithBeats = await Promise.all(
      scenes.map(async (scene) => ({
        scene,
        beats: await context.apiClient.getBeats(scene.id)
      }))
    );
    const data = {
      chapter,
      scenes: scenesWithBeats
    };
    const story = await context.apiClient.getStory(chapter.story_id);
    const folderPath = context.fileManager.getStoryFolderPath(story.title);
    const chaptersFolder = `${folderPath}/00-chapters`;
    await context.fileManager.ensureFolderExists(chaptersFolder);
    const pathResolver = new PathResolver(folderPath);
    const filePath = pathResolver.getChapterPath(chapter);
    await context.fileManager.writeChapterFile(
      data,
      filePath,
      story.title,
      void 0,
      void 0,
      void 0,
      { linkMode: "full_path", storyFolderPath: folderPath }
    );
    const outlinePath = filePath.replace(/\.md$/, ".outline.md");
    const contentsPath = filePath.replace(/\.md$/, ".contents.md");
    const relationsPath = filePath.replace(/\.md$/, ".relations.md");
    const outline = this.outlineGenerator.generateChapterOutline(data, {
      syncedAt: context.timestamp(),
      showHelpBox: context.settings.showHelpBox,
      idField: context.settings.frontmatterIdField,
      storyFolderPath: folderPath
    });
    await context.fileManager.writeFile(outlinePath, outline);
    const sceneContentBlocks = /* @__PURE__ */ new Map();
    const beatContentBlocks = /* @__PURE__ */ new Map();
    for (const sceneWrapper of data.scenes) {
      const sceneBlocks = await context.apiClient.getContentBlocksByScene(sceneWrapper.scene.id);
      sceneContentBlocks.set(sceneWrapper.scene.id, sceneBlocks);
      for (const beat of sceneWrapper.beats) {
        const beatBlocks = await context.apiClient.getContentBlocksByBeat(beat.id);
        beatContentBlocks.set(beat.id, beatBlocks);
      }
    }
    const contents = this.contentsGenerator.generateChapterContents(
      data,
      /* @__PURE__ */ new Map(),
      sceneContentBlocks,
      beatContentBlocks,
      { syncedAt: context.timestamp(), idField: context.settings.frontmatterIdField }
    );
    await context.fileManager.writeFile(contentsPath, contents);
    let worldFolderPath;
    if (story.world_id) {
      try {
        const world = await context.apiClient.getWorld(story.world_id);
        if (world == null ? void 0 : world.name) {
          worldFolderPath = context.fileManager.getWorldFolderPath(world.name);
        }
      } catch (e) {
      }
    }
    await writeRelationsFile({
      entity: {
        id: chapter.id,
        name: `Chapter ${chapter.number}: ${chapter.title}`,
        type: "chapter",
        worldId: (_a = story.world_id) != null ? _a : void 0
      },
      outputPath: relationsPath,
      context,
      worldFolderPath
    });
    return data;
  }
  async push(_entity, _context) {
  }
  async delete(id2, context) {
    await context.apiClient.deleteChapter(id2);
  }
};

// src/sync-v2/handlers/scene/SceneHandler.ts
var SceneHandler = class {
  constructor() {
    this.entityType = "scene";
    this.contentsGenerator = new ContentsGenerator();
    this.outlineGenerator = new OutlineGenerator();
  }
  async pull(id2, context) {
    var _a, _b, _c;
    const scene = await context.apiClient.getScene(id2);
    const beats = await context.apiClient.getBeats(scene.id);
    const sceneWithBeats = { scene, beats };
    const story = await context.apiClient.getStory(scene.story_id);
    const chapterOrder = scene.chapter_id ? (_a = (await context.apiClient.getChapter(scene.chapter_id)).number) != null ? _a : 0 : 0;
    const folderPath = context.fileManager.getStoryFolderPath(story.title);
    const scenesFolder = `${folderPath}/01-scenes`;
    await context.fileManager.ensureFolderExists(scenesFolder);
    const pathResolver = new PathResolver(folderPath);
    const filePath = pathResolver.getScenePath(scene, { chapterOrder });
    const contentBlocks = await context.apiClient.getContentBlocksByScene(scene.id);
    await context.fileManager.writeSceneFile(
      sceneWithBeats,
      filePath,
      story.title,
      contentBlocks,
      [],
      { linkMode: "full_path", storyFolderPath: folderPath, chapterOrder }
    );
    const outlinePath = filePath.replace(/\.md$/, ".outline.md");
    const contentsPath = filePath.replace(/\.md$/, ".contents.md");
    const relationsPath = filePath.replace(/\.md$/, ".relations.md");
    const outline = this.outlineGenerator.generateSceneOutline(sceneWithBeats, {
      syncedAt: context.timestamp(),
      showHelpBox: context.settings.showHelpBox,
      idField: context.settings.frontmatterIdField,
      storyFolderPath: folderPath
    });
    await context.fileManager.writeFile(outlinePath, outline);
    const sceneContentBlocks = /* @__PURE__ */ new Map();
    sceneContentBlocks.set(scene.id, contentBlocks);
    const beatContentBlocks = /* @__PURE__ */ new Map();
    for (const beat of beats) {
      const beatBlocks = await context.apiClient.getContentBlocksByBeat(beat.id);
      beatContentBlocks.set(beat.id, beatBlocks);
    }
    const contents = this.contentsGenerator.generateSceneContents(
      sceneWithBeats,
      sceneContentBlocks,
      beatContentBlocks,
      { syncedAt: context.timestamp(), idField: context.settings.frontmatterIdField }
    );
    await context.fileManager.writeFile(contentsPath, contents);
    let worldFolderPath;
    if (story.world_id) {
      try {
        const world = await context.apiClient.getWorld(story.world_id);
        if (world == null ? void 0 : world.name) {
          worldFolderPath = context.fileManager.getWorldFolderPath(world.name);
        }
      } catch (e) {
      }
    }
    await writeRelationsFile({
      entity: {
        id: scene.id,
        name: `Scene ${(_b = scene.order_num) != null ? _b : 0}: ${scene.goal || "Untitled"}`,
        type: "scene",
        worldId: (_c = story.world_id) != null ? _c : void 0
      },
      outputPath: relationsPath,
      context,
      worldFolderPath
    });
    return sceneWithBeats;
  }
  async push(entity, context) {
    var _a, _b, _c;
    const scene = entity.scene;
    const story = await context.apiClient.getStory(scene.story_id);
    const chapterOrder = scene.chapter_id ? (_a = (await context.apiClient.getChapter(scene.chapter_id)).number) != null ? _a : 0 : 0;
    const folderPath = context.fileManager.getStoryFolderPath(story.title);
    const pathResolver = new PathResolver(folderPath);
    const filePath = pathResolver.getScenePath(scene, { chapterOrder });
    let fileContent;
    try {
      fileContent = await context.fileManager.readFile(filePath);
    } catch (error) {
      if (((_b = error == null ? void 0 : error.message) == null ? void 0 : _b.includes("missing")) || (error == null ? void 0 : error.code) === "ENOENT") {
        (_c = context.emitWarning) == null ? void 0 : _c.call(context, {
          code: "scene_file_not_found",
          message: `Scene file not found: ${filePath}`,
          filePath
        });
        return;
      }
      throw error;
    }
    const frontmatter = context.fileManager.parseFrontmatter(fileContent);
    const currentPovCharacterId = frontmatter.pov_character_id && frontmatter.pov_character_id !== "null" && frontmatter.pov_character_id.trim() !== "" ? frontmatter.pov_character_id.trim() : null;
    const currentLocationId = frontmatter.location_id && frontmatter.location_id !== "null" && frontmatter.location_id.trim() !== "" ? frontmatter.location_id.trim() : null;
    const currentScene = await context.apiClient.getScene(scene.id);
    const oldPovCharacterId = currentScene.pov_character_id || null;
    const oldLocationId = currentScene.location_id || null;
    const needsUpdate = currentPovCharacterId !== oldPovCharacterId || currentLocationId !== oldLocationId || frontmatter.goal !== currentScene.goal || frontmatter.time_ref !== currentScene.time_ref || parseInt(frontmatter.order_num) !== currentScene.order_num || frontmatter.chapter_id !== (currentScene.chapter_id || null);
    if (needsUpdate) {
      await context.apiClient.updateScene(scene.id, {
        pov_character_id: currentPovCharacterId || void 0,
        location_id: currentLocationId || void 0,
        goal: frontmatter.goal || currentScene.goal,
        time_ref: frontmatter.time_ref || currentScene.time_ref,
        order_num: parseInt(frontmatter.order_num) || currentScene.order_num,
        chapter_id: frontmatter.chapter_id || null
      });
    }
    await this.ensureSceneRelations(
      scene.id,
      story.id,
      story.world_id || void 0,
      currentPovCharacterId,
      oldPovCharacterId,
      currentLocationId,
      oldLocationId,
      context
    );
  }
  async ensureSceneRelations(sceneId, storyId, worldId, currentPovCharacterId, oldPovCharacterId, currentLocationId, oldLocationId, context) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const existingRelationsResponse = await context.apiClient.listRelationsBySource({
      sourceType: "scene",
      sourceId: sceneId
    });
    const existingRelations = existingRelationsResponse.data;
    if (currentPovCharacterId !== oldPovCharacterId) {
      if (oldPovCharacterId) {
        const oldPovRelation = existingRelations.find(
          (rel) => rel.target_type === "character" && rel.target_id === oldPovCharacterId && rel.relation_type === "pov"
        );
        if (oldPovRelation) {
          try {
            await context.apiClient.deleteRelation(oldPovRelation.id);
          } catch (error) {
            (_a = context.emitWarning) == null ? void 0 : _a.call(context, {
              code: "relation_delete_error",
              message: `Failed to delete old POV relation: ${error}`
            });
          }
        }
      }
      if (currentPovCharacterId) {
        const existingPovRelation = existingRelations.find(
          (rel) => rel.target_type === "character" && rel.target_id === currentPovCharacterId && rel.relation_type === "pov"
        );
        if (!existingPovRelation) {
          try {
            await context.apiClient.getCharacter(currentPovCharacterId);
          } catch (error) {
            (_b = context.emitWarning) == null ? void 0 : _b.call(context, {
              code: "relation_validation_error",
              message: `Cannot create POV relation: character ${currentPovCharacterId} does not exist`
            });
            return;
          }
          try {
            if (!worldId) {
              const story = await context.apiClient.getStory(storyId);
              if (story.world_id) {
                worldId = story.world_id;
              } else {
                (_c = context.emitWarning) == null ? void 0 : _c.call(context, {
                  code: "relation_world_missing",
                  message: `Cannot create POV relation: story ${storyId} has no world_id`
                });
                return;
              }
            }
            await context.apiClient.createRelation({
              sourceType: "scene",
              sourceId: sceneId,
              targetType: "character",
              targetId: currentPovCharacterId,
              relationType: "pov"
            });
          } catch (error) {
            (_d = context.emitWarning) == null ? void 0 : _d.call(context, {
              code: "relation_create_error",
              message: `Failed to create POV relation: ${error}`
            });
          }
        }
      }
    }
    if (currentLocationId !== oldLocationId) {
      if (oldLocationId) {
        const oldLocationRelation = existingRelations.find(
          (rel) => rel.target_type === "location" && rel.target_id === oldLocationId && rel.relation_type === "setting"
        );
        if (oldLocationRelation) {
          try {
            await context.apiClient.deleteRelation(oldLocationRelation.id);
          } catch (error) {
            (_e = context.emitWarning) == null ? void 0 : _e.call(context, {
              code: "relation_delete_error",
              message: `Failed to delete old Location relation: ${error}`
            });
          }
        }
      }
      if (currentLocationId) {
        const existingLocationRelation = existingRelations.find(
          (rel) => rel.target_type === "location" && rel.target_id === currentLocationId && rel.relation_type === "setting"
        );
        if (!existingLocationRelation) {
          try {
            await context.apiClient.getLocation(currentLocationId);
          } catch (error) {
            (_f = context.emitWarning) == null ? void 0 : _f.call(context, {
              code: "relation_validation_error",
              message: `Cannot create Location relation: location ${currentLocationId} does not exist`
            });
            return;
          }
          try {
            if (!worldId) {
              const story = await context.apiClient.getStory(storyId);
              if (story.world_id) {
                worldId = story.world_id;
              } else {
                (_g = context.emitWarning) == null ? void 0 : _g.call(context, {
                  code: "relation_world_missing",
                  message: `Cannot create Location relation: story ${storyId} has no world_id`
                });
                return;
              }
            }
            await context.apiClient.createRelation({
              sourceType: "scene",
              sourceId: sceneId,
              targetType: "location",
              targetId: currentLocationId,
              relationType: "setting"
            });
          } catch (error) {
            (_h = context.emitWarning) == null ? void 0 : _h.call(context, {
              code: "relation_create_error",
              message: `Failed to create Location relation: ${error}`
            });
          }
        }
      }
    }
  }
  async delete(id2, context) {
    await context.apiClient.deleteScene(id2);
  }
};

// src/sync-v2/handlers/beat/BeatHandler.ts
var BeatHandler = class {
  constructor() {
    this.entityType = "beat";
    this.contentsGenerator = new ContentsGenerator();
  }
  async pull(id2, context) {
    var _a, _b, _c, _d, _e;
    const beat = await context.apiClient.getBeat(id2);
    const scene = await context.apiClient.getScene(beat.scene_id);
    const chapterOrder = scene.chapter_id ? (_a = (await context.apiClient.getChapter(scene.chapter_id)).number) != null ? _a : 0 : 0;
    const story = await context.apiClient.getStory(scene.story_id);
    const folderPath = context.fileManager.getStoryFolderPath(story.title);
    const beatsFolder = `${folderPath}/02-beats`;
    await context.fileManager.ensureFolderExists(beatsFolder);
    const pathResolver = new PathResolver(folderPath);
    const filePath = pathResolver.getBeatPath(beat, {
      chapterOrder,
      sceneOrder: (_b = scene.order_num) != null ? _b : 0
    });
    const contentBlocks = await context.apiClient.getContentBlocksByBeat(beat.id);
    await context.fileManager.writeBeatFile(beat, filePath, story.title, contentBlocks, {
      linkMode: "full_path",
      storyFolderPath: folderPath,
      chapterOrder,
      sceneOrder: (_c = scene.order_num) != null ? _c : 0
    });
    const contentsPath = filePath.replace(/\.md$/, ".contents.md");
    const relationsPath = filePath.replace(/\.md$/, ".relations.md");
    const beatContentBlocks = /* @__PURE__ */ new Map();
    beatContentBlocks.set(beat.id, contentBlocks);
    const contents = this.contentsGenerator.generateBeatContents(
      beat,
      beatContentBlocks,
      { syncedAt: context.timestamp(), idField: context.settings.frontmatterIdField }
    );
    await context.fileManager.writeFile(contentsPath, contents);
    let worldFolderPath;
    if (story.world_id) {
      try {
        const world = await context.apiClient.getWorld(story.world_id);
        if (world == null ? void 0 : world.name) {
          worldFolderPath = context.fileManager.getWorldFolderPath(world.name);
        }
      } catch (e) {
      }
    }
    await writeRelationsFile({
      entity: {
        id: beat.id,
        name: `Beat ${(_d = beat.order_num) != null ? _d : 0}: ${beat.intent || "Untitled"}`,
        type: "beat",
        worldId: (_e = story.world_id) != null ? _e : void 0
      },
      outputPath: relationsPath,
      context,
      worldFolderPath
    });
    return beat;
  }
  async push(_entity, _context) {
  }
  async delete(id2, context) {
    await context.apiClient.deleteBeat(id2);
  }
};

// src/sync-v2/parsers/entityFileParser.ts
var FRONTMATTER_REGEX2 = /^---\n([\s\S]*?)\n---/;
var HEADING_REGEX2 = /^(#{1,6})\s+(.+)$/;
var EntityFileParser = class {
  parse(content) {
    const frontmatter = this.parseFrontmatter(content);
    const body = content.replace(FRONTMATTER_REGEX2, "").trimStart();
    const headings = this.parseHeadings(body);
    return { frontmatter, body, headings };
  }
  updateFrontmatter(content, updates) {
    const frontmatter = this.parseFrontmatter(content);
    const merged = { ...frontmatter, ...updates };
    const serialized = this.serializeFrontmatter(merged);
    if (content.match(FRONTMATTER_REGEX2)) {
      return content.replace(FRONTMATTER_REGEX2, serialized);
    }
    return `${serialized}
${content}`;
  }
  getSectionContent(parsed, title) {
    var _a;
    const heading = parsed.headings.find(
      (h) => h.title.toLowerCase() === title.toLowerCase()
    );
    return (_a = heading == null ? void 0 : heading.content) == null ? void 0 : _a.trim();
  }
  parseFrontmatter(content) {
    const match = content.match(FRONTMATTER_REGEX2);
    if (!match) {
      return {};
    }
    const lines = match[1].split("\n");
    const data = {};
    for (const line of lines) {
      const colon = line.indexOf(":");
      if (colon === -1)
        continue;
      const key = line.slice(0, colon).trim();
      const value = line.slice(colon + 1).trim().replace(/^["']|["']$/g, "");
      data[key] = value;
    }
    return data;
  }
  serializeFrontmatter(frontmatter) {
    const lines = Object.entries(frontmatter).map(([key, value]) => `${key}: ${value}`);
    return `---
${lines.join("\n")}
---`;
  }
  parseHeadings(body) {
    const lines = body.split("\n");
    const headings = [];
    let current = null;
    for (const line of lines) {
      const match = line.match(HEADING_REGEX2);
      if (match) {
        if (current) {
          headings.push(current);
        }
        current = {
          level: match[1].length,
          title: match[2].trim(),
          content: ""
        };
      } else if (current) {
        current.content += `${line}
`;
      }
    }
    if (current) {
      headings.push(current);
    }
    return headings.map((heading) => ({
      ...heading,
      content: heading.content.trim()
    }));
  }
};

// src/sync-v2/utils/contentBlockHelpers.ts
async function resolveContentBlockHierarchy(contentBlockId, apiClient) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  try {
    const anchors = await apiClient.getContentAnchors(contentBlockId);
    if (anchors.length === 0) {
      const contentBlock = await apiClient.getContentBlock(contentBlockId);
      if (contentBlock.chapter_id) {
        const chapter2 = await apiClient.getChapter(contentBlock.chapter_id);
        const story2 = await apiClient.getStory(chapter2.story_id);
        return {
          contentBlockId,
          chapter: {
            id: chapter2.id,
            title: chapter2.title,
            number: (_a = chapter2.number) != null ? _a : 0
          },
          story: {
            id: story2.id,
            title: story2.title
          },
          worldId: (_b = story2.world_id) != null ? _b : void 0
        };
      }
      return null;
    }
    const beatAnchor = anchors.find((a) => a.entity_type === "beat");
    const sceneAnchor = anchors.find((a) => a.entity_type === "scene");
    const chapterAnchor = anchors.find((a) => a.entity_type === "chapter");
    let beat = null;
    let scene = null;
    let chapter = null;
    let story = null;
    if (beatAnchor) {
      beat = await apiClient.getBeat(beatAnchor.entity_id);
      scene = await apiClient.getScene(beat.scene_id);
      if (scene.chapter_id) {
        chapter = await apiClient.getChapter(scene.chapter_id);
      }
      story = await apiClient.getStory(scene.story_id);
    } else if (sceneAnchor) {
      scene = await apiClient.getScene(sceneAnchor.entity_id);
      if (scene.chapter_id) {
        chapter = await apiClient.getChapter(scene.chapter_id);
      }
      story = await apiClient.getStory(scene.story_id);
    } else if (chapterAnchor) {
      chapter = await apiClient.getChapter(chapterAnchor.entity_id);
      story = await apiClient.getStory(chapter.story_id);
    } else {
      return null;
    }
    if (!story) {
      return null;
    }
    return {
      contentBlockId,
      beat: beat ? {
        id: beat.id,
        intent: (_c = beat.intent) != null ? _c : void 0,
        order_num: (_d = beat.order_num) != null ? _d : 0
      } : void 0,
      scene: scene ? {
        id: scene.id,
        goal: (_e = scene.goal) != null ? _e : void 0,
        order_num: (_f = scene.order_num) != null ? _f : 0
      } : void 0,
      chapter: chapter ? {
        id: chapter.id,
        title: chapter.title,
        number: (_g = chapter.number) != null ? _g : 0
      } : void 0,
      story: {
        id: story.id,
        title: story.title
      },
      worldId: (_h = story.world_id) != null ? _h : void 0
    };
  } catch (error) {
    console.warn("[Sync V2] Failed to resolve ContentBlock hierarchy", { contentBlockId, error });
    return null;
  }
}
function buildHierarchyContext(hierarchy) {
  const parts = [];
  if (hierarchy.chapter) {
    const chapterNum = hierarchy.chapter.number > 0 ? String(hierarchy.chapter.number) : "?";
    parts.push(`Chapter ${chapterNum}: ${hierarchy.chapter.title}`);
  }
  if (hierarchy.scene) {
    const sceneNum = hierarchy.scene.order_num > 0 ? String(hierarchy.scene.order_num) : "?";
    const sceneTitle = hierarchy.scene.goal || "Untitled Scene";
    parts.push(`Scene ${sceneNum}: ${sceneTitle}`);
  }
  if (hierarchy.beat) {
    const beatNum = hierarchy.beat.order_num > 0 ? String(hierarchy.beat.order_num) : "?";
    const beatTitle = hierarchy.beat.intent || "Untitled Beat";
    parts.push(`Beat ${beatNum}: ${beatTitle}`);
  }
  return parts.join(" > ") || hierarchy.story.title;
}
async function createCitationRelations(mentions, hierarchy, sourceContentBlockId, apiClient, contextString) {
  const result = { created: 0, errors: [] };
  let sourceType;
  let sourceId;
  if (hierarchy.beat) {
    sourceType = "beat";
    sourceId = hierarchy.beat.id;
  } else if (hierarchy.scene) {
    sourceType = "scene";
    sourceId = hierarchy.scene.id;
  } else if (hierarchy.chapter) {
    sourceType = "chapter";
    sourceId = hierarchy.chapter.id;
  } else {
    sourceType = "content_block";
    sourceId = sourceContentBlockId;
  }
  const existingRelationsResponse = await apiClient.listRelationsBySource({
    sourceType,
    sourceId
  });
  const existingRelations = existingRelationsResponse.data;
  const existingRelationsByTarget = /* @__PURE__ */ new Map();
  for (const rel of existingRelations) {
    if (!existingRelationsByTarget.has(rel.target_id)) {
      existingRelationsByTarget.set(rel.target_id, []);
    }
    existingRelationsByTarget.get(rel.target_id).push(rel);
  }
  for (const mention of mentions) {
    try {
      const existingForTarget = existingRelationsByTarget.get(mention.entityId) || [];
      const existingCitation = existingForTarget.find(
        (rel) => rel.target_type === mention.entityType && rel.target_id === mention.entityId && rel.relation_type === "citation" && rel.source_type === sourceType && rel.source_id === sourceId
      );
      if (existingCitation) {
        continue;
      }
      let targetExists = false;
      try {
        switch (mention.entityType) {
          case "character":
            await apiClient.getCharacter(mention.entityId);
            targetExists = true;
            break;
          case "location":
            await apiClient.getLocation(mention.entityId);
            targetExists = true;
            break;
          case "faction":
            await apiClient.getFaction(mention.entityId);
            targetExists = true;
            break;
          case "artifact":
            await apiClient.getArtifact(mention.entityId);
            targetExists = true;
            break;
          case "event":
            await apiClient.getEvent(mention.entityId);
            targetExists = true;
            break;
          case "lore":
            await apiClient.getLore(mention.entityId);
            targetExists = true;
            break;
          default:
            result.errors.push(
              `Unsupported entity type for citation: ${mention.entityType}`
            );
            continue;
        }
      } catch (error) {
        result.errors.push(
          `Target entity ${mention.entityType}:${mention.entityId} does not exist: ${error}`
        );
        continue;
      }
      if (!targetExists) {
        result.errors.push(`Failed to validate target entity ${mention.entityType}:${mention.entityId}`);
        continue;
      }
      const contextWithMetadata = `${contextString} (Source: ContentBlock ${sourceContentBlockId})`;
      await apiClient.createRelation({
        sourceType,
        sourceId,
        targetType: mention.entityType,
        targetId: mention.entityId,
        relationType: "citation",
        context: contextWithMetadata
      });
      result.created++;
    } catch (error) {
      result.errors.push(
        `Failed to create citation for ${mention.entityType}:${mention.entityId}: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
  return result;
}

// src/sync-v2/handlers/content/ContentBlockHandler.ts
var ContentBlockHandler = class {
  constructor() {
    this.entityType = "content_block";
    this.parser = new EntityFileParser();
  }
  async pull(id2, context) {
    const contentBlock = await context.apiClient.getContentBlock(id2);
    let chapter = null;
    if (contentBlock.chapter_id) {
      chapter = await context.apiClient.getChapter(contentBlock.chapter_id);
    }
    const storyId = chapter == null ? void 0 : chapter.story_id;
    if (!storyId) {
      return contentBlock;
    }
    const story = await context.apiClient.getStory(storyId);
    const folderPath = context.fileManager.getStoryFolderPath(story.title);
    const pathResolver = new PathResolver(folderPath);
    const filePath = pathResolver.getContentBlockPath(contentBlock);
    const directory = filePath.split("/").slice(0, -1).join("/");
    await context.fileManager.ensureFolderExists(directory);
    await context.fileManager.writeContentBlockFile(contentBlock, filePath, story.title);
    return contentBlock;
  }
  async push(entity, context) {
    var _a, _b, _c;
    try {
      const story = await this.resolveStoryForContentBlock(entity, context);
      if (!story) {
        throw new Error(`Could not resolve story for content block ${entity.id}`);
      }
      const folderPath = context.fileManager.getStoryFolderPath(story.title);
      const pathResolver = new PathResolver(folderPath);
      const filePath = pathResolver.getContentBlockPath(entity);
      let fileContent;
      try {
        fileContent = await context.fileManager.readFile(filePath);
      } catch (error) {
        (_a = context.emitWarning) == null ? void 0 : _a.call(context, {
          code: "content_block_file_not_found",
          message: `Content block file not found at ${filePath}. Skipping push.`,
          filePath,
          details: error
        });
        return;
      }
      const parsed = this.parser.parse(fileContent);
      const idField = context.settings.frontmatterIdField;
      const contentBlockId = getFrontmatterId(parsed.frontmatter, idField);
      if (!contentBlockId || contentBlockId !== entity.id) {
        (_b = context.emitWarning) == null ? void 0 : _b.call(context, {
          code: "content_block_id_mismatch",
          message: `Content block ID mismatch: expected ${entity.id}, found ${contentBlockId != null ? contentBlockId : "none"}`,
          filePath
        });
        return;
      }
      const content = parsed.body.trim();
      const frontmatter = parsed.frontmatter;
      const updates = {
        content
      };
      if (frontmatter.order_num !== void 0) {
        const orderNum = parseInt(frontmatter.order_num);
        if (!isNaN(orderNum) && orderNum !== entity.order_num) {
          updates.order_num = orderNum;
        }
      }
      if (frontmatter.chapter_id !== void 0) {
        const chapterId = frontmatter.chapter_id === "null" || frontmatter.chapter_id.trim() === "" ? null : frontmatter.chapter_id.trim();
        if (chapterId !== entity.chapter_id) {
          updates.chapter_id = chapterId;
        }
      }
      if (Object.keys(updates).length > 1 || updates.content && updates.content !== entity.content) {
        await context.apiClient.updateContentBlock(entity.id, updates);
      }
      if (content && content.trim().length > 0) {
        await this.processEntityMentions(entity.id, content, context);
      }
    } catch (error) {
      (_c = context.emitWarning) == null ? void 0 : _c.call(context, {
        code: "content_block_push_error",
        message: `Failed to push content block ${entity.id}: ${error instanceof Error ? error.message : String(error)}`,
        details: error
      });
      throw error;
    }
  }
  async processEntityMentions(contentBlockId, content, context) {
    var _a, _b, _c;
    try {
      const mentions = detectEntityMentions(content);
      if (mentions.length === 0) {
        return;
      }
      const resolvedMentions = [];
      for (const mention of mentions) {
        const resolved = await resolveEntityMention(mention, context);
        if (resolved) {
          resolvedMentions.push({
            entityId: resolved.entityId,
            entityType: resolved.entityType,
            worldId: resolved.worldId
          });
        }
      }
      if (resolvedMentions.length === 0) {
        return;
      }
      const hierarchy = await resolveContentBlockHierarchy(contentBlockId, context.apiClient);
      if (!hierarchy) {
        (_a = context.emitWarning) == null ? void 0 : _a.call(context, {
          code: "hierarchy_resolution_failed",
          message: `Could not resolve hierarchy for content block ${contentBlockId}. Citations will not be created.`
        });
        return;
      }
      const contextString = buildHierarchyContext(hierarchy);
      const result = await createCitationRelations(
        resolvedMentions,
        hierarchy,
        contentBlockId,
        context.apiClient,
        contextString
      );
      if (result.created > 0) {
        console.log(
          `[Sync V2] Created ${result.created} citation relation(s) for content block ${contentBlockId}`
        );
      }
      if (result.errors.length > 0) {
        for (const error of result.errors) {
          (_b = context.emitWarning) == null ? void 0 : _b.call(context, {
            code: "citation_creation_error",
            message: error
          });
        }
      }
    } catch (error) {
      (_c = context.emitWarning) == null ? void 0 : _c.call(context, {
        code: "entity_mention_processing_error",
        message: `Failed to process entity mentions for content block ${contentBlockId}: ${error instanceof Error ? error.message : String(error)}`,
        details: error
      });
    }
  }
  async resolveStoryForContentBlock(contentBlock, context) {
    if (contentBlock.chapter_id) {
      try {
        const chapter = await context.apiClient.getChapter(contentBlock.chapter_id);
        if (chapter.story_id) {
          return await context.apiClient.getStory(chapter.story_id);
        }
      } catch (error) {
        console.warn(`Failed to resolve story via chapter_id for content block ${contentBlock.id}`, error);
      }
    }
    try {
      const anchors = await context.apiClient.getContentAnchors(contentBlock.id);
      const sceneAnchor = anchors.find((anchor) => anchor.entity_type === "scene");
      if (sceneAnchor) {
        const scene = await context.apiClient.getScene(sceneAnchor.entity_id);
        if (scene.story_id) {
          return await context.apiClient.getStory(scene.story_id);
        }
      }
      const beatAnchor = anchors.find((anchor) => anchor.entity_type === "beat");
      if (beatAnchor) {
        const beat = await context.apiClient.getBeat(beatAnchor.entity_id);
        const scene = await context.apiClient.getScene(beat.scene_id);
        if (scene.story_id) {
          return await context.apiClient.getStory(scene.story_id);
        }
      }
      const chapterAnchor = anchors.find((anchor) => anchor.entity_type === "chapter");
      if (chapterAnchor) {
        const chapter = await context.apiClient.getChapter(chapterAnchor.entity_id);
        if (chapter.story_id) {
          return await context.apiClient.getStory(chapter.story_id);
        }
      }
    } catch (error) {
      console.warn(`Failed to resolve story via ContentAnchors for content block ${contentBlock.id}`, error);
    }
    return null;
  }
  async delete(id2, context) {
    await context.apiClient.deleteContentBlock(id2);
  }
};

// src/sync-v2/handlers/world/ArchetypeHandler.ts
var ArchetypeHandler = class {
  constructor() {
    this.entityType = "archetype";
    this.frontmatterGenerator = new FrontmatterGenerator();
  }
  async pull(id2, context) {
    const archetype = await context.apiClient.getArchetype(id2);
    const worldsRoot = context.fileManager.getWorldsRootPath();
    const charactersFolder = `${worldsRoot}/characters`;
    const folderPath = `${charactersFolder}/_archetypes`;
    await context.fileManager.ensureFolderExists(worldsRoot);
    await context.fileManager.ensureFolderExists(charactersFolder);
    await context.fileManager.ensureFolderExists(folderPath);
    const filePath = `${folderPath}/${slugify(archetype.name)}.md`;
    await context.fileManager.writeFile(filePath, this.renderArchetype(archetype, context));
    return archetype;
  }
  async push(entity, context) {
    var _a, _b;
    const worldsRoot = context.fileManager.getWorldsRootPath();
    const archetypeFolder = `${worldsRoot}/characters/_archetypes`;
    const filePath = `${archetypeFolder}/${slugify(entity.name)}.md`;
    let localContent;
    try {
      localContent = await context.fileManager.readFile(filePath);
    } catch (e) {
      return;
    }
    const parsed = parseWorldEntityFile(localContent);
    const description = (_a = parsed.description) != null ? _a : void 0;
    if (parsed.name === entity.name && description === ((_b = entity.description) != null ? _b : void 0)) {
      return;
    }
    await context.apiClient.updateArchetype(entity.id, {
      name: parsed.name,
      description
    });
  }
  async delete(id2, context) {
    await context.apiClient.deleteArchetype(id2);
  }
  renderArchetype(archetype, context) {
    const baseFields = {
      id: archetype.id,
      tenant_id: archetype.tenant_id,
      created_at: archetype.created_at,
      updated_at: archetype.updated_at
    };
    const frontmatter = this.frontmatterGenerator.generate(baseFields, void 0, {
      entityType: "archetype",
      date: archetype.created_at,
      idField: context.settings.frontmatterIdField
    });
    return [
      frontmatter,
      "",
      `# ${archetype.name}`,
      "",
      "## Description",
      archetype.description || "_No description yet._",
      ""
    ].join("\n");
  }
};

// src/sync-v2/handlers/world/TraitHandler.ts
var TraitHandler = class {
  constructor() {
    this.entityType = "trait";
    this.frontmatterGenerator = new FrontmatterGenerator();
  }
  async pull(id2, context) {
    const trait = await context.apiClient.getTrait(id2);
    const worldsRoot = context.fileManager.getWorldsRootPath();
    const charactersFolder = `${worldsRoot}/characters`;
    const folderPath = `${charactersFolder}/_traits`;
    await context.fileManager.ensureFolderExists(worldsRoot);
    await context.fileManager.ensureFolderExists(charactersFolder);
    await context.fileManager.ensureFolderExists(folderPath);
    const filePath = `${folderPath}/${slugify(trait.name)}.md`;
    await context.fileManager.writeFile(filePath, this.renderTrait(trait, context));
    return trait;
  }
  async push(entity, context) {
    var _a, _b;
    const worldsRoot = context.fileManager.getWorldsRootPath();
    const folderPath = `${worldsRoot}/characters/_traits`;
    const filePath = `${folderPath}/${slugify(entity.name)}.md`;
    let localContent;
    try {
      localContent = await context.fileManager.readFile(filePath);
    } catch (e) {
      return;
    }
    const parsed = parseWorldEntityFile(localContent);
    const description = (_a = parsed.description) != null ? _a : void 0;
    if (parsed.name === entity.name && (description != null ? description : "") === ((_b = entity.description) != null ? _b : "")) {
      return;
    }
    await context.apiClient.updateTrait(entity.id, {
      name: parsed.name,
      description
    });
  }
  async delete(id2, context) {
    await context.apiClient.deleteTrait(id2);
  }
  renderTrait(trait, context) {
    const baseFields = {
      id: trait.id,
      tenant_id: trait.tenant_id,
      category: trait.category,
      created_at: trait.created_at,
      updated_at: trait.updated_at
    };
    const frontmatter = this.frontmatterGenerator.generate(baseFields, void 0, {
      entityType: "trait",
      date: trait.created_at,
      idField: context.settings.frontmatterIdField
    });
    return [
      frontmatter,
      "",
      `# ${trait.name}`,
      "",
      "## Description",
      trait.description || "_No description yet._",
      ""
    ].join("\n");
  }
};

// src/sync-v2/backup/BackupManager.ts
var BackupManager = class {
  constructor(app) {
    this.app = app;
  }
  async createBackup(filePaths, operationType) {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
    const backupFolderPath = `.story-engine/backups/${timestamp}-${operationType}`;
    const filesCopied = [];
    const errors = [];
    try {
      await this.ensureFolderExists(backupFolderPath);
    } catch (error) {
      return {
        success: false,
        backupPath: backupFolderPath,
        filesCopied,
        errors: [`Failed to create backup folder: ${error}`]
      };
    }
    for (const filePath of filePaths) {
      try {
        const abstract = this.app.vault.getAbstractFileByPath(filePath);
        if (!abstract || !("path" in abstract) || "children" in abstract) {
          continue;
        }
        const content = await this.app.vault.read(abstract);
        const backupFilePath = `${backupFolderPath}/${filePath}`;
        const backupFolder = backupFilePath.substring(0, backupFilePath.lastIndexOf("/"));
        await this.ensureFolderExists(backupFolder);
        await this.app.vault.create(backupFilePath, content);
        filesCopied.push(filePath);
      } catch (error) {
        errors.push(`Failed to backup ${filePath}: ${error}`);
      }
    }
    const manifest = {
      timestamp,
      operationType,
      filesCopied,
      errors
    };
    try {
      await this.app.vault.create(
        `${backupFolderPath}/manifest.json`,
        JSON.stringify(manifest, null, 2)
      );
    } catch (error) {
      errors.push(`Failed to write manifest: ${error}`);
    }
    return {
      success: errors.length === 0,
      backupPath: backupFolderPath,
      filesCopied,
      errors
    };
  }
  getStoryFilesForBackup(storyFolderPath) {
    return [
      `${storyFolderPath}/story.md`,
      `${storyFolderPath}/story.outline.md`,
      `${storyFolderPath}/story.contents.md`,
      `${storyFolderPath}/story.relations.md`
    ];
  }
  getWorldFilesForBackup(worldFolderPath) {
    return [
      `${worldFolderPath}/world.md`,
      `${worldFolderPath}/world.outline.md`,
      `${worldFolderPath}/world.relations.md`
    ];
  }
  async ensureFolderExists(path) {
    const parts = path.split("/");
    let current = "";
    for (const part of parts) {
      current = current ? `${current}/${part}` : part;
      const existing = this.app.vault.getAbstractFileByPath(current);
      if (!existing) {
        await this.app.vault.createFolder(current);
      }
    }
  }
};

// src/sync-v2/core/SyncOrchestrator.ts
var SyncOrchestrator = class {
  constructor(context) {
    this.warningBuffer = [];
    this.context = context;
    this.registry = new EntityRegistry();
    this.contentsGenerator = new ContentsGenerator();
    this.pushPlanner = new PushPlanner();
    this.contentCitationService = new ContentCitationService(context);
    this.pushExecutor = new PushExecutor(context.apiClient, this.contentCitationService);
    this.conflictResolver = new ConflictResolver(context.app, context);
    this.backupManager = new BackupManager(context.app);
    const originalEmitter = this.context.emitWarning;
    this.context.emitWarning = (warning) => {
      this.warningBuffer.push(warning);
      originalEmitter == null ? void 0 : originalEmitter(warning);
    };
    this.registerDefaultHandlers();
  }
  /**
   * Get the ConflictResolver instance
   */
  getConflictResolver() {
    return this.conflictResolver;
  }
  dispose() {
  }
  async run(operation) {
    this.warningBuffer = [];
    try {
      switch (operation.type) {
        case "pull_story":
          return this.attachWarnings(await this.handlePullStory(operation));
        case "pull_all_stories":
          return this.attachWarnings(await this.handlePullAllStories(operation));
        case "push_story":
          return this.attachWarnings(await this.handlePushStory(operation));
        case "pull_chapter":
          return this.attachWarnings(await this.handlePullChapter(operation));
        case "pull_scene":
          return this.attachWarnings(await this.handlePullScene(operation));
        case "pull_beat":
          return this.attachWarnings(await this.handlePullBeat(operation));
        case "pull_content_block":
          return this.attachWarnings(await this.handlePullContentBlock(operation));
        case "pull_world":
          return this.attachWarnings(await this.handlePullWorld(operation));
        case "pull_character":
          return this.attachWarnings(await this.handlePullCharacter(operation));
        case "pull_location":
          return this.attachWarnings(await this.handlePullLocation(operation));
        case "pull_faction":
          return this.attachWarnings(await this.handlePullFaction(operation));
        case "pull_artifact":
          return this.attachWarnings(await this.handlePullArtifact(operation));
        case "pull_event":
          return this.attachWarnings(await this.handlePullEvent(operation));
        case "pull_lore":
          return this.attachWarnings(await this.handlePullLore(operation));
        case "pull_archetype":
          return this.attachWarnings(await this.handlePullArchetype(operation));
        case "pull_trait":
          return this.attachWarnings(await this.handlePullTrait(operation));
      }
      throw new Error(`Unhandled sync operation: ${operation.type}`);
    } catch (error) {
      return this.attachWarnings({
        success: false,
        errors: [
          {
            code: "sync_v2_unhandled_error",
            message: error instanceof Error ? error.message : "Unknown error while executing Sync V2 operation",
            details: error
          }
        ]
      });
    }
  }
  attachWarnings(result) {
    var _a;
    if (this.warningBuffer.length === 0) {
      return result;
    }
    const combined = [...(_a = result.warnings) != null ? _a : [], ...this.warningBuffer];
    return {
      ...result,
      warnings: combined
    };
  }
  async handlePullStory(operation) {
    const { storyId } = operation.payload;
    const handler = this.registry.get("story");
    if (!handler) {
      return this.missingHandler("story");
    }
    await this.backupStoryBeforePull(storyId);
    await handler.pull(storyId, this.context);
    return {
      success: true,
      message: "Story pulled successfully (handlers in progress)."
    };
  }
  async handlePullAllStories(operation) {
    var _a;
    const stories = await this.context.apiClient.listStories();
    return {
      success: false,
      message: "Sync V2 bulk pull is not yet implemented.",
      errors: [
        {
          code: "sync_v2_not_implemented",
          message: "Bulk pull still pending implementation",
          details: {
            requestedWorlds: (_a = operation.payload.includeWorlds) != null ? _a : false,
            storyCount: stories.length
          },
          recoverable: true
        }
      ]
    };
  }
  async handlePushStory(operation) {
    var _a;
    const { folderPath } = operation.payload;
    await this.backupStoryFolder(folderPath, "push");
    try {
      const idField = this.context.settings.frontmatterIdField;
      const metadata = await this.context.fileManager.readStoryMetadata(folderPath, idField);
      const storyId = metadata.frontmatter.id;
      if (!storyId) {
        return {
          success: false,
          errors: [
            {
              code: "sync_v2_missing_story_id",
              message: `Could not determine story ID from story.md frontmatter (using field: ${idField || "id"}).`,
              details: { folderPath, idField: idField || "id" },
              recoverable: false
            }
          ]
        };
      }
      const localContentsPath = `${folderPath}/story.contents.md`;
      const localContents = await this.context.fileManager.readFile(localContentsPath);
      const remoteStory = await this.context.apiClient.getStoryWithHierarchy(storyId);
      const remoteContents = this.contentsGenerator.generateStoryContents({
        story: remoteStory.story,
        chapters: remoteStory.chapters,
        options: {
          syncedAt: this.context.timestamp(),
          idField: this.context.settings.frontmatterIdField
        }
      });
      const plan = this.pushPlanner.buildPlan(remoteContents, localContents);
      if (plan.actions.length === 0) {
        const hasWarnings = plan.unsupportedOperations.length > 0 || plan.untrackedSegments.length > 0;
        return {
          success: true,
          message: hasWarnings ? "Push skipped: only unsupported edits detected (placeholders or free text)." : "Push skipped: no structural changes detected.",
          stats: { skipped: 0 },
          warnings: plan.warnings
        };
      }
      const execution = await this.pushExecutor.execute(plan.actions, {
        worldId: (_a = remoteStory.story.world_id) != null ? _a : void 0
      });
      const success = execution.errors.length === 0;
      const message = success ? `Push applied ${execution.applied} structural updates.` : `Push applied ${execution.applied} updates. ${execution.errors.length} actions failed.`;
      return {
        success,
        message,
        stats: {
          updated: execution.applied,
          skipped: plan.actions.length - execution.applied
        },
        errors: execution.errors.length ? execution.errors : void 0,
        warnings: plan.warnings
      };
    } catch (error) {
      return {
        success: false,
        errors: [
          {
            code: "sync_v2_push_failed",
            message: error instanceof Error ? error.message : "Unknown error while pushing story.",
            details: {
              folderPath
            },
            recoverable: false
          }
        ]
      };
    }
  }
  async backupStoryBeforePull(storyId) {
    var _a, _b;
    if (this.context.backupMode === "off") {
      return;
    }
    try {
      const story = await this.context.apiClient.getStory(storyId);
      if (!(story == null ? void 0 : story.title)) {
        return;
      }
      const folderPath = this.context.fileManager.getStoryFolderPath(story.title);
      await this.backupStoryFolder(folderPath, "pull");
    } catch (error) {
      (_b = (_a = this.context).emitWarning) == null ? void 0 : _b.call(_a, {
        code: "backup_failed",
        message: `Failed to backup story before pull: ${error instanceof Error ? error.message : String(error)}`,
        details: error
      });
    }
  }
  async backupStoryFolder(folderPath, operation) {
    var _a, _b, _c, _d;
    if (this.context.backupMode === "off") {
      return;
    }
    try {
      const filesToBackup = this.backupManager.getStoryFilesForBackup(folderPath);
      const result = await this.backupManager.createBackup(filesToBackup, operation);
      if (!result.success) {
        (_b = (_a = this.context).emitWarning) == null ? void 0 : _b.call(_a, {
          code: "backup_partial",
          message: `Backup parcial: ${result.filesCopied.length} arquivos salvos, ${result.errors.length} erros`,
          details: result.errors
        });
      }
    } catch (error) {
      (_d = (_c = this.context).emitWarning) == null ? void 0 : _d.call(_c, {
        code: "backup_failed",
        message: `Failed to create backup: ${error instanceof Error ? error.message : String(error)}`,
        details: error
      });
    }
  }
  notImplemented(operation) {
    return {
      success: false,
      errors: [
        {
          code: "sync_v2_not_implemented",
          message: `No handler registered for operation "${operation}".`,
          recoverable: true
        }
      ]
    };
  }
  missingHandler(entityType) {
    return {
      success: false,
      errors: [
        {
          code: "sync_v2_missing_handler",
          message: `No handler registered for entity "${entityType}".`,
          recoverable: false
        }
      ]
    };
  }
  registerDefaultHandlers() {
    this.registry.register("story", new StoryHandler());
    this.registry.register("chapter", new ChapterHandler());
    this.registry.register("scene", new SceneHandler());
    this.registry.register("beat", new BeatHandler());
    this.registry.register("content_block", new ContentBlockHandler());
    this.registry.register("world", new WorldHandler());
    this.registry.register("character", new CharacterHandler());
    this.registry.register("location", new LocationHandler());
    this.registry.register("faction", new FactionHandler());
    this.registry.register("artifact", new ArtifactHandler());
    this.registry.register("event", new EventHandler());
    this.registry.register("lore", new LoreHandler());
    this.registry.register("archetype", new ArchetypeHandler());
    this.registry.register("trait", new TraitHandler());
  }
  async handlePullChapter(operation) {
    const handler = this.registry.get("chapter");
    if (!handler) {
      return this.missingHandler("chapter");
    }
    await handler.pull(operation.payload.chapterId, this.context);
    return { success: true, message: "Chapter pulled successfully." };
  }
  async handlePullScene(operation) {
    const handler = this.registry.get("scene");
    if (!handler) {
      return this.missingHandler("scene");
    }
    await handler.pull(operation.payload.sceneId, this.context);
    return { success: true, message: "Scene pulled successfully." };
  }
  async handlePullBeat(operation) {
    const handler = this.registry.get("beat");
    if (!handler) {
      return this.missingHandler("beat");
    }
    await handler.pull(operation.payload.beatId, this.context);
    return { success: true, message: "Beat pulled successfully." };
  }
  async handlePullContentBlock(operation) {
    const handler = this.registry.get("content_block");
    if (!handler) {
      return this.missingHandler("content_block");
    }
    await handler.pull(operation.payload.contentBlockId, this.context);
    return { success: true, message: "Content block pulled successfully." };
  }
  async handlePullWorld(operation) {
    const handler = this.registry.get("world");
    if (!handler) {
      return this.missingHandler("world");
    }
    await handler.pull(operation.payload.worldId, this.context);
    return { success: true, message: "World pulled successfully." };
  }
  async handlePullCharacter(operation) {
    const handler = this.registry.get("character");
    if (!handler) {
      return this.missingHandler("character");
    }
    await handler.pull(operation.payload.entityId, this.context);
    return { success: true, message: "Character pulled successfully." };
  }
  async handlePullLocation(operation) {
    const handler = this.registry.get("location");
    if (!handler) {
      return this.missingHandler("location");
    }
    await handler.pull(operation.payload.entityId, this.context);
    return { success: true, message: "Location pulled successfully." };
  }
  async handlePullFaction(operation) {
    const handler = this.registry.get("faction");
    if (!handler) {
      return this.missingHandler("faction");
    }
    await handler.pull(operation.payload.entityId, this.context);
    return { success: true, message: "Faction pulled successfully." };
  }
  async handlePullArtifact(operation) {
    const handler = this.registry.get("artifact");
    if (!handler) {
      return this.missingHandler("artifact");
    }
    await handler.pull(operation.payload.entityId, this.context);
    return { success: true, message: "Artifact pulled successfully." };
  }
  async handlePullEvent(operation) {
    const handler = this.registry.get("event");
    if (!handler) {
      return this.missingHandler("event");
    }
    await handler.pull(operation.payload.entityId, this.context);
    return { success: true, message: "Event pulled successfully." };
  }
  async handlePullLore(operation) {
    const handler = this.registry.get("lore");
    if (!handler) {
      return this.missingHandler("lore");
    }
    await handler.pull(operation.payload.entityId, this.context);
    return { success: true, message: "Lore pulled successfully." };
  }
  async handlePullArchetype(operation) {
    const handler = this.registry.get("archetype");
    if (!handler) {
      return this.missingHandler("archetype");
    }
    await handler.pull(operation.payload.entityId, this.context);
    return { success: true, message: "Archetype pulled successfully." };
  }
  async handlePullTrait(operation) {
    const handler = this.registry.get("trait");
    if (!handler) {
      return this.missingHandler("trait");
    }
    await handler.pull(operation.payload.entityId, this.context);
    return { success: true, message: "Trait pulled successfully." };
  }
};

// src/sync-v2/apiUpdateNotifier/ApiUpdateNotifierHandler.ts
var import_obsidian20 = require("obsidian");
var ApiUpdateNotifierHandler = class {
  constructor(notifier, orchestrator, context) {
    this.notifier = notifier;
    this.orchestrator = orchestrator;
    this.context = context;
    this.isProcessing = false;
    this.processingQueue = [];
  }
  /**
   * Start listening to API update events
   */
  start() {
    if (this.unsubscribe) {
      return;
    }
    this.unsubscribe = this.notifier.subscribe(async (event) => {
      await this.handleEvent(event);
    });
  }
  /**
   * Stop listening to API update events
   */
  stop() {
    if (this.unsubscribe) {
      this.unsubscribe();
      this.unsubscribe = void 0;
    }
    this.processingQueue = [];
    this.isProcessing = false;
  }
  /**
   * Handle an API update event
   */
  async handleEvent(event) {
    this.processingQueue.push(event);
    if (!this.isProcessing) {
      await this.processQueue();
    }
  }
  /**
   * Process queued events
   */
  async processQueue() {
    var _a, _b;
    if (this.processingQueue.length === 0) {
      this.isProcessing = false;
      return;
    }
    this.isProcessing = true;
    while (this.processingQueue.length > 0) {
      const event = this.processingQueue.shift();
      if (!event) {
        break;
      }
      try {
        await this.processEvent(event);
      } catch (err) {
        console.error(`Failed to process API update event ${event.type} for ${event.entityType}:${event.entityId}`, err);
        (_b = (_a = this.context).emitWarning) == null ? void 0 : _b.call(_a, {
          code: "api_update_failed",
          message: `Failed to sync ${event.entityType} ${event.entityId} from API update`,
          severity: "warning",
          details: { event, error: err }
        });
      }
    }
    this.isProcessing = false;
  }
  /**
   * Process a single API update event
   */
  async processEvent(event) {
    var _a, _b;
    const [entityType, action] = event.type.split(".");
    if (action === "deleted") {
      await this.handleDeletion(event);
      return;
    }
    const operation = this.mapEventToOperation(event);
    if (!operation) {
      return;
    }
    const result = await this.orchestrator.run(operation);
    if (result.warnings && result.warnings.length > 0) {
      for (const warning of result.warnings) {
        (_b = (_a = this.context).emitWarning) == null ? void 0 : _b.call(_a, warning);
      }
    }
    if (result.success) {
      const entityName = this.getEntityDisplayName(event);
      new import_obsidian20.Notice(`${entityName} synced from API`);
    }
  }
  /**
   * Handle deletion events
   * 
   * Note: Full deletion support requires:
   * 1. A way to map entity IDs to file paths (e.g., EntityRegistry with file paths)
   * 2. Deletion of the entity file and potentially related files
   * 3. Cleanup of parent entity files (e.g., if a chapter is deleted, update story.md)
   * 
   * For now, we just log the deletion and emit a warning.
   */
  async handleDeletion(event) {
    var _a, _b;
    console.log(`Entity deleted: ${event.entityType}:${event.entityId}`);
    (_b = (_a = this.context).emitWarning) == null ? void 0 : _b.call(_a, {
      code: "entity_deleted",
      message: `${event.entityType} ${event.entityId} was deleted on the server. Local file deletion is not yet implemented.`,
      severity: "warning",
      details: { event }
    });
  }
  /**
   * Map API update event to sync operation
   */
  mapEventToOperation(event) {
    const [entityType] = event.type.split(".");
    switch (entityType) {
      case "story":
        return { type: "pull_story", payload: { storyId: event.entityId } };
      case "chapter":
        return { type: "pull_chapter", payload: { chapterId: event.entityId } };
      case "scene":
        return { type: "pull_scene", payload: { sceneId: event.entityId } };
      case "beat":
        return { type: "pull_beat", payload: { beatId: event.entityId } };
      case "content_block":
        return { type: "pull_content_block", payload: { contentBlockId: event.entityId } };
      case "character":
        return { type: "pull_character", payload: { entityId: event.entityId } };
      case "location":
        return { type: "pull_location", payload: { entityId: event.entityId } };
      case "faction":
        return { type: "pull_faction", payload: { entityId: event.entityId } };
      case "artifact":
        return { type: "pull_artifact", payload: { entityId: event.entityId } };
      case "event":
        return { type: "pull_event", payload: { entityId: event.entityId } };
      case "lore":
        return { type: "pull_lore", payload: { entityId: event.entityId } };
      case "archetype":
        return { type: "pull_archetype", payload: { entityId: event.entityId } };
      case "trait":
        return { type: "pull_trait", payload: { entityId: event.entityId } };
      case "relation":
        return null;
      default:
        return null;
    }
  }
  /**
   * Get display name for entity
   */
  getEntityDisplayName(event) {
    const entityTypeName = event.entityType.replace("_", " ");
    return `${entityTypeName} ${event.entityId}`;
  }
  dispose() {
    this.stop();
  }
};

// src/sync-v2/core/ModularSyncEngine.ts
var ModularSyncEngine = class {
  constructor(context) {
    this.context = context;
    this.orchestrator = new SyncOrchestrator(context);
    this.initializeApiUpdateNotifier();
  }
  getOrchestrator() {
    return this.orchestrator;
  }
  getContext() {
    return this.context;
  }
  /**
   * Initialize API update notifier handler
   */
  initializeApiUpdateNotifier() {
    if (!this.context.settings.autoSyncOnApiUpdates) {
      return;
    }
    this.apiUpdateNotifierHandler = new ApiUpdateNotifierHandler(
      apiUpdateNotifierV2,
      this.orchestrator,
      this.context
    );
    this.apiUpdateNotifierHandler.start();
  }
  dispose() {
    if (this.apiUpdateNotifierHandler) {
      this.apiUpdateNotifierHandler.dispose();
      this.apiUpdateNotifierHandler = void 0;
    }
    this.orchestrator.dispose();
  }
  async pullStory(storyId, target) {
    const result = await this.orchestrator.run({
      type: "pull_story",
      payload: { storyId, target }
    });
    this.handleResult("pull_story", result);
  }
  async pullAllStories() {
    const result = await this.orchestrator.run({
      type: "pull_all_stories",
      payload: {}
    });
    this.handleResult("pull_all_stories", result);
  }
  async pushStory(folderPath, target) {
    const result = await this.orchestrator.run({
      type: "push_story",
      payload: { folderPath, target }
    });
    this.handleResult("push_story", result);
  }
  handleResult(operation, result) {
    var _a, _b, _c, _d, _e, _f;
    if (result.success) {
      if ((_a = result.warnings) == null ? void 0 : _a.length) {
        const summary = result.warnings.length === 1 ? result.warnings[0].message : `${result.warnings.length} avisos detectados; revise o log.`;
        console.warn(`[Sync V2] warnings for ${operation}`, result.warnings);
        new import_obsidian21.Notice(`Sync V2 (${operation}) aviso: ${summary}`, 6e3);
      }
      if (result.message) {
        new import_obsidian21.Notice(result.message, 3e3);
      }
      return;
    }
    const firstError = (_b = result.errors) == null ? void 0 : _b[0];
    const message = (_d = (_c = firstError == null ? void 0 : firstError.message) != null ? _c : result.message) != null ? _d : `Sync V2 operation "${operation}" failed without error details.`;
    new import_obsidian21.Notice(`Sync V2 (${operation}): ${message}`, 8e3);
    if ((_e = result.warnings) == null ? void 0 : _e.length) {
      console.warn(`[Sync V2] warnings for ${operation}`, result.warnings);
    }
    if ((_f = result.errors) == null ? void 0 : _f.length) {
      console.warn("[Sync V2] operation failed", {
        operation,
        errors: result.errors
      });
    }
  }
};

// src/sync/createSyncEngine.ts
function createSyncEngine(deps, version) {
  var _a;
  if (version === "v2") {
    return new ModularSyncEngine({
      app: deps.app,
      apiClient: deps.apiClient,
      fileManager: deps.fileManager,
      settings: deps.settings,
      timestamp: () => (/* @__PURE__ */ new Date()).toISOString(),
      backupMode: (_a = deps.settings.backupMode) != null ? _a : "snapshots"
    });
  }
  return new SyncService(deps.apiClient, deps.fileManager, deps.settings, deps.app);
}

// src/main.ts
var DEFAULT_SETTINGS = {
  apiUrl: "http://localhost:8080",
  llmGatewayUrl: "http://localhost:8081",
  apiKey: "",
  tenantId: "",
  tenantName: "",
  syncFolderPath: "Stories",
  autoVersionSnapshots: true,
  conflictResolution: "service",
  mode: "local",
  syncVersion: "v1",
  showHelpBox: true,
  localModeVideoUrl: "https://example.com/setup-video",
  autoSyncOnApiUpdates: true,
  autoPushOnFileBlur: true,
  backupMode: "snapshots",
  backupRetentionDays: 7
};
var StoryEnginePlugin = class extends import_obsidian22.Plugin {
  constructor() {
    super(...arguments);
    this.extractResult = null;
    this.extractLogs = [];
    this.extractStatus = "idle";
    this.extractAbortController = null;
  }
  async onload() {
    var _a;
    await this.loadSettings();
    this.apiClient = new StoryEngineClient(
      this.settings.apiUrl,
      this.settings.apiKey,
      this.settings.tenantId || ""
    );
    this.apiClient.setMode(this.settings.mode || "local");
    this.apiClient.setAutoSyncOnApiUpdates(
      (_a = this.settings.autoSyncOnApiUpdates) != null ? _a : true
    );
    this.fileManager = new FileManager(
      this.app.vault,
      this.settings.syncFolderPath || "Stories"
    );
    this.syncService = createSyncEngine(
      {
        app: this.app,
        apiClient: this.apiClient,
        fileManager: this.fileManager,
        settings: this.settings
      },
      this.settings.syncVersion || "v1"
    );
    this.initializeAutoSyncManager();
    this.addSettingTab(new StoryEngineSettingTab(this.app, this));
    this.registerView(
      STORY_LIST_VIEW_TYPE,
      (leaf) => new StoryListView(leaf, this)
    );
    this.registerView(
      STORY_ENGINE_EXTRACT_VIEW_TYPE,
      (leaf) => new StoryEngineExtractView(leaf, this)
    );
    this.addRibbonIcon("book-open", "Story Engine", () => {
      this.activateView();
    });
    registerCommands(this);
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor) => {
        const selection2 = editor.getSelection().trim();
        if (!selection2) {
          return;
        }
        menu.addItem((item) => {
          item.setTitle("Story Engine: Extract Entities and Relations");
          item.setIcon("search");
          item.onClick(() => {
            this.extractSelectionCommand(selection2, true);
          });
        });
        menu.addItem((item) => {
          item.setTitle("Story Engine: Extract Entities Only");
          item.setIcon("search");
          item.onClick(() => {
            this.extractSelectionCommand(selection2, false);
          });
        });
      })
    );
  }
  async onunload() {
    this.app.workspace.detachLeavesOfType(STORY_LIST_VIEW_TYPE);
    this.app.workspace.detachLeavesOfType(STORY_ENGINE_EXTRACT_VIEW_TYPE);
    if (this.syncService) {
      this.syncService.dispose();
    }
    if (this.autoSyncManager) {
      this.autoSyncManager.dispose();
      this.autoSyncManager = void 0;
    }
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    var _a, _b;
    await this.saveData(this.settings);
    if (this.apiClient) {
      this.apiClient.setTenantId(this.settings.tenantId || "");
      this.apiClient.setMode(this.settings.mode || "local");
      this.apiClient.setAutoSyncOnApiUpdates(
        (_a = this.settings.autoSyncOnApiUpdates) != null ? _a : true
      );
    } else {
      this.apiClient = new StoryEngineClient(
        this.settings.apiUrl,
        this.settings.apiKey,
        this.settings.tenantId || ""
      );
      this.apiClient.setMode(this.settings.mode || "local");
      this.apiClient.setAutoSyncOnApiUpdates(
        (_b = this.settings.autoSyncOnApiUpdates) != null ? _b : true
      );
    }
    this.fileManager = new FileManager(
      this.app.vault,
      this.settings.syncFolderPath || "Stories"
    );
    if (this.syncService) {
      this.syncService.dispose();
    }
    this.syncService = createSyncEngine(
      {
        app: this.app,
        apiClient: this.apiClient,
        fileManager: this.fileManager,
        settings: this.settings
      },
      this.settings.syncVersion || "v1"
    );
    this.initializeAutoSyncManager();
  }
  initializeAutoSyncManager() {
    if (this.autoSyncManager) {
      this.autoSyncManager.dispose();
      this.autoSyncManager = void 0;
    }
    if (!this.settings.autoPushOnFileBlur) {
      return;
    }
    const syncVersion = this.settings.syncVersion || "v1";
    if (syncVersion === "v2") {
      const modularEngine = this.syncService;
      if (modularEngine && "getOrchestrator" in modularEngine) {
        const orchestrator = modularEngine.getOrchestrator();
        const context = modularEngine.getContext();
        this.autoSyncManager = new AutoSyncManagerV2(this, orchestrator, context);
      } else {
        console.warn(
          "[AutoSyncManager] Sync V2 selected but ModularSyncEngine not available, falling back to V1"
        );
        this.autoSyncManager = new AutoSyncManager(this);
      }
    } else {
      this.autoSyncManager = new AutoSyncManager(this);
    }
  }
  async createStoryCommand() {
    var _a;
    if (this.settings.mode === "remote") {
      const tenantId = (_a = this.settings.tenantId) == null ? void 0 : _a.trim();
      if (!tenantId) {
        new import_obsidian22.Notice("Please configure Tenant ID in settings", 5e3);
        return;
      }
      const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
      if (!uuidRegex.test(tenantId)) {
        new import_obsidian22.Notice("Invalid Tenant ID format. Please check your settings.", 5e3);
        return;
      }
    }
    new CreateStoryModal(this.app, this, async (title, worldId, shouldSync) => {
      try {
        new import_obsidian22.Notice(`Creating story "${title}"...`);
        const story = await this.apiClient.createStory(title, worldId);
        new import_obsidian22.Notice(`Story "${title}" created successfully`);
        if (shouldSync) {
          try {
            new import_obsidian22.Notice(`Syncing story to Obsidian...`);
            await this.syncService.pullStory(story.id);
            new import_obsidian22.Notice(`Story synced to your vault!`);
          } catch (syncErr) {
            const syncErrorMessage = syncErr instanceof Error ? syncErr.message : "Failed to sync story";
            new import_obsidian22.Notice(`Story created but sync failed: ${syncErrorMessage}`, 5e3);
          }
        }
        const openView = this.app.workspace.getLeavesOfType(STORY_LIST_VIEW_TYPE)[0];
        if (openView) {
          const view = openView.view;
          await view.refresh();
          if (!shouldSync) {
            await view.showStoryDetails(story);
          }
        }
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to create story";
        new import_obsidian22.Notice(`Error: ${errorMessage}`, 5e3);
      }
    }).open();
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(STORY_LIST_VIEW_TYPE)[0];
    if (!leaf) {
      const rightLeaf = workspace.getRightLeaf(false);
      if (!rightLeaf) {
        new import_obsidian22.Notice("Could not create view. Please try again.", 3e3);
        return;
      }
      leaf = rightLeaf;
      await leaf.setViewState({
        type: STORY_LIST_VIEW_TYPE,
        active: true
      });
    }
    workspace.revealLeaf(leaf);
  }
  async activateExtractView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(STORY_ENGINE_EXTRACT_VIEW_TYPE)[0];
    if (!leaf) {
      leaf = workspace.getLeavesOfType(STORY_LIST_VIEW_TYPE)[0];
    }
    if (!leaf) {
      new import_obsidian22.Notice("Could not open extract view. Please try again.", 3e3);
      return;
    }
    await leaf.setViewState({
      type: STORY_ENGINE_EXTRACT_VIEW_TYPE,
      active: true
    });
    workspace.revealLeaf(leaf);
  }
  async getActiveWorldId() {
    var _a;
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      return null;
    }
    const fileContent = await this.app.vault.read(activeFile);
    const frontmatter = this.fileManager.parseFrontmatter(fileContent);
    const storyId = frontmatter.story_id || (activeFile.name === "story.md" ? frontmatter.id : "");
    if (!storyId) {
      return null;
    }
    const story = await this.apiClient.getStory(storyId);
    return (_a = story.world_id) != null ? _a : null;
  }
  async extractSelectionCommand(selection2, includeRelations = true) {
    var _a, _b, _c;
    const trimmedSelection = selection2.trim();
    if (!trimmedSelection) {
      new import_obsidian22.Notice(
        includeRelations ? "Select text to extract entities and relations" : "Select text to extract entities",
        3e3
      );
      return;
    }
    const defaultTypes = ["character", "location", "artefact", "faction", "event"];
    const config = await ExtractConfigModal.open(
      this.app,
      defaultTypes,
      includeRelations
    );
    if (!config) {
      return;
    }
    if (this.settings.mode !== "remote") {
      new import_obsidian22.Notice("Extraction requires the full remote version.", 5e3);
      return;
    }
    const tenantId = (_a = this.settings.tenantId) == null ? void 0 : _a.trim();
    if (!tenantId) {
      new import_obsidian22.Notice("Please configure Tenant ID in settings", 5e3);
      return;
    }
    const gatewayUrl = (_b = this.settings.llmGatewayUrl) == null ? void 0 : _b.trim();
    if (!gatewayUrl) {
      new import_obsidian22.Notice("Please configure LLM Gateway URL in settings", 5e3);
      return;
    }
    let worldId = null;
    try {
      worldId = await this.getActiveWorldId();
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to resolve story";
      new import_obsidian22.Notice(`Error: ${errorMessage}`, 5e3);
      return;
    }
    if (!worldId) {
      new import_obsidian22.Notice(
        "Open a synced story document before extracting entities.",
        5e3
      );
      return;
    }
    this.resetExtractState(trimmedSelection, worldId, config.includeRelations);
    await this.activateView();
    await this.activateExtractView();
    this.updateExtractViews();
    try {
      if ((_c = navigator == null ? void 0 : navigator.clipboard) == null ? void 0 : _c.writeText) {
        await navigator.clipboard.writeText(trimmedSelection);
      }
    } catch (e) {
    }
    new import_obsidian22.Notice("Starting extraction stream...", 3e3);
    await this.startExtractStream({
      tenantId,
      gatewayUrl,
      worldId,
      text: trimmedSelection,
      includeRelations: config.includeRelations,
      entityTypes: config.entityTypes
    });
  }
  updateExtractViews() {
    const listLeaf = this.app.workspace.getLeavesOfType(STORY_LIST_VIEW_TYPE)[0];
    if (listLeaf) {
      const view = listLeaf.view;
      if (view.viewMode === "list") {
        view.renderListContent();
      }
    }
    const extractLeaf = this.app.workspace.getLeavesOfType(STORY_ENGINE_EXTRACT_VIEW_TYPE)[0];
    if (extractLeaf) {
      const view = extractLeaf.view;
      view.setResult(this.extractResult);
      view.setLogs(this.extractLogs, this.extractStatus);
    }
  }
  resetExtractState(text, worldId, includeRelations = true) {
    this.cancelExtractStream();
    this.extractResult = {
      text,
      world_id: worldId,
      entities: [],
      relations: [],
      received_at: (/* @__PURE__ */ new Date()).toISOString(),
      include_relations: includeRelations
    };
    this.extractLogs = [];
    this.extractStatus = "running";
  }
  cancelExtractStream() {
    if (this.extractAbortController) {
      this.extractAbortController.abort();
      this.extractAbortController = null;
      this.extractStatus = "canceled";
      this.appendExtractLog({
        type: "client.cancel",
        message: "Extraction canceled by user."
      });
      this.updateExtractViews();
    }
  }
  appendExtractLog(event) {
    const timestamp = event.timestamp ? new Date(event.timestamp).toISOString() : (/* @__PURE__ */ new Date()).toISOString();
    this.extractLogs.push({
      id: `${timestamp}-${this.extractLogs.length}`,
      eventType: event.type,
      phase: event.phase,
      message: event.message,
      data: event.data,
      timestamp
    });
  }
  async startExtractStream(params) {
    const { tenantId, gatewayUrl, worldId, text, includeRelations, entityTypes } = params;
    const controller = new AbortController();
    this.extractAbortController = controller;
    this.appendExtractLog({
      type: "client.start",
      message: "Opening extraction stream."
    });
    this.updateExtractViews();
    try {
      const response = await fetch(
        `${gatewayUrl.replace(/\/$/, "")}/api/v1/entity-extract/stream`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-Tenant-ID": tenantId,
            ...this.settings.apiKey ? { Authorization: `Bearer ${this.settings.apiKey}` } : {}
          },
          body: JSON.stringify({
            text,
            world_id: worldId,
            include_relations: includeRelations,
            entity_types: entityTypes
          }),
          signal: controller.signal
        }
      );
      if (!response.ok) {
        let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
        try {
          const errorBody = await response.json();
          if (errorBody == null ? void 0 : errorBody.error) {
            errorMessage = errorBody.error;
          }
        } catch (e) {
        }
        throw new Error(errorMessage);
      }
      if (!response.body) {
        throw new Error("No response stream available.");
      }
      const reader = response.body.getReader();
      const decoder = new TextDecoder("utf-8");
      let buffer = "";
      let currentEvent = "message";
      let dataLines = [];
      const flushEvent = () => {
        var _a, _b, _c, _d, _e;
        if (!dataLines.length)
          return;
        const rawData = dataLines.join("\n").trim();
        dataLines = [];
        if (!rawData)
          return;
        let parsed = null;
        try {
          parsed = JSON.parse(rawData);
        } catch (e) {
          this.appendExtractLog({
            type: "parse.error",
            message: "Failed to parse stream event payload.",
            data: { raw: rawData, event: currentEvent }
          });
          this.updateExtractViews();
          return;
        }
        if (!parsed.type) {
          parsed.type = currentEvent || "message";
        }
        if (parsed.type === "relation.error") {
          parsed.message = `\u274C ${parsed.message}`;
        } else if (parsed.type === "relation.success") {
          parsed.message = `\u2705 ${parsed.message}`;
        }
        this.appendExtractLog(parsed);
        if (parsed.type === "result_entities" && ((_a = parsed.data) == null ? void 0 : _a.entities)) {
          const entities = parsed.data.entities;
          if (this.extractResult) {
            this.extractResult.entities = entities != null ? entities : [];
            this.extractResult.received_at = (/* @__PURE__ */ new Date()).toISOString();
          }
          const foundCount = (_b = this.extractResult) == null ? void 0 : _b.entities.filter(
            (entity) => entity.found
          ).length;
          new import_obsidian22.Notice(
            `Entities extracted: ${foundCount != null ? foundCount : 0}/${(_d = (_c = this.extractResult) == null ? void 0 : _c.entities.length) != null ? _d : 0} matched`,
            4e3
          );
        }
        if (parsed.type === "result_relations" && ((_e = parsed.data) == null ? void 0 : _e.relations)) {
          const relations = parsed.data.relations;
          if (this.extractResult) {
            this.extractResult.relations = relations != null ? relations : [];
            this.extractResult.received_at = (/* @__PURE__ */ new Date()).toISOString();
          }
        }
        if (parsed.type === "error") {
          this.extractStatus = "error";
        }
        this.updateExtractViews();
      };
      while (true) {
        const { value, done } = await reader.read();
        if (done)
          break;
        buffer += decoder.decode(value, { stream: true });
        let lineEnd = buffer.indexOf("\n");
        while (lineEnd !== -1) {
          const line = buffer.slice(0, lineEnd).replace(/\r$/, "");
          buffer = buffer.slice(lineEnd + 1);
          lineEnd = buffer.indexOf("\n");
          if (!line) {
            flushEvent();
            currentEvent = "message";
            continue;
          }
          if (line.startsWith("event:")) {
            currentEvent = line.replace("event:", "").trim();
            continue;
          }
          if (line.startsWith("data:")) {
            dataLines.push(line.replace("data:", "").trim());
          }
        }
      }
      this.extractAbortController = null;
      if (this.extractStatus === "running") {
        this.extractStatus = "done";
      }
    } catch (err) {
      if (err instanceof DOMException && err.name === "AbortError") {
        return;
      }
      const errorMessage = err instanceof Error ? err.message : "Failed to extract entities";
      this.extractStatus = "error";
      this.appendExtractLog({
        type: "error",
        message: errorMessage
      });
      new import_obsidian22.Notice(`Error: ${errorMessage}`, 5e3);
      this.updateExtractViews();
    }
  }
  openSettings() {
    const setting = this.app.setting;
    if (setting) {
      setting.open();
      setTimeout(() => {
        setting.openTabById(this.manifest.id);
      }, 100);
    }
  }
};
